{"version":3,"file":"index.js","sources":["../../src/py-to-ts/transpiler.ts","../../src/py-to-ts/SourceMap.ts","../../src/py-to-ts/utils.ts","../../src/py-to-ts/toStringLiteralJS.ts","../../src/py-to-ts/asserts.ts"],"sourcesContent":["import { assert } from './asserts';\r\nimport { Visitor } from 'typhon-lang';\r\nimport { AnnAssign } from 'typhon-lang';\r\nimport { Assign } from 'typhon-lang';\r\nimport { Attribute } from 'typhon-lang';\r\nimport { BinOp, Add, Sub, Mult, Div, BitOr, BitXor, BitAnd, LShift, RShift, FloorDiv, Mod } from 'typhon-lang';\r\nimport { Call } from 'typhon-lang';\r\nimport { ClassDef } from 'typhon-lang';\r\nimport { Compare, Eq, NotEq, Gt, GtE, Lt, LtE, In, NotIn, Is, IsNot } from 'typhon-lang';\r\nimport { Dict } from 'typhon-lang';\r\nimport { ExpressionStatement } from 'typhon-lang';\r\nimport { ForStatement } from 'typhon-lang';\r\nimport { FunctionDef } from 'typhon-lang';\r\nimport { Name } from 'typhon-lang';\r\nimport { IfStatement } from 'typhon-lang';\r\nimport { ImportFrom } from 'typhon-lang';\r\nimport { List } from 'typhon-lang';\r\nimport { Module } from 'typhon-lang';\r\nimport { Num } from 'typhon-lang';\r\nimport { Print } from 'typhon-lang';\r\nimport { ReturnStatement } from 'typhon-lang';\r\nimport { Str } from 'typhon-lang';\r\nimport { parse, SourceKind } from 'typhon-lang';\r\nimport { astFromParse } from 'typhon-lang';\r\nimport { semanticsOfModule } from 'typhon-lang';\r\nimport { SymbolTable } from 'typhon-lang';\r\nimport { SymbolTableScope } from 'typhon-lang';\r\nimport { toStringLiteralJS } from './toStringLiteralJS';\r\nimport { SymbolFlags } from 'typhon-lang';\r\nimport { DEF_LOCAL } from 'typhon-lang';\r\nimport { isClassNameByConvention, isMethod } from './utils';\r\nimport { CodeWriter, TextAndMappings } from 'code-writer';\r\nimport { MappingTree } from 'code-writer';\r\nimport { Position, positionComparator } from 'code-writer';\r\nimport { RBTree } from 'generic-rbtree';\r\nimport { SourceMap } from './SourceMap';\r\n/**\r\n * Provides enhanced scope information beyond the SymbolTableScope.\r\n */\r\nclass PrinterUnit {\r\n    readonly ste: SymbolTableScope;\r\n    readonly name: string;\r\n    /**\r\n     * Some sort of private name?\r\n     */\r\n    private_: string;\r\n    beginLine: number;\r\n    beginColumn: number;\r\n    lineno: number;\r\n    /**\r\n     * Has the line number been set?\r\n     */\r\n    linenoSet: boolean;\r\n    localnames: string[];\r\n    blocknum: number;\r\n    /**\r\n     * TODO: What are these blocks?\r\n     */\r\n    blocks: any[];\r\n    curblock: number;\r\n    /**\r\n     * Used to determine whether a local variable has been declared.\r\n     */\r\n    declared: { [name: string]: boolean } = {};\r\n    scopename: string;\r\n    prefixCode: string;\r\n    varDeclsCode: string;\r\n    switchCode: string;\r\n    suffixCode: string;\r\n    breakCode: string;\r\n    breakBlocks: number[];\r\n    continueBlocks: number[];\r\n    exceptBlocks: number[];\r\n    finallyBlocks: number[];\r\n    argnames: string[];\r\n    /**\r\n     * Stuff that changes on entry/exit of code blocks. must be saved and restored\r\n     * when returning to a block.\r\n     * Corresponds to the body of a module, class, or function.\r\n     */\r\n    constructor(name: string, ste: SymbolTableScope) {\r\n        assert(typeof name === 'string');\r\n        assert(typeof ste === 'object');\r\n        this.name = name;\r\n        this.ste = ste;\r\n\r\n        this.private_ = null;\r\n        this.beginLine = 0;\r\n        this.lineno = 0;\r\n        this.linenoSet = false;\r\n        this.localnames = [];\r\n\r\n        this.blocknum = 0;\r\n        this.blocks = [];\r\n        this.curblock = 0;\r\n\r\n        this.scopename = null;\r\n\r\n        this.prefixCode = '';\r\n        this.varDeclsCode = '';\r\n        this.switchCode = '';\r\n        this.suffixCode = '';\r\n\r\n        // stack of where to go on a break\r\n        this.breakBlocks = [];\r\n        // stack of where to go on a continue\r\n        this.continueBlocks = [];\r\n        this.exceptBlocks = [];\r\n        this.finallyBlocks = [];\r\n    }\r\n    activateScope(): void {\r\n        // Do nothing yet.\r\n    }\r\n    deactivateScope(): void {\r\n        // Do nothing yet.\r\n    }\r\n}\r\n\r\nclass Printer implements Visitor {\r\n    /**\r\n     * The output of all units.\r\n     */\r\n    public result: string[];\r\n    /**\r\n     * Used to instrument the code with the name of the file.\r\n     */\r\n    // private fileName: string;\r\n    /**\r\n     * When a scope is entered, used to obtain the corresponding SymbolTableScope.\r\n     * A CompilerUnit is created for each scope.\r\n     */\r\n    private st: SymbolTable;\r\n    /**\r\n     * Not being used (but being carried through).\r\n     */\r\n    private flags: number;\r\n    /**\r\n     * Not being used. Default is false.\r\n     */\r\n    private interactive: boolean;\r\n    /**\r\n     * Incremented(Decremented) when entering(leaving) a scope.\r\n     * Default is 0.\r\n     * Not being used.\r\n     * It seems a bit redundant because it can be obtained from the stack.length property.\r\n     */\r\n    private nestlevel: number;\r\n    /**\r\n     * Provides custom information about the current scope.\r\n     * Default is null.\r\n     */\r\n    private u: PrinterUnit;\r\n    /**\r\n     * Pushed(Popped) when entering(leaving) a scope.\r\n     * Default is [].\r\n     * Used to provide the compiler unit as scopes are popped.\r\n     */\r\n    private stack: PrinterUnit[];\r\n    /**\r\n     * Pushed whenever we enter a cope, but never popped.\r\n     */\r\n    private allUnits: PrinterUnit[];\r\n    /**\r\n     * Used to provide comments referencing the original source in the transpiled code.\r\n     */\r\n    private source: string[] | boolean;\r\n\r\n    /**\r\n     * The output buffer.\r\n     * This will be joined into a single string.\r\n     */\r\n    private writer: CodeWriter;\r\n    /**\r\n     * Used to provide a unique number for generated symbol names.\r\n     */\r\n    private gensymCount = 0;\r\n    /**\r\n     *\r\n     * @param st The symbol table obtained from semantic analysis.\r\n     * @param flags Not being used yet. May become options.\r\n     * @param sourceText The original source code, provided for annotating the generated code and source mapping.\r\n     */\r\n    constructor(st: SymbolTable, flags: number, sourceText: string, private beginLine: number, private beginColumn: number, trace: boolean) {\r\n        // this.fileName = fileName;\r\n        this.st = st;\r\n        this.flags = flags;\r\n        this.interactive = false;\r\n        this.nestlevel = 0;\r\n        this.u = null;\r\n        this.stack = [];\r\n        this.result = [];\r\n        // this.gensymcount = 0;\r\n        this.allUnits = [];\r\n        this.source = sourceText ? sourceText.split(\"\\n\") : false;\r\n        this.writer = new CodeWriter(beginLine, beginColumn, {}, trace);\r\n    }\r\n\r\n    /**\r\n     * This is the entry point for this visitor.\r\n     */\r\n    transpileModule(module: Module): TextAndMappings {\r\n\r\n        // Traversing the AST sends commands to the writer.\r\n        this.enterScope(\"<module>\", module, this.beginLine, this.beginColumn);\r\n        this.module(module);\r\n        this.exitScope();\r\n\r\n        // Now return the captured events as a transpiled module.\r\n        return this.writer.snapshot();\r\n    }\r\n\r\n    /**\r\n     * Looks up the SymbolTableScope.\r\n     * Pushes a new PrinterUnit onto the stack.\r\n     * Returns a string identifying the scope.\r\n     * @param name The name that will be assigned to the PrinterUnit.\r\n     * @param key A scope object in the AST from sematic analysis. Provides the mapping to the SymbolTableScope.\r\n     */\r\n    enterScope(name: string, key: { scopeId: number }, beginLine: number, beginColumn: number): string {\r\n        const u = new PrinterUnit(name, this.st.getStsForAst(key));\r\n        u.beginLine = beginLine;\r\n        u.beginColumn = beginColumn;\r\n\r\n        if (this.u && this.u.private_) {\r\n            u.private_ = this.u.private_;\r\n        }\r\n\r\n        this.stack.push(this.u);\r\n        this.allUnits.push(u);\r\n        const scopeName = this.gensym('scope');\r\n        u.scopename = scopeName;\r\n\r\n        this.u = u;\r\n        this.u.activateScope();\r\n\r\n        this.nestlevel++;\r\n\r\n        return scopeName;\r\n    }\r\n\r\n    exitScope() {\r\n        if (this.u) {\r\n            this.u.deactivateScope();\r\n        }\r\n        this.nestlevel--;\r\n        if (this.stack.length - 1 >= 0) {\r\n            this.u = this.stack.pop();\r\n        }\r\n        else {\r\n            this.u = null;\r\n        }\r\n        if (this.u) {\r\n            this.u.activateScope();\r\n        }\r\n    }\r\n\r\n    forStatement(fs: ForStatement) {\r\n        const body = fs.body;\r\n        const range = fs.iter;\r\n        const target = fs.target;\r\n        this.writer.write(\"for\", null);\r\n        this.writer.openParen();\r\n\r\n        if (range instanceof Call) {\r\n            this.writer.beginStatement();\r\n\r\n            if (target instanceof Name) {\r\n                const flags: SymbolFlags = this.u.ste.symFlags[target.id.value];\r\n                if (flags && DEF_LOCAL) {\r\n                    if (this.u.declared[target.id.value]) {\r\n                        // The variable has already been declared.\r\n                    }\r\n                    else {\r\n                        // We use let for now because we would need to look ahead for more assignments.\r\n                        // The smenatic analysis could count the number of assignments in the current scope?\r\n                        this.writer.write(\"let \", null);\r\n                        this.u.declared[target.id.value] = true;\r\n                    }\r\n                }\r\n            }\r\n            target.accept(this);\r\n\r\n            this.writer.write(\"=\", null);\r\n\r\n            const secondArg = range.args[1];\r\n            const thirdArg = range.args[2];\r\n            if (range.args[3]) {\r\n                throw new Error(\"Too many arguments\");\r\n            }\r\n            // range() accepts 1 or 2 parameters, if 1 then first param is always 0\r\n            if (secondArg) {\r\n                const firstArg = range.args[0];\r\n                firstArg.accept(this);\r\n                this.writer.endStatement();\r\n            }\r\n            else {\r\n                this.writer.write(\"0\", null);\r\n                this.writer.endStatement();\r\n            }\r\n\r\n            // writing second part of for statement\r\n            this.writer.beginStatement();\r\n            target.accept(this);\r\n            this.writer.write(\"<\", null);\r\n            secondArg.accept(this);\r\n            this.writer.endStatement();\r\n\r\n            // writing third part of for statement\r\n            if (thirdArg) {\r\n                target.accept(this);\r\n                this.writer.write(\"=\", null);\r\n                target.accept(this);\r\n                this.writer.write(\"+\", null);\r\n                thirdArg.accept(this);\r\n            }\r\n            else {\r\n                target.accept(this);\r\n                this.writer.write(\"++\", null);\r\n            }\r\n\r\n        }\r\n        else if (range instanceof Name) {\r\n            // \"for (\" written so far\r\n            const greedyIterator = range.id.value; // The list to iterate over\r\n            this.writer.write(\"let \", null);\r\n\r\n            if (target instanceof Name) {\r\n                const flags: SymbolFlags = this.u.ste.symFlags[target.id.value];\r\n                if (flags && DEF_LOCAL) {\r\n                    if (this.u.declared[target.id.value]) {\r\n                        // The variable has already been declared.\r\n                    }\r\n                    else {\r\n                        // We use let for now because we would need to look ahead for more assignments.\r\n                        // The smenatic analysis could count the number of assignments in the current scope?\r\n                        this.writer.write(\"let \", null);\r\n                        this.u.declared[target.id.value] = true;\r\n                    }\r\n                }\r\n            }\r\n            target.accept(this);\r\n\r\n            this.writer.write(\" of\", null);\r\n            this.writer.write(` ${greedyIterator}`, null);\r\n        }\r\n        else {\r\n            console.log(range);\r\n            throw new Error(`Invalid range... range is instance of ${range.constructor.name}, not 'Call' or 'Name'`);\r\n        }\r\n        this.writer.closeParen();\r\n        this.writer.beginBlock();\r\n        for (const stmt of body) {\r\n            this.writer.beginStatement();\r\n            stmt.accept(this);\r\n            this.writer.endStatement();\r\n        }\r\n        this.writer.endBlock();\r\n    }\r\n\r\n    /**\r\n     * Generates a unique symbol name for the provided namespace.\r\n     */\r\n    gensym(namespace?: 'scope'): string {\r\n        let symbolName = namespace || '';\r\n        symbolName = '$' + symbolName;\r\n        symbolName += this.gensymCount++;\r\n        return symbolName;\r\n    }\r\n\r\n    // Everything below here is an implementation of the Visitor\r\n    annAssign(annassign: AnnAssign): void {\r\n        this.writer.beginStatement();\r\n        // TODO: Declaration.\r\n        // TODO: How to deal with multiple target?\r\n        /**\r\n         * Decides whether to write let or not\r\n         */\r\n        const target = annassign.target;\r\n        if (target instanceof Name) {\r\n            const flags: SymbolFlags = this.u.ste.symFlags[target.id.value];\r\n            if (flags && DEF_LOCAL) {\r\n                if (this.u.declared[target.id.value]) {\r\n                    // The variable has already been declared.\r\n                }\r\n                else {\r\n                    // We use let for now because we would need to look ahead for more assignments.\r\n                    // The smenatic analysis could count the number of assignments in the current scope?\r\n                    this.writer.write(\"let \", null);\r\n                    this.u.declared[target.id.value] = true;\r\n                }\r\n            }\r\n        }\r\n        target.accept(this);\r\n        if (annassign.value) {\r\n            this.writer.write(\":\", null);\r\n            annassign.value.accept(this);\r\n        }\r\n        this.writer.endStatement();\r\n    }\r\n    assign(assign: Assign): void {\r\n        this.writer.beginStatement();\r\n        // TODO: Declaration.\r\n        // TODO: How to deal with multiple target?\r\n        /**\r\n         * Decides whether to write let or not\r\n         */\r\n        for (const target of assign.targets) {\r\n            if (target instanceof Name) {\r\n                const flags: SymbolFlags = this.u.ste.symFlags[target.id.value];\r\n                if (flags && DEF_LOCAL) {\r\n                    if (this.u.declared[target.id.value]) {\r\n                        // The variable has already been declared.\r\n                    }\r\n                    else {\r\n                        // We use let for now because we would need to look ahead for more assignments.\r\n                        // The smenatic analysis could count the number of assignments in the current scope?\r\n                        this.writer.write(\"let \", null);\r\n                        this.u.declared[target.id.value] = true;\r\n                    }\r\n                }\r\n            }\r\n            target.accept(this);\r\n            if (assign.type) {\r\n                this.writer.write(\":\", null);\r\n                assign.type.accept(this);\r\n            }\r\n        }\r\n        this.writer.assign(\"=\", assign.eqRange);\r\n        assign.value.accept(this);\r\n        this.writer.endStatement();\r\n    }\r\n    attribute(attribute: Attribute): void {\r\n        attribute.value.accept(this);\r\n        this.writer.write(\".\", null);\r\n        this.writer.str(attribute.attr.value, attribute.attr.range);\r\n    }\r\n    binOp(be: BinOp): void {\r\n        be.lhs.accept(this);\r\n        const op = be.op;\r\n        const opRange = be.opRange;\r\n        switch (op) {\r\n            case Add: {\r\n                this.writer.binOp(\"+\", opRange);\r\n                break;\r\n            }\r\n            case Sub: {\r\n                this.writer.binOp(\"-\", opRange);\r\n                break;\r\n            }\r\n            case Mult: {\r\n                this.writer.binOp(\"*\", opRange);\r\n                break;\r\n            }\r\n            case Div: {\r\n                this.writer.binOp(\"/\", opRange);\r\n                break;\r\n            }\r\n            case BitOr: {\r\n                this.writer.binOp(\"|\", opRange);\r\n                break;\r\n            }\r\n            case BitXor: {\r\n                this.writer.binOp(\"^\", opRange);\r\n                break;\r\n            }\r\n            case BitAnd: {\r\n                this.writer.binOp(\"&\", opRange);\r\n                break;\r\n            }\r\n            case LShift: {\r\n                this.writer.binOp(\"<<\", opRange);\r\n                break;\r\n            }\r\n            case RShift: {\r\n                this.writer.binOp(\">>\", opRange);\r\n                break;\r\n            }\r\n            case Mod: {\r\n                this.writer.binOp(\"%\", opRange);\r\n                break;\r\n            }\r\n            case FloorDiv: {\r\n                // TODO: What is the best way to handle FloorDiv.\r\n                // This doesn't actually exist in TypeScript.\r\n                this.writer.binOp(\"//\", opRange);\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Unexpected binary operator ${op}: ${typeof op}`);\r\n            }\r\n        }\r\n        be.rhs.accept(this);\r\n    }\r\n    callExpression(ce: Call): void {\r\n        if (ce.func instanceof Name) {\r\n            if (isClassNameByConvention(ce.func)) {\r\n                this.writer.write(\"new \", null);\r\n            }\r\n        }\r\n        else if (ce.func instanceof Attribute) {\r\n            if (isClassNameByConvention(ce.func)) {\r\n                this.writer.write(\"new \", null);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(`Call.func must be a Name ${ce.func}`);\r\n        }\r\n        ce.func.accept(this);\r\n        this.writer.openParen();\r\n        for (let i = 0; i < ce.args.length; i++) {\r\n            if (i > 0) {\r\n                this.writer.comma(null, null);\r\n            }\r\n            const arg = ce.args[i];\r\n            arg.accept(this);\r\n        }\r\n        for (let i = 0; i < ce.keywords.length; ++i) {\r\n            if (i > 0) {\r\n                this.writer.comma(null, null);\r\n            }\r\n            ce.keywords[i].value.accept(this);\r\n        }\r\n        if (ce.starargs) {\r\n            ce.starargs.accept(this);\r\n        }\r\n        if (ce.kwargs) {\r\n            ce.kwargs.accept(this);\r\n        }\r\n        this.writer.closeParen();\r\n    }\r\n    classDef(cd: ClassDef): void {\r\n        this.writer.write(\"class\", null);\r\n        this.writer.space();\r\n        this.writer.name(cd.name.value, cd.name.range);\r\n        // this.writer.openParen();\r\n        // this.writer.closeParen();\r\n        this.writer.beginBlock();\r\n        /*\r\n        this.writer.write(\"constructor\");\r\n        this.writer.openParen();\r\n        this.writer.closeParen();\r\n        this.writer.beginBlock();\r\n        this.writer.endBlock();\r\n        */\r\n        for (const stmt of cd.body) {\r\n            stmt.accept(this);\r\n        }\r\n        this.writer.endBlock();\r\n    }\r\n    compareExpression(ce: Compare) {\r\n        ce.left.accept(this);\r\n        for (const op of ce.ops) {\r\n            switch (op) {\r\n                case Eq: {\r\n                    this.writer.write(\"===\", null);\r\n                    break;\r\n                }\r\n                case NotEq: {\r\n                    this.writer.write(\"!==\", null);\r\n                    break;\r\n                }\r\n                case Lt: {\r\n                    this.writer.write(\"<\", null);\r\n                    break;\r\n                }\r\n                case LtE: {\r\n                    this.writer.write(\"<=\", null);\r\n                    break;\r\n                }\r\n                case Gt: {\r\n                    this.writer.write(\">\", null);\r\n                    break;\r\n                }\r\n                case GtE: {\r\n                    this.writer.write(\">=\", null);\r\n                    break;\r\n                }\r\n                case Is: {\r\n                    this.writer.write(\"===\", null);\r\n                    break;\r\n                }\r\n                case IsNot: {\r\n                    this.writer.write(\"!==\", null);\r\n                    break;\r\n                }\r\n                case In: {\r\n                    this.writer.write(\" in \", null);\r\n                    break;\r\n                }\r\n                case NotIn: {\r\n                    this.writer.write(\" not in \", null);\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(`Unexpected comparison expression operator: ${op}`);\r\n                }\r\n            }\r\n        }\r\n        for (const comparator of ce.comparators) {\r\n            comparator.accept(this);\r\n        }\r\n    }\r\n    dict(dict: Dict): void {\r\n        const keys = dict.keys;\r\n        const values = dict.values;\r\n        const N = keys.length;\r\n        this.writer.beginObject();\r\n        for (let i = 0; i < N; i++) {\r\n            if (i > 0) {\r\n                this.writer.comma(null, null);\r\n            }\r\n            keys[i].accept(this);\r\n            this.writer.write(\":\", null);\r\n            values[i].accept(this);\r\n        }\r\n        this.writer.endObject();\r\n    }\r\n    expressionStatement(s: ExpressionStatement): void {\r\n        this.writer.beginStatement();\r\n        s.value.accept(this);\r\n        this.writer.endStatement();\r\n    }\r\n    functionDef(functionDef: FunctionDef): void {\r\n        const isClassMethod = isMethod(functionDef);\r\n        const sts = this.st.getStsForAst(functionDef);\r\n        const parentScope = this.u.ste;\r\n        for (const scope of parentScope.children) {\r\n            if (sts === scope) {\r\n                this.writer.write(\"export \", null);\r\n            }\r\n        }\r\n        if (!isClassMethod) {\r\n            this.writer.write(\"function \", null);\r\n        }\r\n        this.writer.name(functionDef.name.value, functionDef.name.range);\r\n        this.writer.openParen();\r\n        for (let i = 0; i < functionDef.args.args.length; i++) {\r\n            const arg = functionDef.args.args[i];\r\n            const argType = arg.type;\r\n            if (i === 0) {\r\n                if (arg.name.id.value === 'self') {\r\n                    // Ignore.\r\n                }\r\n                else {\r\n                    arg.name.accept(this);\r\n                    if (argType) {\r\n                        this.writer.write(\":\", null);\r\n                        argType.accept(this);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                arg.name.accept(this);\r\n                if (argType) {\r\n                    this.writer.write(\":\", null);\r\n                    argType.accept(this);\r\n                }\r\n            }\r\n        }\r\n        this.writer.closeParen();\r\n        if (functionDef.returnType) {\r\n            this.writer.write(\":\", null);\r\n            functionDef.returnType.accept(this);\r\n        }\r\n\r\n\r\n        this.writer.beginBlock();\r\n\r\n        for (const stmt of functionDef.body) {\r\n            stmt.accept(this);\r\n        }\r\n        this.writer.endBlock();\r\n    }\r\n    ifStatement(i: IfStatement): void {\r\n        this.writer.write(\"if\", null);\r\n        this.writer.openParen();\r\n        i.test.accept(this);\r\n        this.writer.closeParen();\r\n        this.writer.beginBlock();\r\n        for (const con of i.consequent) {\r\n            con.accept(this);\r\n        }\r\n        this.writer.endBlock();\r\n    }\r\n    importFrom(importFrom: ImportFrom): void {\r\n        this.writer.beginStatement();\r\n        this.writer.write(\"import\", null);\r\n        this.writer.space();\r\n        this.writer.beginBlock();\r\n        for (let i = 0; i < importFrom.names.length; i++) {\r\n            if (i > 0) {\r\n                this.writer.comma(null, null);\r\n            }\r\n            const alias = importFrom.names[i];\r\n            this.writer.name(alias.name.value, alias.name.range);\r\n            if (alias.asname) {\r\n                this.writer.space();\r\n                this.writer.write(\"as\", null);\r\n                this.writer.space();\r\n                this.writer.write(alias.asname, null);\r\n            }\r\n        }\r\n        this.writer.endBlock();\r\n        this.writer.space();\r\n        this.writer.write(\"from\", null);\r\n        this.writer.space();\r\n        this.writer.str(toStringLiteralJS(importFrom.module.value), importFrom.module.range);\r\n        this.writer.endStatement();\r\n    }\r\n    list(list: List): void {\r\n        const elements = list.elts;\r\n        const N = elements.length;\r\n        this.writer.write('[', null);\r\n        for (let i = 0; i < N; i++) {\r\n            if (i > 0) {\r\n                this.writer.comma(null, null);\r\n            }\r\n            elements[i].accept(this);\r\n        }\r\n        this.writer.write(']', null);\r\n    }\r\n    module(m: Module): void {\r\n        for (const stmt of m.body) {\r\n            stmt.accept(this);\r\n        }\r\n    }\r\n    name(name: Name): void {\r\n        // TODO: Since 'True' and 'False' are reserved words in Python,\r\n        // syntactic analysis (parsing) should be sufficient to identify\r\n        // this name as a boolean expression - avoiding this overhead.\r\n        const value = name.id.value;\r\n        const range = name.id.range;\r\n        switch (value) {\r\n            case 'True': {\r\n                this.writer.name('true', range);\r\n                break;\r\n            }\r\n            case 'False': {\r\n                this.writer.name('false', range);\r\n                break;\r\n            }\r\n            case 'str': {\r\n                this.writer.name('string', range);\r\n                break;\r\n            }\r\n            case 'num': {\r\n                this.writer.name('number', range);\r\n                break;\r\n            }\r\n            case 'None': {\r\n                this.writer.name('null', range);\r\n                break;\r\n            }\r\n            /*\r\n            case 'dict': {\r\n                const testDict = \"(function dict(...keys: dictVal[]):Dict {const dict1 = new Dict(keys); return dict1;})\";\r\n                this.writer.name(`${testDict}`, range);\r\n                break;\r\n            }\r\n            */\r\n            case 'bool': {\r\n                this.writer.name('boolean', range);\r\n                break;\r\n            }\r\n            default: {\r\n                this.writer.name(value, range);\r\n            }\r\n        }\r\n    }\r\n    num(num: Num): void {\r\n        const value = num.n.value;\r\n        const range = num.n.range;\r\n        this.writer.num(value.toString(), range);\r\n    }\r\n    print(print: Print): void {\r\n        this.writer.name(\"console\", null);\r\n        this.writer.write(\".\", null);\r\n        this.writer.name(\"log\", null);\r\n        this.writer.openParen();\r\n        for (const value of print.values) {\r\n            value.accept(this);\r\n        }\r\n        this.writer.closeParen();\r\n    }\r\n    returnStatement(rs: ReturnStatement): void {\r\n        this.writer.beginStatement();\r\n        this.writer.write(\"return\", null);\r\n        this.writer.write(\" \", null);\r\n        rs.value.accept(this);\r\n        this.writer.endStatement();\r\n    }\r\n    str(str: Str): void {\r\n        const s = str.s;\r\n        // const begin = str.begin;\r\n        // const end = str.end;\r\n        this.writer.str(toStringLiteralJS(s.value), s.range);\r\n    }\r\n}\r\n\r\nexport function transpileModule(sourceText: string, trace = false): { code: string; sourceMap: SourceMap; } {\r\n    const cst = parse(sourceText, SourceKind.File);\r\n    if (typeof cst === 'object') {\r\n        const stmts = astFromParse(cst);\r\n        const mod = new Module(stmts);\r\n        const symbolTable = semanticsOfModule(mod);\r\n        const printer = new Printer(symbolTable, 0, sourceText, 1, 0, trace);\r\n        const textAndMappings = printer.transpileModule(mod);\r\n        const code = textAndMappings.text;\r\n        const sourceMap = mappingTreeToSourceMap(textAndMappings.tree, trace);\r\n        return { code, sourceMap };\r\n    }\r\n    else {\r\n        throw new Error(`Error parsing source for file.`);\r\n    }\r\n}\r\n\r\nconst NIL_VALUE = new Position(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\nconst HI_KEY = new Position(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\nconst LO_KEY = new Position(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);\r\n\r\nfunction mappingTreeToSourceMap(mappingTree: MappingTree, trace: boolean): SourceMap {\r\n    const sourceToTarget = new RBTree<Position, Position>(LO_KEY, HI_KEY, NIL_VALUE, positionComparator);\r\n    const targetToSource = new RBTree<Position, Position>(LO_KEY, HI_KEY, NIL_VALUE, positionComparator);\r\n    if (mappingTree) {\r\n        for (const mapping of mappingTree.mappings()) {\r\n            const source = mapping.source;\r\n            const target = mapping.target;\r\n            // Convert to immutable values for targets.\r\n            const tBegin = new Position(target.begin.line, target.begin.column);\r\n            const tEnd = new Position(target.end.line, target.end.column);\r\n            if (trace) {\r\n                console.log(`${source.begin} => ${tBegin}`);\r\n                console.log(`${source.end} => ${tEnd}`);\r\n            }\r\n            sourceToTarget.insert(source.begin, tBegin);\r\n            sourceToTarget.insert(source.end, tEnd);\r\n            targetToSource.insert(tBegin, source.begin);\r\n            targetToSource.insert(tEnd, source.end);\r\n        }\r\n    }\r\n    return new SourceMap(sourceToTarget, targetToSource);\r\n}\r\n","import { RBTree } from 'generic-rbtree';\r\nimport { Position } from 'code-writer';\r\n\r\nexport class SourceMap {\r\n    constructor(private sourceToTarget: RBTree<Position, Position>, private targetToSource: RBTree<Position, Position>) {\r\n        // Do nothing yet.\r\n    }\r\n    getTargetPosition(sourcePos: Position): Position | null {\r\n        const nodeL = this.sourceToTarget.glb(sourcePos);\r\n        const nodeU = this.sourceToTarget.lub(sourcePos);\r\n        if (nodeL) {\r\n            if (nodeU) {\r\n                return interpolate(sourcePos.line, sourcePos.column, nodeL.key, nodeL.value);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    getSourcePosition(targetPos: Position): Position {\r\n        const nodeL = this.targetToSource.glb(targetPos);\r\n        if (nodeL) {\r\n            return interpolate(targetPos.line, targetPos.column, nodeL.key, nodeL.value);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\nfunction interpolate(sourceLine: number, sourceColumn: number, sourceBegin: Position, targetBegin: Position): Position {\r\n    const lineOffset = sourceLine - sourceBegin.line;\r\n    const columnOffset = sourceColumn - sourceBegin.column;\r\n    const targetLine = targetBegin.line + lineOffset;\r\n    const targetColumn = targetBegin.column + columnOffset;\r\n    return new Position(targetLine, targetColumn);\r\n}\r\n","import { Attribute } from 'typhon-lang';\r\nimport { FunctionDef } from 'typhon-lang';\r\nimport { Name } from 'typhon-lang';\r\nimport { RangeAnnotated } from 'typhon-lang';\r\n\r\n/**\r\n * Determines whether the name or attribute should be considered to be a class.\r\n * This is a heuristic test based upon the JavaScript convention for class names.\r\n * In future we may be able to use type information.\r\n */\r\nexport function isClassNameByConvention(name: Attribute | Name): boolean {\r\n    const id = name.id;\r\n    if (id instanceof RangeAnnotated && typeof id.value === 'string') {\r\n        // console.lg(`name => ${JSON.stringify(name, null, 2)}`);\r\n        const N = id.value.length;\r\n        if (N > 0) {\r\n            const firstChar = id.value[0];\r\n            return firstChar.toUpperCase() === firstChar;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function isMethod(functionDef: FunctionDef): boolean {\r\n    for (let i = 0; i < functionDef.args.args.length; i++) {\r\n        if (i === 0) {\r\n            const arg = functionDef.args.args[i];\r\n            if (arg.name.id.value === 'self') {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n","/**\r\n * FIXME: Argument should be declared as string but not allowed by TypeScript compiler.\r\n * May be a bug when comparing to 0x7f below.\r\n */\r\nexport function toStringLiteralJS(value: string): string {\r\n    // single is preferred\r\n    let quote = \"'\";\r\n    if (value.indexOf(\"'\") !== -1 && value.indexOf('\"') === -1) {\r\n        quote = '\"';\r\n    }\r\n    const len = value.length;\r\n    let ret = quote;\r\n    for (let i = 0; i < len; ++i) {\r\n        const c = value.charAt(i);\r\n        if (c === quote || c === '\\\\')\r\n            ret += '\\\\' + c;\r\n        else if (c === '\\t')\r\n            ret += '\\\\t';\r\n        else if (c === '\\n')\r\n            ret += '\\\\n';\r\n        else if (c === '\\r')\r\n            ret += '\\\\r';\r\n        else if (c < ' ' || c as any >= 0x7f) {\r\n            let ashex = c.charCodeAt(0).toString(16);\r\n            if (ashex.length < 2) ashex = \"0\" + ashex;\r\n            ret += \"\\\\x\" + ashex;\r\n        }\r\n        else\r\n            ret += c;\r\n    }\r\n    ret += quote;\r\n    return ret;\r\n}\r\n","/**\r\n * We're looking for something that is truthy, not just true.\r\n */\r\nexport function assert(condition: any, message?: string): void {\r\n    if (!condition) {\r\n        throw new Error(message);\r\n    }\r\n}\r\n\r\nexport function fail(message: string): void {\r\n    assert(false, message);\r\n}\r\n"],"names":["Position","RBTree","positionComparator","semanticsOfModule","Module","astFromParse","parse","SourceKind","NotIn","In","IsNot","Is","GtE","Gt","LtE","Lt","NotEq","Eq","Attribute","Name","FloorDiv","Mod","RShift","LShift","BitAnd","BitXor","BitOr","Div","Mult","Sub","Add","DEF_LOCAL","Call","CodeWriter","RangeAnnotated"],"mappings":"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"}