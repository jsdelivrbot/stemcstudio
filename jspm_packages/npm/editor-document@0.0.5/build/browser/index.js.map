{"version":3,"file":"index.js","sources":["../../src/Document.ts","../../src/Range.ts","../../src/EventEmitterClass.ts","../../src/Position.ts","../../src/applyDelta.ts"],"sourcesContent":["import { applyDelta } from './applyDelta';\nimport { equalPositions } from './Position';\nimport { Delta } from './Delta';\nimport { EventEmitterClass } from './EventEmitterClass';\nimport { Position, position } from './Position';\nimport { isEmptyRange, Range, range } from './Range';\nimport { Shareable } from './Shareable';\n\n/**\n * Copies a Position.\n */\nfunction clonePos(pos: Readonly<Position>): Position {\n    return { row: pos.row, column: pos.column };\n}\n\n/**\n * Constructs a Position from row and column.\n */\nfunction pos(row: number, column: number): Position {\n    return { row: row, column: column };\n}\n\nconst $split: (text: string) => string[] = (function () {\n    function foo(text: string): string[] {\n        return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n    }\n    function bar(text: string): string[] {\n        return text.split(/\\r\\n|\\r|\\n/);\n    }\n    // Determine whether the split function performs as we expect.\n    // Here we attempt to separate a string of three separators.\n    // If all works out, we should get back an array of four (4) empty strings.\n    if (\"aaa\".split(/a/).length === 0) {\n        return foo;\n    }\n    else {\n        // In Chrome, this is the mainline because the result\n        // of the test condition length is 4.\n        return bar;\n    }\n})();\n\n/*\nfunction clipPosition(doc: Document, position: Position): Position {\n    const length = doc.getLength();\n    if (position.row >= length) {\n        position.row = Math.max(0, length - 1);\n        position.column = doc.getLine(length - 1).length;\n    }\n    else {\n        position.row = Math.max(0, position.row);\n        position.column = Math.min(Math.max(position.column, 0), doc.getLine(position.row).length);\n    }\n    return position;\n}\n*/\n\nconst CHANGE = 'change';\nconst CHANGE_NEW_LINE_MODE = 'changeNewLineMode';\nexport type DocumentEventName = 'change' | 'changeNewLineMode';\nexport type NewLineMode = 'auto' | 'unix' | 'windows';\n\n/**\n *\n */\nexport class Document implements Shareable {\n\n    /**\n     * The lines of text.\n     * These lines do not include a line terminating character.\n     */\n    private readonly _lines: string[] = [];\n\n    /**\n     *\n     */\n    private _autoNewLine = \"\";\n\n    /**\n     *\n     */\n    private _newLineMode: NewLineMode = \"auto\";\n\n    /**\n     * A source of 'change' events that is observable.\n     */\n    /*\n    public readonly changeEvents: Observable<Delta>;\n    */\n\n    /**\n     *\n     */\n    private _eventBus: EventEmitterClass<DocumentEventName, any, Document> | undefined;\n\n    /**\n     * Maintains a count of the number of references to this instance of Document.\n     */\n    private refCount = 1;\n\n    /**\n     * If text is included, the Document contains those strings; otherwise, it's empty.\n     * A `change` event will be emitted. But does anyone see it?\n     *\n     * @param textOrLines\n     */\n    constructor(textOrLines: string | Array<string>) {\n        this._lines = [\"\"];\n\n        this._eventBus = new EventEmitterClass<DocumentEventName, any, Document>(this);\n        /*\n        this.changeEvents = new Observable<Delta>((observer: Observer<Delta>) => {\n            function changeListener(value: Delta, source: Document) {\n                observer.next(value);\n            }\n            this.addChangeListener(changeListener);\n            return () => {\n                this.removeChangeListener(changeListener);\n            };\n        });\n        */\n\n        // There has to be one line at least in the document. If you pass an empty\n        // string to the insert function, nothing will happen. Workaround.\n        if (textOrLines.length === 0) {\n            this._lines = [\"\"];\n        }\n        else if (Array.isArray(textOrLines)) {\n            this.insertMergedLines({ row: 0, column: 0 }, textOrLines);\n        }\n        else {\n            this.insert({ row: 0, column: 0 }, textOrLines);\n        }\n    }\n\n    protected destructor(): void {\n        this._lines.length = 0;\n        this._eventBus = void 0;\n    }\n\n    public addRef(): number {\n        this.refCount++;\n        return this.refCount;\n    }\n\n    public release(): number {\n        this.refCount--;\n        if (this.refCount === 0) {\n            this.destructor();\n        }\n        else if (this.refCount < 0) {\n            throw new Error(\"Document refCount is negative.\");\n        }\n        return this.refCount;\n    }\n\n    /**\n     * Replaces all the lines in the current `Document` with the value of `text`.\n     * A `change` event will be emitted.\n     */\n    setValue(text: string): void {\n        const row = this.getLength() - 1;\n        const start = position(0, 0);\n        const end = position(row, this.getLine(row).length);\n        // FIXME: Can we avoid the temporary objects?\n        this.remove(range(start, end));\n        this.insert({ row: 0, column: 0 }, text);\n    }\n\n    /**\n     * Returns all the lines in the document as a single string, joined by the new line character.\n     */\n    getValue(): string {\n        return this._lines.join(this.getNewLineCharacter());\n    }\n\n    private eventBusOrThrow() {\n        if (this._eventBus) {\n            return this._eventBus;\n        }\n        else {\n            throw new Error(\"Document is a zombie.\");\n        }\n    }\n\n    /**\n     * Determines the newline character that is present in the presented text\n     * and caches the result in $autoNewLine.\n     * Emits 'changeNewLineMode'.\n     */\n    private $detectNewLine(text: string): void {\n        const match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n        this._autoNewLine = match ? match[1] : \"\\n\";\n        this.eventBusOrThrow()._signal(CHANGE_NEW_LINE_MODE);\n    }\n\n    /**\n     * Returns the newline character that's being used, depending on the value of `newLineMode`.\n     *  If `newLineMode == windows`, `\\r\\n` is returned.\n     *  If `newLineMode == unix`, `\\n` is returned.\n     *  If `newLineMode == auto`, the value of `autoNewLine` is returned.\n     */\n    getNewLineCharacter(): string {\n        switch (this._newLineMode) {\n            case \"windows\":\n                return \"\\r\\n\";\n            case \"unix\":\n                return \"\\n\";\n            default:\n                return this._autoNewLine || \"\\n\";\n        }\n    }\n\n    /**\n     * Sets the new line mode.\n     *\n     * newLineMode is the newline mode to use; can be either `windows`, `unix`, or `auto`.\n     * Emits 'changeNewLineMode'\n     */\n    setNewLineMode(newLineMode: NewLineMode): void {\n        if (this._newLineMode === newLineMode) {\n            return;\n        }\n        this._newLineMode = newLineMode;\n        this.eventBusOrThrow()._signal(CHANGE_NEW_LINE_MODE);\n    }\n\n    /**\n     * Returns the type of newlines being used; either `windows`, `unix`, or `auto`.\n     */\n    getNewLineMode(): NewLineMode {\n        return this._newLineMode;\n    }\n\n    /**\n     * Returns `true` if `text` is a newline character (either `\\r\\n`, `\\r`, or `\\n`).\n     *\n     * @param text The text to check.\n     */\n    isNewLine(text: string): boolean {\n        return (text === \"\\r\\n\" || text === \"\\r\" || text === \"\\n\");\n    }\n\n    /**\n     * Returns a verbatim copy of the given line as it is in the document.\n     *\n     * @param row The row index to retrieve.\n     */\n    getLine(row: number): string {\n        return this._lines[row] || \"\";\n    }\n\n    /**\n     * Returns a COPY of the lines between and including `firstRow` and `lastRow`.\n     * These lines do not include the line terminator.\n     *\n     * @param firstRow The first row index to retrieve.\n     * @param lastRow The final row index to retrieve.\n     */\n    getLines(firstRow: number, lastRow: number): string[] {\n        // The semantics of slice are that it does not include the end index.\n        const end = lastRow + 1;\n        return this._lines.slice(firstRow, end);\n    }\n\n    /**\n     * Returns a COPY of the lines in the document.\n     * These lines do not include the line terminator.\n     */\n    getAllLines(): string[] {\n        return this._lines.slice(0, this._lines.length);\n    }\n\n    /**\n     * Returns the number of rows in the document.\n     */\n    getLength(): number {\n        return this._lines.length;\n    }\n\n    /**\n     * Returns all the text corresponding to the range with line terminators.\n     */\n    getTextRange(range: Readonly<Range>): string {\n        return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    }\n\n    /**\n     * Returns all the text within `range` as an array of lines.\n     */\n    getLinesForRange(range: Readonly<Range>): string[] {\n        let lines: string[];\n        if (range.start.row === range.end.row) {\n            // Handle a single-line range.\n            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n        }\n        else {\n            // Handle a multi-line range.\n            lines = this.getLines(range.start.row, range.end.row);\n            lines[0] = (lines[0] || \"\").substring(range.start.column);\n            const l = lines.length - 1;\n            if (range.end.row - range.start.row === l) {\n                lines[l] = lines[l].substring(0, range.end.column);\n            }\n        }\n        return lines;\n    }\n\n    /**\n     * Inserts a block of `text` at the indicated `position`.\n     * Returns the end position of the inserted text, the character immediately after the last character inserted.\n     * This method also triggers the 'change' event.\n     */\n    insert(position: Position, text: string): Position {\n        // Only detect new lines if the document has no line break yet.\n        if (this.getLength() <= 1) {\n            this.$detectNewLine(text);\n        }\n        return this.insertMergedLines(position, $split(text));\n    }\n\n    /**\n     * Inserts `text` into the `position` at the current row. This method also triggers the `\"change\"` event.\n     *\n     * This differs from the `insert` method in two ways:\n     *   1. This does NOT handle newline characters (single-line text only).\n     *   2. This is faster than the `insert` method for single-line text insertions.\n     */\n    insertInLine(position: Readonly<Position>, text: string): Position {\n        const start: Position = this.clippedPos(position.row, position.column);\n        const end: Position = pos(position.row, position.column + text.length);\n\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: [text]\n        }, true);\n\n        return clonePos(end);\n    }\n\n    /**\n     * Clips the position so that it refers to the nearest valid position.\n     */\n    clippedPos(row: number, column: number): Position {\n        const length = this.getLength();\n        let rowTooBig = false;\n        if (row === void 0) {\n            row = length;\n        }\n        else if (row < 0) {\n            row = 0;\n        }\n        else if (row >= length) {\n            row = length - 1;\n            rowTooBig = true;\n        }\n        const line = this.getLine(row);\n        if (rowTooBig) {\n            column = line.length;\n        }\n        column = Math.min(Math.max(column, 0), line.length);\n        return { row: row, column: column };\n    }\n\n    on(eventName: DocumentEventName, callback: (event: any, source: Document) => any, capturing?: boolean): () => void {\n        return this.eventBusOrThrow().on(eventName, callback, capturing);\n    }\n\n    off(eventName: DocumentEventName, callback: (event: any, source: Document) => any, capturing?: boolean): void {\n        return this.eventBusOrThrow().off(eventName, callback, capturing);\n    }\n\n    /**\n     *\n     */\n    addChangeListener(callback: (event: Delta, source: Document) => void): () => void {\n        return this.on(CHANGE, callback, false);\n    }\n\n    /**\n     *\n     */\n    addChangeNewLineModeListener(callback: (event: any, source: Document) => any): void {\n        this.on(CHANGE_NEW_LINE_MODE, callback, false);\n    }\n\n    /**\n     *\n     */\n    removeChangeListener(callback: (event: Delta, source: Document) => any): void {\n        this.off(CHANGE, callback);\n    }\n\n    /**\n     *\n     */\n    removeChangeNewLineModeListener(callback: (event: any, source: Document) => any): void {\n        this.off(CHANGE_NEW_LINE_MODE, callback);\n    }\n\n    /**\n     * Inserts the elements in `lines` into the document as full lines (does not merge with existing line), starting at the row index given by `row`.\n     * This method also triggers the `\"change\"` event.\n     */\n    insertFullLines(row: number, lines: string[]): Position {\n        // Clip to document.\n        // Allow one past the document end.\n        row = Math.min(Math.max(row, 0), this.getLength());\n\n        // Calculate insertion point.\n        let column = 0;\n        if (row < this.getLength()) {\n            // Insert before the specified row.\n            lines = lines.concat([\"\"]);\n            column = 0;\n        }\n        else {\n            // Insert after the last row in the document.\n            lines = [\"\"].concat(lines);\n            row--;\n            column = this._lines[row].length;\n        }\n\n        // Insert.\n        return this.insertMergedLines({ row: row, column: column }, lines);\n    }\n\n    /**\n     * Inserts the text in `lines` into the document, starting at the `position` given.\n     * Returns the end position of the inserted text.\n     * This method also triggers the 'change' event.\n     */\n    insertMergedLines(position: Readonly<Position>, lines: string[]): Position {\n        const start: Position = this.clippedPos(position.row, position.column);\n        const end: Position = {\n            row: start.row + lines.length - 1,\n            column: (lines.length === 1 ? start.column : 0) + lines[lines.length - 1].length\n        };\n\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"insert\",\n            lines: lines\n        });\n\n        return clonePos(end);\n    }\n\n    /**\n     * Removes the `range` from the document.\n     * This method triggers a 'change' event.\n     *\n     * @param range A specified Range to remove\n     * @return Returns the new `start` property of the range.\n     * If `range` is empty, this function returns the unmodified value of `range.start`.\n     */\n    remove(range: Readonly<Range>): Position {\n        const start = this.clippedPos(range.start.row, range.start.column);\n        const end = this.clippedPos(range.end.row, range.end.column);\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({ start: start, end: end })\n        });\n        return clonePos(start);\n    }\n\n    /**\n     * Removes the specified columns from the `row`.\n     * This method also triggers the `'change'` event.\n     *\n     * @param row The row to remove from.\n     * @param startColumn The column to start removing at.\n     * @param endColumn The column to stop removing at.\n     * @returns An object containing `startRow` and `startColumn`, indicating the new row and column values.<br/>If `startColumn` is equal to `endColumn`, this function returns nothing.\n     */\n    removeInLine(row: number, startColumn: number, endColumn: number): Position {\n        const start = this.clippedPos(row, startColumn);\n        const end = this.clippedPos(row, endColumn);\n\n        this.applyDelta({\n            start: start,\n            end: end,\n            action: \"remove\",\n            lines: this.getLinesForRange({ start: start, end: end })\n        }, true);\n\n        return clonePos(start);\n    }\n\n    /**\n     * Removes a range of full lines and returns a COPY of the removed lines.\n     * This method also triggers the `\"change\"` event.\n     *\n     * @param firstRow The first row to be removed\n     * @param lastRow The last row to be removed\n     */\n    removeFullLines(firstRow: number, lastRow: number): string[] {\n        // Clip to document.\n        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);\n\n        // Calculate deletion range.\n        // Delete the ending new line unless we're at the end of the document.\n        // If we're at the end of the document, delete the starting new line.\n        const deleteFirstNewLine = lastRow === this.getLength() - 1 && firstRow > 0;\n        const deleteLastNewLine = lastRow < this.getLength() - 1;\n        const startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);\n        const startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);\n        const endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);\n        const endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);\n\n        const start = position(startRow, startCol);\n        const end = position(endRow, endCol);\n\n        /**\n         * A copy of delelted lines with line terminators omitted (maintains previous behavior).\n         */\n        const deletedLines = this.getLines(firstRow, lastRow);\n\n        this.applyDelta({\n            start,\n            end,\n            action: \"remove\",\n            lines: this.getLinesForRange(range(start, end))\n        });\n\n        return deletedLines;\n    }\n\n    /**\n     * Removes the new line between `row` and the row immediately following it.\n     *\n     * @param row The row to check.\n     */\n    removeNewLine(row: number): void {\n        if (row < this.getLength() - 1 && row >= 0) {\n            this.applyDelta({\n                start: pos(row, this.getLine(row).length),\n                end: pos(row + 1, 0),\n                action: \"remove\",\n                lines: [\"\", \"\"]\n            });\n        }\n    }\n\n    /**\n     * Replaces a range in the document with the new `text`.\n     * Returns the end position of the change.\n     * This method triggers a 'change' event for the removal.\n     * This method triggers a 'change' event for the insertion.\n     */\n    replace(range: Range, newText: string): Position {\n\n        if (newText.length === 0 && isEmptyRange(range)) {\n            // If the range is empty then the range.start and range.end will be the same.\n            return range.end;\n        }\n\n        const oldText = this.getTextRange(range);\n\n        // Shortcut: If the text we want to insert is the same as it is already\n        // in the document, we don't have to replace anything.\n        if (newText === oldText) {\n            return range.end;\n        }\n\n        this.remove(range);\n\n        return this.insert(range.start, newText);\n    }\n\n    /**\n     * Applies all the changes previously accumulated.\n     */\n    applyDeltas(deltas: Delta[]): void {\n        for (let i = 0; i < deltas.length; i++) {\n            this.applyDelta(deltas[i]);\n        }\n    }\n\n    /**\n     * Reverts any changes previously applied.\n     */\n    revertDeltas(deltas: Delta[]): void {\n        for (let i = deltas.length - 1; i >= 0; i--) {\n            this.revertDelta(deltas[i]);\n        }\n    }\n\n    /**\n     * Applies `delta` (insert and remove actions) to the document and triggers the 'change' event.\n     */\n    applyDelta(delta: Delta, doNotValidate?: boolean): void {\n\n        const isInsert = delta.action === \"insert\";\n        // An empty range is a NOOP.\n        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : equalPositions(delta.start, delta.end)) {\n            return;\n        }\n\n        if (isInsert && delta.lines.length > 20000)\n            this.$splitAndapplyLargeDelta(delta, 20000);\n\n        applyDelta(this._lines, delta, doNotValidate);\n        this.eventBusOrThrow()._signal(CHANGE, delta);\n    }\n\n    private $splitAndapplyLargeDelta(delta: Delta, MAX: number): void {\n        // Split large insert deltas. This is necessary because:\n        //    1. We need to support splicing delta lines into the document via $lines.splice.apply(...)\n        //    2. fn.apply() doesn't work for a large number of params. The smallest threshold is on chrome 40 ~42000.\n        // we use 20000 to leave some space for actual stack\n        //\n        // To Do: Ideally we'd be consistent and also split 'delete' deltas. We don't do this now, because delete\n        //        delta handling is too slow. If we make delete delta handling faster we can split all large deltas\n        //        as shown in https://gist.github.com/aldendaniels/8367109#file-document-snippet-js\n        //        If we do this, update validateDelta() to limit the number of lines in a delete delta.\n        const lines = delta.lines;\n        const l = lines.length;\n        const row = delta.start.row;\n        let column = delta.start.column;\n        let from = 0;\n        let to = 0;\n        do {\n            from = to;\n            to += MAX - 1;\n            const chunk = lines.slice(from, to);\n            if (to > l) {\n                // Update remaining delta.\n                delta.lines = chunk;\n                delta.start.row = row + from;\n                delta.start.column = column;\n                break;\n            }\n            chunk.push(\"\");\n            this.applyDelta({\n                start: pos(row + from, column),\n                end: pos(row + to, column = 0),\n                action: delta.action,\n                lines: chunk\n            }, true);\n        } while (true);\n    }\n\n    /**\n     * Reverts `delta` from the document.\n     * A delta object (can include \"insert\" and \"remove\" actions)\n     */\n    revertDelta(delta: Readonly<Delta>): void {\n        this.applyDelta({\n            start: clonePos(delta.start),\n            end: clonePos(delta.end),\n            action: (delta.action === \"insert\" ? \"remove\" : \"insert\"),\n            lines: delta.lines.slice()\n        });\n    }\n\n    /**\n     * Converts an index position in a document to a `{row, column}` object.\n     *\n     * Index refers to the \"absolute position\" of a character in the document. For example:\n     *\n     * ```javascript\n     * x = 0; // 10 characters, plus one for newline\n     * y = -1;\n     * ```\n     *\n     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.\n     *\n     * @param index An index to convert\n     * @param startRow The row from which to start the conversion\n     * @returns An object of the `index` position.\n     */\n    indexToPosition(index: number, startRow = 0): Position {\n        /**\n         * A local reference to improve performance in the loop.\n         */\n        const lines = this._lines;\n        const newlineLength = this.getNewLineCharacter().length;\n        const l = lines.length;\n        for (let i = startRow || 0; i < l; i++) {\n            index -= lines[i].length + newlineLength;\n            if (index < 0)\n                return { row: i, column: index + lines[i].length + newlineLength };\n        }\n        return { row: l - 1, column: lines[l - 1].length };\n    }\n\n    /**\n     * Converts the `position` in a document to the character's zero-based index.\n     *\n     * Index refers to the \"absolute position\" of a character in the document. For example:\n     *\n     * ```javascript\n     * x = 0; // 10 characters, plus one for newline\n     * y = -1;\n     * ```\n     *\n     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.\n     *\n     * @param position The `{row, column}` to convert.\n     * @param startRow The row from which to start the conversion. Defaults to zero.\n     */\n    positionToIndex(position: Readonly<Position>, startRow = 0): number {\n        /**\n         * A local reference to improve performance in the loop.\n         */\n        const lines = this._lines;\n        const newlineLength = this.getNewLineCharacter().length;\n        let index = 0;\n        const row = Math.min(position.row, lines.length);\n        for (let i = startRow || 0; i < row; ++i) {\n            index += lines[i].length + newlineLength;\n        }\n\n        return index + position.column;\n    }\n}\n","import { Position } from './Position';\nimport { equalPositions } from './Position';\n\n/**\n *\n */\nexport interface Range {\n    /**\n     * The starting position of the range.\n     */\n    start: Position;\n    /**\n     * The ending position of the range.\n     */\n    end: Position;\n}\n\n\nexport function range(start: Position, end: Position): Range {\n    return { start, end };\n}\n\n\n/**\n * The range is empty if the start and end position coincide.\n */\nexport function isEmptyRange(range: Range): boolean {\n    return equalPositions(range.start, range.end);\n}\n","// import { Observable } from 'rxjs/Observable';\n// import { Observer } from 'rxjs/Observer';\n// import { EventBus } from \"../EventBus\";\n// import { Command } from '../../virtual/editor';\nconst stopPropagation = function (this: { propagationStopped: boolean }) { this.propagationStopped = true; };\nconst preventDefault = function (this: { defaultPrevented: boolean }) { this.defaultPrevented = true; };\n/*\nexport interface DefaultHandler<T> {\n    (event: { command: Command<T>; target: T, args: any }, source: T): void;\n}\n*/\n/**\n * Intended to be used as a Mixin.\n * N.B. The original implementation was an object, the TypeScript way is\n * designed to satisfy the compiler.\n */\nexport class EventEmitterClass<NAME extends string, E, T> {\n\n    /**\n     * Each event name has multiple callbacks.\n     */\n    public _eventRegistry: { [name: string]: ((event: E | undefined, source: T) => void)[] };\n\n    /**\n     * There may be one default handler for an event too.\n     */\n    private _defaultHandlers: { [name: string]: (event: E, source: T) => void };\n\n    private owner: T;\n\n    /**\n     *\n     */\n    constructor(owner: T) {\n        this.owner = owner;\n    }\n\n    /**\n     * Calls the listeners any any default handlers with an elaborate\n     * mechanism for limiting both propagation and the default invocation.\n     */\n    private _dispatchEvent(eventName: NAME, event?: E): any {\n\n        if (!this._eventRegistry) {\n            this._eventRegistry = {};\n        }\n\n        if (!this._defaultHandlers) {\n            this._defaultHandlers = {};\n        }\n\n        let listeners = this._eventRegistry[eventName] || [];\n\n        const defaultHandler = this._defaultHandlers[eventName];\n\n        if (!listeners.length && !defaultHandler)\n            return;\n\n        if (typeof event !== \"object\" || !event) {\n            event = <E>{};\n        }\n\n        // FIXME: This smells a bit.\n        if (!event['type']) {\n            event['type'] = eventName;\n        }\n\n        if (!event['stopPropagation']) {\n            event['stopPropagation'] = stopPropagation;\n        }\n\n        if (!event['preventDefault']) {\n            event['preventDefault'] = preventDefault;\n        }\n\n        // Make a copy in order to avoid race conditions.\n        listeners = listeners.slice();\n        for (let i = 0; i < listeners.length; i++) {\n            listeners[i](event, this.owner);\n            if (event['propagationStopped']) {\n                break;\n            }\n        }\n\n        if (defaultHandler && !event['defaultPrevented']) {\n            return defaultHandler(event, this.owner);\n        }\n    }\n\n    /**\n     *\n     */\n    hasListeners(eventName: NAME): boolean {\n        const registry = this._eventRegistry;\n        const listeners = registry && registry[eventName];\n        return listeners && listeners.length > 0;\n    }\n\n    /**\n     * Emit uses the somewhat complex semantics of the dispatchEvent method.\n     * Consider using `signal` for more elementary behaviour.\n     */\n    _emit(eventName: NAME, event?: E): any {\n        return this._dispatchEvent(eventName, event);\n    }\n\n    /**\n     * Calls each listener subscribed to the eventName passing the event and the source.\n     */\n    _signal(eventName: NAME, event?: E) {\n        /**\n         * The listeners subscribed to the specified event name\n         */\n        let listeners = (this._eventRegistry || {})[eventName];\n\n        if (!listeners) {\n            return;\n        }\n\n        // slice just makes a copy so that we don't mess up on array bounds.\n        // It's a bit expensive though?\n        listeners = listeners.slice();\n        for (const listener of listeners) {\n            listener(event, this.owner);\n        }\n    }\n\n    /*\n        events(eventName: NAME): Observable<E> {\n            return new Observable<E>((observer: Observer<E>) => {\n                function changeListener(value: E, source: T) {\n                    observer.next(value);\n                }\n                return this.on(eventName, changeListener, false);\n            });\n        }\n    */\n    once(eventName: NAME, callback: (event: E, source: T) => any) {\n        const _self = this;\n        if (callback) {\n            this.addEventListener(eventName, function newCallback() {\n                _self.removeEventListener(eventName, newCallback);\n                callback.apply(null, arguments);\n            });\n        }\n    }\n    /*\n        setDefaultHandler(eventName: NAME, callback: DefaultHandler<T>) {\n            // FIXME: All this casting is creepy.\n            let handlers: any = this._defaultHandlers;\n            if (!handlers) {\n                handlers = this._defaultHandlers = <any>{ _disabled_: {} };\n            }\n\n            if (handlers[eventName]) {\n                const existingHandler = handlers[eventName];\n                let disabled = handlers._disabled_[eventName];\n                if (!disabled) {\n                    handlers._disabled_[eventName] = disabled = [];\n                }\n                disabled.push(existingHandler);\n                const i = disabled.indexOf(callback);\n                if (i !== -1)\n                    disabled.splice(i, 1);\n            }\n            handlers[eventName] = callback;\n        }\n    */\n    /*\n        removeDefaultHandler(eventName: NAME, callback: (event: E, source: T) => any) {\n            // FIXME: All this casting is creepy.\n            const handlers: any = this._defaultHandlers;\n            if (!handlers) {\n                return;\n            }\n            const disabled = handlers._disabled_[eventName];\n\n            if (handlers[eventName] === callback) {\n                // FIXME: Something wrong here.\n                // unused = handlers[eventName];\n                if (disabled) {\n                    this.setDefaultHandler(eventName, disabled.pop());\n                }\n            }\n            else if (disabled) {\n                const i = disabled.indexOf(callback);\n                if (i !== -1) {\n                    disabled.splice(i, 1);\n                }\n            }\n        }\n    */\n    // Discourage usage.\n    private addEventListener(eventName: NAME, callback: (event: E, source: T) => void, capturing?: boolean) {\n        this._eventRegistry = this._eventRegistry || {};\n\n        let listeners = this._eventRegistry[eventName];\n        if (!listeners) {\n            listeners = this._eventRegistry[eventName] = [];\n        }\n\n        if (listeners.indexOf(callback) === -1) {\n            if (capturing) {\n                listeners.unshift(callback);\n            }\n            else {\n                listeners.push(callback);\n            }\n        }\n        return () => {\n            this.removeEventListener(eventName, callback, capturing);\n        };\n    }\n\n    /**\n     *\n     */\n    on(eventName: NAME, callback: (event: E, source: T) => any, capturing?: boolean): () => void {\n        return this.addEventListener(eventName, callback, capturing);\n    }\n\n    // Discourage usage.\n    private removeEventListener(eventName: NAME, callback: (event: E, source: T) => any, capturing?: boolean) {\n        this._eventRegistry = this._eventRegistry || {};\n\n        const listeners = this._eventRegistry[eventName];\n        if (!listeners)\n            return;\n\n        const index = listeners.indexOf(callback);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    }\n\n    /**\n     *\n     */\n    public off(eventName: NAME, callback: (event: E, source: T) => any, capturing?: boolean): void {\n        return this.removeEventListener(eventName, callback, capturing);\n    }\n\n    /**\n     *\n     */\n    removeAllListeners(eventName: NAME) {\n        if (this._eventRegistry) this._eventRegistry[eventName] = [];\n    }\n}\n","/**\n * The zero-based coordinates of a character in the editor.\n * (row,column) => (0,0) is the topmost and leftmost character.\n */\nexport interface Position {\n    /**\n     * The zero-based row.\n     */\n    row: number;\n    /**\n     * The zero-based column.\n     */\n    column: number;\n}\n\nexport function position(row: number, column: number): Position {\n    return { row, column };\n}\n\n/**\n * Returns 0 if positions are equal, +1 if p1 comes after p2, -1 if p1 comes before p2.\n */\nexport function comparePositions(p1: Position, p2: Position): 1 | -1 | 0 {\n    if (p1.row > p2.row) {\n        return 1;\n    }\n    else if (p1.row < p2.row) {\n        return -1;\n    }\n    else {\n        if (p1.column > p2.column) {\n            return 1;\n        }\n        else if (p1.column < p2.column) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n\nexport function equalPositions(p1: Position, p2: Position): boolean {\n    return p1.row === p2.row && p1.column === p2.column;\n}\n","import { Delta } from './Delta';\n\nexport function applyDelta(docLines: string[], delta: Delta, doNotValidate?: boolean): void {\n\n    // Disabled validation since it breaks autocompletion popup.\n    /*\n    if (!doNotValidate) {\n        validateDelta(docLines, delta);\n    }\n    */\n\n    const row = delta.start.row;\n    const startColumn = delta.start.column;\n    const line = docLines[row] || \"\";\n    switch (delta.action) {\n        case \"insert\":\n            const lines = delta.lines;\n            if (lines.length === 1) {\n                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n            }\n            else {\n                let args: any[] = [row, 1];\n                args = args.concat(delta.lines);\n                docLines.splice.apply(docLines, args);\n                docLines[row] = line.substring(0, startColumn) + docLines[row];\n                docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n            }\n            break;\n        case \"remove\":\n            const endColumn = delta.end.column;\n            const endRow = delta.end.row;\n            if (row === endRow) {\n                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n            }\n            else {\n                docLines.splice(\n                    row, endRow - row + 1,\n                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)\n                );\n            }\n            break;\n        default: {\n            // Do nothing.\n        }\n    }\n}\n"],"names":["position","range"],"mappings":"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"}