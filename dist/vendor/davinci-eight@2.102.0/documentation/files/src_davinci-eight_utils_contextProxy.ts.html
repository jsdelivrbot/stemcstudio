<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/davinci-eight/utils/contextProxy.ts - davinci-eight</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="davinci-eight"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.117.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AnimatedMirror.html">AnimatedMirror</a></li>
                                <li><a href="../classes/AttribLocation.html">AttribLocation</a></li>
                                <li><a href="../classes/AttribMetaInfo.html">AttribMetaInfo</a></li>
                                <li><a href="../classes/BarnGeometry.html">BarnGeometry</a></li>
                                <li><a href="../classes/BoxBuilder.html">BoxBuilder</a></li>
                                <li><a href="../classes/BoxMesh.html">BoxMesh</a></li>
                                <li><a href="../classes/Canvas3D.html">Canvas3D</a></li>
                                <li><a href="../classes/Cartesian1.html">Cartesian1</a></li>
                                <li><a href="../classes/Cartesian2.html">Cartesian2</a></li>
                                <li><a href="../classes/Cartesian3.html">Cartesian3</a></li>
                                <li><a href="../classes/Cartesian4.html">Cartesian4</a></li>
                                <li><a href="../classes/Color.html">Color</a></li>
                                <li><a href="../classes/ColorFacet.html">ColorFacet</a></li>
                                <li><a href="../classes/ColorRGB.html">ColorRGB</a></li>
                                <li><a href="../classes/Complex.html">Complex</a></li>
                                <li><a href="../classes/ContextAttributesLogger.html">ContextAttributesLogger</a></li>
                                <li><a href="../classes/ContextController.html">ContextController</a></li>
                                <li><a href="../classes/ContextRenderer.html">ContextRenderer</a></li>
                                <li><a href="../classes/createView.html">createView</a></li>
                                <li><a href="../classes/CuboidGeometry.html">CuboidGeometry</a></li>
                                <li><a href="../classes/CuboidMesh.html">CuboidMesh</a></li>
                                <li><a href="../classes/CylinderArgs.html">CylinderArgs</a></li>
                                <li><a href="../classes/Dimensions.html">Dimensions</a></li>
                                <li><a href="../classes/Drawable.html">Drawable</a></li>
                                <li><a href="../classes/EIGHTLogger.html">EIGHTLogger</a></li>
                                <li><a href="../classes/ElementArray.html">ElementArray</a></li>
                                <li><a href="../classes/ElementBuffer.html">ElementBuffer</a></li>
                                <li><a href="../classes/EllipsoidMesh.html">EllipsoidMesh</a></li>
                                <li><a href="../classes/Euclidean1.html">Euclidean1</a></li>
                                <li><a href="../classes/Euclidean2.html">Euclidean2</a></li>
                                <li><a href="../classes/Euclidean3.html">Euclidean3</a></li>
                                <li><a href="../classes/EulerFacet.html">EulerFacet</a></li>
                                <li><a href="../classes/Face3.html">Face3</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryAttribute.html">GeometryAttribute</a></li>
                                <li><a href="../classes/GeometryData.html">GeometryData</a></li>
                                <li><a href="../classes/GeometryElements.html">GeometryElements</a></li>
                                <li><a href="../classes/GeometryMeta.html">GeometryMeta</a></li>
                                <li><a href="../classes/HTMLScriptsMaterial.html">HTMLScriptsMaterial</a></li>
                                <li><a href="../classes/IAnimation.html">IAnimation</a></li>
                                <li><a href="../classes/IAnimationClock.html">IAnimationClock</a></li>
                                <li><a href="../classes/IBufferGeometry.html">IBufferGeometry</a></li>
                                <li><a href="../classes/IContextConsumer.html">IContextConsumer</a></li>
                                <li><a href="../classes/IContextMonitor.html">IContextMonitor</a></li>
                                <li><a href="../classes/IContextProvider.html">IContextProvider</a></li>
                                <li><a href="../classes/IDrawable.html">IDrawable</a></li>
                                <li><a href="../classes/IDrawList.html">IDrawList</a></li>
                                <li><a href="../classes/IExchange.html">IExchange</a></li>
                                <li><a href="../classes/IFacet
                extends IUnknown.html">IFacet
                extends IUnknown</a></li>
                                <li><a href="../classes/IFacetVisitor.html">IFacetVisitor</a></li>
                                <li><a href="../classes/IMaterial.html">IMaterial</a></li>
                                <li><a href="../classes/IPrologCommand.html">IPrologCommand</a></li>
                                <li><a href="../classes/IProperties.html">IProperties</a></li>
                                <li><a href="../classes/ISlide.html">ISlide</a></li>
                                <li><a href="../classes/IUnknown.html">IUnknown</a></li>
                                <li><a href="../classes/IUnknownArray.html">IUnknownArray</a></li>
                                <li><a href="../classes/KleinBottleGeometry.html">KleinBottleGeometry</a></li>
                                <li><a href="../classes/Line3.html">Line3</a></li>
                                <li><a href="../classes/LinearElement&lt;I, M, S&gt;.html">LinearElement&lt;I, M, S&gt;</a></li>
                                <li><a href="../classes/LineMaterial.html">LineMaterial</a></li>
                                <li><a href="../classes/LocalizableMessage.html">LocalizableMessage</a></li>
                                <li><a href="../classes/Material.html">Material</a></li>
                                <li><a href="../classes/Matrix4.html">Matrix4</a></li>
                                <li><a href="../classes/Matrix&lt;M&gt;.html">Matrix&lt;M&gt;</a></li>
                                <li><a href="../classes/MeshMaterial.html">MeshMaterial</a></li>
                                <li><a href="../classes/ModelFacet.html">ModelFacet</a></li>
                                <li><a href="../classes/Mutable.html">Mutable</a></li>
                                <li><a href="../classes/NumberIUnknownMap&lt;V&gt;.html">NumberIUnknownMap&lt;V&gt;</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/PerspectiveCamera.html">PerspectiveCamera</a></li>
                                <li><a href="../classes/Point3.html">Point3</a></li>
                                <li><a href="../classes/PointMaterial.html">PointMaterial</a></li>
                                <li><a href="../classes/Rational.html">Rational</a></li>
                                <li><a href="../classes/Scene.html">Scene</a></li>
                                <li><a href="../classes/ShaderVariableDecl.html">ShaderVariableDecl</a></li>
                                <li><a href="../classes/Shareable.html">Shareable</a></li>
                                <li><a href="../classes/Simplex.html">Simplex</a></li>
                                <li><a href="../classes/Simplex1Geometry.html">Simplex1Geometry</a></li>
                                <li><a href="../classes/SmartMaterial.html">SmartMaterial</a></li>
                                <li><a href="../classes/SmartMaterialBuilder.html">SmartMaterialBuilder</a></li>
                                <li><a href="../classes/Spinor3.html">Spinor3</a></li>
                                <li><a href="../classes/StringIUnknownMap.html">StringIUnknownMap</a></li>
                                <li><a href="../classes/StringIUnknownMap&lt;V extends IUnknown&gt;.html">StringIUnknownMap&lt;V extends IUnknown&gt;</a></li>
                                <li><a href="../classes/Symbolic.html">Symbolic</a></li>
                                <li><a href="../classes/UniformLocation.html">UniformLocation</a></li>
                                <li><a href="../classes/Unit.html">Unit</a></li>
                                <li><a href="../classes/Vector1.html">Vector1</a></li>
                                <li><a href="../classes/Vector2.html">Vector2</a></li>
                                <li><a href="../classes/Vector3.html">Vector3</a></li>
                                <li><a href="../classes/Vector4.html">Vector4</a></li>
                                <li><a href="../classes/VectorN.html">VectorN</a></li>
                                <li><a href="../classes/VectorN&lt;T&gt;.html">VectorN&lt;T&gt;</a></li>
                                <li><a href="../classes/VersionLogger.html">VersionLogger</a></li>
                                <li><a href="../classes/View.html">View</a></li>
                                <li><a href="../classes/WebGLClear.html">WebGLClear</a></li>
                                <li><a href="../classes/WebGLClearColor.html">WebGLClearColor</a></li>
                                <li><a href="../classes/WebGLEnable.html">WebGLEnable</a></li>
                                <li><a href="../classes/WindowAnimationRunner.html">WindowAnimationRunner</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/EIGHT.html">EIGHT</a></li>
                                <li><a href="../modules/geometries.html">geometries</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/davinci-eight/utils/contextProxy.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import BufferResource = require(&#x27;../core/BufferResource&#x27;)
import ContextKahuna = require(&#x27;../core/ContextKahuna&#x27;)
import IContextProvider = require(&#x27;../core/IContextProvider&#x27;)
import IContextConsumer = require(&#x27;../core/IContextConsumer&#x27;)
import core = require(&#x27;../core&#x27;)
import GeometryData = require(&#x27;../geometries/GeometryData&#x27;)
import expectArg = require(&#x27;../checks/expectArg&#x27;)
import initWebGL = require(&#x27;../renderers/initWebGL&#x27;)
import IBuffer = require(&#x27;../core/IBuffer&#x27;)
import IBufferGeometry = require(&#x27;../geometries/IBufferGeometry&#x27;)
import isDefined = require(&#x27;../checks/isDefined&#x27;)
import isNumber = require(&#x27;../checks/isNumber&#x27;)
import isUndefined = require(&#x27;../checks/isUndefined&#x27;)
import ITexture = require(&#x27;../core/ITexture&#x27;)
import IUnknown = require(&#x27;../core/IUnknown&#x27;)
import IMaterial = require(&#x27;../core/IMaterial&#x27;)
import mustBeInteger = require(&#x27;../checks/mustBeInteger&#x27;)
import mustBeNumber = require(&#x27;../checks/mustBeNumber&#x27;)
import mustBeString = require(&#x27;../checks/mustBeString&#x27;)
import randumbInteger = require(&#x27;../utils/randumbInteger&#x27;);
import RefCount = require(&#x27;../utils/RefCount&#x27;)
import refChange = require(&#x27;../utils/refChange&#x27;)
import Shareable = require(&#x27;../utils/Shareable&#x27;)
import Simplex = require(&#x27;../geometries/Simplex&#x27;)
import StringIUnknownMap = require(&#x27;../utils/StringIUnknownMap&#x27;)
import Symbolic = require(&#x27;../core/Symbolic&#x27;)
import TextureResource = require(&#x27;../resources/TextureResource&#x27;)
import uuid4 = require(&#x27;../utils/uuid4&#x27;)
import VectorN = require(&#x27;../math/VectorN&#x27;)

let LOGGING_NAME_ELEMENTS_BLOCK = &#x27;ElementsBlock&#x27;
let LOGGING_NAME_ELEMENTS_BLOCK_ATTRIBUTE = &#x27;ElementsBlockAttrib&#x27;
let LOGGING_NAME_MESH = &#x27;Drawable&#x27;

let LOGGING_NAME_KAHUNA = &#x27;ContextKahuna&#x27;



function webglFunctionalConstructorContextBuilder(): string {
  // The following string represents how this API is exposed.
  return &quot;webgl functional constructor&quot;
}

function mustBeContext(gl: WebGLRenderingContext, method: string): WebGLRenderingContext {
  if (gl) {
    return gl;
  }
  else {
    throw new Error(method + &quot;: gl: WebGLRenderingContext is not defined. Either gl has been lost or start() not called.&quot;);
  }
}

/**
 * This could become an encapsulated call?
 * class GeometryDataCommand
 * private
 */
class GeometryDataCommand {
  /**
   * property mode
   * type {number}
   * private
   */
  private mode: number;
  private count: number;
  private type: number;
  private offset: number;
  /**
   * class GeometryDataCommand
   * constructor
   */
  constructor(mode: number, count: number, type: number, offset: number) {
    this.mode = mode;
    this.count = count;
    this.type = type;
    this.offset = offset;
  }
  /**
   * Executes the drawElements command using the instance state.
   * method execute
   * param gl {WebGLRenderingContext}
   */
  execute(gl: WebGLRenderingContext) {
    if (isDefined(gl)) {
      gl.drawElements(this.mode, this.count, this.type, this.offset);
    }
    else {
      console.warn(&quot;HFW: Er, like hey dude! You&#x27;re asking me to draw something without a context. That&#x27;s not cool, but I won&#x27;t complain.&quot;)
    }
  }
}

/**
 * class ElementsBlock
 */
class ElementsBlock extends Shareable {
  // FIXME: Need to convert this into a IUnknownArray
  // Can we know our IMaterial(s)?
  /**
   * Mapping from attribute name to a data structure describing and containing a buffer.
   * property _attributes
   * type {StringIUnknownMap&lt;ElementBlockAttrib&gt;}
   * private
   */
  private _attributes: StringIUnknownMap&lt;ElementsBlockAttrib&gt;;
  /**
   * The buffer containing element indices used in the drawElements command.
   * property _indexBuffer
   * type {IBuffer}
   * private
   */
  private _indexBuffer: IBuffer;
  /**
   * An executable command. May be a call to drawElements or drawArrays.
   * property drawCommand
   * type {GeometryDataCommand}
   */
  public drawCommand: GeometryDataCommand;
  /**
   * class ElementsBlock
   * constructor
   */
  constructor(indexBuffer: IBuffer, attributes: StringIUnknownMap&lt;ElementsBlockAttrib&gt;, drawCommand: GeometryDataCommand) {
    super(LOGGING_NAME_ELEMENTS_BLOCK)
    this._indexBuffer = indexBuffer
    this._indexBuffer.addRef()
    this._attributes = attributes
    this._attributes.addRef()
    this.drawCommand = drawCommand
  }
  protected destructor(): void {
    this._attributes.release()
    this._attributes = void 0
    this._indexBuffer.release()
    this._indexBuffer = void 0
    super.destructor()
  }
  get indexBuffer(): IBuffer {
    this._indexBuffer.addRef()
    return this._indexBuffer
  }
  get attributes(): StringIUnknownMap&lt;ElementsBlockAttrib&gt; {
    this._attributes.addRef()
    return this._attributes
  }
}

class ElementsBlockAttrib extends Shareable {
  private _buffer: IBuffer;
  public size: number;
  public normalized: boolean;
  public stride: number;
  public offset: number;
  constructor(buffer: IBuffer, size: number, normalized: boolean, stride: number, offset: number) {
    super(LOGGING_NAME_ELEMENTS_BLOCK_ATTRIBUTE)
    this._buffer = buffer;
    this._buffer.addRef();
    this.size = size;
    this.normalized = normalized;
    this.stride = stride;
    this.offset = offset;
  }
  destructor(): void {
    this._buffer.release();
    this._buffer = void 0;
    this.size = void 0;
    this.normalized = void 0;
    this.stride = void 0;
    this.offset = void 0;
  }
  get buffer() {
    this._buffer.addRef();
    return this._buffer;
  }
}

// TODO: If mode provided, check consistent with elements.k.
// expectArg(&#x27;mode&#x27;, mode).toSatisfy(isDrawMode(mode, gl), &quot;mode must be one of TRIANGLES, ...&quot;);
function drawMode(k: number, mode: number): number {
  switch (k) {
    case Simplex.K_FOR_TRIANGLE: {
      return mustBeNumber(&#x27;TRIANGLES&#x27;, WebGLRenderingContext.TRIANGLES);
    }
    case Simplex.K_FOR_LINE_SEGMENT: {
      return mustBeNumber(&#x27;LINES&#x27;, WebGLRenderingContext.LINES);
    }
    case Simplex.K_FOR_POINT: {
      return mustBeNumber(&#x27;POINTS&#x27;, WebGLRenderingContext.POINTS);
    }
    case Simplex.K_FOR_EMPTY: {
      return void 0;
    }
    default: {
      throw new Error(&quot;Unexpected k-simplex dimension, k =&gt; &quot; + k);
    }
  }
}

function isDrawMode(mode: number): boolean {
  mustBeNumber(&#x27;mode&#x27;, mode);
  switch(mode) {
    case WebGLRenderingContext.TRIANGLES: {
      return true;
    }
    case WebGLRenderingContext.LINES: {
      return true;
    }
    case WebGLRenderingContext.POINTS: {
      return true;
    }
    default: {
      return false;
    }
  }
}

function isBufferUsage(usage: number): boolean {
  mustBeNumber(&#x27;usage&#x27;, usage);
  switch(usage) {
    case WebGLRenderingContext.STATIC_DRAW: {
      return true;
    }
    default: {
      return false;
    }
  }
}

function messageUnrecognizedMesh(uuid: string): string {
  mustBeString(&#x27;uuid&#x27;, uuid);
  return uuid + &quot; is not a recognized mesh uuid&quot;;
}

function attribKey(aName: string, aNameToKeyName?: {[aName: string]: string}): string {
  if (aNameToKeyName) {
    let key = aNameToKeyName[aName];
    return key ? key : aName;
  }
  else {
    return aName;
  }
}
// FIXME: Use this function pair to replace BEGIN..END
/**
 *
 */
function bindProgramAttribLocations(program: IMaterial, canvasId: number, block: ElementsBlock, aNameToKeyName?: {[name: string]: string}) {
  // FIXME: Expecting canvasId here.
  // FIXME: This is where we get the IMaterial attributes property.
  // FIXME: Can we invert this?
  // What are we offering to the program:
  // block.attributes (reference counted)
  // Offer a NumberIUnknownList&lt;IAttributePointer&gt; which we have prepared up front
  // in order to get the name -&gt; index correct.
  // Then attribute setting should go much faster
  let attribLocations = program.attributes(canvasId)
  if (attribLocations) {
    let aNames = Object.keys(attribLocations)
    let aNamesLength = aNames.length
    var i: number
    for (i = 0; i &lt; aNamesLength; i++) {
      let aName = aNames[i]
      let key: string = attribKey(aName, aNameToKeyName)
      let attributes = block.attributes
      let attribute = attributes.get(key)
      if (attribute) {
        // Associate the attribute buffer with the attribute location.
        // FIXME Would be nice to be able to get a weak reference to the buffer.
        let buffer = attribute.buffer
        buffer.bind()
        let attributeLocation = attribLocations[aName]
        attributeLocation.vertexPointer(attribute.size, attribute.normalized, attribute.stride, attribute.offset)
        buffer.unbind()

        attributeLocation.enable()
        buffer.release()
        attribute.release()
      }
      else {
        // The attribute available may not be required by the program.
        // TODO: (1) Named programs, (2) disable warning by attribute?
        // Do not allow Attribute 0 to be disabled.
        console.warn(&quot;program attribute &quot; + aName + &quot; is not satisfied by the mesh&quot;);
      }
      attributes.release()
    }
  }
  else {
    console.warn(&quot;bindProgramAttribLocations: program.attributes is falsey.&quot;)
  }
}

function unbindProgramAttribLocations(program: IMaterial, canvasId: number) {
  // FIXME: Not sure if this suggests a disableAll() or something more symmetric.
  let attribLocations = program.attributes(canvasId);
  if (attribLocations) {
    Object.keys(attribLocations).forEach(function(aName: string) {
      attribLocations[aName].disable();
    });
  }
  else {
    console.warn(&quot;unbindProgramAttribLocations: program.attributes is falsey.&quot;)
  }
}

/**
 * Implementation of IBufferGeometry coupled to the &#x27;blocks&#x27; implementation.
 */
class BufferGeometry extends Shareable implements IBufferGeometry {
  private canvasId: number;
  private _program: IMaterial;
  private _blocks: StringIUnknownMap&lt;ElementsBlock&gt;;
  private gl: WebGLRenderingContext;
  constructor(canvasId: number, gl: WebGLRenderingContext, blocks: StringIUnknownMap&lt;ElementsBlock&gt;) {
    super(&#x27;BufferGeometry&#x27;)
    this.canvasId = canvasId
    this._blocks = blocks
    this._blocks.addRef()
    this.gl = gl
  }
  protected destructor(): void {
    // FIXME: Check status of Material?
    this._blocks.release()
    super.destructor()
  }
  bind(program: IMaterial, aNameToKeyName?: {[name: string]: string}): void {
    if (this._program !== program) {
      if (this._program) {
        this.unbind()
      }
      let block = this._blocks.get(this.uuid)
      if (block) {
        if (program) {
          this._program = program
          this._program.addRef()
          let indexBuffer = block.indexBuffer
          indexBuffer.bind()
          indexBuffer.release()
          bindProgramAttribLocations(this._program, this.canvasId, block, aNameToKeyName)
        }
        else {
          expectArg(&#x27;program&#x27;, program).toBeObject()
        }
        block.release()
      }
      else {
        throw new Error(messageUnrecognizedMesh(this.uuid))
      }
    }
  }
  draw(): void {
    let block = this._blocks.get(this.uuid)
    if (block) {
      // FIXME: Wondering why we don&#x27;t just make this a parameter?
      // On the other hand, buffer geometry is only good for one context.
      block.drawCommand.execute(this.gl)
      block.release()
    }
    else {
      throw new Error(messageUnrecognizedMesh(this.uuid));
    }
  }
  unbind(): void {
    if (this._program) {
      let block = this._blocks.get(this.uuid)
      if (block) {
        // FIXME: Ask block to unbind index buffer and avoid addRef/release
        let indexBuffer = block.indexBuffer
        indexBuffer.unbind()
        indexBuffer.release()
        // FIXME: Looks like an IMaterial method!
        unbindProgramAttribLocations(this._program, this.canvasId)
        block.release()
      }
      else {
        throw new Error(messageUnrecognizedMesh(this.uuid));
      }
      // We bumped up the reference count during bind. Now we are done.
      this._program.release()
      // Important! The existence of _program indicates the binding state.
      this._program = void 0
    }
  }
}

function webgl(attributes?: WebGLContextAttributes): ContextKahuna {
  // expectArg(&#x27;canvas&#x27;, canvas).toSatisfy(canvas instanceof HTMLCanvasElement, &quot;canvas argument must be an HTMLCanvasElement&quot;);
  // mustBeInteger(&#x27;canvasId&#x27;, canvasId, webglFunctionalConstructorContextBuilder);
  let uuid: string = uuid4().generate();
  let _blocks = new StringIUnknownMap&lt;ElementsBlock&gt;(&#x27;webgl&#x27;);
  // Remark: We only hold weak references to users so that the lifetime of resource
  // objects is not affected by the fact that they are listening for gl events.
  // Users should automatically add themselves upon construction and remove upon release.
  // // FIXME: Really? Not IUnknownArray&lt;IIContextConsumer&gt; ?
  let users: IContextConsumer[] = [];

  function addContextListener(user: IContextConsumer): void {
    expectArg(&#x27;user&#x27;, user).toBeObject()
    let index = users.indexOf(user)
    if (index &lt; 0) {
      users.push(user)
    }
    else {
      console.warn(&quot;user already exists for addContextListener&quot;)
    }
  }

  /**
   * Implementation of removeContextListener for the kahuna.
   */
  function removeContextListener(user: IContextConsumer): void {
    expectArg(&#x27;user&#x27;, user).toBeObject();
    let index = users.indexOf(user);
    if (index &gt;= 0) {
      // FIXME: Potential leak here if IContextConsumer extends IUnknown
      let removals = users.splice(index, 1);
    }
    else {
      // It may be that we just  can&#x27;t do this.
      // Cycles are a problem for reference counting so we have to
      // live with having weak references in one direction.
      // console.warn(&quot;user not found for removeContextListener(user)&quot;)
    }
  }
  function synchronize(user: IContextConsumer): void {
    if (gl) {
      if (gl.isContextLost()) {
        user.contextLost(_canvasId);
      }
      else {
        user.contextGain(kahuna);
      }
    }
    else {
      // FIXME: Broken symmetry.
      // user.contextFree(_canvasId)
    }
  }

  // TODO: Being a local function, capturing blocks, it was not obvious
  // that blocks should need reference counting.
  // Might be good to create a shareable class?
  function createBufferGeometryDeprecatedMaybe(uuid: string, canvasId: number): IBufferGeometry {

    let refCount = 0
    let _program: IMaterial = void 0
    let mesh: IBufferGeometry = {
      addRef(): number {
        refCount++
        refChange(uuid, LOGGING_NAME_MESH, +1)
        _blocks.addRef()
        return refCount
      },
      release(): number {
        refCount--
        refChange(uuid, LOGGING_NAME_MESH, -1)
        if (refCount === 0) {
          if (_blocks.exists(uuid)) {
            _blocks.remove(uuid)
          }
          else {
            console.warn(&quot;[System Error] &quot; + messageUnrecognizedMesh(uuid));
          }
          _blocks.release()
        }
        return refCount
      },
      get uuid() {
        return uuid;
      },
      bind(program: IMaterial, aNameToKeyName?: {[name: string]: string}): void {
        if (_program !== program) {
          if (_program) {
            mesh.unbind()
          }
          let block= _blocks.get(uuid)
          if (block) {
            if (program) {
              _program = program
              _program.addRef()

              let indexBuffer = block.indexBuffer
              indexBuffer.bind()
              indexBuffer.release()

              bindProgramAttribLocations(_program, canvasId, block, aNameToKeyName)
            }
            else {
              expectArg(&#x27;program&#x27;, program).toBeObject()
            }
            block.release()
          }
          else {
            throw new Error(messageUnrecognizedMesh(uuid))
          }
        }
      },
      draw(): void {
        let block = _blocks.get(uuid)
        if (block) {
          block.drawCommand.execute(gl)
          block.release()
        }
        else {
          throw new Error(messageUnrecognizedMesh(uuid));
        }
      },
      unbind(): void {
        if (_program) {
          let block = _blocks.get(uuid)
          if (block) {
            // FIXME: Ask block to unbind index buffer and avoid addRef/release
            let indexBuffer = block.indexBuffer
            indexBuffer.unbind()
            indexBuffer.release()
            // FIXME: Looks like an IMaterial method!
            unbindProgramAttribLocations(_program, _canvasId)
            block.release()
          }
          else {
            throw new Error(messageUnrecognizedMesh(uuid));
          }
          // We bumped up the reference count during bind. Now we are done.
          _program.release()
          // Important! The existence of _program indicates the binding state.
          _program = void 0
        }
      }
    }
    mesh.addRef()
    return mesh
  }

  var gl: WebGLRenderingContext
  /**
   * We must cache the canvas so that we can remove listeners when &#x60;stop() is called.
   * Only between &#x60;start()&#x60; and &#x60;stop()&#x60; is canvas defined.
   * We use a canvasBuilder so the other initialization can happen while we are waiting
   * for the DOM to load. 
   */
  var _canvas: HTMLCanvasElement
  var _canvasId: number
  var refCount: number = 0
  let tokenArg = expectArg(&#x27;token&#x27;, &quot;&quot;)

  let webGLContextLost = function(event: Event) {
    if (isDefined(_canvas)) {
      event.preventDefault()
      gl = void 0
      users.forEach(function(user: IContextConsumer) {
        user.contextLost(_canvasId)
      })
    }
  }

  let webGLContextRestored = function(event: Event) {
    if (isDefined(_canvas)) {
      event.preventDefault()
      gl = initWebGL(_canvas, attributes)
      users.forEach(function(user: IContextConsumer) {
        user.contextGain(kahuna)
      })
    }
  }

  var kahuna: ContextKahuna = {
    get canvasId(): number {
      return _canvasId;
    },
    /**
     *
     */
    createBufferGeometry(elements: GeometryData, mode?: number, usage?: number): IBufferGeometry {
      expectArg(&#x27;elements&#x27;, elements).toSatisfy(elements instanceof GeometryData, &quot;elements must be an instance of GeometryElements&quot;);
      mode = drawMode(elements.k, mode);
      if (!isDefined(mode)) {
        // An empty simplex (k = -1 or vertices.length = k + 1 = 0) begets
        // something that can&#x27;t be drawn (no mode) and it is invisible anyway.
        // In such a case we choose not to allocate any buffers. What would be the usage?
        return void 0;
      }
      if (isDefined(usage)) {
        expectArg(&#x27;usage&#x27;, usage).toSatisfy(isBufferUsage(usage), &quot;usage must be on of STATIC_DRAW, ...&quot;);
      }
      else {
        // TODO; Perhaps a simpler way to be Hyper Functional Warrior is to use WebGLRenderingContext.STATIC_DRAW?
        usage = isDefined(gl) ? gl.STATIC_DRAW : void 0;
        // No usage may be OK. After all it&#x27;s just a hint!
      }
      // It&#x27;s going to get pretty hopeless without a WebGL context.
      // If that&#x27;s the case, let&#x27;s just return undefined now before we start allocating useless stuff.
      if (isUndefined(gl)) {
        if (core.verbose) {
          console.warn(&quot;Impossible to create a buffer geometry without a WebGL context. Sorry, no dice!&quot;);
        }
        return void 0;
      }
      let mesh: IBufferGeometry = new BufferGeometry(_canvasId, gl, _blocks)
      // let mesh: IBufferGeometry = createBufferGeometryDeprecatedMaybe(uuid4().generate(), _canvasId)

      let indexBuffer = kahuna.createElementArrayBuffer();
      indexBuffer.bind();
      if (isDefined(gl)) {
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(elements.indices.data), usage);
      }
      else {
        console.warn(&quot;Unable to bufferData to ELEMENT_ARRAY_BUFFER, WebGL context is undefined.&quot;)
      }
      indexBuffer.unbind();

      let attributes = new StringIUnknownMap&lt;ElementsBlockAttrib&gt;(&#x27;createBufferGeometry&#x27;)
      let names = Object.keys(elements.attributes)
      let namesLength = names.length
      var i: number
      for (i = 0; i &lt; namesLength; i++) {
        let name = names[i]
        let buffer = kahuna.createArrayBuffer()
        buffer.bind()
        let vertexAttrib = elements.attributes[name]
        let data: number[] = vertexAttrib.values.data
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), usage)
        let attribute = new ElementsBlockAttrib(buffer, vertexAttrib.size, false, 0, 0)
        attributes.put(name, attribute)
        attribute.release()
        buffer.unbind()
        buffer.release()
      }
      // Use UNSIGNED_BYTE  if ELEMENT_ARRAY_BUFFER is a Uint8Array.
      // Use UNSIGNED_SHORT if ELEMENT_ARRAY_BUFFER is a Uint16Array.
      switch(elements.k) {

      }
      let drawCommand = new GeometryDataCommand(mode, elements.indices.length, gl.UNSIGNED_SHORT, 0)
      var block =new ElementsBlock(indexBuffer, attributes, drawCommand)
      _blocks.put(mesh.uuid, block)
      block.release()
      attributes.release()
      indexBuffer.release()
      return mesh;
    },
    start(canvas: HTMLCanvasElement, canvasId: number): void {
      let alreadyStarted = isDefined(_canvas);
      if (!alreadyStarted) {
        // cache the arguments
        _canvas = canvas
        _canvasId = canvasId
      }
      else {
        // We&#x27;ll assert that if we have a canvas element then we should have a canvas id.
        mustBeInteger(&#x27;_canvasId&#x27;, _canvasId);
        // We&#x27;ll just be idempotent and ignore the call because we&#x27;ve already been started.
        // To use the canvas might conflict with one we have dynamically created.
        if (core.verbose) {
          console.warn(&quot;Ignoring &#x60;start()&#x60; because already started.&quot;)
        }
        return
      }
      // What if we were given a &quot;no-op&quot; canvasBuilder that returns undefined for the canvas.
      // To not complain is the way of the hyper-functional warrior.
      if (isDefined(_canvas)) {
        gl = initWebGL(_canvas, attributes);
        users.forEach(function(user: IContextConsumer) {
          kahuna.synchronize(user)
        })
        _canvas.addEventListener(&#x27;webglcontextlost&#x27;, webGLContextLost, false)
        _canvas.addEventListener(&#x27;webglcontextrestored&#x27;, webGLContextRestored, false)
      }
    },
    stop(): void {
      if (isDefined(_canvas)) {
        _canvas.removeEventListener(&#x27;webglcontextrestored&#x27;, webGLContextRestored, false)
        _canvas.removeEventListener(&#x27;webglcontextlost&#x27;, webGLContextLost, false)
        if (gl) {
          if (gl.isContextLost()) {
            users.forEach(function(user: IContextConsumer) { user.contextLost(_canvasId) })
          }
          else {
            users.forEach(function(user: IContextConsumer) { user.contextFree(_canvasId) })
          }
          gl = void 0;
        }
        _canvas = void 0;
        _canvasId = void 0;
      }
    },
    addContextListener(user: IContextConsumer): void {
      addContextListener(user);
    },
    removeContextListener(user: IContextConsumer): void {
      removeContextListener(user);
    },
    synchronize(user: IContextConsumer): void {
      synchronize(user)
    },
    get canvas(): HTMLCanvasElement {
      if (!_canvas) {
        // Interesting little side-effect!
        // Love the way kahuna talks in the third person.
        kahuna.start(document.createElement(&#x27;canvas&#x27;), randumbInteger());
        }
      return _canvas;
    },
    get gl(): WebGLRenderingContext {
      if (gl) {
        return gl;
      }
      else {
        console.warn(&quot;property gl: WebGLRenderingContext is not defined. Either gl has been lost or start() not called.&quot;);
        return void 0;
      }
    },
    addRef(): number {
      refCount++;
      refChange(uuid, LOGGING_NAME_KAHUNA, +1);
      return refCount;
    },
    release(): number {
      refCount--;
      refChange(uuid, LOGGING_NAME_KAHUNA, -1);
      if (refCount === 0) {
        _blocks.release();
        while(users.length &gt; 0) {
          let user = users.pop();
        }
      }
      return refCount;
    },
    createArrayBuffer(): IBuffer {
      // TODO: Replace with functional constructor pattern?
      return new BufferResource(kahuna, false);
    },
    createElementArrayBuffer(): IBuffer {
      // TODO: Replace with functional constructor pattern?
      // FIXME
      // It&#x27;s a bit draconian to insist that there be a WegGLRenderingContext.
      // Especially whenthe BufferResource willl be listening for context coming and goings.
      // Let&#x27;s be Hyper-Functional Warrior and let it go.
      // Only problem is, we don&#x27;t know if we should be handling elements or attributes. No problem.
      return new BufferResource(kahuna, true);
    },
    createTexture2D(): ITexture {
      // TODO: Replace with functional constructor pattern.
      // FIXME Does this mean that Texture only has one IContextMonitor?
      return new TextureResource([kahuna], mustBeContext(gl, &#x27;createTexture2D()&#x27;).TEXTURE_2D);
    },
    createTextureCubeMap(): ITexture {
      // TODO: Replace with functional constructor pattern.
      return new TextureResource([kahuna], mustBeContext(gl, &#x27;createTextureCubeMap()&#x27;).TEXTURE_CUBE_MAP);
    }
  };
  kahuna.addRef()
  return kahuna;
}

export = webgl;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
