<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/davinci-eight/core/WebGLRenderer.ts - davinci-eight</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="davinci-eight" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.183.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AbstractMatrix.html">AbstractMatrix</a></li>
                                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
                                <li><a href="../classes/Arrow.html">Arrow</a></li>
                                <li><a href="../classes/ArrowGeometry.html">ArrowGeometry</a></li>
                                <li><a href="../classes/AttribLocation.html">AttribLocation</a></li>
                                <li><a href="../classes/AttribMetaInfo.html">AttribMetaInfo</a></li>
                                <li><a href="../classes/Attribute.html">Attribute</a></li>
                                <li><a href="../classes/BlendFactor.html">BlendFactor</a></li>
                                <li><a href="../classes/Capability.html">Capability</a></li>
                                <li><a href="../classes/CC.html">CC</a></li>
                                <li><a href="../classes/Color.html">Color</a></li>
                                <li><a href="../classes/ColorFacet.html">ColorFacet</a></li>
                                <li><a href="../classes/ColorRGB.html">ColorRGB</a></li>
                                <li><a href="../classes/ColorRGBA.html">ColorRGBA</a></li>
                                <li><a href="../classes/ContextAttributesLogger.html">ContextAttributesLogger</a></li>
                                <li><a href="../classes/createView.html">createView</a></li>
                                <li><a href="../classes/Cuboid.html">Cuboid</a></li>
                                <li><a href="../classes/CuboidGeometry.html">CuboidGeometry</a></li>
                                <li><a href="../classes/CuboidPrimitivesBuilder.html">CuboidPrimitivesBuilder</a></li>
                                <li><a href="../classes/Cylinder.html">Cylinder</a></li>
                                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
                                <li><a href="../classes/Dimensions.html">Dimensions</a></li>
                                <li><a href="../classes/DirectionalLight.html">DirectionalLight</a></li>
                                <li><a href="../classes/DrawMode.html">DrawMode</a></li>
                                <li><a href="../classes/EIGHTLogger.html">EIGHTLogger</a></li>
                                <li><a href="../classes/Euclidean1.html">Euclidean1</a></li>
                                <li><a href="../classes/Euclidean2.html">Euclidean2</a></li>
                                <li><a href="../classes/Euclidean3.html">Euclidean3</a></li>
                                <li><a href="../classes/Facet.html">Facet</a></li>
                                <li><a href="../classes/FacetVisitor.html">FacetVisitor</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/G2.html">G2</a></li>
                                <li><a href="../classes/G3.html">G3</a></li>
                                <li><a href="../classes/GeometricE2.html">GeometricE2</a></li>
                                <li><a href="../classes/GeometricE3.html">GeometricE3</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryContainer.html">GeometryContainer</a></li>
                                <li><a href="../classes/GeometryPrimitive.html">GeometryPrimitive</a></li>
                                <li><a href="../classes/GraphicsProgramSymbols.html">GraphicsProgramSymbols</a></li>
                                <li><a href="../classes/HTMLScriptsMaterial.html">HTMLScriptsMaterial</a></li>
                                <li><a href="../classes/IContextConsumer.html">IContextConsumer</a></li>
                                <li><a href="../classes/IContextListener.html">IContextListener</a></li>
                                <li><a href="../classes/IContextProgramConsumer.html">IContextProgramConsumer</a></li>
                                <li><a href="../classes/IContextProvider.html">IContextProvider</a></li>
                                <li><a href="../classes/IUnknown.html">IUnknown</a></li>
                                <li><a href="../classes/LineMaterial.html">LineMaterial</a></li>
                                <li><a href="../classes/Mat2R.html">Mat2R</a></li>
                                <li><a href="../classes/Mat3R.html">Mat3R</a></li>
                                <li><a href="../classes/Mat4R.html">Mat4R</a></li>
                                <li><a href="../classes/Material.html">Material</a></li>
                                <li><a href="../classes/Mesh.html">Mesh</a></li>
                                <li><a href="../classes/MeshMaterial.html">MeshMaterial</a></li>
                                <li><a href="../classes/ModelE2.html">ModelE2</a></li>
                                <li><a href="../classes/ModelE3.html">ModelE3</a></li>
                                <li><a href="../classes/ModelFacet.html">ModelFacet</a></li>
                                <li><a href="../classes/Mutable.html">Mutable</a></li>
                                <li><a href="../classes/NumberIUnknownMap.html">NumberIUnknownMap</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/PerspectiveCamera.html">PerspectiveCamera</a></li>
                                <li><a href="../classes/PointMaterial.html">PointMaterial</a></li>
                                <li><a href="../classes/PointSizeFacet.html">PointSizeFacet</a></li>
                                <li><a href="../classes/Primitive.html">Primitive</a></li>
                                <li><a href="../classes/PrimitiveBuffers.html">PrimitiveBuffers</a></li>
                                <li><a href="../classes/Pseudo.html">Pseudo</a></li>
                                <li><a href="../classes/QQ.html">QQ</a></li>
                                <li><a href="../classes/R1.html">R1</a></li>
                                <li><a href="../classes/R2.html">R2</a></li>
                                <li><a href="../classes/R3.html">R3</a></li>
                                <li><a href="../classes/R4.html">R4</a></li>
                                <li><a href="../classes/ReflectionFacetE2.html">ReflectionFacetE2</a></li>
                                <li><a href="../classes/ReflectionFacetE3.html">ReflectionFacetE3</a></li>
                                <li><a href="../classes/RigidBody.html">RigidBody</a></li>
                                <li><a href="../classes/Scalar.html">Scalar</a></li>
                                <li><a href="../classes/Scene.html">Scene</a></li>
                                <li><a href="../classes/Shareable.html">Shareable</a></li>
                                <li><a href="../classes/ShareableArray.html">ShareableArray</a></li>
                                <li><a href="../classes/ShareableContextListener.html">ShareableContextListener</a></li>
                                <li><a href="../classes/ShareableWebGLBuffer.html">ShareableWebGLBuffer</a></li>
                                <li><a href="../classes/ShareableWebGLShader.html">ShareableWebGLShader</a></li>
                                <li><a href="../classes/ShareableWebGLTexture.html">ShareableWebGLTexture</a></li>
                                <li><a href="../classes/Sphere.html">Sphere</a></li>
                                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
                                <li><a href="../classes/SpinG2.html">SpinG2</a></li>
                                <li><a href="../classes/SpinG3.html">SpinG3</a></li>
                                <li><a href="../classes/SpinorE1.html">SpinorE1</a></li>
                                <li><a href="../classes/SpinorE2.html">SpinorE2</a></li>
                                <li><a href="../classes/SpinorE3.html">SpinorE3</a></li>
                                <li><a href="../classes/SpinorE4.html">SpinorE4</a></li>
                                <li><a href="../classes/StringIUnknownMap.html">StringIUnknownMap</a></li>
                                <li><a href="../classes/Tetrahedron.html">Tetrahedron</a></li>
                                <li><a href="../classes/TetrahedronGeometry.html">TetrahedronGeometry</a></li>
                                <li><a href="../classes/Trail.html">Trail</a></li>
                                <li><a href="../classes/UniformLocation.html">UniformLocation</a></li>
                                <li><a href="../classes/UniformMetaInfo.html">UniformMetaInfo</a></li>
                                <li><a href="../classes/Unit.html">Unit</a></li>
                                <li><a href="../classes/Vector.html">Vector</a></li>
                                <li><a href="../classes/Vector3Facet.html">Vector3Facet</a></li>
                                <li><a href="../classes/VectorE0.html">VectorE0</a></li>
                                <li><a href="../classes/VectorE1.html">VectorE1</a></li>
                                <li><a href="../classes/VectorE2.html">VectorE2</a></li>
                                <li><a href="../classes/VectorE3.html">VectorE3</a></li>
                                <li><a href="../classes/VectorE4.html">VectorE4</a></li>
                                <li><a href="../classes/VectorN.html">VectorN</a></li>
                                <li><a href="../classes/VersionLogger.html">VersionLogger</a></li>
                                <li><a href="../classes/View.html">View</a></li>
                                <li><a href="../classes/VisualBody.html">VisualBody</a></li>
                                <li><a href="../classes/WebGLBlendFunc.html">WebGLBlendFunc</a></li>
                                <li><a href="../classes/WebGLClearColor.html">WebGLClearColor</a></li>
                                <li><a href="../classes/WebGLDisable.html">WebGLDisable</a></li>
                                <li><a href="../classes/WebGLEnable.html">WebGLEnable</a></li>
                                <li><a href="../classes/WebGLRenderer.html">WebGLRenderer</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/core.html">core</a></li>
                                <li><a href="../modules/EIGHT.html">EIGHT</a></li>
                                <li><a href="../modules/facets.html">facets</a></li>
                                <li><a href="../modules/geometries.html">geometries</a></li>
                                <li><a href="../modules/materials.html">materials</a></li>
                                <li><a href="../modules/math.html">math</a></li>
                                <li><a href="../modules/visual.html">visual</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/davinci-eight/core/WebGLRenderer.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import Capability from &#x27;../commands/Capability&#x27;;
import DrawMode from &#x27;./DrawMode&#x27;;
import core from &#x27;../core&#x27;;
import IContextProvider from &#x27;./IContextProvider&#x27;;
import IContextConsumer from &#x27;./IContextConsumer&#x27;;
import ShareableWebGLBuffer from &#x27;./ShareableWebGLBuffer&#x27;;
import PrimitiveBuffers from &#x27;./PrimitiveBuffers&#x27;;
import Material from &#x27;./Material&#x27;;
import ShareableArray from &#x27;../collections/ShareableArray&#x27;;
import initWebGL from &#x27;./initWebGL&#x27;;
import isDefined from &#x27;../checks/isDefined&#x27;;
import isUndefined from &#x27;../checks/isUndefined&#x27;;
import mustBeArray from &#x27;../checks/mustBeArray&#x27;;
import mustBeDefined from &#x27;../checks/mustBeDefined&#x27;;
import mustBeInteger from &#x27;../checks/mustBeInteger&#x27;;
import mustBeNumber from &#x27;../checks/mustBeNumber&#x27;;
import mustBeObject from &#x27;../checks/mustBeObject&#x27;;
import mustBeString from &#x27;../checks/mustBeString&#x27;;
import mustSatisfy from &#x27;../checks/mustSatisfy&#x27;;
import Primitive from &#x27;./Primitive&#x27;;
import readOnly from &#x27;../i18n/readOnly&#x27;;
import Shareable from &#x27;./Shareable&#x27;;
import StringIUnknownMap from &#x27;../collections/StringIUnknownMap&#x27;;
import WebGLClearColor from &#x27;../commands/WebGLClearColor&#x27;;
import WebGLEnable from &#x27;../commands/WebGLEnable&#x27;;
import WebGLDisable from &#x27;../commands/WebGLDisable&#x27;;

/**
 * Fundamental abstractions in the architecture.
 *
 * @module EIGHT
 * @submodule core
 */

function isBufferUsage(usage: number): boolean {
    mustBeNumber(&#x27;usage&#x27;, usage);
    switch (usage) {
        case WebGLRenderingContext.STATIC_DRAW: {
            return true;
        }
            break;
        default: {
            return false;
        }
    }
}

/**
 * Renders geometric primitives indexed by element array data.
 */
class DrawElementsCommand {

    /**
     * Specifies the kind of primitives to render.
     */
    private mode: DrawMode;

    /**
     * The number of elements to render.
     */
    private count: number;

    /**
     * The type of elements in the element array buffer. Usually a gl.UNSIGNED_SHORT.
     */
    private type: number;

    /**
     * Offset into the element array buffer. Must be a valid multiple of the size of type.
     */
    private offset: number;

    /**
     *
     */
    constructor(mode: DrawMode, count: number, type: number, offset: number) {
        mustBeInteger(&#x27;mode&#x27;, mode)
        mustBeInteger(&#x27;count&#x27;, count)
        mustBeInteger(&#x27;type&#x27;, type)
        mustBeInteger(&#x27;offset&#x27;, offset)
        this.mode = mode
        this.count = count
        this.type = type
        this.offset = offset
    }

    /**
     * Executes the drawElements command using the instance state.
     */
    execute(gl: WebGLRenderingContext) {
        if (isDefined(gl)) {
            switch (this.mode) {
                case DrawMode.TRIANGLE_STRIP:
                    gl.drawElements(gl.TRIANGLE_STRIP, this.count, this.type, this.offset)
                    break
                case DrawMode.TRIANGLE_FAN:
                    gl.drawElements(gl.TRIANGLE_FAN, this.count, this.type, this.offset)
                    break
                case DrawMode.TRIANGLES:
                    gl.drawElements(gl.TRIANGLES, this.count, this.type, this.offset)
                    break
                case DrawMode.LINE_STRIP:
                    gl.drawElements(gl.LINE_STRIP, this.count, this.type, this.offset)
                    break
                case DrawMode.LINE_LOOP:
                    gl.drawElements(gl.LINE_LOOP, this.count, this.type, this.offset)
                    break
                case DrawMode.LINES:
                    gl.drawElements(gl.LINES, this.count, this.type, this.offset)
                    break
                case DrawMode.POINTS:
                    gl.drawElements(gl.POINTS, this.count, this.type, this.offset)
                    break
                default:
                    throw new Error(&quot;mode: &quot; + this.mode)
            }
        }
    }
}

/**
 * A tuple containing (indexBuffer, attributes, drawCommand).
 */
class ElementsBlock extends Shareable implements IContextConsumer {

    /**
     * Mapping from attribute name to a data structure describing and containing a buffer.
     */
    private _attributes: StringIUnknownMap&lt;ElementsBlockAttrib&gt;;

    /**
     * The buffer containing element indices used in the drawElements command.
     * We keep the index buffer private to avoid unnecessary addRef() and release() calls.
     */
    private _indexBuffer: ShareableWebGLBuffer;

    /**
     * An executable command. May be a call to drawElements or drawArrays.
     */
    public drawCommand: DrawElementsCommand;

    /**
     *
     */
    constructor(indexBuffer: ShareableWebGLBuffer, attributes: StringIUnknownMap&lt;ElementsBlockAttrib&gt;, drawCommand: DrawElementsCommand) {
        super(&#x27;ElementsBlock&#x27;)
        this._indexBuffer = indexBuffer
        this._indexBuffer.addRef()
        this._attributes = attributes
        this._attributes.addRef()
        this.drawCommand = drawCommand
    }

    protected destructor(): void {
        this._attributes.release()
        this._attributes = void 0
        this._indexBuffer.release()
        this._indexBuffer = void 0
        super.destructor()
    }

    contextFree(context: IContextProvider): void {
        this._indexBuffer.contextFree(context)
        this._attributes.forEach((key, attribute) =&gt; {
            attribute.contextFree(context)
        })
    }

    contextGain(context: IContextProvider): void {
        this._indexBuffer.contextGain(context)
        this._attributes.forEach((key, attribute) =&gt; {
            attribute.contextGain(context)
        })
    }

    contextLost(): void {
        this._indexBuffer.contextLost()
        this._attributes.forEach((key, attribute) =&gt; {
            attribute.contextLost()
        })
    }

    /**
     * 
     */
    bind() {
        this._indexBuffer.bind()
    }

    unbind() {
        this._indexBuffer.unbind()
    }

    get attributes(): StringIUnknownMap&lt;ElementsBlockAttrib&gt; {
        this._attributes.addRef()
        return this._attributes
    }
    set attributes(unused) {
        throw new Error(readOnly(&#x27;attributes&#x27;).message)
    }
}

/**
 * Keeps track of the buffer and metadata associated with an &#x27;attribute&#x27; variable.
 */
class ElementsBlockAttrib extends Shareable implements IContextConsumer {
    /**
     * The buffer is a shared resource
     */
    private _buffer: ShareableWebGLBuffer;
    public size: number;
    public normalized: boolean;
    public stride: number;
    public offset: number;
    constructor(buffer: ShareableWebGLBuffer, size: number, normalized: boolean, stride: number, offset: number) {
        super(&#x27;ElementsBlockAttrib&#x27;)
        this._buffer = buffer;
        this._buffer.addRef();
        this.size = size;
        this.normalized = normalized;
        this.stride = stride;
        this.offset = offset;
    }
    destructor(): void {
        this._buffer.release();
        this._buffer = void 0;
        this.size = void 0;
        this.normalized = void 0;
        this.stride = void 0;
        this.offset = void 0;
        super.destructor();
    }

    contextFree(context: IContextProvider): void {
        this._buffer.contextFree(context)
    }

    contextGain(context: IContextProvider): void {
        this._buffer.contextGain(context)
    }

    contextLost(): void {
        this._buffer.contextLost()
    }

    get buffer() {
        this._buffer.addRef();
        return this._buffer;
    }
    set buffer(unused) {
        throw new Error(readOnly(&#x27;buffer&#x27;).message)
    }
}

function messageUnrecognizedMesh(uuid: string): string {
    mustBeString(&#x27;uuid&#x27;, uuid);
    return uuid + &quot; is not a recognized mesh uuid&quot;;
}

function attribKey(aName: string, aNameToKeyName?: { [aName: string]: string }): string {
    if (aNameToKeyName) {
        const key = aNameToKeyName[aName];
        return key ? key : aName;
    }
    else {
        return aName;
    }
}

/**
 *
 */
function bindProgramAttribLocations(material: Material, block: ElementsBlock, aNameToKeyName: { [name: string]: string }) {
    const aNames = material.attributeNames
    if (aNames) {
        for (let i = 0, iLength = aNames.length; i &lt; iLength; i++) {
            const aName = aNames[i]
            const key: string = attribKey(aName, aNameToKeyName)
            const attributes = block.attributes
            const attribute: ElementsBlockAttrib = attributes.getWeakRef(key)
            if (attribute) {
                // Associate the attribute buffer with the attribute location.
                // FIXME Would be nice to be able to get a weak reference to the buffer.
                const buffer: ShareableWebGLBuffer = attribute.buffer
                buffer.bind()
                material.vertexPointer(aName, attribute.size, attribute.normalized, attribute.stride, attribute.offset)
                buffer.unbind()
                material.enableAttrib(aName)
                buffer.release()
            }
            else {
                console.warn(&#x60;material attribute ${aName} is not satisfied by the mesh&#x60;)
            }
            attributes.release()
        }
    }
    else {
        console.warn(&quot;material.attributes is falsey.&quot;)
    }
}

/**
 * Implementation of PrimitiveBuffers coupled to the &#x27;blocks&#x27; implementation.
 */
class PrimitiveBuffersImpl extends Shareable implements PrimitiveBuffers {
    private _program: Material;
    private _blocks: StringIUnknownMap&lt;ElementsBlock&gt;;
    private gl: WebGLRenderingContext;
    constructor(gl: WebGLRenderingContext, blocks: StringIUnknownMap&lt;ElementsBlock&gt;) {
        super(&#x27;PrimitiveBuffers&#x27;)
        this._blocks = blocks
        this._blocks.addRef()
        this.gl = gl
    }
    protected destructor(): void {
        this._blocks.release()
        this._blocks = void 0
        this.gl = void 0
        super.destructor()
    }
    bind(program: Material, aNameToKeyName?: { [name: string]: string }): void {
        if (this._program !== program) {
            if (this._program) {
                this.unbind()
            }
            let block = this._blocks.getWeakRef(this.uuid)
            if (block) {
                if (program) {
                    this._program = program
                    this._program.addRef()
                    block.bind()
                    bindProgramAttribLocations(this._program, block, aNameToKeyName)
                }
                else {
                    mustBeObject(&#x27;program&#x27;, program)
                }
            }
            else {
                throw new Error(messageUnrecognizedMesh(this.uuid))
            }
        }
    }
    draw(): void {
        let block = this._blocks.getWeakRef(this.uuid)
        if (block) {
            // FIXME: Wondering why we don&#x27;t just make this a parameter?
            // On the other hand, buffer geometry is only good for one context.
            block.drawCommand.execute(this.gl)
        }
        else {
            throw new Error(messageUnrecognizedMesh(this.uuid));
        }
    }
    unbind(): void {
        if (this._program) {
            let block = this._blocks.getWeakRef(this.uuid)
            if (block) {
                block.unbind()
                this._program.disableAttribs()
            }
            else {
                throw new Error(messageUnrecognizedMesh(this.uuid));
            }
            // We bumped up the reference count during bind. Now we are done.
            this._program.release()
            // Important! The existence of _program indicates the binding state.
            this._program = void 0
        }
    }
}

class WebGLContextProvider extends Shareable implements IContextProvider {
    private _renderer: WebGLRenderer

    /**
     * @property _blocks
     * @type StringIUnknownMap
     * @private
     */
    private _blocks = new StringIUnknownMap&lt;ElementsBlock&gt;();

    constructor(renderer: WebGLRenderer) {
        super(&#x27;WebGLContextProvider&#x27;)
        this._renderer = renderer
    }
    protected destructor(): void {
        this._blocks.release();
        super.destructor()
    }
    get gl() {
        return this._renderer.gl;
    }
    createPrimitiveBuffers(primitive: Primitive, usage?: number): PrimitiveBuffers {
        mustBeObject(&#x27;primitive&#x27;, primitive);
        mustBeInteger(&#x27;primitive.mode&#x27;, primitive.mode);
        mustBeArray(&#x27;primitive.indices&#x27;, primitive.indices);
        mustBeObject(&#x27;primitive.attributes&#x27;, primitive.attributes);
        const gl = this._renderer.gl;
        if (isDefined(usage)) {
            mustSatisfy(&#x27;usage&#x27;, isBufferUsage(usage), () =&gt; { return &#x60;${this._type}.createPrimitiveBuffers&#x60; })
        }
        else {
            usage = isDefined(gl) ? gl.STATIC_DRAW : void 0
        }
        // It&#x27;s going to get pretty hopeless without a WebGL context.
        // If that&#x27;s the case, let&#x27;s just return undefined now before we start allocating useless stuff.
        if (isUndefined(gl)) {
            if (core.verbose) {
                console.warn(&quot;Impossible to create a buffer geometry without a WebGL context.&quot;)
            }
            return void 0
        }

        const mesh: PrimitiveBuffers = new PrimitiveBuffersImpl(gl, this._blocks)

        // TODO: In this use case, the ShareableWebGLBuffer isn&#x27;t expected to recover it data.
        const indexBuffer: ShareableWebGLBuffer = new ShareableWebGLBuffer(true);
        this._renderer.synchronize(indexBuffer)
        indexBuffer.bind();
        if (isDefined(gl)) {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(primitive.indices), usage);
        }
        else {
            console.warn(&quot;Unable to bufferData to ELEMENT_ARRAY_BUFFER, WebGL context is undefined.&quot;)
        }
        indexBuffer.unbind();

        let attributes = new StringIUnknownMap&lt;ElementsBlockAttrib&gt;()
        let names = Object.keys(primitive.attributes)
        let namesLength = names.length
        for (var i = 0; i &lt; namesLength; i++) {
            let name = names[i]
            const buffer: ShareableWebGLBuffer = new ShareableWebGLBuffer(false)
            this._renderer.synchronize(buffer)
            buffer.bind()
            let vertexAttrib = primitive.attributes[name]
            let data: number[] = vertexAttrib.values
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), usage)
            // TODO: stride = 0 and offset = 0
            let attribute = new ElementsBlockAttrib(buffer, vertexAttrib.size, false, 0, 0)
            attributes.put(name, attribute)
            attribute.release()
            buffer.unbind()
            buffer.release()
        }
        // Use UNSIGNED_BYTE  if ELEMENT_ARRAY_BUFFER is a Uint8Array.
        // Use UNSIGNED_SHORT if ELEMENT_ARRAY_BUFFER is a Uint16Array.
        // TODO: Notice that the offset is zero. How do we reuse a buffer.
        let drawCommand = new DrawElementsCommand(primitive.mode, primitive.indices.length, gl.UNSIGNED_SHORT, 0)
        const block = new ElementsBlock(indexBuffer, attributes, drawCommand)
        this._blocks.put(mesh.uuid, block)
        block.release()
        attributes.release()
        indexBuffer.release()
        return mesh
    }

    public emitStartEvent() {
        this._blocks.forEach((key, block) =&gt; {
            this.emitContextGain(block)
        })
    }
    private emitContextGain(consumer: IContextConsumer): void {
        if (this._renderer.gl.isContextLost()) {
            consumer.contextLost();
        }
        else {
            consumer.contextGain(this);
        }
    }

    public emitStopEvent() {
        this._blocks.forEach((key, block) =&gt; {
            this.emitContextFree(block)
        })
    }

    private emitContextFree(consumer: IContextConsumer): void {
        if (this._renderer.gl.isContextLost()) {
            consumer.contextLost();
        }
        else {
            consumer.contextFree(this);
        }
    }
}

/**
 * @class WebGLRenderer
 * @extends Shareable
 */
export default class WebGLRenderer extends Shareable {

    /**
     * @property _gl
     * @type WebGLRenderingContext
     * @private
     */
    private _gl: WebGLRenderingContext;

    /**
     * @property _canvas
     * @type HTMLCanvasElement
     * @private
     */
    private _canvas: HTMLCanvasElement;

    private _attributes: WebGLContextAttributes;

    // Remark: We only hold weak references to users so that the lifetime of resource
    // objects is not affected by the fact that they are listening for gl events.
    // Users should automatically add themselves upon construction and remove upon release.
    // // FIXME: Really? Not ShareableArray&lt;IIContextConsumer&gt; ?
    private _users: IContextConsumer[] = [];

    private _webGLContextLost: (event: Event) =&gt; any;
    private _webGLContextRestored: (event: Event) =&gt; any;

    private _commands = new ShareableArray&lt;IContextConsumer&gt;([])

    private _contextProvider: WebGLContextProvider;

    /**
     * @class WebGLRenderer
     * @constructor
     * @param [attributes] {WebGLContextAttributes} Allow the context to be configured.
     */
    constructor(attributes?: WebGLContextAttributes) {
        super(&#x27;WebGLRenderer&#x27;);
        console.log(&#x60;${core.NAMESPACE} @ ${core.VERSION}&#x60;);
        // FIXME: This seems out of place.
        this._attributes = attributes;

        this._contextProvider = new WebGLContextProvider(this)

        // For convenience.
        this.enable(Capability.DEPTH_TEST);

        this._webGLContextLost = (event: Event) =&gt; {
            if (isDefined(this._canvas)) {
                event.preventDefault()
                this._gl = void 0
                this._users.forEach((user: IContextConsumer) =&gt; {
                    user.contextLost()
                })
            }
        }

        this._webGLContextRestored = (event: Event) =&gt; {
            if (isDefined(this._canvas)) {
                event.preventDefault()
                this._gl = initWebGL(this._canvas, attributes)
                this._users.forEach((user: IContextConsumer) =&gt; {
                    user.contextGain(this._contextProvider)
                })
            }
        }
    }

    /**
     * @method destructor
     * return {void}
     * @protected
     */
    protected destructor(): void {
        this.stop();
        this._contextProvider.release()
        while (this._users.length &gt; 0) {
            this._users.pop();
        }
        this._commands.release();
        super.destructor()
    }

    /**
     * @method addContextListener
     * @param user {IContextConsumer}
     * @return {void}
     */
    addContextListener(user: IContextConsumer): void {
        mustBeObject(&#x27;user&#x27;, user)
        let index = this._users.indexOf(user)
        if (index &lt; 0) {
            this._users.push(user)
        }
        else {
            console.warn(&quot;user already exists for addContextListener&quot;)
        }
    }

    /**
     * @property canvas
     * @type {HTMLCanvasElement}
     */
    get canvas(): HTMLCanvasElement {
        if (!this._canvas) {
            this.start(document.createElement(&#x27;canvas&#x27;));
        }
        return this._canvas;
    }
    set canvas(canvas: HTMLCanvasElement) {
        throw new Error(readOnly(&#x27;canvas&#x27;).message)
    }

    /**
     * @property commands
     * @type {ShareableArray}
     * @beta
     * @readOnly
     */
    get commands(): ShareableArray&lt;IContextConsumer&gt; {
        this._commands.addRef();
        return this._commands;
    }
    set commands(unused) {
        throw new Error(readOnly(&#x27;commands&#x27;).message)
    }

    /**
     * &lt;p&gt;
     * Specifies color values to use by the &lt;code&gt;clear&lt;/code&gt; method to clear the color buffer.
     * &lt;p&gt;
     * @method clearColor
     * @param red {number}
     * @param green {number}
     * @param blue {number}
     * @param alpha {number}
     * @return {WebGLRenderer}
     * @chainable
     */
    clearColor(red: number, green: number, blue: number, alpha: number): WebGLRenderer {
        this._commands.pushWeakRef(new WebGLClearColor(red, green, blue, alpha))
        return this
    }

    /**
     * Turns off specific WebGL capabilities for this context.
     * @method disable
     * @param capability {Capability}
     * @return {WebGLRenderer}
     * @chainable
     */
    disable(capability: Capability): WebGLRenderer {
        this._commands.pushWeakRef(new WebGLDisable(capability))
        return this
    }

    /**
     * Turns on specific WebGL capabilities for this context.
     * @method enable
     * @param capability {Capability}
     * @return {WebGLRenderer}
     * @chainable
     */
    enable(capability: Capability): WebGLRenderer {
        this._commands.pushWeakRef(new WebGLEnable(capability))
        return this
    }

    /**
     * @property gl
     * @type {WebGLRenderingContext}
     * @readOnly
     */
    get gl(): WebGLRenderingContext {
        if (this._gl) {
            return this._gl;
        }
        else {
            return void 0;
        }
    }
    set gl(unused) {
        throw new Error(readOnly(&#x27;gl&#x27;).message)
    }

    /**
     * @method removeContextListener
     * @param user {IContextConsumer}
     * @return {void}
     */
    removeContextListener(user: IContextConsumer): void {
        mustBeObject(&#x27;user&#x27;, user)
        const index = this._users.indexOf(user)
        if (index &gt;= 0) {
            this._users.splice(index, 1)
        }
    }

    /**
     * @method clear
     * @return {void}
     */
    clear(): void {
        const gl = this._gl;
        if (gl) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }
    }

    /**
     * Defines what part of the canvas will be used in rendering the drawing buffer.
     * @method viewport
     * @param x {number}
     * @param y {number}
     * @param width {number}
     * @param height {number}
     * @return {WebGLRenderer}
     * @chainable
     */
    viewport(x: number, y: number, width: number, height: number): WebGLRenderer {
        const gl = this._gl;
        if (gl) {
            this._gl.viewport(x, y, width, height)
        }
        else {
            console.warn(&#x60;${this._type}.viewport() ignored because no context.&#x60;)
        }
        return this
    }

    /**
     * Initializes the WebGL context for the specified &lt;code&gt;canvas&lt;/code&gt;.
     * @method start
     * @param canvas {HTMLCanvasElement} The HTML canvas element.
     * @return {WebGLRenderer}
     * @chainable
     */
    start(canvas: HTMLCanvasElement): WebGLRenderer {
        if (!(canvas instanceof HTMLCanvasElement)) {
            console.warn(&quot;canvas must be an HTMLCanvasElement to start the context.&quot;)
            return this
        }
        mustBeDefined(&#x27;canvas&#x27;, canvas)
        const alreadyStarted = isDefined(this._canvas);
        if (!alreadyStarted) {
            // cache the arguments
            this._canvas = canvas
        }
        else {
            // We&#x27;ll just be idempotent and ignore the call because we&#x27;ve already been started.
            // To use the canvas might conflict with one we have dynamically created.
            if (core.verbose) {
                console.warn(&#x60;${this._type} Ignoring start() because already started.&#x60;)
            }
            return
        }
        // What if we were given a &quot;no-op&quot; canvasBuilder that returns undefined for the canvas.
        // To not complain is the way of the hyper-functional warrior.
        if (isDefined(this._canvas)) {
            this._gl = initWebGL(this._canvas, this._attributes);
            this.emitStartEvent();
            this._canvas.addEventListener(&#x27;webglcontextlost&#x27;, this._webGLContextLost, false)
            this._canvas.addEventListener(&#x27;webglcontextrestored&#x27;, this._webGLContextRestored, false)
        }
        return this
    }

    /**
     * @method stop
     * @return {WebGLRenderer}
     * @chainable
     */
    stop(): WebGLRenderer {
        if (isDefined(this._canvas)) {
            this._canvas.removeEventListener(&#x27;webglcontextrestored&#x27;, this._webGLContextRestored, false)
            this._canvas.removeEventListener(&#x27;webglcontextlost&#x27;, this._webGLContextLost, false)
            if (this._gl) {
                this.emitStopEvent();
                this._gl = void 0;
            }
            this._canvas = void 0;
        }
        return this
    }

    private emitStartEvent() {

        this._contextProvider.emitStartEvent()

        this._users.forEach((user: IContextConsumer) =&gt; {
            this.emitContextGain(user)
        })
        this._commands.forEach((command) =&gt; {
            this.emitContextGain(command);
        })
    }

    private emitContextGain(consumer: IContextConsumer): void {
        if (this._gl.isContextLost()) {
            consumer.contextLost();
        }
        else {
            consumer.contextGain(this._contextProvider);
        }
    }

    private emitStopEvent() {
        this._contextProvider.emitStopEvent()
        this._users.forEach((user: IContextConsumer) =&gt; {
            this.emitContextFree(user)
        })
        this._commands.forEach((command) =&gt; {
            this.emitContextFree(command);
        })
    }

    private emitContextFree(consumer: IContextConsumer): void {
        if (this._gl.isContextLost()) {
            consumer.contextLost();
        }
        else {
            consumer.contextFree(this._contextProvider);
        }
    }

    /**
     * @method synchronize
     * @param consumer {IContextConsumer}
     * @return {void}
     */
    synchronize(consumer: IContextConsumer): void {
        if (this._gl) {
            this.emitContextGain(consumer);
        }
        else {
            // FIXME: Broken symmetry.
        }
    }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
