"bundle";
System.register("js/directives/contextMenu/contextMenu.directive.js", ["angular"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var ng;
  function factory($q) {
    var currentContextMenu = void 0;
    function removeContextMenus() {
      if (currentContextMenu) {
        currentContextMenu.remove();
        currentContextMenu = void 0;
      }
    }
    function handlePromises(ul, event, promises) {
      $q.all(promises).then(function() {
        var topCoordinate = event.pageY;
        var menuHeight = ng.element(ul[0]).prop('offsetHeight');
        var winHeight = event['view'].innerHeight;
        if (topCoordinate > menuHeight && winHeight - topCoordinate < menuHeight) {
          topCoordinate = event.pageY - menuHeight;
        }
        var leftCoordinate = event.pageX;
        var menuWidth = angular.element(ul[0]).prop('offsetWidth');
        var winWidth = event['view'].innerWidth;
        if (leftCoordinate > menuWidth && winWidth - leftCoordinate < menuWidth) {
          leftCoordinate = event.pageX - menuWidth;
        }
        ul.css({
          display: 'block',
          position: 'absolute',
          left: leftCoordinate + 'px',
          top: topCoordinate + 'px'
        });
      });
    }
    function registerEventHandler($scope, enabled, menuItem, li, contextMenuEvent) {
      if (enabled) {
        li.on('click', function(clickEvent) {
          clickEvent.preventDefault();
          $scope.$apply(function() {
            ng.element(contextMenuEvent.currentTarget).removeClass('context');
            removeContextMenus();
            if (ng.isFunction(menuItem.action)) {
              menuItem.action();
            } else {
              console.warn("ContextMenuItem[label=" + menuItem.label + "].action must be a function.");
            }
          });
        });
      } else {
        li.on('click', function(clickEvent) {
          clickEvent.preventDefault();
        });
        li.addClass('disabled');
      }
    }
    function processLabel(menuItem, promises) {
      var anchor = ng.element('<a>');
      anchor.css('padding-right', '8px');
      anchor.attr({
        tabIndex: '-1',
        href: '#'
      });
      var promise = $q.when(menuItem.label);
      promise.then(function(text) {
        anchor.text(text);
      });
      return anchor;
    }
    function renderContextMenuItem($scope, contextMenuEvent, li, menuItem, promises) {
      var label = processLabel(menuItem, promises);
      li.append(label);
      registerEventHandler($scope, true, menuItem, li, contextMenuEvent);
    }
    function renderContextMenu($scope, contextMenuEvent, menu) {
      var promises = [];
      ng.element(event.currentTarget).addClass('context');
      var contextMenu = ng.element('<div>');
      currentContextMenu = contextMenu;
      contextMenu.addClass('dropdown clearfix');
      var ul = ng.element('<ul>');
      ul.addClass('dropdown-menu');
      ul.attr({role: 'menu'});
      ul.css({
        'display': 'block',
        'position': 'absolute',
        'left': contextMenuEvent.pageX + 'px',
        'top': contextMenuEvent.pageY + 'px',
        'z-index': 1000
      });
      angular.forEach(menu, function(menuItem) {
        var li = ng.element('<li>');
        ul.append(li);
        if (menuItem === null) {
          li.addClass('divider');
        } else {
          renderContextMenuItem($scope, contextMenuEvent, li, menuItem, promises);
        }
      });
      contextMenu.append(ul);
      var height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
      contextMenu.css({
        width: '100%',
        height: height + 'px',
        position: 'absolute',
        top: 0,
        left: 0,
        zIndex: 9999
      });
      ng.element(document).find('body').append(contextMenu);
      handlePromises(ul, contextMenuEvent, promises);
      contextMenu.on('mousedown', function(event) {
        if (ng.element(event.target).hasClass('dropdown')) {
          ng.element(event.currentTarget).removeClass('context');
          removeContextMenus();
        }
      });
    }
    function compile(tElem, tAttrs) {
      return {
        pre: function(scope, iElem, iAttrs, controller, transclude) {},
        post: function($scope, iElem, iAttrs, controller, transclude) {
          function contextMenuEventHandler(contextMenuEvent) {
            event.stopPropagation();
            $scope.$apply(function() {
              event.preventDefault();
              var menu = $scope.$eval(iAttrs.contextMenu);
              if (menu instanceof Array) {
                renderContextMenu($scope, contextMenuEvent, menu);
              } else {
                var msg = "context-menu expression must evaluate to an array.";
                console.warn(msg);
              }
            });
          }
          function onDestroyScope() {
            iElem.off('contextmenu', contextMenuEventHandler);
            removeContextMenus();
          }
          iElem.on('contextmenu', contextMenuEventHandler);
          $scope.$on("$destroy", onDestroyScope);
        }
      };
    }
    var directive = {
      require: [],
      restrict: 'A',
      compile: compile
    };
    return directive;
  }
  return {
    setters: [function(ng_1) {
      ng = ng_1;
    }],
    execute: function() {
      factory.$inject = ['$q'];
      exports_1("default", factory);
    }
  };
});

System.register("js/utils/doodleConfig.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function depObject(names, options) {
    function version(name) {
      var matching = options.filter(function(option) {
        return option.name === name;
      });
      if (matching.length > 0) {
        return matching[0].version;
      } else {
        return undefined;
      }
    }
    var obj = {};
    names.forEach(function(name) {
      obj[name] = version(name);
    });
    return obj;
  }
  function default_1(doodle, options) {
    return {
      uuid: doodle.uuid,
      description: doodle.description,
      dependencies: depObject(doodle.dependencies, options),
      operatorOverloading: doodle.operatorOverloading
    };
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/utils/stripWS.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function stripWS(sourceString) {
    return sourceString.replace("\n", "").replace("\t", "").replace("\r", "").replace(" ", "");
  }
  exports_1("default", stripWS);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/utils/doodleToGist.js", ["./doodleConfig", "./stripWS", "./modeFromName"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var doodleConfig_1,
      stripWS_1,
      modeFromName_1;
  function mash(name, content) {
    var mode = modeFromName_1.default(name);
    console.log(name + " => " + mode + ", " + stripWS_1.default(content).length);
    switch (mode) {
      case 'HTML':
        {
          if (stripWS_1.default(content).length > 0) {
            return content;
          } else {
            return '<!DOCTYPE html>\n';
          }
        }
      case 'TypeScript':
        {
          if (stripWS_1.default(content).length > 0) {
            return content;
          } else {
            return '//\n';
          }
        }
      case 'LESS':
        {
          if (stripWS_1.default(content).length > 0) {
            return content;
          } else {
            return '//\n';
          }
        }
    }
    return content;
  }
  function doodleFilesToGistFiles(dFiles) {
    var gFiles = {};
    var names = Object.keys(dFiles);
    var iLen = names.length;
    for (var i = 0; i < iLen; i++) {
      var name_1 = names[i];
      var dFile = dFiles[name_1];
      var gFile = {content: mash(name_1, dFile.content)};
      gFiles[name_1] = gFile;
    }
    return gFiles;
  }
  function default_1(doodle, options) {
    var gist = {
      description: doodle.description,
      public: true,
      files: doodleFilesToGistFiles(doodle.files)
    };
    gist.files['doodle.json'] = {content: JSON.stringify(doodleConfig_1.default(doodle, options), null, 2)};
    return gist;
  }
  exports_1("default", default_1);
  return {
    setters: [function(doodleConfig_1_1) {
      doodleConfig_1 = doodleConfig_1_1;
    }, function(stripWS_1_1) {
      stripWS_1 = stripWS_1_1;
    }, function(modeFromName_1_1) {
      modeFromName_1 = modeFromName_1_1;
    }],
    execute: function() {}
  };
});

System.register("js/controllers/DoodleController.js", ["../utils/doodleToGist", "bootstrap-dialog"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var doodleToGist_1,
      bootstrap_dialog_1;
  var DoodleController;
  return {
    setters: [function(doodleToGist_1_1) {
      doodleToGist_1 = doodleToGist_1_1;
    }, function(bootstrap_dialog_1_1) {
      bootstrap_dialog_1 = bootstrap_dialog_1_1;
    }],
    execute: function() {
      DoodleController = (function() {
        function DoodleController($scope, $state, $stateParams, http, $location, $timeout, $window, github, authManager, cloud, cookie, templates, uuid4, ga, doodlesKey, doodles, options, FILENAME_META, FILENAME_HTML, FILENAME_CODE, FILENAME_LIBS, FILENAME_LESS, FILENAME_MATHSCRIPT_CURRENT_LIB_MIN_JS, FILENAME_TYPESCRIPT_CURRENT_LIB_DTS, STATE_GISTS, STYLE_MARKER, SCRIPTS_MARKER, CODE_MARKER, LIBS_MARKER, VENDOR_FOLDER_MARKER, settings) {
          var GITHUB_TOKEN_COOKIE_NAME = 'github-token';
          authManager.handleGitHubLoginCallback(function(err, token) {
            if (err) {
              $scope.alert(err.message);
            }
          });
          $window.document.body.style.overflow = "hidden";
          $scope.isExplorerVisible = true;
          $scope.toggleExplorer = function() {
            $scope.isExplorerVisible = !$scope.isExplorerVisible;
          };
          ga('create', 'UA-41504069-3', 'auto');
          ga('send', 'pageview');
          $scope.templates = templates;
          $scope.doNew = function(label, value) {
            ga('send', 'event', 'doodle', 'new', label, value);
            $state.go('new');
          };
          $scope.doOpen = function(label, value) {
            ga('send', 'event', 'doodle', 'open', label, value);
            $state.go('open');
          };
          $scope.doCopy = function(label, value) {
            ga('send', 'event', 'doodle', 'copy', label, value);
            $state.go('copy');
          };
          $scope.doProperties = function(label, value) {
            ga('send', 'event', 'doodle', 'properties', label, value);
            $state.go('properties', {doodle: doodles.current()});
          };
          $scope.doUpload = function(label, value) {
            ga('send', 'event', 'doodle', 'upload', label, value);
            var token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
            if (token) {
              var doodle_1 = doodles.current();
              console.log("DOODLE");
              console.log(JSON.stringify(doodle_1));
              var data = doodleToGist_1.default(doodle_1, options);
              console.log("DATA");
              console.log(JSON.stringify(data));
              var gistId_1 = doodle_1.gistId;
              if (gistId_1) {
                github.patchGist(token, gistId_1, data, function(err, response, status, headers, config) {
                  if (err) {
                    if (status === 404) {
                      if (confirm("The Gist associated with your doodle no longer exists.\nWould you like me to disassociate your doodle so that you can create a new Gist?")) {
                        doodle_1.gistId = undefined;
                        doodles.updateStorage();
                      }
                    } else {
                      alert("status: " + JSON.stringify(status));
                      alert("err: " + JSON.stringify(err));
                      alert("response: " + JSON.stringify(response));
                    }
                  } else {
                    doodle_1.updated_at = response.updated_at;
                    doodles.updateStorage();
                    bootstrap_dialog_1.default.show({
                      type: bootstrap_dialog_1.default.TYPE_SUCCESS,
                      title: $("<h3>Upload complete</h3>"),
                      message: "Your doodle was successfully uploaded and patched the existing Gist.",
                      buttons: [{
                        label: "Close",
                        cssClass: 'btn btn-primary',
                        action: function(dialog) {
                          $state.go(STATE_GISTS, {gistId: gistId_1});
                          dialog.close();
                        }
                      }]
                    });
                  }
                });
              } else {
                github.postGist(token, data, function(err, response, status, headers, config) {
                  if (err) {
                    bootstrap_dialog_1.default.show({
                      type: bootstrap_dialog_1.default.TYPE_DANGER,
                      title: $("<h3>Upload failed</h3>"),
                      message: "Unable to patch your Gist at this time.",
                      buttons: [{
                        label: "Close",
                        cssClass: 'btn btn-primary',
                        action: function(dialog) {
                          dialog.close();
                        }
                      }]
                    });
                  } else {
                    doodle_1.gistId = response.id;
                    doodle_1.created_at = response.created_at;
                    doodle_1.updated_at = response.updated_at;
                    doodles.updateStorage();
                    bootstrap_dialog_1.default.show({
                      type: bootstrap_dialog_1.default.TYPE_SUCCESS,
                      title: $("<h3>Upload complete</h3>"),
                      message: "Your doodle was successfully uploaded and associated with a new Gist.",
                      buttons: [{
                        label: "Close",
                        cssClass: 'btn btn-primary',
                        action: function(dialog) {
                          $state.go(STATE_GISTS, {gistId: doodles.current().gistId});
                          dialog.close();
                        }
                      }]
                    });
                  }
                });
              }
            } else {
              bootstrap_dialog_1.default.alert({
                type: bootstrap_dialog_1.default.TYPE_INFO,
                message: "You must be logged in."
              });
            }
          };
          $scope.goHome = function(label, value) {
            ga('send', 'event', 'doodle', 'goHome', label, value);
            $state.go('home');
          };
          $scope.doHelp = function() {};
          if (doodles.length === 0) {
            doodles.createDoodle($scope.templates[0], "My Math Doodle");
          } else {}
        }
        DoodleController.$inject = ['$scope', '$state', '$stateParams', '$http', '$location', '$timeout', '$window', 'GitHub', 'GitHubAuthManager', 'cloud', 'cookie', 'templates', 'uuid4', 'ga', 'doodlesKey', 'doodles', 'options', 'FILENAME_META', 'FILENAME_HTML', 'FILENAME_CODE', 'FILENAME_LIBS', 'FILENAME_LESS', 'FILENAME_MATHSCRIPT_CURRENT_LIB_MIN_JS', 'FILENAME_TYPESCRIPT_CURRENT_LIB_DTS', 'STATE_GISTS', 'STYLE_MARKER', 'SCRIPTS_MARKER', 'CODE_MARKER', 'LIBS_MARKER', 'VENDOR_FOLDER_MARKER', 'settings'];
        return DoodleController;
      }());
      exports_1("default", DoodleController);
    }
  };
});

System.register("js/directives/editor/editor.component.js", ["ace.js", "angular"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var ace_js_1,
      ng;
  function factory($timeout, settings, textService) {
    function link($scope, element, attrs, controllers, transclude) {
      var systemImports = ['/jspm_packages/system.js', '/jspm.config.js'];
      var workerImports = systemImports.concat(['/js/ace-workers.js']);
      var ngModel = controllers[0];
      var workspace = controllers[1];
      var container = element[0];
      var editor = ace_js_1.default.edit(container);
      switch ($scope.mode) {
        case 'JavaScript':
          {
            editor.setLanguageMode(ace_js_1.default.createJavaScriptMode('/js/worker.js', workerImports));
            break;
          }
        case 'TypeScript':
          {
            editor.setLanguageMode(ace_js_1.default.createTypeScriptMode('/js/worker.js', workerImports));
            break;
          }
        case 'HTML':
          {
            editor.setLanguageMode(ace_js_1.default.createHtmlMode('/js/worker.js', workerImports));
            break;
          }
        case 'CSS':
        case 'LESS':
          {
            editor.getSession().setUseWorker(false);
            editor.setLanguageMode(ace_js_1.default.createCssMode('/js/worker.js', workerImports));
            break;
          }
        default:
          {
            console.warn("Unrecognized mode => " + $scope.mode);
          }
      }
      editor.setThemeCss('ace-twilight', '/themes/twilight.css');
      editor.setThemeDark(true);
      editor.setPadding(4);
      editor.setShowInvisibles(settings.showInvisibles);
      editor.setFontSize(settings.fontSize);
      editor.setShowPrintMargin(settings.showPrintMargin);
      editor.setDisplayIndentGuides(settings.displayIndentGuides);
      attrs.$observe('readonly', function(readOnly) {
        editor.setReadOnly(readOnly);
      });
      function onEditorChange(event, source) {
        var viewValue = editor.getValue();
        ngModel.$setViewValue(viewValue);
      }
      ngModel.$formatters.push(function(modelValue) {
        if (ng.isUndefined(modelValue) || modelValue === null) {
          return void 0;
        }
        return modelValue;
      });
      ngModel.$parsers.push(function(viewValue) {
        ngModel.$setValidity('yadda', true);
        return viewValue;
      });
      ngModel.$validators['foo'] = function(modelValue, viewValue) {
        return true;
      };
      ngModel.$render = function() {
        var viewValue = ngModel.$viewValue;
        if (typeof viewValue === 'string') {
          editor.off('change', onEditorChange);
          editor.setValue(viewValue, -1);
          editor.on('change', onEditorChange);
        } else {
          console.warn("$render: Expecting typeof ngModel.$viewValue => '" + typeof viewValue + "' to be 'string'.");
        }
        $timeout(function() {
          resizeEditor();
          editor.gotoLine(0, 0);
        });
      };
      if (transclude) {
        transclude($scope, function(clonedElement) {
          var initialText = textService.normalizeWhitespace(clonedElement.text());
          editor.setValue(initialText, -1);
          if (initialText && !ngModel.$viewValue) {
            var viewValue = initialText;
            ngModel.$setViewValue(viewValue);
          }
        });
      } else {
        console.warn("The transclude option is not set to true");
      }
      editor.on('change', onEditorChange);
      var unregisterWatchNgShow = $scope.$watch('ngShow', function(newShowing, oldShowing) {
        if (newShowing) {
          resizeEditorNextTick();
        }
      });
      function resizeEditorNextTick() {
        $timeout(function() {
          resizeEditor();
        }, 0, false);
      }
      function resizeEditor() {
        editor.resize(true);
        editor.renderer.updateFull();
      }
      function onDestroyScope() {
        unregisterWatchNgShow();
        workspace.detachEditor($scope.id, $scope.mode, editor);
        editor.off('change', onEditorChange);
        editor.destroy();
      }
      $scope.$on('$destroy', onDestroyScope);
      workspace.attachEditor($scope.id, $scope.mode, editor);
    }
    var directive = {
      require: ['ngModel', '^^workspace'],
      priority: 1,
      restrict: 'A',
      scope: {
        id: '@',
        mode: '@',
        ngShow: '<'
      },
      transclude: true,
      link: link
    };
    return directive;
  }
  return {
    setters: [function(ace_js_1_1) {
      ace_js_1 = ace_js_1_1;
    }, function(ng_1) {
      ng = ng_1;
    }],
    execute: function() {
      factory.$inject = ['$timeout', 'settings', 'textService'];
      exports_1("default", factory);
    }
  };
});

System.register("js/directives/explorer/ExplorerController.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var ExplorerController;
  return {
    setters: [],
    execute: function() {
      ExplorerController = (function() {
        function ExplorerController(doodles) {
          this.doodles = doodles;
        }
        ExplorerController.prototype.$onInit = function() {};
        ExplorerController.prototype.$onDestroy = function() {};
        ExplorerController.prototype.openFile = function(name) {
          var doodle = this.doodles.current();
          doodle.openFile(name);
          doodle.selectFile(name);
        };
        ExplorerController.prototype.closeFile = function(name) {
          var doodle = this.doodles.current();
          doodle.closeFile(name);
        };
        ExplorerController.prototype.selectFile = function(name) {
          var doodle = this.doodles.current();
          doodle.selectFile(name);
        };
        ExplorerController.$inject = ['doodles'];
        return ExplorerController;
      }());
      exports_1("default", ExplorerController);
    }
  };
});

System.register("js/directives/explorer/explorer.component.js", ["./ExplorerController"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var ExplorerController_1;
  var ddo;
  function default_1() {
    return ddo;
  }
  exports_1("default", default_1);
  return {
    setters: [function(ExplorerController_1_1) {
      ExplorerController_1 = ExplorerController_1_1;
    }],
    execute: function() {
      ddo = {
        require: ['ngModel'],
        restrict: 'E',
        bindToController: {},
        controller: ExplorerController_1.default,
        controllerAs: '$ctrl',
        templateUrl: 'explorer.html',
        compile: function(tElem, tAttrs) {
          return {
            pre: function(scope, iElem, iAttrs, controller, transclude) {
              var ngModel = controller[0];
              ngModel.$formatters.push(function(modelValue) {
                if (modelValue) {
                  var viewValue = [];
                  var names = Object.keys(modelValue);
                  var iLen = names.length;
                  for (var i = 0; i < iLen; i++) {
                    var name_1 = names[i];
                    var file = modelValue[name_1];
                    viewValue.push({
                      name: name_1,
                      isOpen: file.isOpen,
                      selected: file.selected
                    });
                  }
                  return viewValue;
                } else {
                  return [];
                }
              });
              ngModel.$parsers.push(function(viewValue) {
                ngModel.$setValidity('yadda', true);
                return viewValue;
              });
              ngModel.$validators['foo'] = function(modelValue, viewValue) {
                return true;
              };
            },
            post: function($scope, iElem, iAttrs, controller, transclude) {
              var ngModel = controller[0];
              ngModel.$render = function() {
                $scope.files = ngModel.$viewValue;
              };
              if (transclude) {
                transclude(function(clonedElement) {});
              }
            }
          };
        }
      };
    }
  };
});

System.register("js/directives/explorer/ExplorerFilesController.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var ExplorerFilesController;
  return {
    setters: [],
    execute: function() {
      ExplorerFilesController = (function() {
        function ExplorerFilesController($scope, doodles, modalService) {
          var _this = this;
          this.doodles = doodles;
          this.modalService = modalService;
          $scope.menu = function(name, file) {
            return [{
              label: "Open",
              action: function() {
                _this.openFile(name);
              }
            }, null, {
              label: "Rename",
              action: function() {
                _this.renameFile(name);
              }
            }, {
              label: "Delete",
              action: function() {
                _this.deleteFile(name);
              }
            }];
          };
        }
        ExplorerFilesController.prototype.newFile = function() {
          var _this = this;
          var options = {
            title: 'New File',
            text: '',
            placeholder: "name.extension",
            actionButtonText: 'Create File',
            message: "Enter the name of the new file."
          };
          this.modalService.prompt(options).then(function(name) {
            var doodle = _this.doodles.current();
            if (doodle) {
              try {
                doodle.newFile(name);
                doodle.selectFile(name);
                _this.doodles.updateStorage();
              } catch (e) {
                var alertOptions = {
                  title: "Error",
                  message: e.toString()
                };
                _this.modalService.alert(alertOptions);
              }
            } else {
              console.warn("newFile(" + name + ")");
            }
          }).catch(function(reason) {});
        };
        ExplorerFilesController.prototype.openFile = function(name) {
          var doodle = this.doodles.current();
          if (doodle) {
            doodle.openFile(name);
            doodle.selectFile(name);
          } else {
            console.warn("openFile(" + name + ")");
          }
        };
        ExplorerFilesController.prototype.renameFile = function(oldName) {
          var _this = this;
          var options = {
            title: "Rename '" + oldName + "'",
            text: oldName,
            placeholder: "name.extension",
            actionButtonText: 'Rename File',
            message: "Enter the new name of the file."
          };
          this.modalService.prompt(options).then(function(newName) {
            var doodle = _this.doodles.current();
            if (doodle) {
              try {
                doodle.renameFile(oldName, newName);
                _this.doodles.updateStorage();
              } catch (e) {
                _this.modalService.alert({
                  title: "Error",
                  message: e.toString()
                });
              }
            } else {
              console.warn("renameFile(" + oldName + ", " + newName + ")");
            }
          }).catch(function(reason) {});
        };
        ExplorerFilesController.prototype.deleteFile = function(name) {
          var _this = this;
          var options = {
            title: "Delete '" + name + "'",
            message: "Are you sure you want to delete '" + name + "'?",
            actionButtonText: 'Delete File'
          };
          this.modalService.confirm(options).then(function(result) {
            var doodle = _this.doodles.current();
            if (doodle) {
              doodle.deleteFile(name);
              _this.doodles.updateStorage();
            } else {
              console.warn("deleteFile(" + name + ")");
            }
          }).catch(function(reason) {});
        };
        ExplorerFilesController.$inject = ['$scope', 'doodles', 'modalService'];
        return ExplorerFilesController;
      }());
      exports_1("default", ExplorerFilesController);
    }
  };
});

System.register("js/directives/logoText/logoText.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function default_1() {
    return {
      restrict: 'E',
      scope: {version: '@'},
      template: ["<span class='md-logo-text-math'>math</span>", "<span class='md-logo-text-doodle'>doodle</span>", "<span class='md-logo-text-domain'>.io</span>", "<span class='md-logo-text-version'><sup>{{version}}-βετα</sup></span>"].join('')
    };
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/services/modalService/AlertController.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var AlertController;
  return {
    setters: [],
    execute: function() {
      AlertController = (function() {
        function AlertController($scope, $uibModalInstance, options) {
          console.log(JSON.stringify(options, null, 2));
          $scope.options = options;
          $scope.close = function() {
            $uibModalInstance.close(true);
          };
        }
        AlertController.$inject = ['$scope', '$uibModalInstance', 'options'];
        return AlertController;
      }());
      exports_1("default", AlertController);
    }
  };
});

System.register("js/services/modalService/ConfirmController.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var ConfirmController;
  return {
    setters: [],
    execute: function() {
      ConfirmController = (function() {
        function ConfirmController($scope, $uibModalInstance, options) {
          $scope.options = options;
          $scope.ok = function() {
            var result = null;
            $uibModalInstance.close(result);
          };
          $scope.cancel = function() {
            var reason = 'cancel click';
            $uibModalInstance.dismiss(reason);
          };
        }
        ConfirmController.$inject = ['$scope', '$uibModalInstance', 'options'];
        return ConfirmController;
      }());
      exports_1("default", ConfirmController);
    }
  };
});

System.register("js/services/modalService/PromptController.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var PromptController;
  return {
    setters: [],
    execute: function() {
      PromptController = (function() {
        function PromptController($scope, $uibModalInstance, options) {
          console.log(JSON.stringify(options, null, 2));
          $scope.options = options;
          $scope.ok = function() {
            $uibModalInstance.close($scope.options.text);
          };
          $scope.cancel = function() {
            $uibModalInstance.dismiss('cancel click');
          };
        }
        PromptController.$inject = ['$scope', '$uibModalInstance', 'options'];
        return PromptController;
      }());
      exports_1("default", PromptController);
    }
  };
});

System.register("js/services/modalService/ModalService.js", ["angular"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var ng;
  var DEFAULT_MODAL_SETTINGS,
      DEFAULT_ALERT_OPTIONS,
      DEFAULT_CONFIRM_OPTIONS,
      DEFAULT_PROMPT_OPTIONS,
      ModalService;
  return {
    setters: [function(ng_1) {
      ng = ng_1;
    }],
    execute: function() {
      DEFAULT_MODAL_SETTINGS = {
        backdrop: true,
        keyboard: true
      };
      DEFAULT_ALERT_OPTIONS = {
        title: 'Alert',
        message: 'Danger Will Robinson!'
      };
      DEFAULT_CONFIRM_OPTIONS = {
        cancelButtonText: 'Cancel',
        actionButtonText: 'OK',
        title: 'Confirm',
        message: ''
      };
      DEFAULT_PROMPT_OPTIONS = {
        title: 'Prompt',
        message: '',
        text: '',
        placeholder: '',
        actionButtonText: 'OK',
        cancelButtonText: 'Cancel'
      };
      ModalService = (function() {
        function ModalService($uibModal) {
          this.$uibModal = $uibModal;
        }
        ModalService.prototype.alert = function(options) {
          var settings = {
            backdrop: 'static',
            controller: 'AlertController',
            templateUrl: 'alert-modal.html'
          };
          ng.extend(settings, DEFAULT_MODAL_SETTINGS);
          var mergedOptions = {
            title: '',
            message: ''
          };
          ng.extend(mergedOptions, DEFAULT_ALERT_OPTIONS, options);
          settings.resolve = {options: function() {
              return mergedOptions;
            }};
          return this.$uibModal.open(settings).result;
        };
        ModalService.prototype.confirm = function(options) {
          var settings = {
            backdrop: 'static',
            controller: 'ConfirmController',
            templateUrl: 'confirm-modal.html'
          };
          ng.extend(settings, DEFAULT_MODAL_SETTINGS);
          var mergedOptions = {
            title: '',
            message: ''
          };
          ng.extend(mergedOptions, DEFAULT_CONFIRM_OPTIONS, options);
          settings.resolve = {options: function() {
              return mergedOptions;
            }};
          return this.$uibModal.open(settings).result;
        };
        ModalService.prototype.prompt = function(options) {
          var settings = {
            backdrop: 'static',
            controller: 'PromptController',
            templateUrl: 'prompt-modal.html'
          };
          ng.extend(settings, DEFAULT_MODAL_SETTINGS);
          var mergedOptions = {
            title: '',
            message: '',
            text: '',
            placeholder: ''
          };
          ng.extend(mergedOptions, DEFAULT_PROMPT_OPTIONS, options);
          settings.resolve = {options: function() {
              return mergedOptions;
            }};
          return this.$uibModal.open(settings).result;
        };
        ModalService.$inject = ['$uibModal'];
        return ModalService;
      }());
      exports_1("default", ModalService);
    }
  };
});

System.register("js/directives/resizable/resizable.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function default_1() {
    var toCall;
    function throttle(fun) {
      if (toCall === void 0) {
        toCall = fun;
        setTimeout(function() {
          toCall();
          toCall = void 0;
        }, 100);
      } else {
        toCall = fun;
      }
    }
    return {
      restrict: 'AE',
      scope: {
        rDirections: "=",
        rCenteredX: "=",
        rCenteredY: "=",
        rWidth: "=",
        rHeight: "=",
        rFlex: "=",
        rGrabber: "@",
        rDisabled: '@',
        rNoThrottle: '='
      },
      link: function(scope, element, attr) {
        var flexBasis = 'flexBasis' in document.documentElement.style ? 'flexBasis' : 'webkitFlexBasis' in document.documentElement.style ? 'webkitFlexBasis' : 'msFlexPreferredSize' in document.documentElement.style ? 'msFlexPreferredSize' : 'flexBasis';
        scope.$watch('rWidth', function(value) {
          element[0].style[scope.rFlex ? flexBasis : 'width'] = scope.rWidth + 'px';
        });
        scope.$watch('rHeight', function(value) {
          element[0].style[scope.rFlex ? flexBasis : 'height'] = scope.rHeight + 'px';
        });
        element.addClass('resizable');
        var style = window.getComputedStyle(element[0], null);
        var w;
        var h;
        var dir = scope.rDirections || ['right'];
        var vx = scope.rCenteredX ? 2 : 1;
        var vy = scope.rCenteredY ? 2 : 1;
        var inner = scope.rGrabber ? scope.rGrabber : '<span></span>';
        var start;
        var dragDir;
        var axis;
        var info = {
          id: void 0,
          width: false,
          height: false
        };
        var updateInfo = function() {
          info.width = false;
          info.height = false;
          if (axis === 'x') {
            info.width = scope.rFlex ? parseInt(element[0].style.flexBasis, 10) : parseInt(element[0].style.width, 10);
          } else {
            info.height = scope.rFlex ? parseInt(element[0].style.flexBasis, 10) : parseInt(element[0].style.height, 10);
          }
          info.id = element[0].id;
        };
        var getClientX = function(e) {
          if (e instanceof TouchEvent) {
            return e.touches[0].clientX;
          } else {
            return e.clientX;
          }
        };
        var getClientY = function(e) {
          if (e instanceof TouchEvent) {
            return e.touches[0].clientY;
          } else {
            return e.clientY;
          }
        };
        var dragging = function(e) {
          var offset = axis === 'x' ? start - getClientX(e) : start - getClientY(e);
          switch (dragDir) {
            case 'top':
              if (scope.rFlex) {
                element[0].style.flexBasis = h + (offset * vy) + 'px';
              } else {
                element[0].style.height = h + (offset * vy) + 'px';
              }
              break;
            case 'right':
              if (scope.rFlex) {
                element[0].style.flexGrow = '0';
                element[0].style.flexBasis = w - (offset * vx) + 'px';
              } else {
                element[0].style.width = w - (offset * vx) + 'px';
              }
              break;
            case 'bottom':
              if (scope.rFlex) {
                element[0].style.flexBasis = h - (offset * vy) + 'px';
              } else {
                element[0].style.height = h - (offset * vy) + 'px';
              }
              break;
            case 'left':
              if (scope.rFlex) {
                element[0].style.flexBasis = w + (offset * vx) + 'px';
              } else {
                element[0].style.width = w + (offset * vx) + 'px';
              }
              break;
          }
          updateInfo();
          function resizingEmit() {
            scope.$emit('angular-resizable.resizing', info);
          }
          if (scope.rNoThrottle) {
            resizingEmit();
          } else {
            throttle(resizingEmit);
          }
        };
        var dragEnd = function(e) {
          updateInfo();
          scope.$emit("angular-resizable.resizeEnd", info);
          scope.$apply();
          document.removeEventListener('mouseup', dragEnd, false);
          document.removeEventListener('mousemove', dragging, false);
          document.removeEventListener('touchend', dragEnd, false);
          document.removeEventListener('touchmove', dragging, false);
          element.removeClass('no-transition');
        };
        var dragStart = function(e, direction) {
          dragDir = direction;
          axis = (dragDir === 'left' || dragDir === 'right') ? 'x' : 'y';
          start = (axis === 'x') ? getClientX(e) : getClientY(e);
          w = parseInt(style.getPropertyValue("width"), 10);
          h = parseInt(style.getPropertyValue("height"), 10);
          element.addClass('no-transition');
          document.addEventListener('mouseup', dragEnd, false);
          document.addEventListener('mousemove', dragging, false);
          document.addEventListener('touchend', dragEnd, false);
          document.addEventListener('touchmove', dragging, false);
          if (e.stopPropagation) {
            e.stopPropagation();
          }
          if (e.preventDefault) {
            e.preventDefault();
          }
          e.cancelBubble = true;
          e.returnValue = false;
          updateInfo();
          scope.$emit("angular-resizable.resizeStart", info);
          scope.$apply();
        };
        for (var i = 0,
            iLength = dir.length; i < iLength; i++) {
          (function() {
            var grabber = document.createElement('div');
            var direction = dir[i];
            grabber.setAttribute('class', 'rg-' + dir[i]);
            grabber.innerHTML = inner;
            element[0].appendChild(grabber);
            var mouseDown = function(e) {
              var disabled = (scope.rDisabled === 'true');
              if (!disabled && (e.which === 1)) {
                dragStart(e, direction);
              }
            };
            var touchStart = function(e) {
              var disabled = (scope.rDisabled === 'true');
              if (!disabled && (e.touches)) {
                dragStart(e, direction);
              }
            };
            grabber.ondragstart = function(e) {
              return false;
            };
            grabber.addEventListener('mousedown', mouseDown, false);
            grabber.addEventListener('touchstart', touchStart, false);
          }());
        }
      }
    };
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/services/text/TextService.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var TextService;
  return {
    setters: [],
    execute: function() {
      TextService = (function() {
        function TextService() {}
        TextService.prototype.normalizeWhitespace = function(str) {
          var stripped = str.replace(/^\n/, '');
          if (stripped.length > 0) {
            var firstIndentLength = new RegExp("(?:^|\n)([ \t\r]+)").exec(stripped)[1].length;
            return stripped.replace(new RegExp("(^|\n)[ \t\r]{" + firstIndentLength + "}", 'g'), "$1");
          } else {
            return stripped;
          }
        };
        TextService.$inject = [];
        return TextService;
      }());
      exports_1("default", TextService);
    }
  };
});

(function() {
var define = System.amdDefine;
(function(global, define) {
  var globalDefine = global.define;
  var requirejs,
      require,
      define;
  (function(undef) {
    var main,
        req,
        makeMap,
        handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;
    function hasProp(obj, prop) {
      return hasOwn.call(obj, prop);
    }
    function normalize(name, baseName) {
      var nameParts,
          nameSegment,
          mapValue,
          foundMap,
          lastIndex,
          foundI,
          foundStarMap,
          starI,
          i,
          j,
          part,
          normalizedBaseParts,
          baseParts = baseName && baseName.split("/"),
          map = config.map,
          starMap = (map && map['*']) || {};
      if (name) {
        name = name.split('/');
        lastIndex = name.length - 1;
        if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
          name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
        }
        if (name[0].charAt(0) === '.' && baseParts) {
          normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
          name = normalizedBaseParts.concat(name);
        }
        for (i = 0; i < name.length; i++) {
          part = name[i];
          if (part === '.') {
            name.splice(i, 1);
            i -= 1;
          } else if (part === '..') {
            if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
              continue;
            } else if (i > 0) {
              name.splice(i - 1, 2);
              i -= 2;
            }
          }
        }
        name = name.join('/');
      }
      if ((baseParts || starMap) && map) {
        nameParts = name.split('/');
        for (i = nameParts.length; i > 0; i -= 1) {
          nameSegment = nameParts.slice(0, i).join("/");
          if (baseParts) {
            for (j = baseParts.length; j > 0; j -= 1) {
              mapValue = map[baseParts.slice(0, j).join('/')];
              if (mapValue) {
                mapValue = mapValue[nameSegment];
                if (mapValue) {
                  foundMap = mapValue;
                  foundI = i;
                  break;
                }
              }
            }
          }
          if (foundMap) {
            break;
          }
          if (!foundStarMap && starMap && starMap[nameSegment]) {
            foundStarMap = starMap[nameSegment];
            starI = i;
          }
        }
        if (!foundMap && foundStarMap) {
          foundMap = foundStarMap;
          foundI = starI;
        }
        if (foundMap) {
          nameParts.splice(0, foundI, foundMap);
          name = nameParts.join('/');
        }
      }
      return name;
    }
    function makeRequire(relName, forceSync) {
      return function() {
        var args = aps.call(arguments, 0);
        if (typeof args[0] !== 'string' && args.length === 1) {
          args.push(null);
        }
        return req.apply(undef, args.concat([relName, forceSync]));
      };
    }
    function makeNormalize(relName) {
      return function(name) {
        return normalize(name, relName);
      };
    }
    function makeLoad(depName) {
      return function(value) {
        defined[depName] = value;
      };
    }
    function callDep(name) {
      if (hasProp(waiting, name)) {
        var args = waiting[name];
        delete waiting[name];
        defining[name] = true;
        main.apply(undef, args);
      }
      if (!hasProp(defined, name) && !hasProp(defining, name)) {
        throw new Error('No ' + name);
      }
      return defined[name];
    }
    function splitPrefix(name) {
      var prefix,
          index = name ? name.indexOf('!') : -1;
      if (index > -1) {
        prefix = name.substring(0, index);
        name = name.substring(index + 1, name.length);
      }
      return [prefix, name];
    }
    makeMap = function(name, relName) {
      var plugin,
          parts = splitPrefix(name),
          prefix = parts[0];
      name = parts[1];
      if (prefix) {
        prefix = normalize(prefix, relName);
        plugin = callDep(prefix);
      }
      if (prefix) {
        if (plugin && plugin.normalize) {
          name = plugin.normalize(name, makeNormalize(relName));
        } else {
          name = normalize(name, relName);
        }
      } else {
        name = normalize(name, relName);
        parts = splitPrefix(name);
        prefix = parts[0];
        name = parts[1];
        if (prefix) {
          plugin = callDep(prefix);
        }
      }
      return {
        f: prefix ? prefix + '!' + name : name,
        n: name,
        pr: prefix,
        p: plugin
      };
    };
    function makeConfig(name) {
      return function() {
        return (config && config.config && config.config[name]) || {};
      };
    }
    handlers = {
      require: function(name) {
        return makeRequire(name);
      },
      exports: function(name) {
        var e = defined[name];
        if (typeof e !== 'undefined') {
          return e;
        } else {
          return (defined[name] = {});
        }
      },
      module: function(name) {
        return {
          id: name,
          uri: '',
          exports: defined[name],
          config: makeConfig(name)
        };
      }
    };
    main = function(name, deps, callback, relName) {
      var cjsModule,
          depName,
          ret,
          map,
          i,
          args = [],
          callbackType = typeof callback,
          usingExports;
      relName = relName || name;
      if (callbackType === 'undefined' || callbackType === 'function') {
        deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
        for (i = 0; i < deps.length; i += 1) {
          map = makeMap(deps[i], relName);
          depName = map.f;
          if (depName === "require") {
            args[i] = handlers.require(name);
          } else if (depName === "exports") {
            args[i] = handlers.exports(name);
            usingExports = true;
          } else if (depName === "module") {
            cjsModule = args[i] = handlers.module(name);
          } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {
            args[i] = callDep(depName);
          } else if (map.p) {
            map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
            args[i] = defined[depName];
          } else {
            throw new Error(name + ' missing ' + depName);
          }
        }
        ret = callback ? callback.apply(defined[name], args) : undefined;
        if (name) {
          if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {
            defined[name] = cjsModule.exports;
          } else if (ret !== undef || !usingExports) {
            defined[name] = ret;
          }
        }
      } else if (name) {
        defined[name] = callback;
      }
    };
    requirejs = require = req = function(deps, callback, relName, forceSync, alt) {
      if (typeof deps === "string") {
        if (handlers[deps]) {
          return handlers[deps](callback);
        }
        return callDep(makeMap(deps, callback).f);
      } else if (!deps.splice) {
        config = deps;
        if (config.deps) {
          req(config.deps, config.callback);
        }
        if (!callback) {
          return;
        }
        if (callback.splice) {
          deps = callback;
          callback = relName;
          relName = null;
        } else {
          deps = undef;
        }
      }
      callback = callback || function() {};
      if (typeof relName === 'function') {
        relName = forceSync;
        forceSync = alt;
      }
      if (forceSync) {
        main(undef, deps, callback, relName);
      } else {
        setTimeout(function() {
          main(undef, deps, callback, relName);
        }, 4);
      }
      return req;
    };
    req.config = function(cfg) {
      return req(cfg);
    };
    requirejs._defined = defined;
    define = function(name, deps, callback) {
      if (typeof name !== 'string') {
        throw new Error('See almond README: incorrect module build, no module name');
      }
      if (!deps.splice) {
        callback = deps;
        deps = [];
      }
      if (!hasProp(defined, name) && !hasProp(waiting, name)) {
        waiting[name] = [name, deps, callback];
      }
    };
    define.amd = {jQuery: true};
  }());
  define("../vendor/almond/almond", function() {});
  define('lib/EventEmitterClass', ["require", "exports"], function(require, exports) {
    "use strict";
    "use strict";
    var stopPropagation = function() {
      this.propagationStopped = true;
    };
    var preventDefault = function() {
      this.defaultPrevented = true;
    };
    var EventEmitterClass = (function() {
      function EventEmitterClass(owner) {
        this.owner = owner;
      }
      EventEmitterClass.prototype._dispatchEvent = function(eventName, event) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
          return;
        if (typeof event !== "object" || !event) {
          event = {};
        }
        if (!event.type) {
          event.type = eventName;
        }
        if (!event.stopPropagation) {
          event.stopPropagation = stopPropagation;
        }
        if (!event.preventDefault) {
          event.preventDefault = preventDefault;
        }
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) {
          listeners[i](event, this.owner);
          if (event['propagationStopped']) {
            break;
          }
        }
        if (defaultHandler && !event.defaultPrevented) {
          return defaultHandler(event, this.owner);
        }
      };
      EventEmitterClass.prototype.hasListeners = function(eventName) {
        var registry = this._eventRegistry;
        var listeners = registry && registry[eventName];
        return listeners && listeners.length > 0;
      };
      EventEmitterClass.prototype._emit = function(eventName, event) {
        return this._dispatchEvent(eventName, event);
      };
      EventEmitterClass.prototype._signal = function(eventName, e) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners) {
          return;
        }
        listeners = listeners.slice();
        for (var i = 0,
            iLength = listeners.length; i < iLength; i++) {
          listeners[i](e, this.owner);
        }
      };
      EventEmitterClass.prototype.once = function(eventName, callback) {
        var _self = this;
        callback && this.addEventListener(eventName, function newCallback() {
          _self.removeEventListener(eventName, newCallback);
          callback.apply(null, arguments);
        });
      };
      EventEmitterClass.prototype.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers) {
          handlers = this._defaultHandlers = {_disabled_: {}};
        }
        if (handlers[eventName]) {
          var existingHandler = handlers[eventName];
          var disabled = handlers._disabled_[eventName];
          if (!disabled) {
            handlers._disabled_[eventName] = disabled = [];
          }
          disabled.push(existingHandler);
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
      };
      EventEmitterClass.prototype.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers) {
          return;
        }
        var disabled = handlers._disabled_[eventName];
        if (handlers[eventName] === callback) {
          var unused = handlers[eventName];
          if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
      };
      EventEmitterClass.prototype.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners) {
          listeners = this._eventRegistry[eventName] = [];
        }
        if (listeners.indexOf(callback) === -1) {
          if (capturing) {
            listeners.unshift(callback);
          } else {
            listeners.push(callback);
          }
        }
        return callback;
      };
      EventEmitterClass.prototype.on = function(eventName, callback, capturing) {
        this.addEventListener(eventName, callback, capturing);
      };
      EventEmitterClass.prototype.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          return;
        var index = listeners.indexOf(callback);
        if (index !== -1) {
          listeners.splice(index, 1);
        }
      };
      EventEmitterClass.prototype.removeListener = function(eventName, callback) {
        return this.removeEventListener(eventName, callback);
      };
      EventEmitterClass.prototype.off = function(eventName, callback) {
        return this.removeEventListener(eventName, callback);
      };
      EventEmitterClass.prototype.removeAllListeners = function(eventName) {
        if (this._eventRegistry)
          this._eventRegistry[eventName] = [];
      };
      return EventEmitterClass;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = EventEmitterClass;
  });
  define('Anchor', ["require", "exports", './lib/EventEmitterClass'], function(require, exports, EventEmitterClass_1) {
    "use strict";
    function pointsInOrder(point1, point2, equalPointsInOrder) {
      var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
      return (point1.row < point2.row) || (point1.row === point2.row && bColIsAfter);
    }
    function getTransformedPoint(delta, point, moveIfEqual) {
      var deltaIsInsert = delta.action === "insert";
      var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
      var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
      var deltaStart = delta.start;
      var deltaEnd = deltaIsInsert ? deltaStart : delta.end;
      if (pointsInOrder(point, deltaStart, moveIfEqual)) {
        return {
          column: point.column,
          row: point.row
        };
      }
      if (pointsInOrder(deltaEnd, point, !moveIfEqual)) {
        return {
          column: point.column + (point.row === deltaEnd.row ? deltaColShift : 0),
          row: point.row + deltaRowShift
        };
      }
      return {
        column: deltaStart.column,
        row: deltaStart.row
      };
    }
    var Anchor = (function() {
      function Anchor(doc, row, column) {
        var _this = this;
        this.eventBus = new EventEmitterClass_1.default(this);
        this.documentChangeHandler = function(delta, doc) {
          if (delta.start.row === delta.end.row && delta.start.row !== _this.row) {
            return;
          }
          if (delta.start.row > _this.row) {
            return;
          }
          var point = getTransformedPoint(delta, {
            row: _this.row,
            column: _this.column
          }, _this.insertRight);
          _this.setPosition(point.row, point.column, true);
        };
        this.attach(doc);
        this.setPosition(row, column);
        this.insertRight = false;
      }
      Anchor.prototype.getPosition = function() {
        return this.clipPositionToDocument(this.row, this.column);
      };
      Anchor.prototype.getDocument = function() {
        return this.document;
      };
      Anchor.prototype.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
          pos = {
            row: row,
            column: column
          };
        } else {
          pos = this.clipPositionToDocument(row, column);
        }
        if (this.row === pos.row && this.column === pos.column) {
          return;
        } else {
          var old = {
            row: this.row,
            column: this.column
          };
          this.row = pos.row;
          this.column = pos.column;
          var event_1 = {
            oldPosition: old,
            position: pos
          };
          this.eventBus._signal("change", event_1);
        }
      };
      Anchor.prototype.detach = function() {
        this.document.removeChangeListener(this.documentChangeHandler);
      };
      Anchor.prototype.attach = function(doc) {
        this.document = doc || this.document;
        this.document.addChangeListener(this.documentChangeHandler);
      };
      Anchor.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      Anchor.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      Anchor.prototype.clipPositionToDocument = function(row, column) {
        var pos = {
          column: 0,
          row: 0
        };
        if (row >= this.document.getLength()) {
          pos.row = Math.max(0, this.document.getLength() - 1);
          pos.column = this.document.getLine(pos.row).length;
        } else if (row < 0) {
          pos.row = 0;
          pos.column = 0;
        } else {
          pos.row = row;
          pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }
        if (column < 0) {
          pos.column = 0;
        }
        return pos;
      };
      return Anchor;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Anchor;
  });
  define('createAnchor', ["require", "exports", './Anchor'], function(require, exports, Anchor_1) {
    "use strict";
    function createAnchor(doc, row, column) {
      return new Anchor_1.default(doc, row, column);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createAnchor;
  });
  define('applyDelta', ["require", "exports"], function(require, exports) {
    "use strict";
    function throwDeltaError(delta, errorText) {
      throw "Invalid Delta: " + errorText;
    }
    function positionInDocument(docLines, position) {
      return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
    }
    function validateDelta(docLines, delta) {
      var action = delta.action;
      if (action !== "insert" && action !== "remove")
        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
      if (!(delta.lines instanceof Array))
        throwDeltaError(delta, "delta.lines must be an Array");
      if (!delta.start || !delta.end)
        throwDeltaError(delta, "delta.start/end must be an present");
      var start = delta.start;
      if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, "delta.start must be contained in document");
      var end = delta.end;
      if (action === "remove" && !positionInDocument(docLines, end))
        throwDeltaError(delta, "delta.end " + JSON.stringify(end) + " must be contained in document for 'remove' actions");
      var numRangeRows = end.row - start.row;
      var numRangeLastLineChars = (end.column - (numRangeRows === 0 ? start.column : 0));
      if (numRangeRows !== delta.lines.length - 1 || delta.lines[numRangeRows].length !== numRangeLastLineChars)
        throwDeltaError(delta, "delta.range must match delta lines");
    }
    function applyDelta(docLines, delta, doNotValidate) {
      if (!doNotValidate && false) {
        validateDelta(docLines, delta);
      }
      var row = delta.start.row;
      var startColumn = delta.start.column;
      var line = docLines[row] || "";
      switch (delta.action) {
        case "insert":
          var lines = delta.lines;
          if (lines.length === 1) {
            docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
          } else {
            var args = [row, 1];
            args = args.concat(delta.lines);
            docLines.splice.apply(docLines, args);
            docLines[row] = line.substring(0, startColumn) + docLines[row];
            docLines[row + delta.lines.length - 1] += line.substring(startColumn);
          }
          break;
        case "remove":
          var endColumn = delta.end.column;
          var endRow = delta.end.row;
          if (row === endRow) {
            docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
          } else {
            docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
          }
          break;
        default:
          {}
      }
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = applyDelta;
  });
  define('Range', ["require", "exports"], function(require, exports) {
    "use strict";
    var Range = (function() {
      function Range(startRow, startColumn, endRow, endColumn) {
        this.start = {
          row: startRow,
          column: startColumn
        };
        this.end = {
          row: endRow,
          column: endColumn
        };
      }
      Range.prototype.isEqual = function(range) {
        return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
      };
      Range.prototype.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]");
      };
      Range.prototype.contains = function(row, column) {
        return this.compare(row, column) === 0;
      };
      Range.prototype.compareRange = function(range) {
        var cmp;
        var end = range.end;
        var start = range.start;
        cmp = this.compare(end.row, end.column);
        if (cmp === 1) {
          cmp = this.compare(start.row, start.column);
          if (cmp === 1) {
            return 2;
          } else if (cmp === 0) {
            return 1;
          } else {
            return 0;
          }
        } else if (cmp === -1) {
          return -2;
        } else {
          cmp = this.compare(start.row, start.column);
          if (cmp === -1) {
            return -1;
          } else if (cmp === 1) {
            return 42;
          } else {
            return 0;
          }
        }
      };
      Range.prototype.comparePoint = function(point) {
        return this.compare(point.row, point.column);
      };
      Range.prototype.containsRange = function(range) {
        return this.comparePoint(range.start) === 0 && this.comparePoint(range.end) === 0;
      };
      Range.prototype.intersects = function(range) {
        var cmp = this.compareRange(range);
        return (cmp === -1 || cmp === 0 || cmp === 1);
      };
      Range.prototype.isEnd = function(row, column) {
        return this.end.row === row && this.end.column === column;
      };
      Range.prototype.isStart = function(row, column) {
        return this.start.row === row && this.start.column === column;
      };
      Range.prototype.setStart = function(row, column) {
        this.start.row = row;
        this.start.column = column;
      };
      Range.prototype.setEnd = function(row, column) {
        this.end.row = row;
        this.end.column = column;
      };
      Range.prototype.inside = function(row, column) {
        if (this.compare(row, column) === 0) {
          if (this.isEnd(row, column) || this.isStart(row, column)) {
            return false;
          } else {
            return true;
          }
        }
        return false;
      };
      Range.prototype.insideStart = function(row, column) {
        if (this.compare(row, column) === 0) {
          if (this.isEnd(row, column)) {
            return false;
          } else {
            return true;
          }
        }
        return false;
      };
      Range.prototype.insideEnd = function(row, column) {
        if (this.compare(row, column) === 0) {
          if (this.isStart(row, column)) {
            return false;
          } else {
            return true;
          }
        }
        return false;
      };
      Range.prototype.compare = function(row, column) {
        if (!this.isMultiLine()) {
          if (row === this.start.row) {
            return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
          }
        }
        if (row < this.start.row)
          return -1;
        if (row > this.end.row)
          return 1;
        if (this.start.row === row)
          return column >= this.start.column ? 0 : -1;
        if (this.end.row === row)
          return column <= this.end.column ? 0 : 1;
        return 0;
      };
      Range.prototype.compareStart = function(row, column) {
        if (this.start.row === row && this.start.column === column) {
          return -1;
        } else {
          return this.compare(row, column);
        }
      };
      Range.prototype.compareEnd = function(row, column) {
        if (this.end.row === row && this.end.column === column) {
          return 1;
        } else {
          return this.compare(row, column);
        }
      };
      Range.prototype.compareInside = function(row, column) {
        if (this.end.row === row && this.end.column === column) {
          return 1;
        } else if (this.start.row === row && this.start.column === column) {
          return -1;
        } else {
          return this.compare(row, column);
        }
      };
      Range.prototype.clipRows = function(firstRow, lastRow) {
        if (typeof firstRow !== 'number') {
          throw new TypeError("clipRows() firstRow must be a number.");
        }
        if (typeof lastRow !== 'number') {
          throw new TypeError("clipRows() lastRow must be a number.");
        }
        var start;
        var end;
        if (this.end.row > lastRow)
          end = {
            row: lastRow + 1,
            column: 0
          };
        else if (this.end.row < firstRow)
          end = {
            row: firstRow,
            column: 0
          };
        if (this.start.row > lastRow)
          start = {
            row: lastRow + 1,
            column: 0
          };
        else if (this.start.row < firstRow)
          start = {
            row: firstRow,
            column: 0
          };
        return Range.fromPoints(start || this.start, end || this.end);
      };
      Range.prototype.extend = function(row, column) {
        var cmp = this.compare(row, column);
        if (cmp === 0) {
          return this;
        } else if (cmp === -1) {
          var start = {
            row: row,
            column: column
          };
        } else {
          var end = {
            row: row,
            column: column
          };
        }
        return Range.fromPoints(start || this.start, end || this.end);
      };
      Range.prototype.isEmpty = function() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
      };
      Range.prototype.isMultiLine = function() {
        return (this.start.row !== this.end.row);
      };
      Range.prototype.clone = function() {
        return Range.fromPoints(this.start, this.end);
      };
      Range.prototype.collapseRows = function() {
        if (this.end.column === 0) {
          return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
        } else {
          return new Range(this.start.row, 0, this.end.row, 0);
        }
      };
      Range.prototype.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
      };
      Range.fromPoints = function(start, end) {
        return new Range(start.row, start.column, end.row, end.column);
      };
      Range.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      return Range;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Range;
  });
  define('Document', ["require", "exports", './applyDelta', './lib/EventEmitterClass', './Range'], function(require, exports, applyDelta_1, EventEmitterClass_1, Range_1) {
    "use strict";
    var $split = (function() {
      function foo(text) {
        return text.replace(/\r\n|\r/g, "\n").split("\n");
      }
      function bar(text) {
        return text.split(/\r\n|\r|\n/);
      }
      if ("aaa".split(/a/).length === 0) {
        return foo;
      } else {
        return bar;
      }
    })();
    var CHANGE = 'change';
    var CHANGE_NEW_LINE_MODE = 'changeNewLineMode';
    var Document = (function() {
      function Document(textOrLines) {
        this._lines = [];
        this._autoNewLine = "";
        this._newLineMode = "auto";
        this._lines = [""];
        this._eventBus = new EventEmitterClass_1.default(this);
        if (textOrLines.length === 0) {
          this._lines = [""];
        } else if (Array.isArray(textOrLines)) {
          this.insertMergedLines({
            row: 0,
            column: 0
          }, textOrLines);
        } else {
          this.insert({
            row: 0,
            column: 0
          }, textOrLines);
        }
      }
      Document.prototype.setValue = function(text) {
        var row = this.getLength() - 1;
        this.remove(new Range_1.default(0, 0, row, this.getLine(row).length));
        this.insert({
          row: 0,
          column: 0
        }, text);
      };
      Document.prototype.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
      };
      Document.prototype.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this._autoNewLine = match ? match[1] : "\n";
        this._eventBus._signal(CHANGE_NEW_LINE_MODE);
      };
      Document.prototype.getNewLineCharacter = function() {
        switch (this._newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this._autoNewLine || "\n";
        }
      };
      Document.prototype.setNewLineMode = function(newLineMode) {
        if (this._newLineMode === newLineMode) {
          return;
        }
        this._newLineMode = newLineMode;
        this._eventBus._signal(CHANGE_NEW_LINE_MODE);
      };
      Document.prototype.getNewLineMode = function() {
        return this._newLineMode;
      };
      Document.prototype.isNewLine = function(text) {
        return (text === "\r\n" || text === "\r" || text === "\n");
      };
      Document.prototype.getLine = function(row) {
        return this._lines[row] || "";
      };
      Document.prototype.getLines = function(firstRow, lastRow) {
        return this._lines.slice(firstRow, lastRow + 1);
      };
      Document.prototype.getAllLines = function() {
        return this.getLines(0, this.getLength());
      };
      Document.prototype.getLength = function() {
        return this._lines.length;
      };
      Document.prototype.getTextRange = function(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
      };
      Document.prototype.getLinesForRange = function(range) {
        var lines;
        if (range.start.row === range.end.row) {
          lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
          lines = this.getLines(range.start.row, range.end.row);
          lines[0] = (lines[0] || "").substring(range.start.column);
          var l = lines.length - 1;
          if (range.end.row - range.start.row === l) {
            lines[l] = lines[l].substring(0, range.end.column);
          }
        }
        return lines;
      };
      Document.prototype.insert = function(position, text) {
        if (this.getLength() <= 1) {
          this.$detectNewLine(text);
        }
        return this.insertMergedLines(position, $split(text));
      };
      ;
      Document.prototype.insertInLine = function(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        this.applyDelta({
          start: start,
          end: end,
          action: "insert",
          lines: [text]
        }, true);
        return this.clonePos(end);
      };
      Document.prototype.clippedPos = function(row, column) {
        var length = this.getLength();
        if (row === void 0) {
          row = length;
        } else if (row < 0) {
          row = 0;
        } else if (row >= length) {
          row = length - 1;
          column = void 0;
        }
        var line = this.getLine(row);
        if (column === void 0)
          column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {
          row: row,
          column: column
        };
      };
      Document.prototype.clonePos = function(pos) {
        return {
          row: pos.row,
          column: pos.column
        };
      };
      Document.prototype.pos = function(row, column) {
        return {
          row: row,
          column: column
        };
      };
      Document.prototype.addChangeListener = function(callback) {
        this._eventBus.on(CHANGE, callback, false);
      };
      Document.prototype.addChangeNewLineModeListener = function(callback) {
        this._eventBus.on(CHANGE_NEW_LINE_MODE, callback, false);
      };
      Document.prototype.removeChangeListener = function(callback) {
        this._eventBus.off(CHANGE, callback);
      };
      Document.prototype.removeChangeNewLineModeListener = function(callback) {
        this._eventBus.off(CHANGE_NEW_LINE_MODE, callback);
      };
      Document.prototype.insertFullLines = function(row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row < this.getLength()) {
          lines = lines.concat([""]);
          column = 0;
        } else {
          lines = [""].concat(lines);
          row--;
          column = this._lines[row].length;
        }
        return this.insertMergedLines({
          row: row,
          column: column
        }, lines);
      };
      Document.prototype.insertMergedLines = function(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
          row: start.row + lines.length - 1,
          column: (lines.length === 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        this.applyDelta({
          start: start,
          end: end,
          action: "insert",
          lines: lines
        });
        return this.clonePos(end);
      };
      Document.prototype.remove = function(range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
          start: start,
          end: end,
          action: "remove",
          lines: this.getLinesForRange({
            start: start,
            end: end
          })
        });
        return this.clonePos(start);
      };
      Document.prototype.removeInLine = function(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        this.applyDelta({
          start: start,
          end: end,
          action: "remove",
          lines: this.getLinesForRange({
            start: start,
            end: end
          })
        }, true);
        return this.clonePos(start);
      };
      Document.prototype.removeFullLines = function(firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
        var deleteFirstNewLine = lastRow === this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine = lastRow < this.getLength() - 1;
        var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);
        var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);
        var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);
        var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);
        var range = new Range_1.default(startRow, startCol, endRow, endCol);
        var deletedLines = this._lines.slice(firstRow, lastRow + 1);
        this.applyDelta({
          start: range.start,
          end: range.end,
          action: "remove",
          lines: this.getLinesForRange(range)
        });
        return deletedLines;
      };
      ;
      Document.prototype.removeNewLine = function(row) {
        if (row < this.getLength() - 1 && row >= 0) {
          this.applyDelta({
            start: this.pos(row, this.getLine(row).length),
            end: this.pos(row + 1, 0),
            action: "remove",
            lines: ["", ""]
          });
        }
      };
      Document.prototype.replace = function(range, text) {
        if (text.length === 0 && range.isEmpty()) {
          return range.start;
        }
        if (text === this.getTextRange(range)) {
          return range.end;
        }
        this.remove(range);
        if (text) {
          var end = this.insert(range.start, text);
        } else {
          end = range.start;
        }
        return end;
      };
      Document.prototype.applyDeltas = function(deltas) {
        for (var i = 0; i < deltas.length; i++) {
          this.applyDelta(deltas[i]);
        }
      };
      Document.prototype.revertDeltas = function(deltas) {
        for (var i = deltas.length - 1; i >= 0; i--) {
          this.revertDelta(deltas[i]);
        }
      };
      Document.prototype.applyDelta = function(delta, doNotValidate) {
        var isInsert = delta.action === "insert";
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range_1.default.comparePoints(delta.start, delta.end)) {
          return;
        }
        if (isInsert && delta.lines.length > 20000)
          this.$splitAndapplyLargeDelta(delta, 20000);
        applyDelta_1.default(this._lines, delta, doNotValidate);
        this._eventBus._signal(CHANGE, delta);
      };
      Document.prototype.$splitAndapplyLargeDelta = function(delta, MAX) {
        var lines = delta.lines;
        var l = lines.length;
        var row = delta.start.row;
        var column = delta.start.column;
        var from = 0,
            to = 0;
        do {
          from = to;
          to += MAX - 1;
          var chunk = lines.slice(from, to);
          if (to > l) {
            delta.lines = chunk;
            delta.start.row = row + from;
            delta.start.column = column;
            break;
          }
          chunk.push("");
          this.applyDelta({
            start: this.pos(row + from, column),
            end: this.pos(row + to, column = 0),
            action: delta.action,
            lines: chunk
          }, true);
        } while (true);
      };
      Document.prototype.revertDelta = function(delta) {
        this.applyDelta({
          start: this.clonePos(delta.start),
          end: this.clonePos(delta.end),
          action: (delta.action === "insert" ? "remove" : "insert"),
          lines: delta.lines.slice()
        });
      };
      ;
      Document.prototype.indexToPosition = function(index, startRow) {
        var lines = this._lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0,
            l = lines.length; i < l; i++) {
          index -= lines[i].length + newlineLength;
          if (index < 0)
            return {
              row: i,
              column: index + lines[i].length + newlineLength
            };
        }
        return {
          row: l - 1,
          column: lines[l - 1].length
        };
      };
      Document.prototype.positionToIndex = function(pos, startRow) {
        var lines = this._lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
          index += lines[i].length + newlineLength;
        return index + pos.column;
      };
      return Document;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Document;
  });
  define('createDocument', ["require", "exports", './Document'], function(require, exports, Document_1) {
    "use strict";
    function createDocument(textOrLines) {
      return new Document_1.default(textOrLines);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createDocument;
  });
  define('lib/oop', ["require", "exports"], function(require, exports) {
    "use strict";
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }});
    }
    exports.inherits = inherits;
    function mixin(obj, base) {
      for (var key in base) {
        obj[key] = base[key];
      }
      return obj;
    }
    exports.mixin = mixin;
    function implement(proto, base) {
      mixin(proto, base);
    }
    exports.implement = implement;
  });
  define('lib/dom', ["require", "exports"], function(require, exports) {
    "use strict";
    var XHTML_NS = "http://www.w3.org/1999/xhtml";
    function getDocumentBody(doc) {
      if (doc === void 0) {
        doc = document;
      }
      return (doc.body || doc.getElementsByTagName("body")[0]);
    }
    exports.getDocumentBody = getDocumentBody;
    function createHTMLDivElement(namespaceURI) {
      return document.createElementNS ? document.createElementNS(namespaceURI || XHTML_NS, 'div') : document.createElement('div');
    }
    exports.createHTMLDivElement = createHTMLDivElement;
    function createElement(tagName, namespaceURI) {
      return document.createElementNS ? document.createElementNS(namespaceURI || XHTML_NS, tagName) : document.createElement(tagName);
    }
    exports.createElement = createElement;
    function hasCssClass(element, name) {
      var classes = element.className.split(/\s+/g);
      return classes.indexOf(name) !== -1;
    }
    exports.hasCssClass = hasCssClass;
    function addCssClass(element, name) {
      if (!hasCssClass(element, name)) {
        element.className += " " + name;
      }
    }
    exports.addCssClass = addCssClass;
    function removeCssClass(element, name) {
      var classes = element.className.split(/\s+/g);
      while (true) {
        var index = classes.indexOf(name);
        if (index === -1) {
          break;
        }
        classes.splice(index, 1);
      }
      element.className = classes.join(" ");
    }
    exports.removeCssClass = removeCssClass;
    function toggleCssClass(element, name) {
      var classes = element.className.split(/\s+/g);
      var add = true;
      while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
          break;
        }
        add = false;
        classes.splice(index, 1);
      }
      if (add)
        classes.push(name);
      element.className = classes.join(" ");
      return add;
    }
    exports.toggleCssClass = toggleCssClass;
    function setCssClass(node, className, include) {
      if (include) {
        addCssClass(node, className);
      } else {
        removeCssClass(node, className);
      }
    }
    exports.setCssClass = setCssClass;
    function makeComputedStyle() {
      if (window.getComputedStyle) {
        return function(element, style) {
          return (window.getComputedStyle(element, "") || {})[style] || "";
        };
      } else {
        return function(element, style) {
          if (style) {
            return element['currentStyle'][style];
          }
          return element['currentStyle'];
        };
      }
    }
    exports.computedStyle = makeComputedStyle();
    function scrollbarWidth(document) {
      var inner = createElement("ace_inner");
      inner.style.width = "100%";
      inner.style.minWidth = "0px";
      inner.style.height = "200px";
      inner.style.display = "block";
      var outer = createElement("ace_outer");
      var style = outer.style;
      style.position = "absolute";
      style.left = "-10000px";
      style.overflow = "hidden";
      style.width = "200px";
      style.minWidth = "0px";
      style.height = "150px";
      style.display = "block";
      outer.appendChild(inner);
      var body = document.documentElement;
      body.appendChild(outer);
      var noScrollbar = inner.offsetWidth;
      style.overflow = "scroll";
      var withScrollbar = inner.offsetWidth;
      if (noScrollbar === withScrollbar) {
        withScrollbar = outer.clientWidth;
      }
      body.removeChild(outer);
      return noScrollbar - withScrollbar;
    }
    exports.scrollbarWidth = scrollbarWidth;
    function setInnerHtml(element, innerHTML) {
      var clonedElement = element.cloneNode(false);
      clonedElement.innerHTML = innerHTML;
      element.parentNode.replaceChild(clonedElement, element);
      return clonedElement;
    }
    exports.setInnerHtml = setInnerHtml;
    function makeGetInnerText() {
      if ("textContent" in document.documentElement) {
        return function(el) {
          return el.textContent;
        };
      } else {
        return function(el) {
          return el.innerText;
        };
      }
    }
    function makeSetInnerText() {
      if ("textContent" in document.documentElement) {
        return function(el, innerText) {
          el.textContent = innerText;
        };
      } else {
        return function(el, innerText) {
          el.innerText = innerText;
        };
      }
    }
    exports.getInnerText = makeGetInnerText();
    exports.setInnerText = makeSetInnerText();
    function getParentWindow(document) {
      return document.defaultView;
    }
    exports.getParentWindow = getParentWindow;
  });
  define('lib/lang/createDelayedCall', ["require", "exports"], function(require, exports) {
    "use strict";
    function createDelayedCall(fcn, defaultTimeout) {
      var timer = null;
      var callback = function() {
        timer = null;
        fcn();
      };
      var _self = function(timeout) {
        if (timer == null) {
          timer = window.setTimeout(callback, timeout || defaultTimeout);
        }
      };
      _self.delay = function(timeout) {
        if (timer) {
          window.clearTimeout(timer);
        }
        timer = window.setTimeout(callback, timeout || defaultTimeout);
      };
      _self.schedule = _self;
      _self.call = function() {
        this.cancel();
        fcn();
      };
      _self.cancel = function() {
        if (timer) {
          window.clearTimeout(timer);
        }
        timer = null;
      };
      _self.isPending = function() {
        return !!timer;
      };
      return _self;
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createDelayedCall;
  });
  define('lib/lang', ["require", "exports"], function(require, exports) {
    "use strict";
    function last(a) {
      return a[a.length - 1];
    }
    exports.last = last;
    function stringReverse(s) {
      return s.split("").reverse().join("");
    }
    exports.stringReverse = stringReverse;
    function stringRepeat(s, count) {
      var result = '';
      while (count > 0) {
        if (count & 1) {
          result += s;
        }
        if (count >>= 1) {
          s += s;
        }
      }
      return result;
    }
    exports.stringRepeat = stringRepeat;
    var trimBeginRegexp = /^\s\s*/;
    var trimEndRegexp = /\s\s*$/;
    function stringTrimLeft(s) {
      return s.replace(trimBeginRegexp, '');
    }
    exports.stringTrimLeft = stringTrimLeft;
    ;
    function stringTrimRight(s) {
      return s.replace(trimEndRegexp, '');
    }
    exports.stringTrimRight = stringTrimRight;
    function copyObject(obj) {
      var copy = {};
      for (var key in obj) {
        copy[key] = obj[key];
      }
      return copy;
    }
    exports.copyObject = copyObject;
    function copyArray(array) {
      var copy = [];
      for (var i = 0,
          l = array.length; i < l; i++) {
        if (array[i] && typeof array[i] == "object")
          copy[i] = this.copyObject(array[i]);
        else
          copy[i] = array[i];
      }
      return copy;
    }
    exports.copyArray = copyArray;
    function deepCopy(obj) {
      if (typeof obj !== "object" || !obj)
        return obj;
      var cons = obj.constructor;
      if (cons === RegExp)
        return obj;
      var copy = cons();
      for (var key in obj) {
        if (typeof obj[key] === "object") {
          copy[key] = deepCopy(obj[key]);
        } else {
          copy[key] = obj[key];
        }
      }
      return copy;
    }
    exports.deepCopy = deepCopy;
    function arrayToMap(xs, value) {
      var map = {};
      for (var i = 0,
          iLength = xs.length; i < iLength; i++) {
        map[xs[i]] = value;
      }
      return map;
    }
    exports.arrayToMap = arrayToMap;
    function createMap(props) {
      var map = Object.create(null);
      for (var i in props) {
        map[i] = props[i];
      }
      return map;
    }
    exports.createMap = createMap;
    function arrayRemove(array, value) {
      for (var i = 0; i <= array.length; i++) {
        if (value === array[i]) {
          array.splice(i, 1);
        }
      }
    }
    exports.arrayRemove = arrayRemove;
    function escapeRegExp(str) {
      return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
    }
    exports.escapeRegExp = escapeRegExp;
    function getMatchOffsets(s, searchValue) {
      var matches = [];
      s.replace(searchValue, function(str) {
        matches.push({
          offset: arguments[arguments.length - 2],
          length: str.length
        });
        return "lang.getMatchOffsets";
      });
      return matches;
    }
    exports.getMatchOffsets = getMatchOffsets;
    ;
    function deferredCall(fcn) {
      var timer = null;
      var callback = function() {
        timer = null;
        fcn();
      };
      var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
      };
      deferred.schedule = deferred;
      deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
      };
      deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
      };
      deferred.isPending = function() {
        return timer;
      };
      return deferred;
    }
    exports.deferredCall = deferredCall;
    ;
  });
  define('lib/useragent', ["require", "exports"], function(require, exports) {
    "use strict";
    exports.OS = {
      LINUX: "LINUX",
      MAC: "MAC",
      WINDOWS: "WINDOWS"
    };
    function getOS() {
      if (exports.isMac) {
        return exports.OS.MAC;
      } else if (exports.isLinux) {
        return exports.OS.LINUX;
      } else {
        return exports.OS.WINDOWS;
      }
    }
    exports.getOS = getOS;
    var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
    var ua = navigator.userAgent;
    exports.isWin = (os == "win");
    exports.isMac = (os == "mac");
    exports.isLinux = (os == "linux");
    exports.isIE = (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0) ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
    exports.isOldIE = exports.isIE && exports.isIE < 9;
    exports.isGecko = (('Controllers' in window) || ('controllers' in window)) && window.navigator.product === "Gecko";
    exports.isMozilla = exports.isGecko;
    exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv\:(\d+)/) || [])[1], 10) < 4;
    exports.isOpera = ('opera' in window) && Object.prototype.toString.call(window['opera']) == "[object Opera]";
    exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
    exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;
    exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
    exports.isAIR = ua.indexOf("AdobeAIR") >= 0;
    exports.isAndroid = ua.indexOf("Android") >= 0;
    exports.isIPad = ua.indexOf("iPad") >= 0;
    exports.isTouchPad = ua.indexOf("TouchPad") >= 0;
    exports.isMobile = exports.isAndroid || exports.isIPad || exports.isTouchPad;
  });
  define('lib/keys', ["require", "exports", './oop'], function(require, exports, oop_1) {
    "use strict";
    var Keys = {
      MODIFIER_KEYS: {
        16: 'Shift',
        17: 'Ctrl',
        18: 'Alt',
        224: 'Meta'
      },
      KEY_MODS: {
        "ctrl": 1,
        "alt": 2,
        "option": 2,
        "shift": 4,
        "super": 8,
        "meta": 8,
        "command": 8,
        "cmd": 8
      },
      FUNCTION_KEYS: {
        8: "Backspace",
        9: "Tab",
        13: "Return",
        19: "Pause",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "Print",
        45: "Insert",
        46: "Delete",
        96: "Numpad0",
        97: "Numpad1",
        98: "Numpad2",
        99: "Numpad3",
        100: "Numpad4",
        101: "Numpad5",
        102: "Numpad6",
        103: "Numpad7",
        104: "Numpad8",
        105: "Numpad9",
        '-13': "NumpadEnter",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "Numlock",
        145: "Scrolllock"
      },
      PRINTABLE_KEYS: {
        32: ' ',
        48: '0',
        49: '1',
        50: '2',
        51: '3',
        52: '4',
        53: '5',
        54: '6',
        55: '7',
        56: '8',
        57: '9',
        59: ';',
        61: '=',
        65: 'a',
        66: 'b',
        67: 'c',
        68: 'd',
        69: 'e',
        70: 'f',
        71: 'g',
        72: 'h',
        73: 'i',
        74: 'j',
        75: 'k',
        76: 'l',
        77: 'm',
        78: 'n',
        79: 'o',
        80: 'p',
        81: 'q',
        82: 'r',
        83: 's',
        84: 't',
        85: 'u',
        86: 'v',
        87: 'w',
        88: 'x',
        89: 'y',
        90: 'z',
        107: '+',
        109: '-',
        110: '.',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\''
      },
      enter: 13,
      esc: 27,
      escape: 27,
      del: 46
    };
    var name,
        i;
    for (i in Keys.FUNCTION_KEYS) {
      name = Keys.FUNCTION_KEYS[i].toLowerCase();
      Keys[name] = parseInt(i, 10);
    }
    for (i in Keys.PRINTABLE_KEYS) {
      name = Keys.PRINTABLE_KEYS[i].toLowerCase();
      Keys[name] = parseInt(i, 10);
    }
    oop_1.mixin(Keys, Keys.MODIFIER_KEYS);
    oop_1.mixin(Keys, Keys.PRINTABLE_KEYS);
    oop_1.mixin(Keys, Keys.FUNCTION_KEYS);
    Keys[173] = '-';
    (function() {
      var mods = ["cmd", "ctrl", "alt", "shift"];
      for (var i = Math.pow(2, mods.length); i--; ) {
        var f = function(s) {
          return i & Keys.KEY_MODS[s];
        };
        var filtrate = mods.filter(f);
        Keys.KEY_MODS[i] = mods.filter(f).join("-") + "-";
      }
    })();
    exports.FUNCTION_KEYS = Keys.FUNCTION_KEYS;
    exports.PRINTABLE_KEYS = Keys.PRINTABLE_KEYS;
    exports.MODIFIER_KEYS = Keys.MODIFIER_KEYS;
    exports.KEY_MODS = Keys.KEY_MODS;
    exports.enter = Keys["return"];
    exports.escape = Keys.esc;
    exports.del = Keys["delete"];
    function keyCodeToString(keyCode) {
      var keyString = Keys[keyCode];
      if (typeof keyString !== "string") {
        keyString = String.fromCharCode(keyCode);
      }
      return keyString.toLowerCase();
    }
    exports.keyCodeToString = keyCodeToString;
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Keys;
  });
  define('keyboard/KeyboardHandler', ["require", "exports", "../lib/keys", "../lib/keys", "../lib/useragent"], function(require, exports, keys_1, keys_2, useragent_1) {
    "use strict";
    var KeyboardHandler = (function() {
      function KeyboardHandler(commands, platform) {
        this.platform = platform || (useragent_1.isMac ? "mac" : "win");
        this.commands = {};
        this.commandKeyBinding = {};
        if (commands) {
          this.addCommands(commands);
        }
      }
      KeyboardHandler.prototype.addCommand = function(command) {
        if (this.commands[command.name]) {
          this.removeCommand(command);
        }
        this.commands[command.name] = command;
        if (command.bindKey) {
          this._buildKeyHash(command);
        }
      };
      KeyboardHandler.prototype.removeCommand = function(command) {
        var name = (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        delete this.commands[name];
        var ckb = this.commandKeyBinding;
        for (var hashId in ckb) {
          if (ckb.hasOwnProperty(hashId)) {
            for (var key in ckb[hashId]) {
              if (ckb[hashId][key] === command) {
                delete ckb[hashId][key];
              }
            }
          }
        }
      };
      KeyboardHandler.prototype.bindKey = function(key, action) {
        if (!key) {
          throw new TypeError("key must be a string.");
        }
        this.addCommand({
          exec: action,
          bindKey: key,
          name: key
        });
      };
      KeyboardHandler.prototype.bindCommand = function(key, command) {
        var self = this;
        if (!key) {
          return;
        }
        var ckb = this.commandKeyBinding;
        key.split("|").forEach(function(keyPart) {
          var binding = self.parseKeys(keyPart);
          var hashId = binding.hashId;
          (ckb[hashId] || (ckb[hashId] = {}))[binding.key] = command;
        }, self);
      };
      KeyboardHandler.prototype.addCommands = function(commands) {
        for (var i = 0,
            iLength = commands.length; i < iLength; i++) {
          this.addCommand(commands[i]);
        }
      };
      KeyboardHandler.prototype.removeCommands = function(commands) {
        var _this = this;
        Object.keys(commands).forEach(function(name) {
          _this.removeCommand(commands[name]);
        });
      };
      KeyboardHandler.prototype.bindKeys = function(keyList) {
        var self = this;
        Object.keys(keyList).forEach(function(key) {
          self.bindKey(key, keyList[key]);
        }, self);
      };
      KeyboardHandler.prototype._buildKeyHash = function(command) {
        var binding = command.bindKey;
        if (!binding)
          return;
        var key = typeof binding === "string" ? binding : binding[this.platform];
        this.bindCommand(key, command);
      };
      KeyboardHandler.prototype.parseKeys = function(keys) {
        if (keys.indexOf(" ") !== -1)
          keys = keys.split(/\s+/).pop();
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
          return x;
        });
        var key = parts.pop();
        var keyCode = keys_2.default[key];
        if (keys_1.FUNCTION_KEYS[keyCode])
          key = keys_1.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
          return {
            key: key,
            hashId: -1
          };
        else if (parts.length === 1 && parts[0] === "shift")
          return {
            key: key.toUpperCase(),
            hashId: -1
          };
        var hashId = 0;
        for (var i = parts.length; i--; ) {
          var modifier = keys_1.KEY_MODS[parts[i]];
          if (modifier === null) {
            throw new Error("invalid modifier " + parts[i] + " in " + keys);
          }
          hashId |= modifier;
        }
        return {
          key: key,
          hashId: hashId
        };
      };
      KeyboardHandler.prototype.findKeyCommand = function(hashId, keyString) {
        var ckbr = this.commandKeyBinding;
        return ckbr[hashId] && ckbr[hashId][keyString];
      };
      KeyboardHandler.prototype.handleKeyboard = function(data, hashId, keyString, keyCode, e) {
        var response = {command: this.findKeyCommand(hashId, keyString)};
        return response;
      };
      KeyboardHandler.prototype.attach = function(editor) {};
      KeyboardHandler.prototype.detach = function(editor) {};
      return KeyboardHandler;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = KeyboardHandler;
  });
  define('lib/event', ["require", "exports", './keys', './useragent'], function(require, exports, keys_1, useragent_1) {
    "use strict";
    function addListener(target, type, callback, useCapture) {
      if (target.addEventListener) {
        return target.addEventListener(type, callback, false);
      }
    }
    exports.addListener = addListener;
    function removeListener(target, type, callback, useCapture) {
      if (target.removeEventListener) {
        return target.removeEventListener(type, callback, false);
      }
    }
    exports.removeListener = removeListener;
    function stopEvent(e) {
      stopPropagation(e);
      preventDefault(e);
      return false;
    }
    exports.stopEvent = stopEvent;
    function stopPropagation(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
    }
    exports.stopPropagation = stopPropagation;
    function preventDefault(e) {
      var RETURN_VALUE_DEPRECATED = 'returnValue';
      if (e.preventDefault) {
        e.preventDefault();
      } else if (e[RETURN_VALUE_DEPRECATED]) {
        e[RETURN_VALUE_DEPRECATED] = false;
      }
    }
    exports.preventDefault = preventDefault;
    function getButton(e) {
      if (e.type == "dblclick")
        return 0;
      if (e.type == "contextmenu" || (useragent_1.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
        return 2;
      if (e.preventDefault) {
        return e.button;
      } else {
        return {
          1: 0,
          2: 2,
          4: 1
        }[e.button];
      }
    }
    exports.getButton = getButton;
    function capture(unused, acquireCaptureHandler, releaseCaptureHandler) {
      var element = document;
      function releaseMouse(e) {
        acquireCaptureHandler && acquireCaptureHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);
        removeListener(element, "mousemove", acquireCaptureHandler, true);
        removeListener(element, "mouseup", releaseMouse, true);
        removeListener(element, "dragstart", releaseMouse, true);
      }
      addListener(element, "mousemove", acquireCaptureHandler, true);
      addListener(element, "mouseup", releaseMouse, true);
      addListener(element, "dragstart", releaseMouse, true);
      return releaseMouse;
    }
    exports.capture = capture;
    function addMouseWheelListener(element, callback) {
      if ("onmousewheel" in element) {
        addListener(element, "mousewheel", function(e) {
          var factor = 8;
          if (e['wheelDeltaX'] !== undefined) {
            e['wheelX'] = -e['wheelDeltaX'] / factor;
            e['wheelY'] = -e['wheelDeltaY'] / factor;
          } else {
            e['wheelX'] = 0;
            e['wheelY'] = -e.wheelDelta / factor;
          }
          callback(e);
        });
      } else if ("onwheel" in element) {
        addListener(element, "wheel", function(e) {
          var factor = 0.35;
          switch (e.deltaMode) {
            case e.DOM_DELTA_PIXEL:
              e.wheelX = e.deltaX * factor || 0;
              e.wheelY = e.deltaY * factor || 0;
              break;
            case e.DOM_DELTA_LINE:
            case e.DOM_DELTA_PAGE:
              e.wheelX = (e.deltaX || 0) * 5;
              e.wheelY = (e.deltaY || 0) * 5;
              break;
          }
          callback(e);
        });
      } else {
        addListener(element, "DOMMouseScroll", function(e) {
          if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
            e.wheelX = (e.detail || 0) * 5;
            e.wheelY = 0;
          } else {
            e.wheelX = 0;
            e.wheelY = (e.detail || 0) * 5;
          }
          callback(e);
        });
      }
    }
    exports.addMouseWheelListener = addMouseWheelListener;
    function addMultiMouseDownListener(el, timeouts, eventHandler, callbackName) {
      var clicks = 0;
      var startX,
          startY,
          timer;
      var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
      };
      addListener(el, "mousedown", function(e) {
        if (getButton(e) !== 0) {
          clicks = 0;
        } else if (e.detail > 1) {
          clicks++;
          if (clicks > 4)
            clicks = 1;
        } else {
          clicks = 1;
        }
        if (useragent_1.isIE) {
          var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
          if (!timer || isNewClick)
            clicks = 1;
          if (timer)
            clearTimeout(timer);
          timer = setTimeout(function() {
            timer = null;
          }, timeouts[clicks - 1] || 600);
          if (clicks == 1) {
            startX = e.clientX;
            startY = e.clientY;
          }
        }
        e['_clicks'] = clicks;
        eventHandler[callbackName]("mousedown", e);
        if (clicks > 4)
          clicks = 0;
        else if (clicks > 1)
          return eventHandler[callbackName](eventNames[clicks], e);
      });
      if (useragent_1.isOldIE) {
        addListener(el, "dblclick", function(e) {
          clicks = 2;
          if (timer)
            clearTimeout(timer);
          timer = setTimeout(function() {
            timer = null;
          }, timeouts[clicks - 1] || 600);
          eventHandler[callbackName]("mousedown", e);
          eventHandler[callbackName](eventNames[clicks], e);
        });
      }
    }
    exports.addMultiMouseDownListener = addMultiMouseDownListener;
    var getModifierHash = useragent_1.isMac && useragent_1.isOpera && !("KeyboardEvent" in window) ? function(e) {
      return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
    } : function(e) {
      return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    };
    function getModifierString(e) {
      return keys_1.KEY_MODS[getModifierHash(e)];
    }
    exports.getModifierString = getModifierString;
    function normalizeCommandKeys(callback, e, keyCode) {
      var hashId = getModifierHash(e);
      if (!useragent_1.isMac && pressedKeys) {
        if (pressedKeys[91] || pressedKeys[92])
          hashId |= 8;
        if (pressedKeys.altGr) {
          if ((3 & hashId) != 3)
            pressedKeys.altGr = 0;
          else
            return;
        }
        if (keyCode === 18 || keyCode === 17) {
          if (keyCode === 17 && e.location === 1) {
            ts = e.timeStamp;
          } else if (keyCode === 18 && hashId === 3 && e.location === 2) {
            var dt = -ts;
            ts = e.timeStamp;
            dt += ts;
            if (dt < 3)
              pressedKeys.altGr = true;
          }
        }
      }
      if (keyCode in keys_1.MODIFIER_KEYS) {
        switch (keys_1.MODIFIER_KEYS[keyCode]) {
          case "Alt":
            hashId = 2;
            break;
          case "Shift":
            hashId = 4;
            break;
          case "Ctrl":
            hashId = 1;
            break;
          default:
            hashId = 8;
            break;
        }
        keyCode = -1;
      }
      if (hashId & 8 && (keyCode === 91 || keyCode === 93)) {
        keyCode = -1;
      }
      if (!hashId && keyCode === 13) {
        if (e.location === 3) {
          callback(e, hashId, -keyCode);
          if (e.defaultPrevented)
            return;
        }
      }
      if (useragent_1.isChromeOS && hashId & 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
          return;
        else
          hashId &= ~8;
      }
      if (!hashId && !(keyCode in keys_1.FUNCTION_KEYS) && !(keyCode in keys_1.PRINTABLE_KEYS)) {
        return false;
      }
      return callback(e, hashId, keyCode);
    }
    var pressedKeys = null;
    function resetPressedKeys(e) {
      pressedKeys = Object.create(null);
    }
    var ts = 0;
    function addCommandKeyListener(el, callback) {
      if (useragent_1.isOldGecko || (useragent_1.isOpera && !("KeyboardEvent" in window))) {
        var lastKeyDownKeyCode = null;
        addListener(el, "keydown", function(e) {
          lastKeyDownKeyCode = e.keyCode;
        });
        addListener(el, "keypress", function(e) {
          return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
        });
      } else {
        var lastDefaultPrevented = null;
        addListener(el, "keydown", function(e) {
          pressedKeys[e.keyCode] = true;
          var result = normalizeCommandKeys(callback, e, e.keyCode);
          lastDefaultPrevented = e.defaultPrevented;
          return result;
        });
        addListener(el, 'keypress', function(e) {
          if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
            stopEvent(e);
            lastDefaultPrevented = null;
          }
        });
        addListener(el, 'keyup', function(e) {
          pressedKeys[e.keyCode] = null;
        });
        if (!pressedKeys) {
          pressedKeys = Object.create(null);
          addListener(window, 'focus', resetPressedKeys);
        }
      }
    }
    exports.addCommandKeyListener = addCommandKeyListener;
    var nextFrameCandidate = window.requestAnimationFrame || window['mozRequestAnimationFrame'] || window['webkitRequestAnimationFrame'] || window.msRequestAnimationFrame || window['oRequestAnimationFrame'];
    if (nextFrameCandidate) {
      nextFrameCandidate = nextFrameCandidate.bind(window);
    } else {
      nextFrameCandidate = function(callback) {
        setTimeout(callback, 17);
      };
    }
    exports.requestAnimationFrame = nextFrameCandidate;
  });
  define('editor_protocol', ["require", "exports"], function(require, exports) {
    "use strict";
    exports.COMMAND_NAME_AUTO_COMPLETE = "autoComplete";
    exports.COMMAND_NAME_INSERT_STRING = "insertstring";
    exports.COMMAND_NAME_BACKSPACE = "backspace";
    exports.COMMAND_NAME_DEL = "del";
  });
  define('keyboard/KeyBinding', ["require", "exports", "../lib/keys", "../lib/event", "../editor_protocol"], function(require, exports, keys_1, event_1, editor_protocol_1) {
    "use strict";
    var KeyBinding = (function() {
      function KeyBinding(editor) {
        this.editor = editor;
        this.$data = {editor: editor};
        this.$handlers = [];
        this.setDefaultHandler(editor.commands.hashHandler);
      }
      KeyBinding.prototype.setDefaultHandler = function(kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
      };
      KeyBinding.prototype.setKeyboardHandler = function(kb) {
        var h = this.$handlers;
        if (h[h.length - 1] === kb)
          return;
        while (h[h.length - 1] && h[h.length - 1] !== this.$defaultHandler)
          this.removeKeyboardHandler(h[h.length - 1]);
        this.addKeyboardHandler(kb, 1);
      };
      KeyBinding.prototype.addKeyboardHandler = function(kb, pos) {
        if (!kb) {
          return;
        }
        var i = this.$handlers.indexOf(kb);
        if (i !== -1) {
          this.$handlers.splice(i, 1);
        }
        if (pos === void 0) {
          this.$handlers.push(kb);
        } else {
          this.$handlers.splice(pos, 0, kb);
        }
        if (i === -1 && kb.attach) {
          kb.attach(this.editor);
        }
      };
      KeyBinding.prototype.removeKeyboardHandler = function(kb) {
        var i = this.$handlers.indexOf(kb);
        if (i === -1) {
          return false;
        }
        this.$handlers.splice(i, 1);
        if (kb.detach) {
          kb.detach(this.editor);
        }
        return true;
      };
      KeyBinding.prototype.getKeyboardHandler = function() {
        return this.$handlers[this.$handlers.length - 1];
      };
      KeyBinding.prototype.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.editor.commands;
        for (var i = this.$handlers.length; i--; ) {
          toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
          if (!toExecute || !toExecute.command)
            continue;
          if (toExecute.command === null) {
            success = true;
          } else {
            success = commands.exec(toExecute.command, this.editor, toExecute.args);
          }
          if (success && e && hashId !== -1 && toExecute.passEvent !== true && toExecute.command.passEvent !== true) {
            event_1.stopEvent(e);
          }
          if (success)
            break;
        }
        return success;
      };
      KeyBinding.prototype.onCommandKey = function(e, hashId, keyCode) {
        var keyString = keys_1.keyCodeToString(keyCode);
        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
      };
      KeyBinding.prototype.onTextInput = function(text) {
        var success = this.$callKeyboardHandlers(-1, text);
        if (!success) {
          var command = this.editor.commands.getCommandByName(editor_protocol_1.COMMAND_NAME_INSERT_STRING);
          this.editor.commands.exec(command, this.editor, text);
        }
      };
      return KeyBinding;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = KeyBinding;
  });
  define('keyboard/TextInput', ["require", "exports", "../lib/event", "../lib/useragent", "../lib/dom", "../lib/lang/createDelayedCall", '../editor_protocol', '../editor_protocol'], function(require, exports, event_1, useragent_1, dom_1, createDelayedCall_1, editor_protocol_1, editor_protocol_2) {
    "use strict";
    var BROKEN_SETDATA = useragent_1.isChrome < 18;
    var USE_IE_MIME_TYPE = useragent_1.isIE;
    var PLACEHOLDER = "\x01\x01";
    var TextInput = (function() {
      function TextInput(container, editor) {
        var _this = this;
        this.editor = editor;
        this.tempStyle = '';
        this.afterContextMenu = false;
        this.inComposition = false;
        this.text = dom_1.createElement("textarea");
        this.text.className = "ace_text-input";
        if (useragent_1.isTouchPad) {
          this.text.setAttribute("x-palm-disable-auto-cap", 'true');
        }
        this.text.wrap = "off";
        this.text['autocorrect'] = "off";
        this.text['autocapitalize'] = "off";
        this.text.spellcheck = false;
        this.text.style.opacity = "0";
        container.insertBefore(this.text, container.firstChild);
        var copied = false;
        this.pasted = false;
        var isSelectionEmpty = true;
        try {
          this._isFocused = document.activeElement === this.text;
        } catch (e) {}
        event_1.addListener(this.text, "blur", function() {
          editor.onBlur();
          _this._isFocused = false;
        });
        event_1.addListener(this.text, "focus", function() {
          _this._isFocused = true;
          editor.onFocus();
          _this.resetSelection();
        });
        var syncSelection = createDelayedCall_1.default(function() {
          _this._isFocused && _this.resetSelection(isSelectionEmpty);
        });
        this.syncValue = createDelayedCall_1.default(function() {
          if (!_this.inComposition) {
            _this.text.value = PLACEHOLDER;
            _this._isFocused && _this.resetSelection();
          }
        });
        useragent_1.isWebKit || editor.on('changeSelection', function(event, editor) {
          if (editor.selection.isEmpty() !== isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
          }
        });
        this.resetValue();
        if (this._isFocused) {
          editor.onFocus();
        }
        var isAllSelected = function(text) {
          return text.selectionStart === 0 && text.selectionEnd === text.value.length;
        };
        if (!this.text.setSelectionRange && this.text.createTextRange) {
          this.text.setSelectionRange = function(selectionStart, selectionEnd) {
            var range = this.createTextRange();
            range.collapse(true);
            range.moveStart('character', selectionStart);
            range.moveEnd('character', selectionEnd);
            range.select();
          };
          isAllSelected = function(text) {
            try {
              var range = text.ownerDocument['selection'].createRange();
            } catch (e) {}
            if (!range || range.parentElement() !== text)
              return false;
            return range.text === text.value;
          };
        }
        if (useragent_1.isOldIE) {
          var inPropertyChange = false;
          var onPropertyChange = function(e) {
            if (inPropertyChange)
              return;
            var data = _this.text.value;
            if (_this.inComposition || !data || data === PLACEHOLDER)
              return;
            if (e && data === PLACEHOLDER[0])
              return syncProperty.schedule();
            _this.sendText(data);
            inPropertyChange = true;
            _this.resetValue();
            inPropertyChange = false;
          };
          var syncProperty = createDelayedCall_1.default(onPropertyChange);
          event_1.addListener(this.text, "propertychange", onPropertyChange);
          var keytable = {
            13: 1,
            27: 1
          };
          event_1.addListener(this.text, "keyup", function(e) {
            if (_this.inComposition && (!_this.text.value || keytable[e.keyCode]))
              setTimeout(onCompositionEnd, 0);
            if ((_this.text.value.charCodeAt(0) || 0) < 129) {
              return syncProperty.call();
            }
            _this.inComposition ? onCompositionUpdate() : onCompositionStart();
          });
          event_1.addListener(this.text, "keydown", function(e) {
            syncProperty.schedule(50);
          });
        }
        var onSelect = function(e) {
          if (copied) {
            copied = false;
          } else if (isAllSelected(_this.text)) {
            editor.selectAll();
            _this.resetSelection();
          } else if (_this.inputHandler) {
            _this.resetSelection(editor.selection.isEmpty());
          }
        };
        var onInput = function(e) {
          if (_this.inComposition) {
            return;
          }
          var data = _this.text.value;
          _this.sendText(data);
          _this.resetValue();
        };
        var handleClipboardData = function(e, data) {
          var clipboardData = e.clipboardData || window['clipboardData'];
          if (!clipboardData || BROKEN_SETDATA)
            return;
          var mime = USE_IE_MIME_TYPE ? "Text" : "text/plain";
          if (data) {
            return clipboardData.setData(mime, data) !== false;
          } else {
            return clipboardData.getData(mime);
          }
        };
        var doCopy = function(e, isCut) {
          var data = editor.getSelectedText();
          if (!data)
            return event_1.preventDefault(e);
          if (handleClipboardData(e, data)) {
            isCut ? editor.onCut() : editor.onCopy();
            event_1.preventDefault(e);
          } else {
            copied = true;
            _this.text.value = data;
            _this.text.select();
            setTimeout(function() {
              copied = false;
              _this.resetValue();
              _this.resetSelection();
              isCut ? editor.onCut() : editor.onCopy();
            });
          }
        };
        var onCut = function(e) {
          doCopy(e, true);
        };
        var onCopy = function(e) {
          doCopy(e, false);
        };
        var onPaste = function(e) {
          var data = handleClipboardData(e);
          if (typeof data === "string") {
            if (data)
              editor.onPaste(data);
            if (useragent_1.isIE)
              setTimeout(function() {
                _this.resetSelection();
              });
            event_1.preventDefault(e);
          } else {
            _this.text.value = "";
            _this.pasted = true;
          }
        };
        event_1.addCommandKeyListener(this.text, editor.onCommandKey.bind(editor));
        event_1.addListener(this.text, "select", onSelect);
        event_1.addListener(this.text, "input", onInput);
        event_1.addListener(this.text, "cut", onCut);
        event_1.addListener(this.text, "copy", onCopy);
        event_1.addListener(this.text, "paste", onPaste);
        if (!('oncut' in this.text) || !('oncopy' in this.text) || !('onpaste' in this.text)) {
          event_1.addListener(container, "keydown", function(e) {
            if ((useragent_1.isMac && !e.metaKey) || !e.ctrlKey)
              return;
            switch (e.keyCode) {
              case 67:
                onCopy(e);
                break;
              case 86:
                onPaste(e);
                break;
              case 88:
                onCut(e);
                break;
              default:
                {}
            }
          });
        }
        var onCompositionStart = function() {
          if (_this.inComposition || !editor.onCompositionStart || editor.$readOnly)
            return;
          _this.inComposition = {};
          editor.onCompositionStart();
          setTimeout(onCompositionUpdate, 0);
          editor.on("mousedown", onCompositionEnd);
          if (!editor.selection.isEmpty()) {
            editor.insert("", false);
            editor.getSession().markUndoGroup();
            editor.selection.clearSelection();
          }
          editor.getSession().markUndoGroup();
        };
        var onCompositionUpdate = function() {
          if (!_this.inComposition || !editor.onCompositionUpdate || editor.$readOnly)
            return;
          var val = _this.text.value.replace(/\x01/g, "");
          if (_this.inComposition.lastValue === val)
            return;
          editor.onCompositionUpdate(val);
          if (_this.inComposition.lastValue)
            editor.undo();
          _this.inComposition.lastValue = val;
          if (_this.inComposition.lastValue) {
            var r = editor.selection.getRange();
            editor.insert(_this.inComposition.lastValue, false);
            editor.getSession().markUndoGroup();
            _this.inComposition.range = editor.selection.getRange();
            editor.selection.setRange(r);
            editor.selection.clearSelection();
          }
        };
        var onCompositionEnd = function(e, editor) {
          if (!editor.onCompositionEnd || editor.$readOnly)
            return;
          var c = _this.inComposition;
          _this.inComposition = false;
          var timer = setTimeout(function() {
            timer = null;
            var str = _this.text.value.replace(/\x01/g, "");
            if (_this.inComposition)
              return;
            else if (str === c.lastValue)
              _this.resetValue();
            else if (!c.lastValue && str) {
              _this.resetValue();
              _this.sendText(str);
            }
          });
          _this.inputHandler = function compositionInputHandler(str) {
            if (timer)
              clearTimeout(timer);
            str = str.replace(/\x01/g, "");
            if (str === c.lastValue)
              return "";
            if (c.lastValue && timer)
              editor.undo();
            return str;
          };
          editor.onCompositionEnd();
          editor.off("mousedown", onCompositionEnd);
          if (e.type === "compositionend" && c.range) {
            editor.selection.setRange(c.range);
          }
        };
        var syncComposition = createDelayedCall_1.default(onCompositionUpdate, 50);
        event_1.addListener(this.text, "compositionstart", onCompositionStart);
        if (useragent_1.isGecko) {
          event_1.addListener(this.text, "text", function() {
            syncComposition.schedule();
          });
        } else {
          event_1.addListener(this.text, "keyup", function() {
            syncComposition.schedule();
          });
          event_1.addListener(this.text, "keydown", function() {
            syncComposition.schedule();
          });
        }
        event_1.addListener(this.text, "compositionend", onCompositionEnd);
        var onContextMenu = function(e) {
          editor.textInput.onContextMenu(e);
          _this.onContextMenuClose();
        };
        event_1.addListener(editor.renderer.scroller, "contextmenu", onContextMenu);
        event_1.addListener(this.text, "contextmenu", onContextMenu);
      }
      TextInput.prototype.getElement = function() {
        return this.text;
      };
      TextInput.prototype.isFocused = function() {
        return this._isFocused;
      };
      TextInput.prototype.moveToMouse = function(e, bringToFront) {
        var _this = this;
        if (!this.tempStyle) {
          this.tempStyle = this.text.style.cssText;
        }
        this.text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + this.text.style.height + ";" + (useragent_1.isIE ? "opacity:0.1;" : "");
        var rect = this.editor.container.getBoundingClientRect();
        var style = window.getComputedStyle(this.editor.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(style.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - this.text.clientHeight - 2;
        var move = function(e) {
          _this.text.style.left = e.clientX - left - 2 + "px";
          _this.text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
        };
        move(e);
        if (e.type !== "mousedown")
          return;
        if (this.editor.renderer.$keepTextAreaAtCursor) {
          this.editor.renderer.$keepTextAreaAtCursor = null;
        }
        if (useragent_1.isWin) {
          event_1.capture(this.editor.container, move, function() {
            _this.onContextMenuClose();
          });
        }
      };
      TextInput.prototype.setReadOnly = function(readOnly) {
        this.text.readOnly = readOnly;
      };
      TextInput.prototype.focus = function() {
        return this.text.focus();
      };
      TextInput.prototype.blur = function() {
        return this.text.blur();
      };
      TextInput.prototype.onContextMenuClose = function() {
        var _this = this;
        setTimeout(function() {
          if (_this.tempStyle) {
            _this.text.style.cssText = _this.tempStyle;
            _this.tempStyle = '';
          }
          if (_this.editor.renderer.$keepTextAreaAtCursor == null) {
            _this.editor.renderer.$keepTextAreaAtCursor = true;
            _this.editor.renderer.$moveTextAreaToCursor();
          }
        }, 0);
      };
      TextInput.prototype.onContextMenu = function(e) {
        this.afterContextMenu = true;
        this.resetSelection(this.editor.selection.isEmpty());
        this.editor._emit("nativecontextmenu", {
          target: this.editor,
          domEvent: e
        });
        this.moveToMouse(e, true);
      };
      TextInput.prototype.sendText = function(data) {
        if (this.inputHandler) {
          data = this.inputHandler(data);
          this.inputHandler = null;
        }
        if (this.pasted) {
          this.resetSelection();
          if (data) {
            this.editor.onPaste(data);
          }
          this.pasted = false;
        } else if (data === PLACEHOLDER.charAt(0)) {
          if (this.afterContextMenu) {
            var delCommand = this.editor.commands.getCommandByName(editor_protocol_2.COMMAND_NAME_DEL);
            this.editor.execCommand(delCommand, {source: "ace"});
          } else {
            var backCommand = this.editor.commands.getCommandByName(editor_protocol_1.COMMAND_NAME_BACKSPACE);
            this.editor.execCommand(backCommand, {source: "ace"});
          }
        } else {
          if (data.substring(0, 2) === PLACEHOLDER)
            data = data.substr(2);
          else if (data.charAt(0) === PLACEHOLDER.charAt(0))
            data = data.substr(1);
          else if (data.charAt(data.length - 1) === PLACEHOLDER.charAt(0))
            data = data.slice(0, -1);
          if (data.charAt(data.length - 1) === PLACEHOLDER.charAt(0))
            data = data.slice(0, -1);
          if (data) {
            this.editor.onTextInput(data);
          }
        }
        if (this.afterContextMenu) {
          this.afterContextMenu = false;
        }
      };
      TextInput.prototype.resetSelection = function(isEmpty) {
        if (this.inComposition) {
          return;
        }
        if (this.inputHandler) {
          this.selectionStart = 0;
          this.selectionEnd = isEmpty ? 0 : this.text.value.length - 1;
        } else {
          this.selectionStart = isEmpty ? 2 : 1;
          this.selectionEnd = 2;
        }
        try {
          this.text.setSelectionRange(this.selectionStart, this.selectionEnd);
        } catch (e) {}
      };
      TextInput.prototype.setInputHandler = function(inputHandler) {
        this.inputHandler = inputHandler;
      };
      TextInput.prototype.getInputHandler = function() {
        return this.inputHandler;
      };
      TextInput.prototype.resetValue = function() {
        if (this.inComposition) {
          return;
        }
        this.text.value = PLACEHOLDER;
        if (useragent_1.isWebKit)
          this.syncValue.schedule();
      };
      return TextInput;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = TextInput;
  });
  define('Search', ["require", "exports", "./lib/lang", "./lib/oop", "./Range"], function(require, exports, lang_1, oop_1, Range_1) {
    "use strict";
    var Search = (function() {
      function Search() {
        this.$options = {};
      }
      Search.prototype.set = function(options) {
        oop_1.mixin(this.$options, options);
        return this;
      };
      Search.prototype.getOptions = function() {
        return lang_1.copyObject(this.$options);
      };
      Search.prototype.setOptions = function(options) {
        this.$options = options;
      };
      Search.prototype.find = function(session) {
        var iterator = this.$matchIterator(session, this.$options);
        if (!iterator) {
          return void 0;
        }
        var firstRange = null;
        iterator.forEach(function(range, row, offset) {
          if (!range.start) {
            var column = range.offset + (offset || 0);
            firstRange = new Range_1.default(row, column, row, column + range.length);
          } else {
            firstRange = range;
          }
          return true;
        });
        return firstRange;
      };
      Search.prototype.findAll = function(session) {
        var options = this.$options;
        if (!options.needle) {
          return [];
        }
        this.$assembleRegExp(options);
        var range = options.range;
        var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
        var ranges = [];
        if (options.$isMultiLine) {
          var re = options.re;
          var len = re.length;
          var maxRow = lines.length - len;
          var prevRange;
          outer: for (var row = re['offset'] || 0; row <= maxRow; row++) {
            for (var j = 0; j < len; j++)
              if (lines[row + j].search(re[j]) == -1)
                continue outer;
            var startLine = lines[row];
            var line = lines[row + len - 1];
            var startIndex = startLine.length - startLine.match(re[0])[0].length;
            var endIndex = line.match(re[len - 1])[0].length;
            if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
              continue;
            }
            ranges.push(prevRange = new Range_1.default(row, startIndex, row + len - 1, endIndex));
            if (len > 2)
              row = row + len - 2;
          }
        } else {
          var re = options.re;
          for (var i = 0; i < lines.length; i++) {
            var matches = lang_1.getMatchOffsets(lines[i], re);
            for (var j = 0; j < matches.length; j++) {
              var match = matches[j];
              ranges.push(new Range_1.default(i, match.offset, i, match.offset + match.length));
            }
          }
        }
        if (range) {
          var startColumn = range.start.column;
          var endColumn = range.start.column;
          var i = 0,
              j = ranges.length - 1;
          while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
            i++;
          while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
            j--;
          ranges = ranges.slice(i, j + 1);
          for (i = 0, j = ranges.length; i < j; i++) {
            ranges[i].start.row += range.start.row;
            ranges[i].end.row += range.start.row;
          }
        }
        return ranges;
      };
      Search.prototype.replace = function(input, replacement) {
        var options = this.$options;
        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine) {
          return replacement;
        }
        if (!re) {
          return;
        }
        var match = re.exec(input);
        if (!match || match[0].length !== input.length) {
          return null;
        }
        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
          var parts = replacement.split("");
          for (var i = Math.min(input.length, input.length); i--; ) {
            var ch = input[i];
            if (ch && ch.toLowerCase() != ch)
              parts[i] = parts[i].toUpperCase();
            else
              parts[i] = parts[i].toLowerCase();
          }
          replacement = parts.join("");
        }
        return replacement;
      };
      Search.prototype.$matchIterator = function(session, options) {
        var re = this.$assembleRegExp(options);
        if (!re) {
          return false;
        }
        var self = this,
            callback,
            backwards = options.backwards;
        if (options.$isMultiLine) {
          var len = re.length;
          var matchIterator = function(line, row, offset) {
            var startIndex = line.search(re[0]);
            if (startIndex == -1)
              return;
            for (var i = 1; i < len; i++) {
              line = session.getLine(row + i);
              if (line.search(re[i]) == -1)
                return;
            }
            var endIndex = line.match(re[len - 1])[0].length;
            var range = new Range_1.default(row, startIndex, row + len - 1, endIndex);
            if (re['offset'] == 1) {
              range.start.row--;
              range.start.column = Number.MAX_VALUE;
            } else if (offset)
              range.start.column += offset;
            if (callback(range))
              return true;
          };
        } else if (backwards) {
          var matchIterator = function(line, row, startIndex) {
            var matches = lang_1.getMatchOffsets(line, re);
            for (var i = matches.length - 1; i >= 0; i--)
              if (callback(matches[i], row, startIndex))
                return true;
          };
        } else {
          var matchIterator = function(line, row, startIndex) {
            var matches = lang_1.getMatchOffsets(line, re);
            for (var i = 0; i < matches.length; i++)
              if (callback(matches[i], row, startIndex))
                return true;
          };
        }
        return {forEach: function(_callback) {
            callback = _callback;
            self.$lineIterator(session, options).forEach(matchIterator);
          }};
      };
      Search.prototype.$assembleRegExp = function(options, $disableFakeMultiline) {
        if (!options.needle) {
          options.re = false;
        } else if (options.needle instanceof RegExp) {
          options.re = options.needle;
        } else if (typeof options.needle === 'string') {
          var needleString = options.needle;
          if (!options.regExp) {
            needleString = lang_1.escapeRegExp(needleString);
          }
          if (options.wholeWord) {
            needleString = "\\b" + needleString + "\\b";
          }
          var modifier = options.caseSensitive ? "g" : "gi";
          options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needleString);
          if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needleString, modifier);
          try {
            options.re = new RegExp(needleString, modifier);
          } catch (e) {
            options.re = false;
          }
        } else {
          throw new Error("typeof options.needle => " + typeof options.needle);
        }
        return options.re;
      };
      Search.prototype.$assembleMultilineRegExp = function(needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re = [];
        for (var i = 0; i < parts.length; i++) {
          try {
            re.push(new RegExp(parts[i], modifier));
          } catch (e) {
            return void 0;
          }
        }
        if (parts[0] === "") {
          re.shift();
          re['offset'] = 1;
        } else {
          re['offset'] = 0;
        }
        return re;
      };
      Search.prototype.$lineIterator = function(session, options) {
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;
        var range = options.range;
        var start = options.start;
        if (!start) {
          if (range) {
            start = backwards ? range.end : range.start;
          } else {
            var x = session.getSelection().getRange();
            start = (skipCurrent !== backwards) ? x.end : x.start;
          }
        }
        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;
        var forEach = backwards ? function(callback) {
          var row = start.row;
          var line = session.getLine(row).substring(0, start.column);
          if (callback(line, row))
            return;
          for (row--; row >= firstRow; row--)
            if (callback(session.getLine(row), row))
              return;
          if (options.wrap == false)
            return;
          for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
            if (callback(session.getLine(row), row))
              return;
        } : function(callback) {
          var row = start.row;
          var line = session.getLine(row).substr(start.column);
          if (callback(line, row, start.column))
            return;
          for (row = row + 1; row <= lastRow; row++)
            if (callback(session.getLine(row), row))
              return;
          if (options.wrap == false)
            return;
          for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
            if (callback(session.getLine(row), row))
              return;
        };
        return {forEach: forEach};
      };
      return Search;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Search;
  });
  define('lib/mix', ["require", "exports"], function(require, exports) {
    "use strict";
    function applyMixins(derivedCtor, baseCtors) {
      baseCtors.forEach(function(baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function(name) {
          derivedCtor.prototype[name] = baseCtor.prototype[name];
        });
      });
    }
    exports.applyMixins = applyMixins;
  });
  define('commands/CommandManager', ["require", "exports", "../lib/mix", "../keyboard/KeyboardHandler", "../lib/EventEmitterClass"], function(require, exports, mix_1, KeyboardHandler_1, EventEmitterClass_1) {
    "use strict";
    var CommandManager = (function() {
      function CommandManager(platform, commands) {
        this.eventBus = new EventEmitterClass_1.default(this);
        this.hashHandler = new KeyboardHandler_1.default(commands, platform);
        this.eventBus.setDefaultHandler("exec", function(e) {
          return e.command.exec(e.editor, e.args || {});
        });
      }
      CommandManager.prototype.setDefaultHandler = function(eventName, callback) {
        this.eventBus.setDefaultHandler(eventName, callback);
      };
      CommandManager.prototype.removeDefaultHandler = function(eventName, callback) {
        this.eventBus.removeDefaultHandler(eventName, callback);
      };
      Object.defineProperty(CommandManager.prototype, "platform", {
        get: function() {
          return this.hashHandler.platform;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(CommandManager.prototype, "commands", {
        get: function() {
          return this.hashHandler.commands;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(CommandManager.prototype, "commandKeyBinding", {
        get: function() {
          return this.hashHandler.commandKeyBinding;
        },
        enumerable: true,
        configurable: true
      });
      CommandManager.prototype.bindKey = function(key, command) {
        return this.hashHandler.bindKey(key, command);
      };
      CommandManager.prototype.bindKeys = function(keyList) {
        return this.hashHandler.bindKeys(keyList);
      };
      CommandManager.prototype.addCommand = function(command) {
        this.hashHandler.addCommand(command);
      };
      CommandManager.prototype.removeCommand = function(commandName) {
        this.hashHandler.removeCommand(commandName);
      };
      CommandManager.prototype.findKeyCommand = function(hashId, keyString) {
        return this.hashHandler.findKeyCommand(hashId, keyString);
      };
      CommandManager.prototype.parseKeys = function(keys) {
        return this.hashHandler.parseKeys(keys);
      };
      CommandManager.prototype.addCommands = function(commands) {
        this.hashHandler.addCommands(commands);
      };
      CommandManager.prototype.removeCommands = function(commands) {
        this.hashHandler.removeCommands(commands);
      };
      CommandManager.prototype.handleKeyboard = function(data, hashId, keyString, keyCode) {
        return this.hashHandler.handleKeyboard(data, hashId, keyString, keyCode);
      };
      CommandManager.prototype.getCommandByName = function(name) {
        return this.hashHandler.commands[name];
      };
      CommandManager.prototype.exec = function(command, editor, args) {
        if (typeof command === 'string') {
          throw new TypeError("command must not be a string.");
        }
        if (!command) {
          return false;
        }
        if (editor && editor.$readOnly && !command.readOnly) {
          return false;
        }
        var e = {
          editor: editor,
          command: command,
          args: args
        };
        var retvalue = this.eventBus._emit("exec", e);
        this.eventBus._signal("afterExec", e);
        return retvalue === false ? false : true;
      };
      CommandManager.prototype.toggleRecording = function(editor) {
        if (this.$inReplay)
          return;
        editor && editor._emit("changeStatus");
        if (this.recording) {
          this.macro.pop();
          this.eventBus.off("exec", this.$addCommandToMacro);
          if (!this.macro.length)
            this.macro = this.oldMacro;
          return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
          this.$addCommandToMacro = function(e) {
            this.macro.push([e.command, e.args]);
          }.bind(this);
        }
        this.oldMacro = this.macro;
        this.macro = [];
        this.eventBus.on("exec", this.$addCommandToMacro);
        return this.recording = true;
      };
      CommandManager.prototype.replay = function(editor) {
        if (this.$inReplay || !this.macro)
          return;
        if (this.recording)
          return this.toggleRecording(editor);
        try {
          this.$inReplay = true;
          this.macro.forEach(function(x) {
            if (typeof x == "string")
              this.exec(x, editor);
            else
              this.exec(x[0], editor, x[1]);
          }, this);
        } finally {
          this.$inReplay = false;
        }
      };
      CommandManager.prototype.trimMacro = function(m) {
        return m.map(function(x) {
          if (typeof x[0] != "string")
            x[0] = x[0].name;
          if (!x[1])
            x = x[0];
          return x;
        });
      };
      CommandManager.prototype.on = function(eventName, callback, capturing) {
        this.eventBus.on(eventName, callback, capturing);
      };
      CommandManager.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      return CommandManager;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = CommandManager;
    mix_1.applyMixins(CommandManager, [KeyboardHandler_1.default]);
  });
  define('dom/getDocumentHead', ["require", "exports"], function(require, exports) {
    "use strict";
    function getDocumentHead(doc) {
      return (doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = getDocumentHead;
  });
  define('lib/net', ["require", "exports", '../dom/getDocumentHead'], function(require, exports, getDocumentHead_1) {
    "use strict";
    function get(url, callback) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          callback(xhr.responseText);
        }
      };
      xhr.send(null);
    }
    exports.get = get;
    function loadScript(src, callback, doc) {
      var head = getDocumentHead_1.default(doc);
      var s = doc.createElement('script');
      s.src = src;
      head.appendChild(s);
      s.onload = s['onreadystatechange'] = function(_, isAbort) {
        if (isAbort || !s['readyState'] || s['readyState'] === "loaded" || s['readyState'] === "complete") {
          s = s.onload = s['onreadystatechange'] = null;
          if (!isAbort) {
            callback();
          }
        }
      };
    }
    exports.loadScript = loadScript;
    function qualifyURL(url) {
      var a = document.createElement('a');
      a.href = url;
      return a.href;
    }
    exports.qualifyURL = qualifyURL;
  });
  define('config', ["require", "exports", "./lib/lang", "./lib/oop", "./lib/net"], function(require, exports, lang_1, oop_1, net_1) {
    "use strict";
    var global = (function() {
      return this || typeof window !== 'undefined' && window;
    })();
    var options = {
      packaged: false,
      workerPath: null,
      modePath: null,
      themePath: null,
      basePath: "",
      suffix: ".js",
      $moduleUrls: {}
    };
    function get(key) {
      if (!options.hasOwnProperty(key)) {
        throw new Error("Unknown config key: " + key);
      }
      return options[key];
    }
    exports.get = get;
    function set(key, value) {
      if (!options.hasOwnProperty(key)) {
        throw new Error("Unknown config key: " + key);
      }
      options[key] = value;
    }
    exports.set = set;
    function all() {
      return lang_1.copyObject(options);
    }
    exports.all = all;
    function moduleUrl(moduleName, component) {
      if (options.$moduleUrls[moduleName]) {
        return options.$moduleUrls[moduleName];
      }
      var parts = moduleName.split("/");
      component = component || parts[parts.length - 2] || "";
      var sep = component === "snippets" ? "/" : "-";
      var base = parts[parts.length - 1];
      if (component === 'worker' && sep === '-') {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
      }
      if ((!base || base == component) && parts.length > 1) {
        base = parts[parts.length - 2];
      }
      var path = options[component + "Path"];
      if (path == null) {
        path = options.basePath;
      } else if (sep == "/") {
        component = sep = "";
      }
      if (path && path.slice(-1) != "/") {
        path += "/";
      }
      return path + component + sep + base + get("suffix");
    }
    exports.moduleUrl = moduleUrl;
    function setModuleUrl(name, subst) {
      return options.$moduleUrls[name] = subst;
    }
    exports.setModuleUrl = setModuleUrl;
    exports.$loading = {};
    function loadModule(what, onLoad, doc) {
      if (doc === void 0) {
        doc = document;
      }
      var module;
      var moduleName;
      var moduleType;
      if (Array.isArray(what)) {
        moduleType = what[0];
        moduleName = what[1];
      } else {
        moduleName = what;
      }
      try {} catch (e) {}
      if (module && !exports.$loading[moduleName])
        return onLoad && onLoad(module);
      if (!exports.$loading[moduleName]) {
        exports.$loading[moduleName] = [];
      }
      exports.$loading[moduleName].push(onLoad);
      if (exports.$loading[moduleName].length > 1)
        return;
      var afterLoad = function() {};
      if (!get("packaged")) {
        return afterLoad();
      }
      net_1.loadScript(moduleUrl(moduleName, moduleType), afterLoad, doc);
    }
    exports.loadModule = loadModule;
    function init(packaged) {
      options.packaged = packaged || module.packaged;
      if (!global.document)
        return "";
      var scriptOptions = {};
      var scriptUrl = "";
      var currentScript = (document['currentScript'] || document['_currentScript']);
      var currentDocument = currentScript && currentScript.ownerDocument || document;
      var scripts = currentDocument.getElementsByTagName("script");
      for (var i = 0; i < scripts.length; i++) {
        var script = scripts[i];
        var src = script.src || script.getAttribute("src");
        if (!src)
          continue;
        var attributes = script.attributes;
        for (var j = 0,
            l = attributes.length; j < l; j++) {
          var attr = attributes[j];
          if (attr.name.indexOf("data-ace-") === 0) {
            scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
          }
        }
        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
        if (m) {
          scriptUrl = m[1];
        }
      }
      if (scriptUrl) {
        scriptOptions['base'] = scriptOptions['base'] || scriptUrl;
        scriptOptions['packaged'] = true;
      }
      scriptOptions['basePath'] = scriptOptions['base'];
      scriptOptions['workerPath'] = scriptOptions['workerPath'] || scriptOptions['base'];
      scriptOptions['modePath'] = scriptOptions['modePath'] || scriptOptions['base'];
      scriptOptions['themePath'] = scriptOptions['themePath'] || scriptOptions['base'];
      delete scriptOptions['base'];
      for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== "undefined")
          set(key, scriptOptions[key]);
    }
    exports.init = init;
    ;
    function deHyphenate(str) {
      return str.replace(/-(.)/g, function(m, m1) {
        return m1.toUpperCase();
      });
    }
    var optionsProvider = {
      setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
          this.setOption(key, optList[key]);
        }, this);
      },
      getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
          optionNames = Object.keys(this.$options);
        } else if (!Array.isArray(optionNames)) {
          result = optionNames;
          optionNames = Object.keys(result);
        }
        optionNames.forEach(function(key) {
          result[key] = this.getOption(key);
        }, this);
        return result;
      },
      setOption: function(name, value) {
        if (this["$" + name] === value)
          return;
        var opt = this.$options[name];
        if (!opt) {
          if (typeof console != "undefined" && console.warn)
            console.warn('misspelled option "' + name + '"');
          return undefined;
        }
        if (opt.forwardTo)
          return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
        if (!opt.handlesSet)
          this["$" + name] = value;
        if (opt && opt.set)
          opt.set.call(this, value);
      },
      getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
          if (typeof console != "undefined" && console.warn)
            console.warn('misspelled option "' + name + '"');
          return undefined;
        }
        if (opt.forwardTo)
          return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
      }
    };
    var defaultOptions = {};
    function defineOptions(obj, path, options) {
      if (!obj.$options) {
        defaultOptions[path] = obj.$options = {};
      }
      Object.keys(options).forEach(function(key) {
        var opt = options[key];
        if (typeof opt === "string") {
          opt = {forwardTo: opt};
        }
        opt.name || (opt.name = key);
        obj.$options[opt.name] = opt;
        if ("initialValue" in opt) {
          obj["$" + opt.name] = opt.initialValue;
        }
      });
      oop_1.implement(obj, optionsProvider);
      return this;
    }
    exports.defineOptions = defineOptions;
    function resetOptions(obj) {
      Object.keys(obj.$options).forEach(function(key) {
        var opt = obj.$options[key];
        if ("value" in opt) {
          obj.setOption(key, opt.value);
        }
      });
    }
    exports.resetOptions = resetOptions;
    function setDefaultValue(path, name, value) {
      var opts = defaultOptions[path] || (defaultOptions[path] = {});
      if (opts[name]) {
        if (opts.forwardTo)
          setDefaultValue(opts.forwardTo, name, value);
        else
          opts[name].value = value;
      }
    }
    exports.setDefaultValue = setDefaultValue;
    function setDefaultValues(path, optionHash) {
      Object.keys(optionHash).forEach(function(key) {
        setDefaultValue(path, key, optionHash[key]);
      });
    }
    exports.setDefaultValues = setDefaultValues;
  });
  define('commands/default_commands', ["require", "exports", "../lib/lang", "../config", "../Range", '../editor_protocol', '../editor_protocol', "../editor_protocol"], function(require, exports, lang_1, config_1, Range_1, editor_protocol_1, editor_protocol_2, editor_protocol_3) {
    "use strict";
    function bindKey(win, mac) {
      return {
        win: win,
        mac: mac
      };
    }
    var commands = [{
      name: "showSettingsMenu",
      bindKey: bindKey("Ctrl-,", "Command-,"),
      exec: function(editor) {
        config_1.loadModule("ace/ext/settings_menu", function(module) {
          module.init(editor);
        });
      },
      readOnly: true
    }, {
      name: "goToNextError",
      bindKey: bindKey("Alt-E", "Ctrl-E"),
      exec: function(editor) {
        config_1.loadModule("ace/ext/error_marker", function(module) {
          module.showErrorMarker(editor, 1);
        });
      },
      scrollIntoView: "animate",
      readOnly: true
    }, {
      name: "goToPreviousError",
      bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
      exec: function(editor) {
        config_1.loadModule("ace/ext/error_marker", function(module) {
          module.showErrorMarker(editor, -1);
        });
      },
      scrollIntoView: "animate",
      readOnly: true
    }, {
      name: "selectall",
      bindKey: bindKey("Ctrl-A", "Command-A"),
      exec: function(editor) {
        editor.selectAll();
      },
      readOnly: true
    }, {
      name: "centerselection",
      bindKey: bindKey(null, "Ctrl-L"),
      exec: function(editor) {
        editor.centerSelection();
      },
      readOnly: true
    }, {
      name: "gotoline",
      bindKey: bindKey("Ctrl-L", "Command-L"),
      exec: function(editor) {
        var line = parseInt(prompt("Enter line number:"), 10);
        if (!isNaN(line)) {
          editor.gotoLine(line);
        }
      },
      readOnly: true
    }, {
      name: "fold",
      bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
      exec: function(editor) {
        editor.getSession().toggleFold(false);
      },
      scrollIntoView: "center",
      readOnly: true
    }, {
      name: "unfold",
      bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
      exec: function(editor) {
        editor.getSession().toggleFold(true);
      },
      scrollIntoView: "center",
      readOnly: true
    }, {
      name: "toggleFoldWidget",
      bindKey: bindKey("F2", "F2"),
      exec: function(editor) {
        editor.getSession().toggleFoldWidget();
      },
      scrollIntoView: "center",
      readOnly: true
    }, {
      name: "toggleParentFoldWidget",
      bindKey: bindKey("Alt-F2", "Alt-F2"),
      exec: function(editor) {
        editor.getSession().toggleFoldWidget(true);
      },
      scrollIntoView: "center",
      readOnly: true
    }, {
      name: "foldall",
      bindKey: bindKey("Ctrl-Alt-0", "Ctrl-Command-Option-0"),
      exec: function(editor) {
        editor.getSession().foldAll();
      },
      scrollIntoView: "center",
      readOnly: true
    }, {
      name: "foldOther",
      bindKey: bindKey("Alt-0", "Command-Option-0"),
      exec: function(editor) {
        editor.getSession().foldAll();
      },
      scrollIntoView: "center",
      readOnly: true
    }, {
      name: "unfoldall",
      bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
      exec: function(editor) {
        editor.getSession().unfold();
      },
      scrollIntoView: "center",
      readOnly: true
    }, {
      name: "findnext",
      bindKey: bindKey("Ctrl-K", "Command-G"),
      exec: function(editor) {
        editor.findNext();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "center",
      readOnly: true
    }, {
      name: "findprevious",
      bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
      exec: function(editor) {
        editor.findPrevious();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "center",
      readOnly: true
    }, {
      name: "selectOrFindNext",
      bindKey: bindKey("Alt-K", "Ctrl-G"),
      exec: function(editor) {
        if (editor.selection.isEmpty()) {
          editor.selection.selectWord();
        } else {
          editor.findNext();
        }
      },
      readOnly: true
    }, {
      name: "selectOrFindPrevious",
      bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
      exec: function(editor) {
        if (editor.selection.isEmpty()) {
          editor.selection.selectWord();
        } else {
          editor.findPrevious();
        }
      },
      readOnly: true
    }, {
      name: "find",
      bindKey: bindKey("Ctrl-F", "Command-F"),
      exec: function(editor) {
        config_1.loadModule("ace/ext/searchbox", function(e) {
          e.Search(editor);
        });
      },
      readOnly: true
    }, {
      name: "overwrite",
      bindKey: bindKey("Insert", "Insert"),
      exec: function(editor) {
        editor.toggleOverwrite();
      },
      readOnly: true
    }, {
      name: "selecttostart",
      bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
      exec: function(editor) {
        editor.getSelection().selectFileStart();
      },
      multiSelectAction: "forEach",
      readOnly: true,
      scrollIntoView: "animate",
      aceCommandGroup: "fileJump"
    }, {
      name: "gotostart",
      bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
      exec: function(editor) {
        editor.navigateFileStart();
      },
      multiSelectAction: "forEach",
      readOnly: true,
      scrollIntoView: "animate",
      aceCommandGroup: "fileJump"
    }, {
      name: "selectup",
      bindKey: bindKey("Shift-Up", "Shift-Up"),
      exec: function(editor) {
        editor.getSelection().selectUp();
      },
      multiSelectAction: "forEach",
      readOnly: true
    }, {
      name: "golineup",
      bindKey: bindKey("Up", "Up|Ctrl-P"),
      exec: function(editor, args) {
        editor.navigateUp(args.times);
      },
      multiSelectAction: "forEach",
      readOnly: true
    }, {
      name: "selecttoend",
      bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
      exec: function(editor) {
        editor.getSelection().selectFileEnd();
      },
      multiSelectAction: "forEach",
      readOnly: true,
      scrollIntoView: "animate",
      aceCommandGroup: "fileJump"
    }, {
      name: "gotoend",
      bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
      exec: function(editor) {
        editor.navigateFileEnd();
      },
      multiSelectAction: "forEach",
      readOnly: true,
      scrollIntoView: "animate",
      aceCommandGroup: "fileJump"
    }, {
      name: "selectdown",
      bindKey: bindKey("Shift-Down", "Shift-Down"),
      exec: function(editor) {
        editor.getSelection().selectDown();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "golinedown",
      bindKey: bindKey("Down", "Down|Ctrl-N"),
      exec: function(editor, args) {
        editor.navigateDown(args.times);
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectwordleft",
      bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
      exec: function(editor) {
        editor.getSelection().selectWordLeft();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "gotowordleft",
      bindKey: bindKey("Ctrl-Left", "Option-Left"),
      exec: function(editor) {
        editor.navigateWordLeft();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selecttolinestart",
      bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
      exec: function(editor) {
        editor.getSelection().selectLineStart();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "gotolinestart",
      bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
      exec: function(editor) {
        editor.navigateLineStart();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectleft",
      bindKey: bindKey("Shift-Left", "Shift-Left"),
      exec: function(editor) {
        editor.getSelection().selectLeft();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "gotoleft",
      bindKey: bindKey("Left", "Left|Ctrl-B"),
      exec: function(editor, args) {
        editor.navigateLeft(args.times);
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectwordright",
      bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
      exec: function(editor) {
        editor.getSelection().selectWordRight();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "gotowordright",
      bindKey: bindKey("Ctrl-Right", "Option-Right"),
      exec: function(editor) {
        editor.navigateWordRight();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selecttolineend",
      bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
      exec: function(editor) {
        editor.getSelection().selectLineEnd();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "gotolineend",
      bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
      exec: function(editor) {
        editor.navigateLineEnd();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectright",
      bindKey: bindKey("Shift-Right", "Shift-Right"),
      exec: function(editor) {
        editor.getSelection().selectRight();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "gotoright",
      bindKey: bindKey("Right", "Right|Ctrl-F"),
      exec: function(editor, args) {
        editor.navigateRight(args.times);
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectpagedown",
      bindKey: "Shift-PageDown",
      exec: function(editor) {
        editor.selectPageDown();
      },
      readOnly: true
    }, {
      name: "pagedown",
      bindKey: bindKey(null, "Option-PageDown"),
      exec: function(editor) {
        editor.scrollPageDown();
      },
      readOnly: true
    }, {
      name: "gotopagedown",
      bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
      exec: function(editor) {
        editor.gotoPageDown();
      },
      readOnly: true
    }, {
      name: "selectpageup",
      bindKey: "Shift-PageUp",
      exec: function(editor) {
        editor.selectPageUp();
      },
      readOnly: true
    }, {
      name: "pageup",
      bindKey: bindKey(null, "Option-PageUp"),
      exec: function(editor) {
        editor.scrollPageUp();
      },
      readOnly: true
    }, {
      name: "gotopageup",
      bindKey: "PageUp",
      exec: function(editor) {
        editor.gotoPageUp();
      },
      readOnly: true
    }, {
      name: "scrollup",
      bindKey: bindKey("Ctrl-Up", null),
      exec: function(e) {
        e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
      },
      readOnly: true
    }, {
      name: "scrolldown",
      bindKey: bindKey("Ctrl-Down", null),
      exec: function(e) {
        e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
      },
      readOnly: true
    }, {
      name: "selectlinestart",
      bindKey: "Shift-Home",
      exec: function(editor) {
        editor.getSelection().selectLineStart();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectlineend",
      bindKey: "Shift-End",
      exec: function(editor) {
        editor.getSelection().selectLineEnd();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "togglerecording",
      bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
      exec: function(editor) {
        editor.commands.toggleRecording(editor);
      },
      readOnly: true
    }, {
      name: "replaymacro",
      bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
      exec: function(editor) {
        editor.commands.replay(editor);
      },
      readOnly: true
    }, {
      name: "jumptomatching",
      bindKey: bindKey("Ctrl-P", "Ctrl-P"),
      exec: function(editor) {
        editor.jumpToMatching();
      },
      multiSelectAction: "forEach",
      readOnly: true
    }, {
      name: "selecttomatching",
      bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
      exec: function(editor) {
        editor.jumpToMatching(true);
      },
      multiSelectAction: "forEach",
      readOnly: true
    }, {
      name: "passKeysToBrowser",
      bindKey: bindKey("null", "null"),
      exec: function() {},
      passEvent: true,
      readOnly: true
    }, {
      name: "cut",
      exec: function(editor) {
        var range = editor.getSelectionRange();
        editor._emit("cut", range);
        if (!editor.selection.isEmpty()) {
          editor.getSession().remove(range);
          editor.clearSelection();
        }
      },
      scrollIntoView: "cursor",
      multiSelectAction: "forEach"
    }, {
      name: "removeline",
      bindKey: bindKey("Ctrl-D", "Command-D"),
      exec: function(editor) {
        editor.removeLines();
      },
      scrollIntoView: "cursor",
      multiSelectAction: "forEachLine"
    }, {
      name: "duplicateSelection",
      bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
      exec: function(editor) {
        editor.duplicateSelection();
      },
      scrollIntoView: "cursor",
      multiSelectAction: "forEach"
    }, {
      name: "sortlines",
      bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
      exec: function(editor) {
        editor.sortLines();
      },
      scrollIntoView: "selection",
      multiSelectAction: "forEachLine"
    }, {
      name: "togglecomment",
      bindKey: bindKey("Ctrl-/", "Command-/"),
      exec: function(editor) {
        editor.toggleCommentLines();
      },
      multiSelectAction: "forEachLine",
      scrollIntoView: "selectionPart"
    }, {
      name: "toggleBlockComment",
      bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
      exec: function(editor) {
        editor.toggleBlockComment();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "selectionPart"
    }, {
      name: "modifyNumberUp",
      bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
      exec: function(editor) {
        editor.modifyNumber(1);
      },
      multiSelectAction: "forEach"
    }, {
      name: "modifyNumberDown",
      bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
      exec: function(editor) {
        editor.modifyNumber(-1);
      },
      multiSelectAction: "forEach"
    }, {
      name: "replace",
      bindKey: bindKey("Ctrl-H", "Command-Option-F"),
      exec: function(editor) {
        config_1.loadModule("ace/ext/searchbox", function(e) {
          e.Search(editor, true);
        });
      }
    }, {
      name: "undo",
      bindKey: bindKey("Ctrl-Z", "Command-Z"),
      exec: function(editor) {
        editor.undo();
      }
    }, {
      name: "redo",
      bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
      exec: function(editor) {
        editor.redo();
      }
    }, {
      name: "copylinesup",
      bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
      exec: function(editor) {
        editor.copyLinesUp();
      },
      scrollIntoView: "cursor"
    }, {
      name: "movelinesup",
      bindKey: bindKey("Alt-Up", "Option-Up"),
      exec: function(editor) {
        editor.moveLinesUp();
      },
      scrollIntoView: "cursor"
    }, {
      name: "copylinesdown",
      bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
      exec: function(editor) {
        editor.copyLinesDown();
      },
      scrollIntoView: "cursor"
    }, {
      name: "movelinesdown",
      bindKey: bindKey("Alt-Down", "Option-Down"),
      exec: function(editor) {
        editor.moveLinesDown();
      },
      scrollIntoView: "cursor"
    }, {
      name: editor_protocol_2.COMMAND_NAME_DEL,
      bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
      exec: function(editor) {
        editor.remove("right");
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: editor_protocol_1.COMMAND_NAME_BACKSPACE,
      bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
      exec: function(editor) {
        editor.remove("left");
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "cut_or_delete",
      bindKey: bindKey("Shift-Delete", null),
      exec: function(editor) {
        if (editor.selection.isEmpty()) {
          editor.remove("left");
        } else {
          return false;
        }
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "removetolinestart",
      bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
      exec: function(editor) {
        editor.removeToLineStart();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "removetolineend",
      bindKey: bindKey("Alt-Delete", "Ctrl-K"),
      exec: function(editor) {
        editor.removeToLineEnd();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "removewordleft",
      bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
      exec: function(editor) {
        editor.removeWordLeft();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "removewordright",
      bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
      exec: function(editor) {
        editor.removeWordRight();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "outdent",
      bindKey: bindKey("Shift-Tab", "Shift-Tab"),
      exec: function(editor) {
        editor.blockOutdent();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "selectionPart"
    }, {
      name: "indent",
      bindKey: bindKey("Tab", "Tab"),
      exec: function(editor) {
        editor.indent();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "selectionPart"
    }, {
      name: "blockoutdent",
      bindKey: bindKey("Ctrl-[", "Ctrl-["),
      exec: function(editor) {
        editor.blockOutdent();
      },
      multiSelectAction: "forEachLine",
      scrollIntoView: "selectionPart"
    }, {
      name: "blockindent",
      bindKey: bindKey("Ctrl-]", "Ctrl-]"),
      exec: function(editor) {
        editor.blockIndent();
      },
      multiSelectAction: "forEachLine",
      scrollIntoView: "selectionPart"
    }, {
      name: editor_protocol_3.COMMAND_NAME_INSERT_STRING,
      exec: function(editor, str) {
        editor.insert(str);
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "inserttext",
      exec: function(editor, args) {
        editor.insert(lang_1.stringRepeat(args.text || "", args.times || 1));
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "splitline",
      bindKey: bindKey(null, "Ctrl-O"),
      exec: function(editor) {
        editor.splitLine();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "transposeletters",
      bindKey: bindKey("Ctrl-T", "Ctrl-T"),
      exec: function(editor) {
        editor.transposeLetters();
      },
      multiSelectAction: function(editor) {
        editor.transposeLetters();
      },
      scrollIntoView: "cursor"
    }, {
      name: "touppercase",
      bindKey: bindKey("Ctrl-U", "Ctrl-U"),
      exec: function(editor) {
        editor.toUpperCase();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "tolowercase",
      bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
      exec: function(editor) {
        editor.toLowerCase();
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor"
    }, {
      name: "expandtoline",
      bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
      exec: function(editor) {
        var range = editor.selection.getRange();
        range.start.column = range.end.column = 0;
        range.end.row++;
        editor.selection.setRange(range, false);
      },
      multiSelectAction: "forEach",
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "joinlines",
      bindKey: bindKey(null, null),
      exec: function(editor) {
        var isBackwards = editor.selection.isBackwards();
        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
        var insertLine = editor.session.doc.getLine(selectionStart.row);
        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
          var curLine = lang_1.stringTrimLeft(lang_1.stringTrimRight(editor.session.doc.getLine(i)));
          if (curLine.length !== 0) {
            curLine = " " + curLine;
          }
          insertLine += curLine;
        }
        ;
        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
          insertLine += editor.session.doc.getNewLineCharacter();
        }
        editor.clearSelection();
        editor.session.doc.replace(new Range_1.default(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
        if (selectedCount > 0) {
          editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
          editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
        } else {
          firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
          editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
        }
      },
      multiSelectAction: "forEach",
      readOnly: true
    }, {
      name: "invertSelection",
      bindKey: bindKey(null, null),
      exec: function(editor) {
        var endRow = editor.session.doc.getLength() - 1;
        var endCol = editor.session.doc.getLine(endRow).length;
        var ranges = editor.selection.rangeList.ranges;
        var newRanges = [];
        if (ranges.length < 1) {
          ranges = [editor.selection.getRange()];
        }
        for (var i = 0; i < ranges.length; i++) {
          if (i == (ranges.length - 1)) {
            if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
              newRanges.push(new Range_1.default(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
            }
          }
          if (i === 0) {
            if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
              newRanges.push(new Range_1.default(0, 0, ranges[i].start.row, ranges[i].start.column));
            }
          } else {
            newRanges.push(new Range_1.default(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
          }
        }
        editor.exitMultiSelectMode();
        editor.clearSelection();
        for (var i = 0; i < newRanges.length; i++) {
          editor.selection.addRange(newRanges[i], false);
        }
      },
      readOnly: true,
      scrollIntoView: "none"
    }];
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = commands;
  });
  define('TokenIterator', ["require", "exports"], function(require, exports) {
    "use strict";
    var TokenIterator = (function() {
      function TokenIterator(session, initialRow, initialColumn) {
        this.session = session;
        this.$row = initialRow;
        this.$rowTokens = session.getTokens(initialRow);
        var token = session.getTokenAt(initialRow, initialColumn);
        this.$tokenIndex = token ? token.index : -1;
      }
      TokenIterator.prototype.stepBackward = function() {
        this.$tokenIndex -= 1;
        while (this.$tokenIndex < 0) {
          this.$row -= 1;
          if (this.$row < 0) {
            this.$row = 0;
            return null;
          }
          this.$rowTokens = this.session.getTokens(this.$row);
          this.$tokenIndex = this.$rowTokens.length - 1;
        }
        return this.$rowTokens[this.$tokenIndex];
      };
      TokenIterator.prototype.stepForward = function() {
        if (this.$rowTokens) {
          this.$tokenIndex += 1;
          var rowCount;
          while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount) {
              rowCount = this.session.getLength();
            }
            if (this.$row >= rowCount) {
              this.$row = rowCount - 1;
              return null;
            }
            this.$rowTokens = this.session.getTokens(this.$row);
            this.$tokenIndex = 0;
          }
          return this.$rowTokens[this.$tokenIndex];
        } else {
          return void 0;
        }
      };
      TokenIterator.prototype.getCurrentToken = function() {
        if (this.$rowTokens) {
          return this.$rowTokens[this.$tokenIndex];
        } else {
          return void 0;
        }
      };
      TokenIterator.prototype.getCurrentTokenRow = function() {
        return this.$row;
      };
      TokenIterator.prototype.getCurrentTokenColumn = function() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
          return column;
        column = 0;
        while (tokenIndex > 0) {
          tokenIndex -= 1;
          column += rowTokens[tokenIndex].value.length;
        }
        return column;
      };
      return TokenIterator;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = TokenIterator;
  });
  define('comparePoints', ["require", "exports"], function(require, exports) {
    "use strict";
    function comparePoints(p1, p2) {
      return p1.row - p2.row || p1.column - p2.column;
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = comparePoints;
  });
  define('RangeList', ["require", "exports", "./comparePoints"], function(require, exports, comparePoints_1) {
    "use strict";
    var RangeList = (function() {
      function RangeList() {
        this.ranges = [];
      }
      RangeList.prototype.pointIndex = function(pos, excludeEdges, startIndex) {
        var list = this.ranges;
        for (var i = startIndex || 0; i < list.length; i++) {
          var range = list[i];
          var cmpEnd = comparePoints_1.default(pos, range.end);
          if (cmpEnd > 0) {
            continue;
          }
          var cmpStart = comparePoints_1.default(pos, range.start);
          if (cmpEnd === 0) {
            return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
          }
          if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges)) {
            return i;
          }
          return -i - 1;
        }
        return -i - 1;
      };
      RangeList.prototype.add = function(range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
          startIndex = -startIndex - 1;
        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
        if (endIndex < 0) {
          endIndex = -endIndex - 1;
        } else {
          endIndex++;
        }
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
      };
      RangeList.prototype.addList = function(list) {
        var removed = [];
        for (var i = list.length; i--; ) {
          removed.push.call(removed, this.add(list[i]));
        }
        return removed;
      };
      RangeList.prototype.substractPoint = function(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0) {
          return this.ranges.splice(i, 1);
        }
      };
      RangeList.prototype.merge = function() {
        var removed = [];
        var list = this.ranges;
        list = list.sort(function(a, b) {
          return comparePoints_1.default(a.start, b.start);
        });
        var next = list[0],
            range;
        for (var i = 1; i < list.length; i++) {
          range = next;
          next = list[i];
          var cmp = comparePoints_1.default(range.end, next.start);
          if (cmp < 0)
            continue;
          if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
            continue;
          if (comparePoints_1.default(range.end, next.end) < 0) {
            range.end.row = next.end.row;
            range.end.column = next.end.column;
          }
          list.splice(i, 1);
          removed.push(next);
          next = range;
          i--;
        }
        this.ranges = list;
        return removed;
      };
      RangeList.prototype.contains = function(row, column) {
        return this.pointIndex({
          row: row,
          column: column
        }) >= 0;
      };
      RangeList.prototype.containsPoint = function(pos) {
        return this.pointIndex(pos) >= 0;
      };
      RangeList.prototype.rangeAtPoint = function(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0) {
          return this.ranges[i];
        }
      };
      RangeList.prototype.clipRows = function(startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow) {
          return [];
        }
        var startIndex = this.pointIndex({
          row: startRow,
          column: 0
        });
        if (startIndex < 0) {
          startIndex = -startIndex - 1;
        }
        var excludeEdges = true;
        var endIndex = this.pointIndex({
          row: endRow,
          column: 0
        }, excludeEdges, startIndex);
        if (endIndex < 0) {
          endIndex = -endIndex - 1;
        }
        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
          clipped.push(list[i]);
        }
        return clipped;
      };
      RangeList.prototype.removeAll = function() {
        return this.ranges.splice(0, this.ranges.length);
      };
      RangeList.prototype.attach = function(session) {
        if (this.session) {
          this.detach();
        }
        this.session = session;
        this.onChange = this.$onChange.bind(this);
        this.session.on('change', this.onChange);
      };
      RangeList.prototype.detach = function() {
        if (!this.session) {
          return;
        }
        this.session.off('change', this.onChange);
        this.session = null;
      };
      RangeList.prototype.$onChange = function(e, session) {
        var changeRange = e.data.range;
        if (e.data.action[0] == "i") {
          var start = changeRange.start;
          var end = changeRange.end;
        } else {
          var end = changeRange.start;
          var start = changeRange.end;
        }
        var startRow = start.row;
        var endRow = end.row;
        var lineDif = endRow - startRow;
        var colDiff = -start.column + end.column;
        var ranges = this.ranges;
        for (var i = 0,
            n = ranges.length; i < n; i++) {
          var r = ranges[i];
          if (r.end.row < startRow) {
            continue;
          }
          if (r.start.row > startRow) {
            break;
          }
          if (r.start.row == startRow && r.start.column >= start.column) {
            if (r.start.column == start.column && this['$insertRight']) {} else {
              r.start.column += colDiff;
              r.start.row += lineDif;
            }
          }
          if (r.end.row == startRow && r.end.column >= start.column) {
            if (r.end.column == start.column && this['$insertRight']) {
              continue;
            }
            if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
              if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column) {
                r.end.column -= colDiff;
              }
            }
            r.end.column += colDiff;
            r.end.row += lineDif;
          }
        }
        if (lineDif != 0 && i < n) {
          for (; i < n; i++) {
            var r = ranges[i];
            r.start.row += lineDif;
            r.end.row += lineDif;
          }
        }
      };
      return RangeList;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = RangeList;
  });
  define('Selection', ["require", "exports", "./lib/lang", "./lib/EventEmitterClass", "./Range", "./RangeList", "./Anchor"], function(require, exports, lang_1, EventEmitterClass_1, Range_1, RangeList_1, Anchor_1) {
    "use strict";
    var Selection = (function() {
      function Selection(session) {
        var _this = this;
        this.rangeCount = 0;
        this.ranges = [];
        this.rangeList = new RangeList_1.default();
        this.eventBus = new EventEmitterClass_1.default(this);
        this.session = session;
        this.doc = session.getDocument();
        this.clearSelection();
        this.lead = this.selectionLead = new Anchor_1.default(this.doc, 0, 0);
        this.anchor = this.selectionAnchor = new Anchor_1.default(this.doc, 0, 0);
        this.lead.on("change", function(event, source) {
          _this.eventBus._emit("changeCursor");
          if (!_this.$isEmpty) {
            _this.eventBus._emit("changeSelection");
          }
          if (!_this.$keepDesiredColumnOnChange && event.oldPosition.column !== event.position.column) {
            _this.$desiredColumn = null;
          }
        });
        this.selectionAnchor.on("change", function(event, source) {
          if (!_this.$isEmpty) {
            _this.eventBus._emit("changeSelection");
          }
        });
      }
      Selection.prototype.$initRangeList = function() {
        if (this.rangeList)
          return;
        this.rangeList = new RangeList_1.default();
        this.ranges = [];
        this.rangeCount = 0;
      };
      ;
      Selection.prototype.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
          this.$onRemoveRange(removed);
          return removed[0];
        }
      };
      ;
      Selection.prototype.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
      };
      Selection.prototype.splitIntoLines = function() {
        var _this = this;
        if (this.rangeCount > 1) {
          var ranges = this.rangeList.ranges;
          var lastRange = ranges[ranges.length - 1];
          var range = Range_1.default.fromPoints(ranges[0].start, lastRange.end);
          this.toSingleRange();
          this.setSelectionRange(range, lastRange.cursor === lastRange.start);
        } else {
          var range = this.getRange();
          var isBackwards = this.isBackwards();
          var startRow = range.start.row;
          var endRow = range.end.row;
          if (startRow === endRow) {
            if (isBackwards)
              var start = range.end,
                  end = range.start;
            else
              var start = range.start,
                  end = range.end;
            this.addRange(Range_1.default.fromPoints(end, end));
            this.addRange(Range_1.default.fromPoints(start, start));
            return;
          }
          var rectSel = [];
          var r = this.getLineRange(startRow, true);
          r.start.column = range.start.column;
          rectSel.push(r);
          for (var i = startRow + 1; i < endRow; i++) {
            rectSel.push(this.getLineRange(i, true));
          }
          r = this.getLineRange(endRow, true);
          r.end.column = range.end.column;
          rectSel.push(r);
          rectSel.forEach(function(range) {
            _this.addRange(range);
          });
        }
      };
      ;
      Selection.prototype.isEmpty = function() {
        return (this.$isEmpty || (this.anchor.row === this.lead.row && this.anchor.column === this.lead.column));
      };
      Selection.prototype.isMultiLine = function() {
        if (this.isEmpty()) {
          return false;
        }
        return this.getRange().isMultiLine();
      };
      Selection.prototype.getCursor = function() {
        return this.lead.getPosition();
      };
      Selection.prototype.setSelectionAnchor = function(row, column) {
        if (typeof row !== 'number') {
          throw new TypeError("row must be a number");
        }
        if (typeof column !== 'number') {
          throw new TypeError("column must be a number");
        }
        this.anchor.setPosition(row, column);
        if (this.$isEmpty) {
          this.$isEmpty = false;
          this.eventBus._emit("changeSelection");
        }
      };
      Selection.prototype.getSelectionAnchor = function() {
        if (this.$isEmpty) {
          return this.getSelectionLead();
        } else {
          return this.anchor.getPosition();
        }
      };
      Selection.prototype.getSelectionLead = function() {
        return this.lead.getPosition();
      };
      Selection.prototype.shiftSelection = function(columns) {
        if (this.$isEmpty) {
          this.moveCursorTo(this.lead.row, this.lead.column + columns);
          return;
        }
        var anchor = this.getSelectionAnchor();
        var lead = this.getSelectionLead();
        var isBackwards = this.isBackwards();
        if (!isBackwards || anchor.column !== 0)
          this.setSelectionAnchor(anchor.row, anchor.column + columns);
        if (isBackwards || lead.column !== 0) {
          this.$moveSelection(function() {
            this.moveCursorTo(lead.row, lead.column + columns);
          });
        }
      };
      Selection.prototype.isBackwards = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row === lead.row && anchor.column > lead.column));
      };
      Selection.prototype.getRange = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        if (typeof anchor.row !== 'number') {
          throw new TypeError();
        }
        if (typeof anchor.column !== 'number') {
          throw new TypeError();
        }
        if (typeof lead.row !== 'number') {
          throw new TypeError();
        }
        if (typeof lead.column !== 'number') {
          throw new TypeError();
        }
        if (this.isEmpty())
          return Range_1.default.fromPoints(lead, lead);
        if (this.isBackwards()) {
          return Range_1.default.fromPoints(lead, anchor);
        } else {
          return Range_1.default.fromPoints(anchor, lead);
        }
      };
      Selection.prototype.clearSelection = function() {
        if (!this.$isEmpty) {
          this.$isEmpty = true;
          this.eventBus._emit("changeSelection");
        }
      };
      Selection.prototype.selectAll = function() {
        var lastRow = this.doc.getLength() - 1;
        this.setSelectionAnchor(0, 0);
        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
      };
      Selection.prototype.setRange = function(range, reverse) {
        this.setSelectionRange(range, reverse);
      };
      Selection.prototype.setSelectionRange = function(range, reverse) {
        if (reverse) {
          this.setSelectionAnchor(range.end.row, range.end.column);
          this.selectTo(range.start.row, range.start.column);
        } else {
          this.setSelectionAnchor(range.start.row, range.start.column);
          this.selectTo(range.end.row, range.end.column);
        }
        if (this.getRange().isEmpty())
          this.$isEmpty = true;
        this.$desiredColumn = null;
      };
      Selection.prototype.$moveSelection = function(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
          this.setSelectionAnchor(lead.row, lead.column);
        mover.call(this);
      };
      Selection.prototype.selectTo = function(row, column) {
        this.$moveSelection(function() {
          this.moveCursorTo(row, column);
        });
      };
      Selection.prototype.selectToPosition = function(position) {
        var self = this;
        this.$moveSelection(function() {
          self.moveCursorToPosition(position);
        });
      };
      Selection.prototype.moveTo = function(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
      };
      Selection.prototype.moveToPosition = function(pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
      };
      Selection.prototype.selectUp = function() {
        this.$moveSelection(this.moveCursorUp);
      };
      Selection.prototype.selectDown = function() {
        this.$moveSelection(this.moveCursorDown);
      };
      Selection.prototype.selectRight = function() {
        this.$moveSelection(this.moveCursorRight);
      };
      Selection.prototype.selectLeft = function() {
        this.$moveSelection(this.moveCursorLeft);
      };
      Selection.prototype.selectLineStart = function() {
        this.$moveSelection(this.moveCursorLineStart);
      };
      Selection.prototype.selectLineEnd = function() {
        this.$moveSelection(this.moveCursorLineEnd);
      };
      Selection.prototype.selectFileEnd = function() {
        this.$moveSelection(this.moveCursorFileEnd);
      };
      Selection.prototype.selectFileStart = function() {
        this.$moveSelection(this.moveCursorFileStart);
      };
      Selection.prototype.selectWordRight = function() {
        this.$moveSelection(this.moveCursorWordRight);
      };
      Selection.prototype.selectWordLeft = function() {
        this.$moveSelection(this.moveCursorWordLeft);
      };
      Selection.prototype.getWordRange = function(row, column) {
        if (typeof column === "undefined") {
          var cursor = this.lead;
          row = cursor.row;
          column = cursor.column;
        }
        return this.session.getWordRange(row, column);
      };
      Selection.prototype.selectWord = function() {
        this.setSelectionRange(this.getWordRange(this.lead.row, this.lead.column));
      };
      Selection.prototype.selectAWord = function() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
      };
      Selection.prototype.getLineRange = function(row, excludeLastChar) {
        var rowStart = typeof row === "number" ? row : this.lead.row;
        var rowEnd;
        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
          rowStart = foldLine.start.row;
          rowEnd = foldLine.end.row;
        } else {
          rowEnd = rowStart;
        }
        if (excludeLastChar) {
          return new Range_1.default(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        } else {
          return new Range_1.default(rowStart, 0, rowEnd + 1, 0);
        }
      };
      Selection.prototype.selectLine = function() {
        this.setSelectionRange(this.getLineRange());
      };
      Selection.prototype.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length) {
          this.$onRemoveRange(removed);
        } else if (this.ranges[0]) {
          this.fromOrientedRange(this.ranges[0]);
        }
      };
      ;
      Selection.prototype.moveCursorUp = function() {
        this.moveCursorBy(-1, 0);
      };
      Selection.prototype.moveCursorDown = function() {
        this.moveCursorBy(1, 0);
      };
      Selection.prototype.moveCursorLeft = function() {
        var cursor = this.lead.getPosition();
        var fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
          this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column === 0) {
          if (cursor.row > 0) {
            this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
          }
        } else {
          var tabSize = this.session.getTabSize();
          if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column - tabSize, cursor.column).split(" ").length - 1 === tabSize)
            this.moveCursorBy(0, -tabSize);
          else
            this.moveCursorBy(0, -1);
        }
      };
      Selection.prototype.moveCursorRight = function() {
        var pos = this.lead.getPosition();
        var fold = this.session.getFoldAt(pos.row, pos.column, 1);
        if (fold) {
          this.moveCursorTo(fold.end.row, fold.end.column);
        } else if (this.lead.column === this.doc.getLine(this.lead.row).length) {
          if (this.lead.row < this.doc.getLength() - 1) {
            this.moveCursorTo(this.lead.row + 1, 0);
          }
        } else {
          var tabSize = this.session.getTabSize();
          var cursor = this.lead;
          if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column + tabSize).split(" ").length - 1 === tabSize) {
            this.moveCursorBy(0, tabSize);
          } else {
            this.moveCursorBy(0, 1);
          }
        }
      };
      Selection.prototype.moveCursorLineStart = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
        var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
        var leadingSpace = beforeCursor.match(/^\s*/);
        if (leadingSpace[0].length !== column && !this.session.$useEmacsStyleLineStart)
          firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
      };
      Selection.prototype.moveCursorLineEnd = function() {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column === lineEnd.column) {
          var line = this.session.getLine(lineEnd.row);
          if (lineEnd.column === line.length) {
            var textEnd = line.search(/\s+$/);
            if (textEnd > 0)
              lineEnd.column = textEnd;
          }
        }
        this.moveCursorTo(lineEnd.row, lineEnd.column);
      };
      Selection.prototype.moveCursorFileEnd = function() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
      };
      Selection.prototype.moveCursorFileStart = function() {
        this.moveCursorTo(0, 0);
      };
      Selection.prototype.moveCursorLongWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);
        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
          this.moveCursorTo(fold.end.row, fold.end.column);
          return;
        }
        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
          column += this.session.nonTokenRe.lastIndex;
          this.session.nonTokenRe.lastIndex = 0;
          rightOfCursor = line.substring(column);
        }
        if (column >= line.length) {
          this.moveCursorTo(row, line.length);
          this.moveCursorRight();
          if (row < this.doc.getLength() - 1)
            this.moveCursorWordRight();
          return;
        }
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
          column += this.session.tokenRe.lastIndex;
          this.session.tokenRe.lastIndex = 0;
        }
        this.moveCursorTo(row, column);
      };
      Selection.prototype.moveCursorLongWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
          this.moveCursorTo(fold.start.row, fold.start.column);
          return;
        }
        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
          str = this.doc.getLine(row).substring(0, column);
        }
        var leftOfCursor = lang_1.stringReverse(str);
        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
          column -= this.session.nonTokenRe.lastIndex;
          leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
          this.session.nonTokenRe.lastIndex = 0;
        }
        if (column <= 0) {
          this.moveCursorTo(row, 0);
          this.moveCursorLeft();
          if (row > 0)
            this.moveCursorWordLeft();
          return;
        }
        if (match = this.session.tokenRe.exec(leftOfCursor)) {
          column -= this.session.tokenRe.lastIndex;
          this.session.tokenRe.lastIndex = 0;
        }
        this.moveCursorTo(row, column);
      };
      Selection.prototype.$shortWordEndIndex = function(rightOfCursor) {
        var match;
        var index = 0;
        var ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;
        tokenRe.lastIndex = 0;
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
          index = this.session.tokenRe.lastIndex;
        } else {
          while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
            index++;
          if (index < 1) {
            tokenRe.lastIndex = 0;
            while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
              tokenRe.lastIndex = 0;
              index++;
              if (whitespaceRe.test(ch)) {
                if (index > 2) {
                  index--;
                  break;
                } else {
                  while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                    index++;
                  if (index > 2)
                    break;
                }
              }
            }
          }
        }
        tokenRe.lastIndex = 0;
        return index;
      };
      Selection.prototype.moveCursorShortWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
          return this.moveCursorTo(fold.end.row, fold.end.column);
        if (column === line.length) {
          var l = this.doc.getLength();
          do {
            row++;
            rightOfCursor = this.doc.getLine(row);
          } while (row < l && /^\s*$/.test(rightOfCursor));
          if (!/^\s+/.test(rightOfCursor))
            rightOfCursor = "";
          column = 0;
        }
        var index = this.$shortWordEndIndex(rightOfCursor);
        this.moveCursorTo(row, column + index);
      };
      Selection.prototype.moveCursorShortWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
          return this.moveCursorTo(fold.start.row, fold.start.column);
        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
          do {
            row--;
            line = this.doc.getLine(row);
          } while (row > 0 && /^\s*$/.test(line));
          column = line.length;
          if (!/\s+$/.test(line))
            line = "";
        }
        var leftOfCursor = lang_1.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);
        return this.moveCursorTo(row, column - index);
      };
      Selection.prototype.moveCursorWordRight = function() {
        if (this.session.$selectLongWords) {
          this.moveCursorLongWordRight();
        } else {
          this.moveCursorShortWordRight();
        }
      };
      Selection.prototype.moveCursorWordLeft = function() {
        if (this.session.$selectLongWords) {
          this.moveCursorLongWordLeft();
        } else {
          this.moveCursorShortWordLeft();
        }
      };
      Selection.prototype.moveCursorBy = function(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
        if (chars === 0) {
          if (this.$desiredColumn)
            screenPos.column = this.$desiredColumn;
          else
            this.$desiredColumn = screenPos.column;
        }
        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
          if (this.session.lineWidgets && this.session.lineWidgets[docPos.row])
            docPos.row++;
        }
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
      };
      Selection.prototype.moveCursorToPosition = function(position) {
        this.moveCursorTo(position.row, position.column);
      };
      Selection.prototype.moveCursorTo = function(row, column, keepDesiredColumn) {
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
          row = fold.start.row;
          column = fold.start.column;
        }
        this.$keepDesiredColumnOnChange = true;
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;
        if (!keepDesiredColumn)
          this.$desiredColumn = null;
      };
      Selection.prototype.moveCursorToScreen = function(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
      };
      Selection.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      Selection.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      Selection.prototype.detach = function() {
        this.lead.detach();
        this.anchor.detach();
        this.session = this.doc = null;
      };
      Selection.prototype.fromOrientedRange = function(range) {
        this.setSelectionRange(range, range.cursor === range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
      };
      Selection.prototype.toOrientedRange = function(range) {
        var r = this.getRange();
        if (range) {
          range.start.column = r.start.column;
          range.start.row = r.start.row;
          range.end.column = r.end.column;
          range.end.row = r.end.row;
        } else {
          range = r;
        }
        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
      };
      Selection.prototype.getRangeOfMovements = function(func) {
        var start = this.getCursor();
        try {
          func.call(null, this);
          var end = this.getCursor();
          return Range_1.default.fromPoints(start, end);
        } catch (e) {
          return Range_1.default.fromPoints(start, start);
        } finally {
          this.moveCursorToPosition(start);
        }
      };
      Selection.prototype.toJSON = function() {
        if (this.rangeCount) {
          var ranges = this.ranges.map(function(r) {
            var r1 = r.clone();
            r1.isBackwards = r.cursor === r.start;
            return r1;
          });
          return ranges;
        } else {
          var range = this.getRange();
          range.isBackwards = this.isBackwards();
          return [range];
        }
      };
      Selection.prototype.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length) {
          this.$onRemoveRange(removed);
        }
        if (range) {
          this.fromOrientedRange(range);
        }
      };
      Selection.prototype.addRange = function(range, $blockChangeEvents) {
        if (!range) {
          return;
        }
        if (!this.inMultiSelectMode && this.rangeCount === 0) {
          var oldRange = this.toOrientedRange();
          this.rangeList.add(oldRange);
          this.rangeList.add(range);
          if (this.rangeList.ranges.length !== 2) {
            this.rangeList.removeAll();
            return $blockChangeEvents || this.fromOrientedRange(range);
          }
          this.rangeList.removeAll();
          this.rangeList.add(oldRange);
          this.$onAddRange(oldRange);
        }
        if (!range.cursor) {
          range.cursor = range.end;
        }
        var removed = this.rangeList.add(range);
        this.$onAddRange(range);
        if (removed.length)
          this.$onRemoveRange(removed);
        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
          this.eventBus._signal("multiSelect");
          this.inMultiSelectMode = true;
          this.session.$undoSelect = false;
          this.rangeList.attach(this.session);
        }
        return $blockChangeEvents || this.fromOrientedRange(range);
      };
      Selection.prototype.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        var event = {range: range};
        this.eventBus._signal("addRange", event);
      };
      ;
      Selection.prototype.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount === 1 && this.inMultiSelectMode) {
          var lastRange = this.rangeList.ranges.pop();
          removed.push(lastRange);
          this.rangeCount = 0;
        }
        for (var i = removed.length; i--; ) {
          var index = this.ranges.indexOf(removed[i]);
          this.ranges.splice(index, 1);
        }
        var event = {ranges: removed};
        this.eventBus._signal("removeRange", event);
        if (this.rangeCount === 0 && this.inMultiSelectMode) {
          this.inMultiSelectMode = false;
          this.eventBus._signal("singleSelect");
          this.session.$undoSelect = true;
          this.rangeList.detach();
        }
        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange())) {
          this.fromOrientedRange(lastRange);
        }
      };
      ;
      Selection.prototype.fromJSON = function(data) {
        if (data.start === void 0) {
          if (this.rangeList) {
            this.toSingleRange(data[0]);
            for (var i = data.length; i--; ) {
              var r = Range_1.default.fromPoints(data[i].start, data[i].end);
              if (data.isBackwards)
                r.cursor = r.start;
              this.addRange(r, true);
            }
            return;
          } else
            data = data[0];
        }
        if (this.rangeList)
          this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
      };
      Selection.prototype.isEqual = function(data) {
        if ((data.length || this.rangeCount) && data.length !== this.rangeCount)
          return false;
        if (!data.length || !this.ranges)
          return this.getRange().isEqual(data);
        for (var i = this.ranges.length; i--; ) {
          if (!this.ranges[i].isEqual(data[i]))
            return false;
        }
        return true;
      };
      return Selection;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Selection;
  });
  define('Tokenizer', ["require", "exports"], function(require, exports) {
    "use strict";
    var MAX_TOKEN_COUNT = 1000;
    var Tokenizer = (function() {
      function Tokenizer(rules) {
        var _this = this;
        this.states = rules;
        this.regExps = {};
        this.matchMappings = {};
        for (var key in this.states) {
          var state = this.states[key];
          var ruleRegExps = [];
          var matchTotal = 0;
          var mapping = this.matchMappings[key] = {defaultToken: "text"};
          var flag = "g";
          var splitterRules = [];
          for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
              mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive)
              flag = "gi";
            if (rule.regex == null)
              continue;
            if (rule.regex instanceof RegExp)
              rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
              if (rule.token.length == 1 || matchcount == 1) {
                rule.token = rule.token[0];
              } else if (matchcount - 1 != rule.token.length) {
                throw new Error("number of classes and regexp groups in '" + rule.token + "'\n'" + rule.regex + "' doesn't match\n" + (matchcount - 1) + "!=" + rule.token.length);
              } else {
                rule.tokenArray = rule.token;
                rule.token = null;
                rule.onMatch = this.$arrayTokens;
              }
            } else if (typeof rule.token === "function" && !rule.onMatch) {
              if (matchcount > 1) {
                rule.onMatch = this.$applyToken;
              } else {
                rule.onMatch = rule.token;
              }
            }
            if (matchcount > 1) {
              if (/\\\d/.test(rule.regex)) {
                adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                  return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                });
              } else {
                matchcount = 1;
                adjustedregex = this.removeCapturingGroups(rule.regex);
              }
              if (!rule.splitRegex && typeof rule.token != "string")
                splitterRules.push(rule);
            }
            mapping[matchTotal] = i;
            matchTotal += matchcount;
            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch)
              rule.onMatch = null;
          }
          if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push("$");
          }
          splitterRules.forEach(function(rule) {
            rule.splitRegex = _this.createSplitterRegexp(rule.regex, flag);
          });
          this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
        }
      }
      Tokenizer.prototype.$setMaxTokenCount = function(m) {
        MAX_TOKEN_COUNT = m | 0;
      };
      Tokenizer.prototype.$applyToken = function(str) {
        var values = this.splitRegex.exec(str).slice(1);
        var types = this.token.apply(this, values);
        if (typeof types === "string") {
          return [{
            type: types,
            value: str
          }];
        }
        var tokens = [];
        for (var i = 0,
            l = types.length; i < l; i++) {
          if (values[i])
            tokens[tokens.length] = {
              type: types[i],
              value: values[i]
            };
        }
        return tokens;
      };
      Tokenizer.prototype.$arrayTokens = function(str) {
        if (!str) {
          return [];
        }
        var values = this.splitRegex.exec(str);
        if (!values)
          return "text";
        var tokens = [];
        var types = this.tokenArray;
        for (var i = 0,
            l = types.length; i < l; i++) {
          if (values[i + 1])
            tokens[tokens.length] = {
              type: types[i],
              value: values[i + 1]
            };
        }
        return tokens;
      };
      Tokenizer.prototype.removeCapturingGroups = function(src) {
        var r = src.replace(/\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g, function(x, y) {
          return y ? "(?:" : x;
        });
        return r;
      };
      Tokenizer.prototype.createSplitterRegexp = function(src, flag) {
        if (src.indexOf("(?=") != -1) {
          var stack = 0;
          var inChClass = false;
          var lastCapture = {};
          src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index) {
            if (inChClass) {
              inChClass = square != "]";
            } else if (square) {
              inChClass = true;
            } else if (parenClose) {
              if (stack == lastCapture.stack) {
                lastCapture.end = index + 1;
                lastCapture.stack = -1;
              }
              stack--;
            } else if (parenOpen) {
              stack++;
              if (parenOpen.length != 1) {
                lastCapture.stack = stack;
                lastCapture.start = index;
              }
            }
            return m;
          });
          if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
            src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        return new RegExp(src, (flag || "").replace("g", ""));
      };
      Tokenizer.prototype.getLineTokens = function(line, startState) {
        var stack;
        if (startState && typeof startState !== 'string') {
          stack = startState.slice(0);
          startState = stack[0];
          if (startState === '#tmp') {
            stack.shift();
            startState = stack.shift();
          }
        } else {
          stack = [];
        }
        var currentState = startState || "start";
        var state = this.states[currentState];
        if (!state) {
          currentState = "start";
          state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;
        var match;
        var tokens = [];
        var lastIndex = 0;
        var token = {
          type: null,
          value: ""
        };
        while (match = re.exec(line)) {
          var type = mapping.defaultToken;
          var rule = null;
          var value = match[0];
          var index = re.lastIndex;
          if (index - value.length > lastIndex) {
            var skipped = line.substring(lastIndex, index - value.length);
            if (token.type == type) {
              token.value += skipped;
            } else {
              if (token.type)
                tokens.push(token);
              token = {
                type: type,
                value: skipped
              };
            }
          }
          for (var i = 0; i < match.length - 2; i++) {
            if (match[i + 1] === undefined)
              continue;
            rule = state[mapping[i]];
            if (rule.onMatch)
              type = rule.onMatch(value, currentState, stack);
            else
              type = rule.token;
            if (rule.next) {
              if (typeof rule.next === 'string') {
                currentState = rule.next;
              } else {
                currentState = rule.next(currentState, stack);
              }
              state = this.states[currentState];
              if (!state) {
                currentState = "start";
                state = this.states[currentState];
              }
              mapping = this.matchMappings[currentState];
              lastIndex = index;
              re = this.regExps[currentState];
              re.lastIndex = index;
            }
            break;
          }
          if (value) {
            if (typeof type == "string") {
              if ((!rule || rule.merge !== false) && token.type === type) {
                token.value += value;
              } else {
                if (token.type)
                  tokens.push(token);
                token = {
                  type: type,
                  value: value
                };
              }
            } else if (type) {
              if (token.type)
                tokens.push(token);
              token = {
                type: null,
                value: ""
              };
              for (var i = 0; i < type.length; i++)
                tokens.push(type[i]);
            }
          }
          if (lastIndex == line.length)
            break;
          lastIndex = index;
          if (tokens.length > MAX_TOKEN_COUNT) {
            while (lastIndex < line.length) {
              if (token.type)
                tokens.push(token);
              token = {
                value: line.substring(lastIndex, lastIndex += 2000),
                type: "overflow"
              };
            }
            currentState = "start";
            stack = [];
            break;
          }
        }
        if (token.type)
          tokens.push(token);
        if (stack.length > 1) {
          if (stack[0] !== currentState) {
            stack.unshift('#tmp', currentState);
          }
        }
        return {
          tokens: tokens,
          state: stack.length ? stack : currentState
        };
      };
      return Tokenizer;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Tokenizer;
  });
  define('TabstopManager', ["require", "exports", "./comparePoints", "./lib/lang/createDelayedCall", "./keyboard/KeyboardHandler", "./Range"], function(require, exports, comparePoints_1, createDelayedCall_1, KeyboardHandler_1, Range_1) {
    "use strict";
    var TabstopManager = (function() {
      function TabstopManager(editor) {
        var _this = this;
        this.keyboardHandler = new KeyboardHandler_1.default();
        this.$onChange = this.onChange.bind(this);
        this.$onChangeSelection = createDelayedCall_1.default(this.onChangeSelection.bind(this)).schedule;
        this.$onChangeSession = this.onChangeSession.bind(this);
        this.$onAfterExec = this.onAfterExec.bind(this);
        this.attach(editor);
        this.keyboardHandler.bindKeys({
          "Tab": function(editor) {
            if (editor.snippetManager && editor.snippetManager.expandWithTab(editor)) {
              return;
            } else {
              _this.tabNext(1);
            }
          },
          "Shift-Tab": function(editor) {
            _this.tabNext(-1);
          },
          "Esc": function(editor) {
            _this.detach();
          },
          "Return": function(editor) {
            editor.tabstopManager.tabNext(1);
            return false;
          }
        });
      }
      TabstopManager.prototype.attach = function(editor) {
        editor.tabstopManager = this;
        this.index = 0;
        this.ranges = [];
        this.tabstops = [];
        this.$openTabstops = null;
        this.selectedTabstop = null;
        this.editor = editor;
        this.editor.on("change", this.$onChange);
        this.editor.on("changeSelection", this.$onChangeSelection);
        this.editor.on("changeSession", this.$onChangeSession);
        this.editor.commands.on("afterExec", this.$onAfterExec);
        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
      };
      TabstopManager.prototype.detach = function() {
        this.tabstops.forEach(this.removeTabstopMarkers, this);
        this.ranges = null;
        this.tabstops = null;
        this.selectedTabstop = null;
        this.editor.off("change", this.$onChange);
        this.editor.off("changeSelection", this.$onChangeSelection);
        this.editor.off("changeSession", this.$onChangeSession);
        this.editor.commands.off("afterExec", this.$onAfterExec);
        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
        this.editor.tabstopManager = null;
        this.editor = null;
      };
      TabstopManager.prototype.onChange = function(delta, editor) {
        var isRemove = delta.action === "remove";
        var start = delta.start;
        var end = delta.end;
        var startRow = start.row;
        var endRow = end.row;
        var lineDif = endRow - startRow;
        var colDiff = end.column - start.column;
        if (isRemove) {
          lineDif = -lineDif;
          colDiff = -colDiff;
        }
        if (!this.$inChange && isRemove) {
          var ts = this.selectedTabstop;
          var changedOutside = ts && !ts.some(function(range) {
            return comparePoints_1.default(range.start, start) <= 0 && comparePoints_1.default(range.end, end) >= 0;
          });
          if (changedOutside)
            return this.detach();
        }
        var ranges = this.ranges;
        for (var i = 0; i < ranges.length; i++) {
          var r = ranges[i];
          if (r.end.row < start.row)
            continue;
          if (isRemove && comparePoints_1.default(start, r.start) < 0 && comparePoints_1.default(end, r.end) > 0) {
            this.removeRange(r);
            i--;
            continue;
          }
          if (r.start.row === startRow && r.start.column > start.column)
            r.start.column += colDiff;
          if (r.end.row === startRow && r.end.column >= start.column)
            r.end.column += colDiff;
          if (r.start.row >= startRow)
            r.start.row += lineDif;
          if (r.end.row >= startRow)
            r.end.row += lineDif;
          if (comparePoints_1.default(r.start, r.end) > 0)
            this.removeRange(r);
        }
        if (!ranges.length)
          this.detach();
      };
      TabstopManager.prototype.updateLinkedFields = function() {
        var ts = this.selectedTabstop;
        if (!ts || !ts.hasLinkedRanges) {
          return;
        }
        this.$inChange = true;
        var session = this.editor.getSession();
        var text = session.getTextRange(ts.firstNonLinked);
        for (var i = ts.length; i--; ) {
          var range = ts[i];
          if (!range.linked) {
            continue;
          }
          var fmt = this.editor.snippetManager.tmStrFormat(text, range.original);
          session.replace(range, fmt);
        }
        this.$inChange = false;
      };
      TabstopManager.prototype.onAfterExec = function(e) {
        if (e.command && !e.command.readOnly)
          this.updateLinkedFields();
      };
      TabstopManager.prototype.onChangeSelection = function(event, editor) {
        if (!this.editor)
          return;
        var lead = this.editor.selection.lead;
        var anchor = this.editor.selection.anchor;
        var isEmpty = this.editor.selection.isEmpty();
        for (var i = this.ranges.length; i--; ) {
          if (this.ranges[i].linked)
            continue;
          var containsLead = this.ranges[i].contains(lead.row, lead.column);
          var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
          if (containsLead && containsAnchor)
            return;
        }
        this.detach();
      };
      TabstopManager.prototype.onChangeSession = function(event, editor) {
        this.detach();
      };
      TabstopManager.prototype.tabNext = function(dir) {
        var max = this.tabstops.length;
        var index = this.index + (dir || 1);
        index = Math.min(Math.max(index, 1), max);
        if (index === max) {
          index = 0;
        }
        this.selectTabstop(index);
        if (index === 0) {
          this.detach();
        }
      };
      TabstopManager.prototype.selectTabstop = function(index) {
        this.$openTabstops = null;
        var ts = this.tabstops[this.index];
        if (ts) {
          this.addTabstopMarkers(ts);
        }
        this.index = index;
        ts = this.tabstops[this.index];
        if (!ts || !ts.length) {
          return;
        }
        this.selectedTabstop = ts;
        if (!this.editor.inVirtualSelectionMode) {
          var sel = this.editor.multiSelect;
          sel.toSingleRange(ts.firstNonLinked.clone());
          for (var i = ts.length; i--; ) {
            if (ts.hasLinkedRanges && ts[i].linked) {
              continue;
            }
            sel.addRange(ts[i].clone(), true);
          }
          if (sel.ranges[0])
            sel.addRange(sel.ranges[0].clone());
        } else {
          this.editor.selection.setRange(ts.firstNonLinked);
        }
        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
      };
      TabstopManager.prototype.addTabstops = function(tabstops, start, end, selectionIndex) {
        var _this = this;
        if (!this.$openTabstops) {
          this.$openTabstops = [];
        }
        if (!tabstops[0]) {
          var p = Range_1.default.fromPoints(end, end);
          moveRelative(p.start, start);
          moveRelative(p.end, start);
          tabstops[0] = [p];
          tabstops[0].index = 0;
        }
        var i = this.index;
        var arg = [i + 1, 0];
        var ranges = this.ranges;
        tabstops.forEach(function(ts, index) {
          var dest = _this.$openTabstops[index] || ts;
          for (var i = ts.length; i--; ) {
            var originalRange = ts[i];
            var range = Range_1.default.fromPoints(originalRange.start, originalRange.end || originalRange.start);
            movePoint(range.start, start);
            movePoint(range.end, start);
            range.original = originalRange;
            range.tabstop = dest;
            ranges.push(range);
            if (dest !== ts)
              dest.unshift(range);
            else
              dest[i] = range;
            if (originalRange.fmtString) {
              range.linked = true;
              dest.hasLinkedRanges = true;
            } else if (!dest.firstNonLinked) {
              dest.firstNonLinked = range;
            }
          }
          if (!dest.firstNonLinked)
            dest.hasLinkedRanges = false;
          if (dest === ts) {
            arg.push(dest);
            _this.$openTabstops[index] = dest;
          }
          _this.addTabstopMarkers(dest);
        });
        if (arg.length > 2) {
          if (this.tabstops.length)
            arg.push(arg.splice(2, 1)[0]);
          this.tabstops.splice.apply(this.tabstops, arg);
        }
      };
      TabstopManager.prototype.addTabstopMarkers = function(ts) {
        var session = this.editor.session;
        ts.forEach(function(range) {
          if (!range.markerId) {
            range.markerId = session.addMarker(range, "ace_snippet-marker", "text");
          }
        });
      };
      TabstopManager.prototype.removeTabstopMarkers = function(ts) {
        var session = this.editor.session;
        ts.forEach(function(range) {
          session.removeMarker(range.markerId);
          range.markerId = null;
        });
      };
      TabstopManager.prototype.removeRange = function(range) {
        var i = range.tabstop.indexOf(range);
        range.tabstop.splice(i, 1);
        i = this.ranges.indexOf(range);
        this.ranges.splice(i, 1);
        this.editor.session.removeMarker(range.markerId);
        if (!range.tabstop.length) {
          i = this.tabstops.indexOf(range.tabstop);
          if (i != -1)
            this.tabstops.splice(i, 1);
          if (!this.tabstops.length)
            this.detach();
        }
      };
      return TabstopManager;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = TabstopManager;
    var movePoint = function(point, diff) {
      if (point.row === 0)
        point.column += diff.column;
      point.row += diff.row;
    };
    var moveRelative = function(point, start) {
      if (point.row == start.row)
        point.column -= start.column;
      point.row -= start.row;
    };
  });
  define('SnippetManager', ["require", "exports", "./lib/EventEmitterClass", "./lib/lang", "./Tokenizer", "./TabstopManager"], function(require, exports, EventEmitterClass_1, lang_1, Tokenizer_1, TabstopManager_1) {
    "use strict";
    var INCLUDE_SCOPES = 'includeScopes';
    function escape(ch) {
      return "(?:[^\\\\" + ch + "]|\\\\.)";
    }
    function tabstopTokenArray(str, _, stack) {
      str = str.substr(1);
      if (/^\d+$/.test(str) && !stack.inFormatString) {
        return [{tabstopId: parseInt(str, 10)}];
      }
      return [{text: str}];
    }
    var SnippetManager = (function() {
      function SnippetManager() {
        this.snippetMap = {};
        this.snippetNameMap = {};
        this.variables = {};
        this.eventBus = new EventEmitterClass_1.default(this);
      }
      SnippetManager.prototype.getTokenizer = function() {
        SnippetManager.prototype.getTokenizer = function() {
          return SnippetManager.$tokenizer;
        };
        return SnippetManager.$tokenizer;
      };
      SnippetManager.prototype.tokenizeTmSnippet = function(str, startState) {
        return this.getTokenizer().getLineTokens(str, startState).tokens.map(function(x) {
          return x.value || x;
        });
      };
      SnippetManager.prototype.$getDefaultValue = function(editor, name) {
        if (/^[A-Z]\d+$/.test(name)) {
          var i = name.substr(1);
          return (this.variables[name[0] + "__"] || {})[i];
        }
        if (/^\d+$/.test(name)) {
          return (this.variables['__'] || {})[name];
        }
        name = name.replace(/^TM_/, "");
        if (!editor)
          return;
        var s = editor.session;
        switch (name) {
          case "CURRENT_WORD":
            var r = s.getWordRange(editor.getCursorPosition().row, editor.getCursorPosition().column);
          case "SELECTION":
          case "SELECTED_TEXT":
            return s.getTextRange(r);
          case "CURRENT_LINE":
            return s.getLine(editor.getCursorPosition().row);
          case "PREV_LINE":
            return s.getLine(editor.getCursorPosition().row - 1);
          case "LINE_INDEX":
            return editor.getCursorPosition().column;
          case "LINE_NUMBER":
            return editor.getCursorPosition().row + 1;
          case "SOFT_TABS":
            return s.getUseSoftTabs() ? "YES" : "NO";
          case "TAB_SIZE":
            return s.getTabSize();
          case "FILENAME":
          case "FILEPATH":
            return "";
          case "FULLNAME":
            return "Ace";
        }
      };
      SnippetManager.prototype.getVariableValue = function(editor, varName) {
        if (this.variables.hasOwnProperty(varName))
          return this.variables[varName](editor, varName) || "";
        return this.$getDefaultValue(editor, varName) || "";
      };
      SnippetManager.prototype.tmStrFormat = function(str, ch, editor) {
        var flag = ch.flag || "";
        var re = new RegExp(ch.guard, flag.replace(/[^gi]/, ""));
        var fmtTokens = this.tokenizeTmSnippet(ch.fmt, "formatString");
        var self = this;
        var formatted = str.replace(re, function() {
          self.variables['__'] = arguments;
          var fmtParts = self.resolveVariables(fmtTokens, editor);
          var gChangeCase = "E";
          for (var i = 0; i < fmtParts.length; i++) {
            var ch = fmtParts[i];
            if (typeof ch === "object") {
              fmtParts[i] = "";
              if (ch.changeCase && ch.local) {
                var next = fmtParts[i + 1];
                if (next && typeof next == "string") {
                  if (ch.changeCase === "u")
                    fmtParts[i] = next[0].toUpperCase();
                  else
                    fmtParts[i] = next[0].toLowerCase();
                  fmtParts[i + 1] = next.substr(1);
                }
              } else if (ch.changeCase) {
                gChangeCase = ch.changeCase;
              }
            } else if (gChangeCase === "U") {
              fmtParts[i] = ch.toUpperCase();
            } else if (gChangeCase === "L") {
              fmtParts[i] = ch.toLowerCase();
            }
          }
          return fmtParts.join("");
        });
        self.variables['__'] = null;
        return formatted;
      };
      SnippetManager.prototype.resolveVariables = function(snippet, editor) {
        var result = [];
        for (var i = 0; i < snippet.length; i++) {
          var ch = snippet[i];
          if (typeof ch == "string") {
            result.push(ch);
          } else if (typeof ch != "object") {
            continue;
          } else if (ch.skip) {
            gotoNext(ch);
          } else if (ch.processed < i) {
            continue;
          } else if (ch.text) {
            var value = this.getVariableValue(editor, ch.text);
            if (value && ch.fmtString)
              value = this.tmStrFormat(value, ch);
            ch.processed = i;
            if (ch.expectIf == null) {
              if (value) {
                result.push(value);
                gotoNext(ch);
              }
            } else {
              if (value) {
                ch.skip = ch.elseBranch;
              } else
                gotoNext(ch);
            }
          } else if (ch.tabstopId != null) {
            result.push(ch);
          } else if (ch.changeCase != null) {
            result.push(ch);
          }
        }
        function gotoNext(ch) {
          var i1 = snippet.indexOf(ch, i + 1);
          if (i1 != -1)
            i = i1;
        }
        return result;
      };
      SnippetManager.prototype.insertSnippetForSelection = function(editor, snippetText) {
        var cursor = editor.getCursorPosition();
        var session = editor.getSession();
        var line = session.getLine(cursor.row);
        var tabString = session.getTabString();
        var indentString = line.match(/^\s*/)[0];
        if (cursor.column < indentString.length)
          indentString = indentString.slice(0, cursor.column);
        var tokens = this.tokenizeTmSnippet(snippetText);
        tokens = this.resolveVariables(tokens, editor);
        tokens = tokens.map(function(x) {
          if (x == "\n") {
            return x + indentString;
          }
          if (typeof x === "string") {
            return x.replace(/\t/g, tabString);
          }
          return x;
        });
        var tabstops = [];
        tokens.forEach(function(p, i) {
          if (typeof p != "object")
            return;
          var id = p.tabstopId;
          var ts = tabstops[id];
          if (!ts) {
            ts = tabstops[id] = [];
            ts.index = id;
            ts.value = "";
          }
          if (ts.indexOf(p) !== -1)
            return;
          ts.push(p);
          var i1 = tokens.indexOf(p, i + 1);
          if (i1 === -1)
            return;
          var value = tokens.slice(i + 1, i1);
          var isNested = value.some(function(t) {
            return typeof t === "object";
          });
          if (isNested && !ts.value) {
            ts.value = value;
          } else if (value.length && (!ts.value || typeof ts.value !== "string")) {
            ts.value = value.join("");
          }
        });
        tabstops.forEach(function(ts) {
          ts.length = 0;
        });
        var expanding = {};
        function copyValue(val) {
          var copy = [];
          for (var i = 0; i < val.length; i++) {
            var p = val[i];
            if (typeof p === "object") {
              if (expanding[p.tabstopId])
                continue;
              var j = val.lastIndexOf(p, i - 1);
              p = copy[j] || {tabstopId: p.tabstopId};
            }
            copy[i] = p;
          }
          return copy;
        }
        for (var i = 0; i < tokens.length; i++) {
          var p = tokens[i];
          if (typeof p !== "object")
            continue;
          var id = p.tabstopId;
          var i1 = tokens.indexOf(p, i + 1);
          if (expanding[id]) {
            if (expanding[id] === p)
              expanding[id] = null;
            continue;
          }
          var ts = tabstops[id];
          var arg = (typeof ts.value === "string") ? [ts.value] : copyValue(ts.value);
          arg.unshift(i + 1, Math.max(0, i1 - i));
          arg.push(p);
          expanding[id] = p;
          tokens.splice.apply(tokens, arg);
          if (ts.indexOf(p) === -1)
            ts.push(p);
        }
        var row = 0,
            column = 0;
        var text = "";
        tokens.forEach(function(t) {
          if (typeof t === "string") {
            if (t[0] === "\n") {
              column = t.length - 1;
              row++;
            } else
              column += t.length;
            text += t;
          } else {
            if (!t.start)
              t.start = {
                row: row,
                column: column
              };
            else
              t.end = {
                row: row,
                column: column
              };
          }
        });
        var range = editor.getSelectionRange();
        var end = editor.getSession().replace(range, text);
        var tsManager = editor.tabstopManager ? editor.tabstopManager : new TabstopManager_1.default(editor);
        var selectionId = editor.inVirtualSelectionMode && editor.selection.index;
        tsManager.addTabstops(tabstops, range.start, end, selectionId);
      };
      SnippetManager.prototype.insertSnippet = function(editor, snippetText, options) {
        var _this = this;
        if (editor.inVirtualSelectionMode) {
          return this.insertSnippetForSelection(editor, snippetText);
        }
        editor.forEachSelection(function() {
          _this.insertSnippetForSelection(editor, snippetText);
        }, null, {keepOrder: true});
        if (editor.tabstopManager) {
          editor.tabstopManager.tabNext();
        }
      };
      SnippetManager.prototype.$getScope = function(editor) {
        var session = editor.getSession();
        var scope = session.$mode.$id || "";
        scope = scope.split("/").pop();
        if (scope === "html" || scope === "php") {
          if (scope === "php" && !session.$mode['inlinePhp'])
            scope = "html";
          var c = editor.getCursorPosition();
          var state = session.getState(c.row);
          if (typeof state === "object") {
            state = state[0];
          }
          if (state.substring) {
            if (state.substring(0, 3) == "js-")
              scope = "javascript";
            else if (state.substring(0, 4) == "css-")
              scope = "css";
            else if (state.substring(0, 4) == "php-")
              scope = "php";
          }
        }
        return scope;
      };
      SnippetManager.prototype.getActiveScopes = function(editor) {
        var scope = this.$getScope(editor);
        var scopes = [scope];
        var snippetMap = this.snippetMap;
        if (snippetMap[scope] && snippetMap[scope][INCLUDE_SCOPES]) {
          scopes.push.apply(scopes, snippetMap[scope][INCLUDE_SCOPES]);
        }
        scopes.push("_");
        return scopes;
      };
      SnippetManager.prototype.expandWithTab = function(editor, options) {
        var _this = this;
        var result = editor.forEachSelection(function() {
          return _this.expandSnippetForSelection(editor, options);
        }, null, {keepOrder: true});
        if (result && editor.tabstopManager) {
          editor.tabstopManager.tabNext();
        }
        return result;
      };
      SnippetManager.prototype.expandSnippetForSelection = function(editor, options) {
        var _this = this;
        var cursor = editor.getCursorPosition();
        var session = editor.getSession();
        var line = session.getLine(cursor.row);
        var before = line.substring(0, cursor.column);
        var after = line.substr(cursor.column);
        var snippetMap = this.snippetMap;
        var snippet;
        var scopes = this.getActiveScopes(editor);
        scopes.some(function(scope) {
          var snippets = snippetMap[scope];
          if (snippets) {
            snippet = _this.findMatchingSnippet(snippets, before, after);
          }
          return !!snippet;
        });
        if (!snippet) {
          return false;
        }
        if (options && options.dryRun) {
          return true;
        }
        session.doc.removeInLine(cursor.row, cursor.column - snippet.replaceBefore.length, cursor.column + snippet.replaceAfter.length);
        this.variables['M__'] = snippet.matchBefore;
        this.variables['T__'] = snippet.matchAfter;
        this.insertSnippetForSelection(editor, snippet.content);
        this.variables['M__'] = this.variables['T__'] = null;
        return true;
      };
      SnippetManager.prototype.findMatchingSnippet = function(snippetList, before, after) {
        for (var i = snippetList.length; i--; ) {
          var s = snippetList[i];
          if (s.startRe && !s.startRe.test(before))
            continue;
          if (s.endRe && !s.endRe.test(after))
            continue;
          if (!s.startRe && !s.endRe)
            continue;
          s.matchBefore = s.startRe ? s.startRe.exec(before) : [""];
          s.matchAfter = s.endRe ? s.endRe.exec(after) : [""];
          s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : "";
          s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : "";
          return s;
        }
      };
      SnippetManager.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      SnippetManager.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      SnippetManager.prototype.register = function(snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;
        var self = this;
        function wrapRegexp(src) {
          if (src && !/^\^?\(.*\)\$?$|^\\b$/.test(src))
            src = "(?:" + src + ")";
          return src || "";
        }
        function guardedRegexp(re, guard, opening) {
          re = wrapRegexp(re);
          guard = wrapRegexp(guard);
          if (opening) {
            re = guard + re;
            if (re && re[re.length - 1] != "$")
              re = re + "$";
          } else {
            re = re + guard;
            if (re && re[0] != "^")
              re = "^" + re;
          }
          return new RegExp(re);
        }
        function addSnippet(s) {
          if (!s.scope)
            s.scope = scope || "_";
          scope = s.scope;
          if (!snippetMap[scope]) {
            snippetMap[scope] = [];
            snippetNameMap[scope] = {};
          }
          var map = snippetNameMap[scope];
          if (s.name) {
            var existingSnippet = map[s.name];
            if (existingSnippet) {
              self.unregister([existingSnippet]);
            }
            map[s.name] = s;
          }
          snippetMap[scope].push(s);
          if (s.tabTrigger && !s.trigger) {
            if (!s.guard && /^\w/.test(s.tabTrigger))
              s.guard = "\\b";
            s.trigger = lang_1.escapeRegExp(s.tabTrigger);
          }
          s.startRe = guardedRegexp(s.trigger, s.guard, true);
          s.triggerRe = new RegExp(s.trigger, "");
          s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
          s.endTriggerRe = new RegExp(s.endTrigger, "");
        }
        if (Array.isArray(snippets)) {
          snippets.forEach(addSnippet);
        } else {
          throw new TypeError("snippets must be an array of Snippet.");
        }
        this.eventBus._signal("registerSnippets", {scope: scope});
      };
      SnippetManager.prototype.unregister = function(snippets, scope) {
        var snippetMap = this.snippetMap;
        var snippetNameMap = this.snippetNameMap;
        function removeSnippet(s) {
          var nameMap = snippetNameMap[s.scope || scope];
          if (nameMap && nameMap[s.name]) {
            delete nameMap[s.name];
            var map = snippetMap[s.scope || scope];
            var i = map && map.indexOf(s);
            if (i >= 0)
              map.splice(i, 1);
          }
        }
        if (Array.isArray(snippets)) {
          snippets.forEach(removeSnippet);
        } else {
          throw new TypeError("snippets must be an array of Snippet.");
        }
      };
      SnippetManager.prototype.parseSnippetFile = function(str) {
        str = str.replace(/\r/g, "");
        var list = [];
        var snippet = {};
        var re = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
        var m;
        while (m = re.exec(str)) {
          if (m[1]) {
            try {
              snippet = JSON.parse(m[1]);
              list.push(snippet);
            } catch (e) {}
          }
          if (m[4]) {
            snippet.content = m[4].replace(/^\t/gm, "");
            list.push(snippet);
            snippet = {};
          } else {
            var key = m[2];
            var val = m[3];
            if (typeof key === 'string') {
              if (key === "regex") {
                var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                snippet.guard = guardRe.exec(val)[1];
                snippet.trigger = guardRe.exec(val)[1];
                snippet.endTrigger = guardRe.exec(val)[1];
                snippet.endGuard = guardRe.exec(val)[1];
              } else if (key === "snippet") {
                snippet.tabTrigger = val.match(/^\S*/)[0];
                if (!snippet.name) {
                  snippet.name = val;
                }
              } else {
                snippet[key] = val;
              }
            } else {}
          }
        }
        return list;
      };
      SnippetManager.prototype.getSnippetByName = function(name, editor) {
        var _this = this;
        var snippet;
        this.getActiveScopes(editor).some(function(scope) {
          var snippets = _this.snippetNameMap[scope];
          if (snippets) {
            snippet = snippets[name];
          }
          return !!snippet;
        }, this);
        return snippet;
      };
      SnippetManager.$tokenizer = new Tokenizer_1.default({
        start: [{
          regex: /:/,
          onMatch: function(value, state, stack) {
            if (stack.length && stack[0].expectIf) {
              stack[0].expectIf = false;
              stack[0].elseBranch = stack[0];
              return [stack[0]];
            }
            return ":";
          }
        }, {
          regex: /\\./,
          onMatch: function(value, state, stack) {
            var ch = value[1];
            if (ch == "}" && stack.length) {
              return [ch];
            } else if ("`$\\".indexOf(ch) != -1) {
              return [ch];
            } else if (stack.inFormatString) {
              if (ch == "n")
                return ["\n"];
              else if (ch == "t")
                return ["\n"];
              else if ("ulULE".indexOf(ch) != -1) {
                return [{
                  changeCase: ch,
                  local: ch > "a"
                }];
              }
            } else {
              return [value];
            }
          }
        }, {
          regex: /}/,
          onMatch: function(val, state, stack) {
            return [stack.length ? stack.shift() : val];
          }
        }, {
          regex: /\$(?:\d+|\w+)/,
          onMatch: tabstopTokenArray
        }, {
          regex: /\$\{[\dA-Z_a-z]+/,
          onMatch: function(value, state, stack) {
            var tokens = tabstopTokenArray(value.substr(1), state, stack);
            stack.unshift(tokens[0]);
            return tokens;
          },
          next: "snippetVar"
        }, {
          regex: /\n/,
          token: "newline",
          merge: false
        }],
        snippetVar: [{
          regex: "\\|" + escape("\\|") + "*\\|",
          onMatch: function(val, state, stack) {
            stack[0].choices = val.slice(1, -1).split(",");
          },
          next: "start"
        }, {
          regex: "/(" + escape("/") + "+)/(?:(" + escape("/") + "*)/)(\\w*):?",
          onMatch: function(value, state, stack) {
            var ts = stack[0];
            ts.fmtString = value;
            value = this.splitRegex.exec(value);
            ts.guard = value[1];
            ts.fmt = value[2];
            ts.flag = value[3];
            return "";
          },
          next: "start"
        }, {
          regex: "`" + escape("`") + "*`",
          onMatch: function(value, state, stack) {
            stack[0].code = value.splice(1, -1);
            return "";
          },
          next: "start"
        }, {
          regex: "\\?",
          onMatch: function(val, state, stack) {
            if (stack[0])
              stack[0].expectIf = true;
          },
          next: "start"
        }, {
          regex: "([^:}\\\\]|\\\\.)*:?",
          token: "",
          next: "start"
        }],
        formatString: [{
          regex: "/(" + escape("/") + "+)/",
          token: "regex"
        }, {
          regex: "",
          onMatch: function(val, state, stack) {
            stack.inFormatString = true;
          },
          next: "start"
        }]
      });
      return SnippetManager;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = SnippetManager;
  });
  define('hammer/utils', ["require", "exports"], function(require, exports) {
    "use strict";
    var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
    exports.TEST_ELEMENT = document.createElement('div');
    var TYPE_FUNCTION = 'function';
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    function setTimeoutContext(fn, timeout, context) {
      return setTimeout(bindFn(fn, context), timeout);
    }
    exports.setTimeoutContext = setTimeoutContext;
    function invokeArrayArg(arg, fn, context) {
      if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
      }
      return false;
    }
    exports.invokeArrayArg = invokeArrayArg;
    function each(obj, iterator, context) {
      var i;
      if (!obj) {
        return;
      }
      if (obj.forEach) {
        obj.forEach(iterator, context);
      } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
          iterator.call(context, obj[i], i, obj);
          i++;
        }
      } else {
        for (i in obj) {
          obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
      }
    }
    exports.each = each;
    function extend(dest, src, merge) {
      var keys = Object.keys(src);
      var i = 0;
      while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
          dest[keys[i]] = src[keys[i]];
        }
        i++;
      }
      return dest;
    }
    exports.extend = extend;
    function merge(dest, src) {
      return extend(dest, src, true);
    }
    exports.merge = merge;
    function inherit(child, base, properties) {
      var baseP = base.prototype,
          childP;
      childP = child.prototype = Object.create(baseP);
      childP.constructor = child;
      childP._super = baseP;
      if (properties) {
        extend(childP, properties);
      }
    }
    exports.inherit = inherit;
    function bindFn(fn, context) {
      return function boundFn() {
        return fn.apply(context, arguments);
      };
    }
    exports.bindFn = bindFn;
    function ifUndefined(val1, val2) {
      return (val1 === undefined) ? val2 : val1;
    }
    exports.ifUndefined = ifUndefined;
    function addEventListeners(eventTarget, types, handler) {
      each(splitStr(types), function(type) {
        eventTarget.addEventListener(type, handler, false);
      });
    }
    exports.addEventListeners = addEventListeners;
    function removeEventListeners(eventTarget, types, handler) {
      each(splitStr(types), function(type) {
        eventTarget.removeEventListener(type, handler, false);
      });
    }
    exports.removeEventListeners = removeEventListeners;
    function hasParent(node, parent) {
      while (node) {
        if (node == parent) {
          return true;
        }
        node = node.parentNode;
      }
      return false;
    }
    exports.hasParent = hasParent;
    function inStr(str, find) {
      return str.indexOf(find) > -1;
    }
    exports.inStr = inStr;
    function splitStr(str) {
      return str.trim().split(/\s+/g);
    }
    exports.splitStr = splitStr;
    function inArray(src, find, findByKey) {
      if (src.indexOf && !findByKey) {
        return src.indexOf(find);
      } else {
        var i = 0;
        while (i < src.length) {
          if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
            return i;
          }
          i++;
        }
        return -1;
      }
    }
    exports.inArray = inArray;
    function toArray(obj) {
      return Array.prototype.slice.call(obj, 0);
    }
    exports.toArray = toArray;
    function uniqueArray(src, key, sort) {
      var results = [];
      var values = [];
      var i = 0;
      while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
          results.push(src[i]);
        }
        values[i] = val;
        i++;
      }
      if (sort) {
        if (!key) {
          results = results.sort();
        } else {
          results = results.sort(function sortUniqueArray(a, b) {
            return a[key] > b[key] ? 1 : 0;
          });
        }
      }
      return results;
    }
    exports.uniqueArray = uniqueArray;
    function prefixed(obj, property) {
      var prefix,
          prop;
      var camelProp = property[0].toUpperCase() + property.slice(1);
      var i = 0;
      while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;
        if (prop in obj) {
          return prop;
        }
        i++;
      }
      return undefined;
    }
    exports.prefixed = prefixed;
    var _uniqueId = 1;
    function uniqueId() {
      return _uniqueId++;
    }
    exports.uniqueId = uniqueId;
    function getWindowForElement(element) {
      var doc = element.ownerDocument;
      if (doc) {
        return doc.defaultView || window;
      } else {
        return window;
      }
    }
    exports.getWindowForElement = getWindowForElement;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('hammer/hammer', ["require", "exports", './utils'], function(require, exports, utils_1) {
    "use strict";
    exports.TOUCH_ACTION_COMPUTE = 'compute';
    exports.TOUCH_ACTION_AUTO = 'auto';
    exports.TOUCH_ACTION_MANIPULATION = 'manipulation';
    exports.TOUCH_ACTION_NONE = 'none';
    exports.TOUCH_ACTION_PAN_X = 'pan-x';
    exports.TOUCH_ACTION_PAN_Y = 'pan-y';
    var STOP = 1;
    var FORCED_STOP = 2;
    var VectorE2 = (function() {
      function VectorE2(x, y) {
        this.x = x;
        this.y = y;
      }
      VectorE2.prototype.add = function(other) {
        return new VectorE2(this.x + other.x, this.y + other.y);
      };
      VectorE2.prototype.sub = function(other) {
        return new VectorE2(this.x - other.x, this.y - other.y);
      };
      VectorE2.prototype.div = function(other) {
        return new VectorE2(this.x / other, this.y / other);
      };
      VectorE2.prototype.dot = function(other) {
        return this.x * other.x + this.y * other.y;
      };
      VectorE2.prototype.norm = function() {
        return Math.sqrt(this.quadrance());
      };
      VectorE2.prototype.quadrance = function() {
        return this.x * this.x + this.y * this.y;
      };
      VectorE2.prototype.toString = function() {
        return 'VectorE2(' + this.x + ', ' + this.y + ')';
      };
      return VectorE2;
    }());
    exports.VectorE2 = VectorE2;
    var ClientLocation = (function() {
      function ClientLocation(clientX, clientY) {
        this.clientX = clientX;
        this.clientY = clientY;
      }
      ClientLocation.prototype.moveTo = function(clientX, clientY) {
        this.clientX = clientX;
        this.clientY = clientY;
      };
      ClientLocation.prototype.sub = function(other) {
        return new VectorE2(this.clientX - other.clientX, this.clientY - other.clientY);
      };
      ClientLocation.fromTouch = function(touch) {
        return new ClientLocation(touch.clientX, touch.clientY);
      };
      ClientLocation.prototype.toString = function() {
        return 'ClientLocation(' + this.clientX + ', ' + this.clientY + ')';
      };
      return ClientLocation;
    }());
    exports.ClientLocation = ClientLocation;
    var Session = (function() {
      function Session() {
        this.compEvents = [];
        this.reset();
      }
      Session.prototype.reset = function() {
        this.startTime = Date.now();
        this.compEvents = [];
        this.curRecognizer = undefined;
      };
      Session.prototype.push = function(compEvent) {
        this.compEvents.push(compEvent);
      };
      Session.prototype.computeMovement = function(center) {
        if (center) {
          if (this.compEvents.length > 0) {
            var prev = this.compEvents[this.compEvents.length - 1];
            return center.sub(prev.center);
          } else {
            return undefined;
          }
        } else {
          return undefined;
        }
      };
      Session.prototype.computeVelocity = function(center, deltaTime) {
        if (center) {
          if (this.compEvents.length > 0) {
            var prev = this.compEvents[this.compEvents.length - 1];
            return center.sub(prev.center).div(deltaTime - prev.deltaTime);
          } else {
            return undefined;
          }
        } else {
          return undefined;
        }
      };
      return Session;
    }());
    exports.Session = Session;
    var Manager = (function() {
      function Manager(element) {
        this.handlers = {};
        this.session = new Session();
        this.recognizers = [];
        this.domEvents = false;
        this.enable = true;
        this.cssProps = {};
        this.element = element;
        this.inputTarget = element;
        this.input = new TouchInput(this, inputHandler);
        this.touchAction = new TouchAction(this, exports.TOUCH_ACTION_COMPUTE);
        this.toggleCssProps(true);
      }
      Manager.prototype.stop = function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
      };
      Manager.prototype.recognize = function(inputData, touchEvent) {
        var session = this.session;
        if (session.stopped) {
          return;
        }
        this.touchAction.preventDefaults(inputData, touchEvent);
        var recognizer;
        var recognizers = this.recognizers;
        var curRecognizer = session.curRecognizer;
        if (!curRecognizer || (curRecognizer && curRecognizer.state & exports.STATE_RECOGNIZED)) {
          curRecognizer = session.curRecognizer = null;
        }
        var i = 0;
        while (i < recognizers.length) {
          recognizer = recognizers[i];
          if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
            recognizer.recognize(inputData);
          } else {
            recognizer.reset();
          }
          if (!curRecognizer && recognizer.state & (exports.STATE_BEGAN | exports.STATE_CHANGED | exports.STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = recognizer;
          }
          i++;
        }
      };
      Manager.prototype.get = function(eventName) {
        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
          if (recognizers[i].eventName === eventName) {
            return recognizers[i];
          }
        }
        return null;
      };
      Manager.prototype.add = function(recognizer) {
        var existing = this.get(recognizer.eventName);
        if (existing) {
          this.remove(existing);
        }
        this.recognizers.push(recognizer);
        recognizer.manager = this;
        this.touchAction.update();
        return recognizer;
      };
      Manager.prototype.remove = function(recognizer) {
        var recognizers = this.recognizers;
        recognizer = this.get(recognizer.eventName);
        recognizers.splice(utils_1.inArray(recognizers, recognizer), 1);
        this.touchAction.update();
        return this;
      };
      Manager.prototype.on = function(events, handler) {
        var handlers = this.handlers;
        utils_1.each(utils_1.splitStr(events), function(event) {
          handlers[event] = handlers[event] || [];
          handlers[event].push(handler);
        });
        return this;
      };
      Manager.prototype.off = function(events, handler) {
        var handlers = this.handlers;
        utils_1.each(utils_1.splitStr(events), function(event) {
          if (!handler) {
            delete handlers[event];
          } else {
            handlers[event].splice(utils_1.inArray(handlers[event], handler), 1);
          }
        });
        return this;
      };
      Manager.prototype.emit = function(eventName, data) {
        if (this.domEvents) {
          triggerDomEvent(event, data);
        }
        var handlers = this.handlers[eventName] && this.handlers[eventName].slice();
        if (!handlers || !handlers.length) {
          return;
        }
        var i = 0;
        while (i < handlers.length) {
          handlers[i](data);
          i++;
        }
      };
      Manager.prototype.updateTouchAction = function() {
        this.touchAction.update();
      };
      Manager.prototype.destroy = function() {
        this.element && this.toggleCssProps(false);
        this.handlers = {};
        this.session = undefined;
        this.input.destroy();
        this.element = null;
      };
      Manager.prototype.toggleCssProps = function(add) {
        if (!this.element.style) {
          return;
        }
        var element = this.element;
        utils_1.each(this.cssProps, function(value, name) {
          element.style[utils_1.prefixed(element.style, name)] = add ? value : '';
        });
      };
      Manager.prototype.cancelContextMenu = function() {};
      return Manager;
    }());
    exports.Manager = Manager;
    function triggerDomEvent(event, data) {
      var gestureEvent = document.createEvent('Event');
      gestureEvent.initEvent(event, true, true);
      gestureEvent['gesture'] = data;
      data.target.dispatchEvent(gestureEvent);
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = ('ontouchstart' in window);
    var SUPPORT_POINTER_EVENTS = utils_1.prefixed(window, 'PointerEvent') !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var PREFIXED_TOUCH_ACTION = utils_1.prefixed(utils_1.TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    var TouchAction = (function() {
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype.set = function(value) {
        if (value === exports.TOUCH_ACTION_COMPUTE) {
          value = this.compute();
        }
        if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
          this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
      };
      TouchAction.prototype.update = function() {
        this.set(exports.TOUCH_ACTION_COMPUTE);
      };
      TouchAction.prototype.compute = function() {
        var actions = [];
        utils_1.each(this.manager.recognizers, function(recognizer) {
          if (recognizer.enabled) {
            actions = actions.concat(recognizer.getTouchAction());
          }
        });
        return cleanTouchActions(actions.join(' '));
      };
      TouchAction.prototype.preventDefaults = function(input, touchEvent) {
        if (NATIVE_TOUCH_ACTION) {
          return;
        }
        if (this.prevented) {
          touchEvent.preventDefault();
          return;
        }
      };
      TouchAction.prototype.preventSrc = function(srcEvent) {
        this.prevented = true;
        srcEvent.preventDefault();
      };
      return TouchAction;
    }());
    function cleanTouchActions(actions) {
      if (utils_1.inStr(actions, exports.TOUCH_ACTION_NONE)) {
        return exports.TOUCH_ACTION_NONE;
      }
      var hasPanX = utils_1.inStr(actions, exports.TOUCH_ACTION_PAN_X);
      var hasPanY = utils_1.inStr(actions, exports.TOUCH_ACTION_PAN_Y);
      if (hasPanX && hasPanY) {
        return exports.TOUCH_ACTION_PAN_X + ' ' + exports.TOUCH_ACTION_PAN_Y;
      }
      if (hasPanX || hasPanY) {
        return hasPanX ? exports.TOUCH_ACTION_PAN_X : exports.TOUCH_ACTION_PAN_Y;
      }
      if (utils_1.inStr(actions, exports.TOUCH_ACTION_MANIPULATION)) {
        return exports.TOUCH_ACTION_MANIPULATION;
      }
      return exports.TOUCH_ACTION_AUTO;
    }
    exports.INPUT_TYPE_TOUCH = 'touch';
    exports.INPUT_TYPE_PEN = 'pen';
    exports.INPUT_TYPE_MOUSE = 'mouse';
    exports.INPUT_TYPE_KINECT = 'kinect';
    var COMPUTE_INTERVAL = 25;
    exports.INPUT_START = 1;
    exports.INPUT_MOVE = 2;
    exports.INPUT_END = 4;
    exports.INPUT_CANCEL = 8;
    function decodeEventType(eventType) {
      switch (eventType) {
        case exports.INPUT_START:
          {
            return "START";
          }
        case exports.INPUT_MOVE:
          {
            return "MOVE";
          }
        case exports.INPUT_END:
          {
            return "END";
          }
        case exports.INPUT_CANCEL:
          {
            return "CANCEL";
          }
        default:
          {
            return "eventType=" + eventType;
          }
      }
    }
    exports.decodeEventType = decodeEventType;
    exports.DIRECTION_UNDEFINED = 0;
    exports.DIRECTION_LEFT = 1;
    exports.DIRECTION_RIGHT = 2;
    exports.DIRECTION_UP = 4;
    exports.DIRECTION_DOWN = 8;
    exports.DIRECTION_HORIZONTAL = exports.DIRECTION_LEFT | exports.DIRECTION_RIGHT;
    exports.DIRECTION_VERTICAL = exports.DIRECTION_UP | exports.DIRECTION_DOWN;
    exports.DIRECTION_ALL = exports.DIRECTION_HORIZONTAL | exports.DIRECTION_VERTICAL;
    var PROPS_XY = ['x', 'y'];
    var PROPS_CLIENT_XY = ['clientX', 'clientY'];
    var Input = (function() {
      function Input(manager, touchElementEvents, touchTargetEvents, touchWindowEvents) {
        var self = this;
        this.manager = manager;
        this.evEl = touchElementEvents;
        this.evTarget = touchTargetEvents;
        this.evWin = touchWindowEvents;
        this.element = manager.element;
        this.target = manager.inputTarget;
        this.domHandler = function(event) {
          if (manager.enable) {
            self.handler(event);
          }
        };
        this.init();
      }
      Input.prototype.handler = function(event) {};
      Input.prototype.init = function() {
        this.evEl && utils_1.addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && utils_1.addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && utils_1.addEventListeners(utils_1.getWindowForElement(this.element), this.evWin, this.domHandler);
      };
      Input.prototype.destroy = function() {
        this.evEl && utils_1.removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && utils_1.removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && utils_1.removeEventListeners(utils_1.getWindowForElement(this.element), this.evWin, this.domHandler);
      };
      return Input;
    }());
    function inputHandler(manager, eventType, touchEvent) {
      var compEvent = computeIComputedEvent(manager, eventType, touchEvent);
      manager.recognize(compEvent, touchEvent);
      manager.session.push(compEvent);
    }
    function computeIComputedEvent(manager, eventType, touchEvent) {
      var touchesLength = touchEvent.touches.length;
      var changedPointersLen = touchEvent.changedTouches.length;
      var isFirst = (eventType & exports.INPUT_START && (touchesLength - changedPointersLen === 0));
      var isFinal = (eventType & (exports.INPUT_END | exports.INPUT_CANCEL) && (touchesLength - changedPointersLen === 0));
      if (isFirst) {
        manager.session.reset();
      }
      var session = manager.session;
      var center = computeCenter(touchEvent.touches);
      var movement = session.computeMovement(center);
      var timeStamp = Date.now();
      var movementTime = timeStamp - session.startTime;
      var distance = movement ? movement.norm() : 0;
      var direction = getDirection(movement);
      var velocity = session.computeVelocity(center, movementTime);
      var compEvent = {
        center: center,
        movement: movement,
        deltaTime: movementTime,
        direction: direction,
        distance: distance,
        eventType: eventType,
        rotation: 0,
        timeStamp: timeStamp,
        touchesLength: touchEvent.touches.length,
        scale: 1,
        velocity: velocity
      };
      return compEvent;
    }
    function computeCenter(touches) {
      var touchesLength = touches.length;
      if (touchesLength === 1) {
        return ClientLocation.fromTouch(touches[0]);
      } else if (touchesLength === 0) {
        return undefined;
      } else {
        var x = 0,
            y = 0,
            i = 0;
        while (i < touchesLength) {
          x += touches[i].clientX;
          y += touches[i].clientY;
          i++;
        }
        return new ClientLocation(Math.round(x / touchesLength), Math.round(y / touchesLength));
      }
    }
    function getVelocity(deltaTime, x, y) {
      return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
      };
    }
    function getDirection(movement) {
      var N = new VectorE2(0, -1);
      var S = new VectorE2(0, +1);
      var E = new VectorE2(+1, 0);
      var W = new VectorE2(-1, 0);
      var cosineThreshold = Math.cos(7 * Math.PI / 16);
      if (movement) {
        var unit = movement.div(movement.norm());
        var direction = exports.DIRECTION_UNDEFINED;
        if (unit.dot(N) > cosineThreshold) {
          direction |= exports.DIRECTION_UP;
        }
        if (unit.dot(S) > cosineThreshold) {
          direction |= exports.DIRECTION_DOWN;
        }
        if (unit.dot(E) > cosineThreshold) {
          direction |= exports.DIRECTION_RIGHT;
        }
        if (unit.dot(W) > cosineThreshold) {
          direction |= exports.DIRECTION_LEFT;
        }
        return direction;
      } else {
        return exports.DIRECTION_UNDEFINED;
      }
    }
    function getDistance(p1, p2, props) {
      if (!props) {
        props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
      return Math.sqrt((x * x) + (y * y));
    }
    exports.getDistance = getDistance;
    function getAngle(p1, p2, props) {
      if (!props) {
        props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
      return Math.atan2(y, x) * 180 / Math.PI;
    }
    function getRotation(start, end) {
      return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    function getScale(start, end) {
      return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }
    var TOUCH_INPUT_MAP = {
      touchstart: exports.INPUT_START,
      touchmove: exports.INPUT_MOVE,
      touchend: exports.INPUT_END,
      touchcancel: exports.INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
    var TouchInput = (function(_super) {
      __extends(TouchInput, _super);
      function TouchInput(manager, callback) {
        _super.call(this, manager, undefined, TOUCH_TARGET_EVENTS, undefined);
        this.targetIds = {};
        this.callback = callback;
      }
      TouchInput.prototype.handler = function(event) {
        var eventType = TOUCH_INPUT_MAP[event.type];
        this.callback(this.manager, eventType, event);
      };
      return TouchInput;
    }(Input));
    function getTouches(event, type) {
      var allTouches = utils_1.toArray(event.touches);
      var targetIds = this.targetIds;
      if (type & (exports.INPUT_START | exports.INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
      }
      var i,
          targetTouches,
          changedTouches = utils_1.toArray(event.changedTouches),
          changedTargetTouches = [],
          target = this.target;
      targetTouches = allTouches.filter(function(touch) {
        return utils_1.hasParent(touch.target, target);
      });
      if (type === exports.INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
          targetIds[targetTouches[i].identifier] = true;
          i++;
        }
      }
      i = 0;
      while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
          changedTargetTouches.push(changedTouches[i]);
        }
        if (type & (exports.INPUT_END | exports.INPUT_CANCEL)) {
          delete targetIds[changedTouches[i].identifier];
        }
        i++;
      }
      if (!changedTargetTouches.length) {
        return;
      }
      return [utils_1.uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
    }
    exports.STATE_UNDEFINED = 0;
    exports.STATE_POSSIBLE = 1;
    exports.STATE_BEGAN = 2;
    exports.STATE_CHANGED = 4;
    exports.STATE_RECOGNIZED = 8;
    exports.STATE_CANCELLED = 16;
    exports.STATE_FAILED = 32;
    var Recognizer = (function() {
      function Recognizer(eventName, enabled) {
        this.simultaneous = {};
        this.requireFail = [];
        this.eventName = eventName;
        this.enabled = enabled;
        this.id = utils_1.uniqueId();
        this.manager = null;
        this.state = exports.STATE_POSSIBLE;
      }
      Recognizer.prototype.set = function(options) {
        this.manager && this.manager.updateTouchAction();
        return this;
      };
      Recognizer.prototype.recognizeWith = function(otherRecognizer) {
        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
        if (!simultaneous[otherRecognizer.id]) {
          simultaneous[otherRecognizer.id] = otherRecognizer;
          otherRecognizer.recognizeWith(this);
        }
        return this;
      };
      Recognizer.prototype.dropRecognizeWith = function(otherRecognizer) {
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
        delete this.simultaneous[otherRecognizer.id];
        return this;
      };
      Recognizer.prototype.requireFailure = function(otherRecognizer) {
        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
        if (utils_1.inArray(requireFail, otherRecognizer) === -1) {
          requireFail.push(otherRecognizer);
          otherRecognizer.requireFailure(this);
        }
        return this;
      };
      Recognizer.prototype.dropRequireFailure = function(otherRecognizer) {
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
        var index = utils_1.inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
          this.requireFail.splice(index, 1);
        }
        return this;
      };
      Recognizer.prototype.hasRequireFailures = function() {
        return this.requireFail.length > 0;
      };
      Recognizer.prototype.canRecognizeWith = function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
      };
      Recognizer.prototype.emit = function() {
        var self = this;
        var state = this.state;
        function emit(withState) {
          var eventName = self.eventName + (withState ? stateStr(state) : '');
          self.manager.emit(eventName, undefined);
        }
        if (state < exports.STATE_RECOGNIZED) {
          emit(true);
        }
        emit(false);
        if (state >= exports.STATE_RECOGNIZED) {
          emit(true);
        }
      };
      Recognizer.prototype.tryEmit = function() {
        if (this.canEmit()) {
          return this.emit();
        } else {}
        this.state = exports.STATE_FAILED;
      };
      Recognizer.prototype.canEmit = function() {
        var i = 0;
        while (i < this.requireFail.length) {
          if (!(this.requireFail[i].state & (exports.STATE_FAILED | exports.STATE_POSSIBLE))) {
            return false;
          }
          i++;
        }
        return true;
      };
      Recognizer.prototype.recognize = function(compEvent) {
        if (!this.enabled) {
          this.reset();
          this.state = exports.STATE_FAILED;
          return;
        }
        if (this.state & (exports.STATE_RECOGNIZED | exports.STATE_CANCELLED | exports.STATE_FAILED)) {
          this.state = exports.STATE_POSSIBLE;
        }
        this.state = this.process(compEvent);
        if (this.state & (exports.STATE_BEGAN | exports.STATE_CHANGED | exports.STATE_RECOGNIZED | exports.STATE_CANCELLED)) {
          this.tryEmit();
        }
      };
      Recognizer.prototype.process = function(inputData) {
        return exports.STATE_UNDEFINED;
      };
      Recognizer.prototype.getTouchAction = function() {
        return [];
      };
      Recognizer.prototype.reset = function() {};
      return Recognizer;
    }());
    exports.Recognizer = Recognizer;
    function stateStr(state) {
      if (state & exports.STATE_CANCELLED) {
        return 'cancel';
      } else if (state & exports.STATE_RECOGNIZED) {
        return 'end';
      } else if (state & exports.STATE_CHANGED) {
        return 'move';
      } else if (state & exports.STATE_BEGAN) {
        return 'start';
      }
      return '';
    }
    exports.stateStr = stateStr;
    function stateDecode(state) {
      var states = [];
      if (state & exports.STATE_POSSIBLE) {
        states.push('STATE_POSSIBLE');
      } else if (state & exports.STATE_CANCELLED) {
        states.push('STATE_CANCELLED');
      } else if (state & exports.STATE_RECOGNIZED) {
        states.push('STATE_RECOGNIZED');
      } else if (state & exports.STATE_CHANGED) {
        states.push('STATE_CHANGED');
      } else if (state & exports.STATE_BEGAN) {
        states.push('STATE_BEGAN');
      } else if (state & exports.STATE_UNDEFINED) {
        states.push('STATE_UNDEFINED');
      } else if (state & exports.STATE_FAILED) {
        states.push('STATE_FAILED');
      } else {
        states.push('' + state);
      }
      return states.join(' ');
    }
    exports.stateDecode = stateDecode;
    function directionStr(direction) {
      var ds = [];
      if (direction & exports.DIRECTION_DOWN) {
        ds.push('down');
      }
      if (direction & exports.DIRECTION_UP) {
        ds.push('up');
      }
      if (direction & exports.DIRECTION_LEFT) {
        ds.push('left');
      }
      if (direction & exports.DIRECTION_RIGHT) {
        ds.push('right');
      }
      return ds.join(' ');
    }
    exports.directionStr = directionStr;
    function getRecognizerByNameIfManager(recognizer, manager) {
      if (manager) {
        return manager.get(recognizer.eventName);
      }
      return recognizer;
    }
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('hammer/recognizers/attribute', ["require", "exports", '../hammer'], function(require, exports, hammer_1) {
    "use strict";
    var ContinuousRecognizer = (function(_super) {
      __extends(ContinuousRecognizer, _super);
      function ContinuousRecognizer(eventName, enabled, pointers) {
        _super.call(this, eventName, enabled);
        this.pointers = pointers;
      }
      ContinuousRecognizer.prototype.attributeTest = function(input) {
        switch (input.eventType) {
          case hammer_1.INPUT_START:
            {
              return input.touchesLength === this.pointers;
            }
          case hammer_1.INPUT_MOVE:
            {
              return input.touchesLength === this.pointers;
            }
          case hammer_1.INPUT_END:
            {
              return input.touchesLength === this.pointers - 1;
            }
          case hammer_1.INPUT_CANCEL:
            {
              return true;
            }
          default:
            {
              throw new Error(hammer_1.decodeEventType(input.eventType));
            }
        }
      };
      ContinuousRecognizer.prototype.process = function(input) {
        var state = this.state;
        var eventType = input.eventType;
        var isRecognized = state & (hammer_1.STATE_BEGAN | hammer_1.STATE_CHANGED);
        var isValid = this.attributeTest(input);
        if (isRecognized && (eventType & hammer_1.INPUT_CANCEL || !isValid)) {
          return state | hammer_1.STATE_CANCELLED;
        } else if (isRecognized || isValid) {
          if (eventType & hammer_1.INPUT_END) {
            return state | hammer_1.STATE_RECOGNIZED;
          } else if (!(state & hammer_1.STATE_BEGAN)) {
            return hammer_1.STATE_BEGAN;
          } else {
            return state | hammer_1.STATE_CHANGED;
          }
        }
        return hammer_1.STATE_FAILED;
      };
      return ContinuousRecognizer;
    }(hammer_1.Recognizer));
    exports.ContinuousRecognizer = ContinuousRecognizer;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('hammer/recognizers/pan', ["require", "exports", './attribute', '../hammer'], function(require, exports, attribute_1, hammer_1) {
    "use strict";
    var PanRecognizer = (function(_super) {
      __extends(PanRecognizer, _super);
      function PanRecognizer(eventName, enabled) {
        _super.call(this, eventName, enabled, 1);
        this.direction = hammer_1.DIRECTION_ALL;
        this.threshold = 10;
      }
      PanRecognizer.prototype.setDirection = function(direction) {
        this.direction = direction;
        return this;
      };
      PanRecognizer.prototype.setThreshold = function(threshold) {
        this.threshold = threshold;
        return this;
      };
      PanRecognizer.prototype.getTouchAction = function() {
        var actions = [];
        if (this.direction & hammer_1.DIRECTION_HORIZONTAL) {
          actions.push(hammer_1.TOUCH_ACTION_PAN_Y);
        }
        if (this.direction & hammer_1.DIRECTION_VERTICAL) {
          actions.push(hammer_1.TOUCH_ACTION_PAN_X);
        }
        return actions;
      };
      PanRecognizer.prototype.directionTest = function(input) {
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.movement.x;
        var y = input.movement.y;
        if (!(direction & this.direction)) {
          if (this.direction & hammer_1.DIRECTION_HORIZONTAL) {
            direction = (x === 0) ? hammer_1.DIRECTION_UNDEFINED : (x < 0) ? hammer_1.DIRECTION_LEFT : hammer_1.DIRECTION_RIGHT;
            hasMoved = x != this.pX;
            distance = Math.abs(input.movement.x);
          } else {
            direction = (y === 0) ? hammer_1.DIRECTION_UNDEFINED : (y < 0) ? hammer_1.DIRECTION_UP : hammer_1.DIRECTION_DOWN;
            hasMoved = y != this.pY;
            distance = Math.abs(input.movement.y);
          }
        }
        var directionAllowed = (direction & this.direction) > 0;
        return hasMoved && distance > this.threshold && directionAllowed;
      };
      PanRecognizer.prototype.attributeTest = function(input) {
        this.movement = input.movement;
        if (input.movement) {
          var directionOK = this.directionTest(input);
          var began = (this.state & hammer_1.STATE_BEGAN) > 0;
          return _super.prototype.attributeTest.call(this, input) && (began || (!began && directionOK));
        } else {
          return true;
        }
      };
      PanRecognizer.prototype.emit = function() {
        if (this.movement) {
          this.manager.emit(this.eventName, this.movement);
        }
      };
      return PanRecognizer;
    }(attribute_1.ContinuousRecognizer));
    exports.PanRecognizer = PanRecognizer;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('hammer/recognizers/tap', ["require", "exports", '../hammer', '../utils'], function(require, exports, hammer_1, utils_1) {
    "use strict";
    function isCorrectTouchCount(input) {
      switch (input.eventType) {
        case hammer_1.INPUT_START:
          {
            return input.touchesLength === 1;
          }
        case hammer_1.INPUT_MOVE:
          {
            return input.touchesLength === 1;
          }
        case hammer_1.INPUT_END:
          {
            return input.touchesLength === 0;
          }
        case hammer_1.INPUT_CANCEL:
          {
            return true;
          }
        default:
          {
            throw new Error(hammer_1.decodeEventType(input.eventType));
          }
      }
    }
    var TapRecognizer = (function(_super) {
      __extends(TapRecognizer, _super);
      function TapRecognizer(eventName, enabled) {
        _super.call(this, eventName ? eventName : 'tap', enabled);
        this.count = 0;
        this.taps = 1;
        this.pointers = 1;
        this.time = 250;
        this.threshold = 6;
        this.interval = 300;
        this.posThreshold = 10;
      }
      TapRecognizer.prototype.getTouchAction = function() {
        return [hammer_1.TOUCH_ACTION_MANIPULATION];
      };
      TapRecognizer.prototype.process = function(input) {
        this.reset();
        if (!isCorrectTouchCount(input)) {
          return hammer_1.STATE_FAILED;
        }
        if ((input.eventType & hammer_1.INPUT_START) && (this.count === 0)) {
          this.center = input.center;
          return this.failTimeout();
        }
        if (input.distance >= this.threshold) {
          return hammer_1.STATE_FAILED;
        }
        if (input.deltaTime >= this.time) {
          return hammer_1.STATE_FAILED;
        }
        if (input.eventType !== hammer_1.INPUT_END) {
          this.center = input.center;
          return this.failTimeout();
        } else {}
        var validInterval = this.pTime ? (input.timeStamp - this.pTime < this.interval) : true;
        var validMultiTap = !this.pCenter || hammer_1.getDistance(this.pCenter, input.center) < this.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;
        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }
        var tapCount = this.count % this.taps;
        if (tapCount === 0) {
          if (!this.hasRequireFailures()) {
            return hammer_1.STATE_RECOGNIZED;
          } else {
            this._timer = utils_1.setTimeoutContext(function() {
              this.state = hammer_1.STATE_RECOGNIZED;
              this.tryEmit();
            }, this.interval, this);
            return hammer_1.STATE_BEGAN;
          }
        }
        return hammer_1.STATE_FAILED;
      };
      TapRecognizer.prototype.failTimeout = function() {
        this._timer = utils_1.setTimeoutContext(function() {
          this.state = hammer_1.STATE_FAILED;
        }, this.interval, this);
        return hammer_1.STATE_FAILED;
      };
      TapRecognizer.prototype.reset = function() {
        clearTimeout(this._timer);
      };
      TapRecognizer.prototype.emit = function() {
        if (this.state === hammer_1.STATE_RECOGNIZED) {
          this.manager.emit(this.eventName, this.center);
        }
      };
      return TapRecognizer;
    }(hammer_1.Recognizer));
    exports.TapRecognizer = TapRecognizer;
  });
  define('touch/touch', ["require", "exports", '../hammer/hammer', '../hammer/recognizers/pan', '../hammer/recognizers/tap'], function(require, exports, hammer_1, pan_1, tap_1) {
    "use strict";
    function touchManager(editor) {
      var target = editor.renderer.getMouseEventTarget();
      var manager = new hammer_1.Manager(target);
      manager.add(new pan_1.PanRecognizer('pan', true).setDirection(hammer_1.DIRECTION_VERTICAL).setThreshold(20));
      manager.add(new tap_1.TapRecognizer('tap', true));
      manager.on('pan', function(movement) {
        editor.renderer.scrollBy(-movement.x, -movement.y);
      });
      manager.on('tap', function(event) {
        var pos = editor.renderer.screenToTextCoordinates(event.clientX, event.clientY);
        pos.row = Math.max(0, Math.min(pos.row, editor.getSession().getLength() - 1));
        editor.moveCursorToPosition(pos);
        editor.renderer.scrollCursorIntoView();
        editor.focus();
      });
      return manager;
    }
    exports.touchManager = touchManager;
  });
  define('Tooltip', ["require", "exports", "./lib/dom"], function(require, exports, dom_1) {
    "use strict";
    var Tooltip = (function() {
      function Tooltip(parentElement) {
        this.isOpen = false;
        this.$element = null;
        this.$parentElement = parentElement;
      }
      Tooltip.prototype.$init = function() {
        this.$element = dom_1.createElement('div');
        this.$element.className = "ace_tooltip";
        this.$element.style.display = "none";
        this.$parentElement.appendChild(this.$element);
        return this.$element;
      };
      Tooltip.prototype.getElement = function() {
        return this.$element || this.$init();
      };
      Tooltip.prototype.setText = function(text) {
        dom_1.setInnerText(this.getElement(), text);
      };
      Tooltip.prototype.setHtml = function(html) {
        this.getElement().innerHTML = html;
      };
      Tooltip.prototype.setPosition = function(left, top) {
        var style = this.getElement().style;
        style.left = left + "px";
        style.top = top + "px";
      };
      Tooltip.prototype.setClassName = function(className) {
        dom_1.addCssClass(this.getElement(), className);
      };
      Tooltip.prototype.show = function() {
        if (!this.isOpen) {
          this.getElement().style.display = 'block';
          this.isOpen = true;
        }
      };
      Tooltip.prototype.hide = function() {
        if (this.isOpen) {
          this.getElement().style.display = 'none';
          this.isOpen = false;
        }
      };
      Tooltip.prototype.getHeight = function() {
        return this.getElement().offsetHeight;
      };
      Tooltip.prototype.getWidth = function() {
        return this.getElement().offsetWidth;
      };
      return Tooltip;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Tooltip;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('Editor', ["require", "exports", "./lib/oop", "./lib/dom", './lib/lang/createDelayedCall', "./lib/lang", "./lib/useragent", "./keyboard/KeyboardHandler", "./keyboard/KeyBinding", "./keyboard/TextInput", "./Search", "./Range", "./lib/EventEmitterClass", "./commands/CommandManager", "./commands/default_commands", "./config", "./TokenIterator", './editor_protocol', './editor_protocol', './editor_protocol', './editor_protocol', './Selection', './SnippetManager', "./lib/event", './touch/touch', "./Tooltip"], function(require, exports, oop_1, dom_1, createDelayedCall_1, lang_1, useragent_1, KeyboardHandler_1, KeyBinding_1, TextInput_1, Search_1, Range_1, EventEmitterClass_1, CommandManager_1, default_commands_1, config_1, TokenIterator_1, editor_protocol_1, editor_protocol_2, editor_protocol_3, editor_protocol_4, Selection_1, SnippetManager_1, event_1, touch_1, Tooltip_1) {
    "use strict";
    var search = new Search_1.default();
    function find(session, needle, dir) {
      search.$options.wrap = true;
      search.$options.needle = needle;
      search.$options.backwards = dir == -1;
      return search.find(session);
    }
    var Editor = (function() {
      function Editor(renderer, session) {
        var _this = this;
        this.completers = [];
        this.snippetManager = new SnippetManager_1.default();
        this.eventBus = new EventEmitterClass_1.default(this);
        this.curOp = null;
        this.prevOp = {};
        this.$mergeableCommands = [editor_protocol_2.COMMAND_NAME_BACKSPACE, editor_protocol_3.COMMAND_NAME_DEL, editor_protocol_4.COMMAND_NAME_INSERT_STRING];
        this.commands = new CommandManager_1.default(useragent_1.isMac ? "mac" : "win", default_commands_1.default);
        this.container = renderer.getContainerElement();
        this.renderer = renderer;
        this.textInput = new TextInput_1.default(renderer.getTextAreaContainer(), this);
        this.renderer.textarea = this.textInput.getElement();
        this.keyBinding = new KeyBinding_1.default(this);
        if (useragent_1.isMobile) {
          this.$touchHandler = touch_1.touchManager(this);
          this.$mouseHandler = new MouseHandler(this);
        } else {
          this.$touchHandler = touch_1.touchManager(this);
          this.$mouseHandler = new MouseHandler(this);
        }
        new FoldHandler(this);
        this.$blockScrolling = 0;
        this.$search = new Search_1.default().set({wrap: true});
        this.$historyTracker = this.$historyTracker.bind(this);
        this.commands.on("exec", this.$historyTracker);
        this.$initOperationListeners();
        this._$emitInputEvent = createDelayedCall_1.default(function() {
          _this._signal("input", {});
          _this.session.bgTokenizer && _this.session.bgTokenizer.scheduleStart();
        });
        this.on("change", function() {
          _this._$emitInputEvent.schedule(31);
        });
        this.on("changeSession", function(e, editor) {
          var session = _this.session;
          if (session && !session.multiSelect) {
            session.$selectionMarkers = [];
            session.selection.$initRangeList();
            session.multiSelect = session.selection;
          }
          _this.multiSelect = session && session.multiSelect;
          var onAddRange = function(event, selection) {
            _this.addSelectionMarker(event.range);
            _this.renderer.updateCursor();
            _this.renderer.updateBackMarkers();
          };
          var onRemoveRange = function(event, selection) {
            _this.removeSelectionMarkers(event.ranges);
            _this.renderer.updateCursor();
            _this.renderer.updateBackMarkers();
          };
          var keyboardMultiSelect = new KeyboardHandler_1.default([{
            name: "singleSelection",
            bindKey: "esc",
            exec: function(editor) {
              editor.exitMultiSelectMode();
            },
            scrollIntoView: "cursor",
            readOnly: true,
            isAvailable: function(editor) {
              return editor && editor.inMultiSelectMode;
            }
          }]);
          var onMultiSelect = function(unused, selection) {
            if (_this.inMultiSelectMode) {
              return;
            }
            _this.inMultiSelectMode = true;
            _this.setStyle("ace_multiselect");
            _this.keyBinding.addKeyboardHandler(keyboardMultiSelect);
            _this.commands.setDefaultHandler("exec", onMultiSelectExec);
            _this.renderer.updateCursor();
            _this.renderer.updateBackMarkers();
          };
          var onSingleSelect = function(unused, selection) {
            if (_this.session.multiSelect.inVirtualMode) {
              return;
            }
            _this.inMultiSelectMode = false;
            _this.unsetStyle("ace_multiselect");
            _this.keyBinding.removeKeyboardHandler(keyboardMultiSelect);
            _this.commands.removeDefaultHandler("exec", onMultiSelectExec);
            _this.renderer.updateCursor();
            _this.renderer.updateBackMarkers();
            _this._emit("changeSelection");
          };
          var onMultiSelectExec = function(e) {
            var command = e.command;
            var editor = e.editor;
            if (!editor.multiSelect)
              return;
            if (!command.multiSelectAction) {
              var result = command.exec(editor, e.args || {});
              editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
              editor.multiSelect.mergeOverlappingRanges();
            } else if (command.multiSelectAction === "forEach") {
              result = editor.forEachSelection(command.exec, e.args);
            } else if (command.multiSelectAction === "forEachLine") {
              result = editor.forEachSelection(command.exec, e.args, {$byLines: true});
            } else if (command.multiSelectAction === "single") {
              editor.exitMultiSelectMode();
              result = command.exec(editor, e.args || {});
            } else {
              if (typeof command.multiSelectAction === 'function') {
                var action = command.multiSelectAction;
                result = action(editor, e.args || {});
              } else {
                throw new TypeError("multiSelectAction");
              }
            }
            return result;
          };
          var checkMultiselectChange = function(unused, anchor) {
            if (_this.inMultiSelectMode && !_this.inVirtualSelectionMode) {
              var range = _this.multiSelect.ranges[0];
              if (_this.multiSelect.isEmpty() && anchor == _this.multiSelect.anchor)
                return;
              var pos = anchor == _this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
              if (pos.row != anchor.row || _this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                _this.multiSelect.toSingleRange(_this.multiSelect.toOrientedRange());
            }
          };
          var oldSession = e.oldSession;
          if (oldSession) {
            oldSession.multiSelect.off("addRange", onAddRange);
            oldSession.multiSelect.off("removeRange", onRemoveRange);
            oldSession.multiSelect.off("multiSelect", onMultiSelect);
            oldSession.multiSelect.off("singleSelect", onSingleSelect);
            oldSession.multiSelect.lead.off("change", checkMultiselectChange);
            oldSession.multiSelect.anchor.off("change", checkMultiselectChange);
          }
          if (session) {
            session.multiSelect.on("addRange", onAddRange);
            session.multiSelect.on("removeRange", onRemoveRange);
            session.multiSelect.on("multiSelect", onMultiSelect);
            session.multiSelect.on("singleSelect", onSingleSelect);
            session.multiSelect.lead.on("change", checkMultiselectChange);
            session.multiSelect.anchor.on("change", checkMultiselectChange);
          }
          if (session && _this.inMultiSelectMode != session.selection.inMultiSelectMode) {
            if (session.selection.inMultiSelectMode) {
              onMultiSelect(void 0, session.selection);
            } else {
              onSingleSelect(void 0, session.selection);
            }
          }
        });
        this.setSession(session);
        config_1.resetOptions(this);
      }
      Editor.prototype.cancelMouseContextMenu = function() {
        this.$mouseHandler.cancelContextMenu();
      };
      Object.defineProperty(Editor.prototype, "selection", {
        get: function() {
          return this.session.getSelection();
        },
        set: function(selection) {
          this.session.setSelection(selection);
        },
        enumerable: true,
        configurable: true
      });
      Editor.prototype.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor) {
          orientedRange.cursor = orientedRange.end;
        }
        var style = this.getSelectionStyle();
        orientedRange.markerId = this.session.addMarker(orientedRange, "ace_selection", style);
        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
      };
      Editor.prototype.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
          var range = ranges[i];
          if (!range.markerId) {
            continue;
          }
          this.session.removeMarker(range.markerId);
          var index = markerList.indexOf(range);
          if (index !== -1) {
            markerList.splice(index, 1);
          }
        }
        this.session.selectionMarkerCount = markerList.length;
      };
      Editor.prototype.forEachSelection = function(action, args, options) {
        if (this.inVirtualSelectionMode) {
          return;
        }
        var keepOrder = options && options.keepOrder;
        var $byLines = options && options.$byLines;
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection.ranges : rangeList.ranges);
        var result;
        if (!ranges.length) {
          return action(this, args || {});
        }
        var reg = selection._eventRegistry;
        selection._eventRegistry = {};
        var tmpSel = new Selection_1.default(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--; ) {
          if ($byLines) {
            while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
              i--;
          }
          tmpSel.fromOrientedRange(ranges[i]);
          tmpSel.index = i;
          this.selection = session.selection = tmpSel;
          var actionResult = action(this, args || {});
          if (!result && actionResult !== undefined) {
            result = actionResult;
          }
          tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();
        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange(void 0, this.session);
        this.onSelectionChange(void 0, this.selection);
        if (anim && anim.from === anim.to) {
          this.renderer.animateScrolling(anim.from);
        }
        return result;
      };
      Editor.prototype.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;
        var screenLead = this.session.documentToScreenPosition(range.cursor.row, range.cursor.column);
        if (this.selection.$desiredColumn)
          screenLead.column = this.selection.$desiredColumn;
        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
        var anchor;
        if (!range.isEmpty()) {
          var row = isBackwards ? range.end.row : range.start.row;
          var column = isBackwards ? range.end.column : range.start.column;
          var screenAnchor = this.session.documentToScreenPosition(row, column);
          anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
          anchor = lead;
        }
        var newRange;
        if (isBackwards) {
          newRange = Range_1.default.fromPoints(lead, anchor);
          newRange.cursor = newRange.start;
        } else {
          newRange = Range_1.default.fromPoints(anchor, lead);
          newRange.cursor = newRange.end;
        }
        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
          this.selection.addRange(range);
        } else {
          if (skip) {
            var toRemove = range.cursor;
          }
        }
        this.selection.addRange(newRange);
        if (toRemove) {
          this.selection.substractPoint(toRemove);
        }
      };
      Editor.prototype.selectMore = function(dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;
        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
          range = session.getWordRange(range.start.row, range.start.column);
          range.cursor = dir === -1 ? range.start : range.end;
          this.multiSelect.addRange(range);
          if (stopAtFirst)
            return;
        }
        var needle = session.getTextRange(range);
        var newRange = find(session, needle, dir);
        if (newRange) {
          newRange.cursor = dir == -1 ? newRange.start : newRange.end;
          this.$blockScrolling += 1;
          this.session.unfold(newRange);
          this.multiSelect.addRange(newRange);
          this.$blockScrolling -= 1;
          this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip) {
          this.multiSelect.substractPoint(range.cursor);
        }
      };
      Editor.prototype.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        var row = -1;
        var sameRowRanges = ranges.filter(function(r) {
          if (r.cursor.row == row)
            return true;
          row = r.cursor.row;
        });
        if (!ranges.length || sameRowRanges.length === ranges.length - 1) {
          var range = this.selection.getRange();
          var fr = range.start.row,
              lr = range.end.row;
          var guessRange = fr == lr;
          if (guessRange) {
            var max = this.session.getLength();
            var line;
            do {
              line = this.session.getLine(lr);
            } while (/[=:]/.test(line) && ++lr < max);
            do {
              line = this.session.getLine(fr);
            } while (/[=:]/.test(line) && --fr > 0);
            if (fr < 0)
              fr = 0;
            if (lr >= max)
              lr = max - 1;
          }
          var lines = this.session.removeFullLines(fr, lr);
          lines = this.$reAlignText(lines, guessRange);
          this.session.insert({
            row: fr,
            column: 0
          }, lines.join("\n") + "\n");
          if (!guessRange) {
            range.start.column = 0;
            range.end.column = lines[lines.length - 1].length;
          }
          this.selection.setRange(range);
        } else {
          sameRowRanges.forEach(function(r) {
            sel.substractPoint(r.cursor);
          });
          var maxCol = 0;
          var minSpace = Infinity;
          var spaceOffsets = ranges.map(function(r) {
            var p = r.cursor;
            var line = session.getLine(p.row);
            var spaceOffset = line.substr(p.column).search(/\S/g);
            if (spaceOffset == -1)
              spaceOffset = 0;
            if (p.column > maxCol)
              maxCol = p.column;
            if (spaceOffset < minSpace)
              minSpace = spaceOffset;
            return spaceOffset;
          });
          ranges.forEach(function(r, i) {
            var p = r.cursor;
            var l = maxCol - p.column;
            var d = spaceOffsets[i] - minSpace;
            if (l > d)
              session.insert(p, lang_1.stringRepeat(" ", l - d));
            else
              session.remove(new Range_1.default(p.row, p.column, p.row, p.column - l + d));
            r.start.column = r.end.column = maxCol;
            r.start.row = r.end.row = p.row;
            r.cursor = r.end;
          });
          sel.fromOrientedRange(ranges[0]);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        }
      };
      Editor.prototype.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true;
        var isRightAligned = true;
        var startW;
        var textW;
        var endW;
        return lines.map(function(line) {
          var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
          if (!m)
            return [line];
          if (startW == null) {
            startW = m[1].length;
            textW = m[2].length;
            endW = m[3].length;
            return m;
          }
          if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
            isRightAligned = false;
          if (startW != m[1].length)
            isLeftAligned = false;
          if (startW > m[1].length)
            startW = m[1].length;
          if (textW < m[2].length)
            textW = m[2].length;
          if (endW > m[3].length)
            endW = m[3].length;
          return m;
        }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
        function spaces(n) {
          return lang_1.stringRepeat(" ", n);
        }
        function alignLeft(m) {
          return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m) {
          return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m) {
          return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
        }
      };
      Editor.prototype.$initOperationListeners = function() {
        var _this = this;
        function last(a) {
          return a[a.length - 1];
        }
        this.selections = [];
        this.commands.on("exec", function(e) {
          _this.startOperation(e);
          var command = e.command;
          if (command.aceCommandGroup === "fileJump") {
            var prev = _this.prevOp;
            if (!prev || prev.command.aceCommandGroup !== "fileJump") {
              _this.lastFileJumpPos = last(_this.selections);
            }
          } else {
            _this.lastFileJumpPos = null;
          }
        }, true);
        this.commands.on("afterExec", function(e, cm) {
          var command = e.command;
          if (command.aceCommandGroup === "fileJump") {
            if (_this.lastFileJumpPos && !_this.curOp.selectionChanged) {
              _this.selection.fromJSON(_this.lastFileJumpPos);
            }
          }
          _this.endOperation(e);
        }, true);
        this.$opResetTimer = createDelayedCall_1.default(this.endOperation.bind(this));
        this.eventBus.on("change", function() {
          _this.curOp || _this.startOperation();
          _this.curOp.docChanged = true;
        }, true);
        this.eventBus.on("changeSelection", function() {
          _this.curOp || _this.startOperation();
          _this.curOp.selectionChanged = true;
        }, true);
      };
      Editor.prototype.startOperation = function(commandEvent) {
        var _this = this;
        if (this.curOp) {
          if (!commandEvent || this.curOp.command)
            return;
          this.prevOp = this.curOp;
        }
        if (!commandEvent) {
          this.previousCommand = null;
          commandEvent = {};
        }
        this.$opResetTimer.schedule();
        this.curOp = {
          command: commandEvent.command || {},
          args: commandEvent.args,
          scrollTop: this.renderer.scrollTop
        };
        var command = this.curOp.command;
        if (command && command.scrollIntoView) {
          this.$blockScrolling++;
        }
        this.selection.toJSON().forEach(function(range) {
          _this.selections.push(range);
        });
      };
      Editor.prototype.endOperation = function(unused) {
        if (this.curOp) {
          var command = this.curOp.command;
          if (command && command.scrollIntoView) {
            this.$blockScrolling--;
            switch (command.scrollIntoView) {
              case "center":
                this.renderer.scrollCursorIntoView(null, 0.5);
                break;
              case "animate":
              case "cursor":
                this.renderer.scrollCursorIntoView();
                break;
              case "selectionPart":
                var range = this.selection.getRange();
                var config = this.renderer.layerConfig;
                if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                  this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                }
                break;
              default:
                break;
            }
            if (command.scrollIntoView == "animate")
              this.renderer.animateScrolling(this.curOp.scrollTop);
          }
          this.prevOp = this.curOp;
          this.curOp = null;
        }
      };
      Editor.prototype.$historyTracker = function(e) {
        if (!this.$mergeUndoDeltas)
          return;
        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        var shouldMerge = prev.command && (e.command.name == prev.command.name);
        if (e.command.name === editor_protocol_4.COMMAND_NAME_INSERT_STRING) {
          var text = e.args;
          if (this.mergeNextCommand === undefined)
            this.mergeNextCommand = true;
          shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
          this.mergeNextCommand = true;
        } else {
          shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1;
        }
        if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2000) {
          shouldMerge = false;
        }
        if (shouldMerge)
          this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
          this.sequenceStartTime = Date.now();
      };
      Editor.prototype.setKeyboardHandler = function(keyboardHandler) {
        if (!keyboardHandler) {
          this.keyBinding.setKeyboardHandler(null);
        } else if (typeof keyboardHandler === "string") {
          this.$keybindingId = keyboardHandler;
          var _self = this;
          config_1.loadModule(["keybinding", keyboardHandler], function(module) {
            if (_self.$keybindingId == keyboardHandler)
              _self.keyBinding.setKeyboardHandler(module && module.handler);
          }, this.container.ownerDocument);
        } else {
          this.$keybindingId = null;
          this.keyBinding.setKeyboardHandler(keyboardHandler);
        }
      };
      Editor.prototype.getKeyboardHandler = function() {
        return this.keyBinding.getKeyboardHandler();
      };
      Editor.prototype.setSession = function(session) {
        if (this.session === session) {
          return;
        }
        var oldSession = this.session;
        if (oldSession) {
          this.session.off("change", this.$onDocumentChange);
          this.session.off("changeMode", this.$onChangeMode);
          this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
          this.session.off("changeTabSize", this.$onChangeTabSize);
          this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
          this.session.off("changeWrapMode", this.$onChangeWrapMode);
          this.session.off("onChangeFold", this.$onChangeFold);
          this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
          this.session.off("changeBackMarker", this.$onChangeBackMarker);
          this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
          this.session.off("changeAnnotation", this.$onChangeAnnotation);
          this.session.off("changeOverwrite", this.$onCursorChange);
          this.session.off("changeScrollTop", this.$onScrollTopChange);
          this.session.off("changeScrollLeft", this.$onScrollLeftChange);
          var selection = this.session.getSelection();
          selection.off("changeCursor", this.$onCursorChange);
          selection.off("changeSelection", this.$onSelectionChange);
        }
        this.session = session;
        if (session) {
          this.$onDocumentChange = this.onDocumentChange.bind(this);
          session.on("change", this.$onDocumentChange);
          this.renderer.setSession(session);
          this.$onChangeMode = this.onChangeMode.bind(this);
          session.on("changeMode", this.$onChangeMode);
          this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
          session.on("tokenizerUpdate", this.$onTokenizerUpdate);
          this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
          session.on("changeTabSize", this.$onChangeTabSize);
          this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
          session.on("changeWrapLimit", this.$onChangeWrapLimit);
          this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
          session.on("changeWrapMode", this.$onChangeWrapMode);
          this.$onChangeFold = this.onChangeFold.bind(this);
          session.on("changeFold", this.$onChangeFold);
          this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
          session.on("changeFrontMarker", this.$onChangeFrontMarker);
          this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
          session.on("changeBackMarker", this.$onChangeBackMarker);
          this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
          session.on("changeBreakpoint", this.$onChangeBreakpoint);
          this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
          session.on("changeAnnotation", this.$onChangeAnnotation);
          this.$onCursorChange = this.onCursorChange.bind(this);
          session.on("changeOverwrite", this.$onCursorChange);
          this.$onScrollTopChange = this.onScrollTopChange.bind(this);
          session.on("changeScrollTop", this.$onScrollTopChange);
          this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
          session.on("changeScrollLeft", this.$onScrollLeftChange);
          this.selection = session.getSelection();
          this.selection.on("changeCursor", this.$onCursorChange);
          this.$onSelectionChange = this.onSelectionChange.bind(this);
          this.selection.on("changeSelection", this.$onSelectionChange);
          this.onChangeMode(void 0, this.session);
          this.$blockScrolling += 1;
          this.onCursorChange(void 0, this.session);
          this.$blockScrolling -= 1;
          this.onScrollTopChange(void 0, this.session);
          this.onScrollLeftChange(void 0, this.session);
          this.onSelectionChange(void 0, this.selection);
          this.onChangeFrontMarker(void 0, this.session);
          this.onChangeBackMarker(void 0, this.session);
          this.onChangeBreakpoint(void 0, this.session);
          this.onChangeAnnotation(void 0, this.session);
          session.getUseWrapMode() && this.renderer.adjustWrapLimit();
          this.renderer.updateFull();
        }
        var changeSessionEvent = {
          session: session,
          oldSession: oldSession
        };
        this.eventBus._signal("changeSession", changeSessionEvent);
        if (oldSession) {
          var changeEditorEvent = {oldEditor: this};
          oldSession._signal("changeEditor", changeEditorEvent);
        }
        if (session) {
          var changeEditorEvent = {editor: this};
          session._signal("changeEditor", changeEditorEvent);
        }
      };
      Editor.prototype.getSession = function() {
        return this.session;
      };
      Editor.prototype.setLanguageMode = function(mode) {
        return this.session.setLanguageMode(mode);
      };
      Editor.prototype.setPadding = function(padding) {
        return this.renderer.setPadding(padding);
      };
      Editor.prototype.setTabSize = function(tabSize) {
        return this.session.setTabSize(tabSize);
      };
      Editor.prototype.setThemeCss = function(themeId, href) {
        return this.renderer.setThemeCss(themeId, href);
      };
      Editor.prototype.setThemeDark = function(isDark) {
        return this.renderer.setThemeDark(isDark);
      };
      Editor.prototype.setValue = function(text, cursorPos) {
        if (this.session) {
          this.session.setValue(text);
        } else {
          console.warn("session is missing for Editor");
          return;
        }
        if (!cursorPos) {
          this.selectAll();
        } else if (cursorPos === +1) {
          this.navigateFileEnd();
        } else if (cursorPos === -1) {
          this.navigateFileStart();
        }
      };
      Editor.prototype.getValue = function() {
        return this.session.getValue();
      };
      Editor.prototype.getSelection = function() {
        return this.selection;
      };
      Editor.prototype.resize = function(force) {
        this.renderer.onResize(force);
      };
      Editor.prototype.getTheme = function() {
        return this.renderer.getTheme();
      };
      Editor.prototype.setStyle = function(style) {
        this.renderer.setStyle(style);
      };
      Editor.prototype.unsetStyle = function(style) {
        this.renderer.unsetStyle(style);
      };
      Editor.prototype.getFontSize = function() {
        return this.getOption("fontSize") || dom_1.computedStyle(this.container, "fontSize");
      };
      Editor.prototype.setFontSize = function(fontSize) {
        this.setOption("fontSize", fontSize);
      };
      Editor.prototype.insertSnippet = function(content, options) {
        return this.snippetManager.insertSnippet(this, content, options);
      };
      Editor.prototype.expandSnippet = function(options) {
        return this.snippetManager.expandWithTab(this, options);
      };
      Editor.prototype.$highlightBrackets = function() {
        if (this.session.$bracketHighlight) {
          this.session.removeMarker(this.session.$bracketHighlight);
          this.session.$bracketHighlight = void 0;
        }
        if (this.$highlightPending) {
          return;
        }
        var self = this;
        this.$highlightPending = true;
        setTimeout(function() {
          self.$highlightPending = false;
          var pos = self.session.findMatchingBracket(self.getCursorPosition());
          if (pos) {
            var range = new Range_1.default(pos.row, pos.column, pos.row, pos.column + 1);
          } else if (self.session.$mode && self.session.$mode.getMatching) {
            var range = self.session.$mode.getMatching(self.session);
          }
          if (range) {
            self.session.$bracketHighlight = self.session.addMarker(range, "ace_bracket", "text");
          }
        }, 50);
      };
      Editor.prototype.$highlightTags = function() {
        var session = this.session;
        if (this.$highlightTagPending) {
          return;
        }
        var self = this;
        this.$highlightTagPending = true;
        setTimeout(function() {
          self.$highlightTagPending = false;
          var pos = self.getCursorPosition();
          var iterator = new TokenIterator_1.default(self.session, pos.row, pos.column);
          var token = iterator.getCurrentToken();
          if (!token || token.type.indexOf('tag-name') === -1) {
            session.removeMarker(session.$tagHighlight);
            session.$tagHighlight = null;
            return;
          }
          var tag = token.value;
          var depth = 0;
          var prevToken = iterator.stepBackward();
          if (prevToken.value == '<') {
            do {
              prevToken = token;
              token = iterator.stepForward();
              if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                if (prevToken.value === '<') {
                  depth++;
                } else if (prevToken.value === '</') {
                  depth--;
                }
              }
            } while (token && depth >= 0);
          } else {
            do {
              token = prevToken;
              prevToken = iterator.stepBackward();
              if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                if (prevToken.value === '<') {
                  depth++;
                } else if (prevToken.value === '</') {
                  depth--;
                }
              }
            } while (prevToken && depth <= 0);
            iterator.stepForward();
          }
          if (!token) {
            session.removeMarker(session.$tagHighlight);
            session.$tagHighlight = null;
            return;
          }
          var row = iterator.getCurrentTokenRow();
          var column = iterator.getCurrentTokenColumn();
          var range = new Range_1.default(row, column, row, column + token.value.length);
          if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range) !== 0) {
            session.removeMarker(session.$tagHighlight);
            session.$tagHighlight = null;
          }
          if (range && !session.$tagHighlight)
            session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
      };
      Editor.prototype.focus = function() {
        var _this = this;
        setTimeout(function() {
          _this.textInput.focus();
        });
        this.textInput.focus();
      };
      Editor.prototype.isFocused = function() {
        return this.textInput.isFocused();
      };
      Editor.prototype.blur = function() {
        this.textInput.blur();
      };
      Editor.prototype.onFocus = function() {
        if (this.$isFocused) {
          return;
        }
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this.eventBus._emit("focus");
      };
      Editor.prototype.onBlur = function() {
        if (!this.$isFocused) {
          return;
        }
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this.eventBus._emit("blur");
      };
      Editor.prototype.$cursorChange = function() {
        this.renderer.updateCursor();
      };
      Editor.prototype.onDocumentChange = function(delta, session) {
        var wrap = this.session.$useWrapMode;
        var lastRow = (delta.start.row === delta.end.row ? delta.end.row : Infinity);
        this.renderer.updateLines(delta.start.row, lastRow, wrap);
        this.eventBus._signal("change", delta);
        this.$cursorChange();
        this.$updateHighlightActiveLine();
      };
      Editor.prototype.onTokenizerUpdate = function(event, session) {
        var rows = event.data;
        this.renderer.updateLines(rows.first, rows.last);
      };
      Editor.prototype.onScrollTopChange = function(event, session) {
        this.renderer.scrollToY(session.getScrollTop());
      };
      Editor.prototype.onScrollLeftChange = function(event, session) {
        this.renderer.scrollToX(session.getScrollLeft());
      };
      Editor.prototype.onCursorChange = function(event, session) {
        this.$cursorChange();
        if (!this.$blockScrolling) {
          this.renderer.scrollCursorIntoView();
        }
        this.$highlightBrackets();
        this.$highlightTags();
        this.$updateHighlightActiveLine();
        this.eventBus._signal("changeSelection");
      };
      Editor.prototype.$updateHighlightActiveLine = function() {
        var session = this.session;
        var renderer = this.renderer;
        var highlight;
        if (this.$highlightActiveLine) {
          if ((this.$selectionStyle !== "line" || !this.selection.isMultiLine())) {
            highlight = this.getCursorPosition();
          }
          if (renderer.$maxLines && session.getLength() === 1 && !(renderer.$minLines > 1)) {
            highlight = false;
          }
        }
        if (session.$highlightLineMarker && !highlight) {
          session.removeMarker(session.$highlightLineMarker.markerId);
          session.$highlightLineMarker = null;
        } else if (!session.$highlightLineMarker && highlight) {
          var range = new Range_1.default(highlight.row, highlight.column, highlight.row, Infinity);
          range.markerId = session.addMarker(range, "ace_active-line", "screenLine");
          session.$highlightLineMarker = range;
        } else if (highlight) {
          session.$highlightLineMarker.start.row = highlight.row;
          session.$highlightLineMarker.end.row = highlight.row;
          session.$highlightLineMarker.start.column = highlight.column;
          session._signal("changeBackMarker");
        }
      };
      Editor.prototype.onSelectionChange = function(unused, selection) {
        var session = this.session;
        if (typeof session.$selectionMarker === 'number') {
          session.removeMarker(session.$selectionMarker);
          session.$selectionMarker = null;
        }
        if (!this.selection.isEmpty()) {
          var range = this.selection.getRange();
          var style = this.getSelectionStyle();
          session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
          this.$updateHighlightActiveLine();
        }
        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re);
        this.eventBus._signal("changeSelection");
      };
      Editor.prototype.$getSelectionHighLightRegexp = function() {
        var session = this.session;
        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
          return;
        var startOuter = selection.start.column - 1;
        var endOuter = selection.end.column + 1;
        var line = session.getLine(selection.start.row);
        var lineCols = line.length;
        var needle = line.substring(Math.max(startOuter, 0), Math.min(endOuter, lineCols));
        if ((startOuter >= 0 && /^[\w\d]/.test(needle)) || (endOuter <= lineCols && /[\w\d]$/.test(needle)))
          return;
        needle = line.substring(selection.start.column, selection.end.column);
        if (!/^[\w\d]+$/.test(needle))
          return;
        var re = this.$search.$assembleRegExp({
          wholeWord: true,
          caseSensitive: true,
          needle: needle
        });
        return re;
      };
      Editor.prototype.onChangeFrontMarker = function(event, session) {
        this.updateFrontMarkers();
      };
      Editor.prototype.updateFrontMarkers = function() {
        this.renderer.updateFrontMarkers();
      };
      Editor.prototype.onChangeBackMarker = function(event, session) {
        this.renderer.updateBackMarkers();
      };
      Editor.prototype.updateBackMarkers = function() {
        this.renderer.updateBackMarkers();
      };
      Editor.prototype.onChangeBreakpoint = function(event, editSession) {
        this.renderer.updateBreakpoints();
        this.eventBus._emit("changeBreakpoint", event);
      };
      Editor.prototype.onChangeAnnotation = function(event, session) {
        this.renderer.setAnnotations(session.getAnnotations());
        this.eventBus._emit("changeAnnotation", event);
      };
      Editor.prototype.onChangeMode = function(event, session) {
        this.renderer.updateText();
        this.eventBus._emit("changeMode", event);
      };
      Editor.prototype.onChangeWrapLimit = function(event, session) {
        this.renderer.updateFull();
      };
      Editor.prototype.onChangeWrapMode = function(event, session) {
        this.renderer.onResize(true);
      };
      Editor.prototype.onChangeFold = function(event, session) {
        this.$updateHighlightActiveLine();
        this.renderer.updateFull();
      };
      Editor.prototype.getSelectedText = function() {
        return this.session.getTextRange(this.getSelectionRange());
      };
      Editor.prototype.getCopyText = function() {
        var text = this.getSelectedText();
        this.eventBus._signal("copy", text);
        return text;
      };
      Editor.prototype.onCopy = function() {
        var copyCommand = this.commands.getCommandByName("copy");
        if (copyCommand) {
          this.commands.exec(copyCommand, this);
        }
      };
      Editor.prototype.onCut = function() {
        var cutCommand = this.commands.getCommandByName("cut");
        if (cutCommand) {
          this.commands.exec(cutCommand, this);
        }
      };
      Editor.prototype.onPaste = function(text) {
        if (this.$readOnly)
          return;
        var e = {text: text};
        this.eventBus._signal("paste", e);
        this.insert(e.text, true);
      };
      Editor.prototype.execCommand = function(command, args) {
        this.commands.exec(command, this, args);
      };
      Editor.prototype.insert = function(text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();
        var transform;
        if (this.getBehavioursEnabled() && !pasted) {
          transform = mode && mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
          if (transform) {
            if (text !== transform.text) {
              this.session.mergeUndoDeltas = false;
              this.$mergeNextCommand = false;
            }
            text = transform.text;
          }
        }
        if (text === "\t") {
          text = this.session.getTabString();
        }
        if (!this.selection.isEmpty()) {
          var range = this.getSelectionRange();
          cursor = this.session.remove(range);
          this.clearSelection();
        } else if (this.session.getOverwrite()) {
          var range = Range_1.default.fromPoints(cursor, cursor);
          range.end.column += text.length;
          this.session.remove(range);
        }
        if (text === "\n" || text === "\r\n") {
          var line = session.getLine(cursor.row);
          if (cursor.column > line.search(/\S|$/)) {
            var d = line.substr(cursor.column).search(/\S|$/);
            session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
          }
        }
        this.clearSelection();
        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        var end = session.insert(cursor, text);
        if (transform && transform.selection) {
          if (transform.selection.length === 2) {
            this.selection.setSelectionRange(new Range_1.default(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
          } else {
            this.selection.setSelectionRange(new Range_1.default(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
          }
        }
        if (session.getDocument().isNewLine(text)) {
          var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
          session.insert({
            row: cursor.row + 1,
            column: 0
          }, lineIndent);
        }
        if (shouldOutdent) {
          mode.autoOutdent(lineState, session, cursor.row);
        }
      };
      Editor.prototype.on = function(eventName, callback, capturing) {
        this.eventBus.on(eventName, callback, capturing);
      };
      Editor.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      Editor.prototype.setDefaultHandler = function(eventName, callback) {
        this.eventBus.setDefaultHandler(eventName, callback);
      };
      Editor.prototype._emit = function(eventName, event) {
        this.eventBus._emit(eventName, event);
      };
      Editor.prototype._signal = function(eventName, event) {
        this.eventBus._signal(eventName, event);
      };
      Editor.prototype.hasListeners = function(eventName) {
        return this.eventBus.hasListeners(eventName);
      };
      Editor.prototype.onTextInput = function(text) {
        this.keyBinding.onTextInput(text);
        if (text === '.') {
          var command = this.commands.getCommandByName(editor_protocol_1.COMMAND_NAME_AUTO_COMPLETE);
          if (command) {
            this.commands.exec(command, this);
          }
        } else if (this.getSession().getDocument().isNewLine(text)) {
          var lineNumber = this.getCursorPosition().row;
        }
      };
      Editor.prototype.onCommandKey = function(e, hashId, keyCode) {
        this.keyBinding.onCommandKey(e, hashId, keyCode);
      };
      Editor.prototype.setOverwrite = function(overwrite) {
        this.session.setOverwrite(overwrite);
      };
      Editor.prototype.getOverwrite = function() {
        return this.session.getOverwrite();
      };
      Editor.prototype.toggleOverwrite = function() {
        this.session.toggleOverwrite();
      };
      Editor.prototype.setScrollSpeed = function(speed) {
        this.setOption("scrollSpeed", speed);
      };
      Editor.prototype.getScrollSpeed = function() {
        return this.getOption("scrollSpeed");
      };
      Editor.prototype.setDragDelay = function(dragDelay) {
        this.setOption("dragDelay", dragDelay);
      };
      Editor.prototype.getDragDelay = function() {
        return this.getOption("dragDelay");
      };
      Editor.prototype.setSelectionStyle = function(selectionStyle) {
        this.setOption("selectionStyle", selectionStyle);
      };
      Editor.prototype.getSelectionStyle = function() {
        return this.getOption("selectionStyle");
      };
      Editor.prototype.setHighlightActiveLine = function(highlightActiveLine) {
        this.setOption("highlightActiveLine", highlightActiveLine);
      };
      Editor.prototype.getHighlightActiveLine = function() {
        return this.getOption("highlightActiveLine");
      };
      Editor.prototype.setHighlightGutterLine = function(highlightGutterLine) {
        this.setOption("highlightGutterLine", highlightGutterLine);
      };
      Editor.prototype.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
      };
      Editor.prototype.setHighlightSelectedWord = function(highlightSelectedWord) {
        this.setOption("highlightSelectedWord", highlightSelectedWord);
      };
      Editor.prototype.getHighlightSelectedWord = function() {
        return this.$highlightSelectedWord;
      };
      Editor.prototype.setAnimatedScroll = function(animatedScroll) {
        this.renderer.setAnimatedScroll(animatedScroll);
      };
      Editor.prototype.getAnimatedScroll = function() {
        return this.renderer.getAnimatedScroll();
      };
      Editor.prototype.setShowInvisibles = function(showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
      };
      Editor.prototype.getShowInvisibles = function() {
        return this.renderer.getShowInvisibles();
      };
      Editor.prototype.setDisplayIndentGuides = function(displayIndentGuides) {
        this.renderer.setDisplayIndentGuides(displayIndentGuides);
      };
      Editor.prototype.getDisplayIndentGuides = function() {
        return this.renderer.getDisplayIndentGuides();
      };
      Editor.prototype.setShowPrintMargin = function(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
      };
      Editor.prototype.getShowPrintMargin = function() {
        return this.renderer.getShowPrintMargin();
      };
      Editor.prototype.setPrintMarginColumn = function(printMarginColumn) {
        this.renderer.setPrintMarginColumn(printMarginColumn);
      };
      Editor.prototype.getPrintMarginColumn = function() {
        return this.renderer.getPrintMarginColumn();
      };
      Editor.prototype.setReadOnly = function(readOnly) {
        this.setOption("readOnly", readOnly);
      };
      Editor.prototype.getReadOnly = function() {
        return this.getOption("readOnly");
      };
      Editor.prototype.setBehavioursEnabled = function(behavioursEnabled) {
        this.setOption("behavioursEnabled", behavioursEnabled);
      };
      Editor.prototype.getBehavioursEnabled = function() {
        return this.getOption("behavioursEnabled");
      };
      Editor.prototype.setWrapBehavioursEnabled = function(wrapBehavioursEnabled) {
        this.setOption("wrapBehavioursEnabled", wrapBehavioursEnabled);
      };
      Editor.prototype.getWrapBehavioursEnabled = function() {
        return this.getOption("wrapBehavioursEnabled");
      };
      Editor.prototype.setShowFoldWidgets = function(showFoldWidgets) {
        this.setOption("showFoldWidgets", showFoldWidgets);
      };
      Editor.prototype.getShowFoldWidgets = function() {
        return this.getOption("showFoldWidgets");
      };
      Editor.prototype.setFadeFoldWidgets = function(fadeFoldWidgets) {
        this.setOption("fadeFoldWidgets", fadeFoldWidgets);
      };
      Editor.prototype.getFadeFoldWidgets = function() {
        return this.getOption("fadeFoldWidgets");
      };
      Editor.prototype.remove = function(direction) {
        if (this.selection.isEmpty()) {
          if (direction === "left")
            this.selection.selectLeft();
          else
            this.selection.selectRight();
        }
        var selectionRange = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
          var session = this.session;
          var state = session.getState(selectionRange.start.row);
          var newRange = session.getMode().transformAction(state, 'deletion', this, session, selectionRange);
          if (selectionRange.end.column === 0) {
            var text = session.getTextRange(selectionRange);
            if (text[text.length - 1] === "\n") {
              var line = session.getLine(selectionRange.end.row);
              if (/^\s+$/.test(line)) {
                selectionRange.end.column = line.length;
              }
            }
          }
          if (newRange) {
            selectionRange = newRange;
          }
        }
        this.session.remove(selectionRange);
        this.clearSelection();
      };
      Editor.prototype.removeWordRight = function() {
        if (this.selection.isEmpty()) {
          this.selection.selectWordRight();
        }
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
      };
      Editor.prototype.removeWordLeft = function() {
        if (this.selection.isEmpty())
          this.selection.selectWordLeft();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
      };
      Editor.prototype.removeToLineStart = function() {
        if (this.selection.isEmpty())
          this.selection.selectLineStart();
        this.session.remove(this.getSelectionRange());
        this.clearSelection();
      };
      Editor.prototype.removeToLineEnd = function() {
        if (this.selection.isEmpty())
          this.selection.selectLineEnd();
        var range = this.getSelectionRange();
        if (range.start.column === range.end.column && range.start.row === range.end.row) {
          range.end.column = 0;
          range.end.row++;
        }
        this.session.remove(range);
        this.clearSelection();
      };
      Editor.prototype.splitLine = function() {
        if (!this.selection.isEmpty()) {
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        }
        var cursor = this.getCursorPosition();
        this.insert("\n", false);
        this.moveCursorToPosition(cursor);
      };
      Editor.prototype.transposeLetters = function() {
        if (!this.selection.isEmpty()) {
          return;
        }
        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
          return;
        var line = this.session.getLine(cursor.row);
        var swap,
            range;
        if (column < line.length) {
          swap = line.charAt(column) + line.charAt(column - 1);
          range = new Range_1.default(cursor.row, column - 1, cursor.row, column + 1);
        } else {
          swap = line.charAt(column - 1) + line.charAt(column - 2);
          range = new Range_1.default(cursor.row, column - 2, cursor.row, column);
        }
        this.session.replace(range, swap);
      };
      Editor.prototype.toLowerCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
          this.selection.selectWord();
        }
        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
      };
      Editor.prototype.toUpperCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
          this.selection.selectWord();
        }
        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
      };
      Editor.prototype.indent = function() {
        var session = this.session;
        var range = this.getSelectionRange();
        if (range.start.row < range.end.row) {
          var rows = this.$getSelectedRows();
          session.indentRows(rows.first, rows.last, "\t");
          return;
        } else if (range.start.column < range.end.column) {
          var text = session.getTextRange(range);
          if (!/^\s+$/.test(text)) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
          }
        }
        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);
        if (this.session.getUseSoftTabs()) {
          var count = (size - column % size);
          var indentString = lang_1.stringRepeat(" ", count);
        } else {
          var count = column % size;
          while (line[range.start.column] === " " && count) {
            range.start.column--;
            count--;
          }
          this.selection.setSelectionRange(range);
          indentString = "\t";
        }
        return this.insert(indentString, false);
      };
      Editor.prototype.blockIndent = function() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "\t");
      };
      Editor.prototype.blockOutdent = function() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
      };
      Editor.prototype.sortLines = function() {
        var rows = this.$getSelectedRows();
        var session = this.session;
        var lines = [];
        for (i = rows.first; i <= rows.last; i++)
          lines.push(session.getLine(i));
        lines.sort(function(a, b) {
          if (a.toLowerCase() < b.toLowerCase())
            return -1;
          if (a.toLowerCase() > b.toLowerCase())
            return 1;
          return 0;
        });
        var deleteRange = new Range_1.default(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
          var line = session.getLine(i);
          deleteRange.start.row = i;
          deleteRange.end.row = i;
          deleteRange.end.column = line.length;
          session.replace(deleteRange, lines[i - rows.first]);
        }
      };
      Editor.prototype.toggleCommentLines = function() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
      };
      Editor.prototype.toggleBlockComment = function() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
      };
      Editor.prototype.getNumberAt = function(row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;
        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
          var m = _numberRx.exec(s);
          if (m.index <= column && m.index + m[0].length >= column) {
            var retval = {
              value: m[0],
              start: m.index,
              end: m.index + m[0].length
            };
            return retval;
          }
        }
        return null;
      };
      Editor.prototype.modifyNumber = function(amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        var charRange = new Range_1.default(row, column - 1, row, column);
        var c = parseFloat(this.session.getTextRange(charRange));
        if (!isNaN(c) && isFinite(c)) {
          var nr = this.getNumberAt(row, column);
          if (nr) {
            var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
            var decimals = nr.start + nr.value.length - fp;
            var t = parseFloat(nr.value);
            t *= Math.pow(10, decimals);
            if (fp !== nr.end && column < fp) {
              amount *= Math.pow(10, nr.end - column - 1);
            } else {
              amount *= Math.pow(10, nr.end - column);
            }
            t += amount;
            t /= Math.pow(10, decimals);
            var nnr = t.toFixed(decimals);
            var replaceRange = new Range_1.default(row, nr.start, row, nr.end);
            this.session.replace(replaceRange, nnr);
            this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
          }
        }
      };
      Editor.prototype.removeLines = function() {
        var rows = this.$getSelectedRows();
        var range;
        if (rows.first === 0 || rows.last + 1 < this.session.getLength())
          range = new Range_1.default(rows.first, 0, rows.last + 1, 0);
        else
          range = new Range_1.default(rows.first - 1, this.session.getLine(rows.first - 1).length, rows.last, this.session.getLine(rows.last).length);
        this.session.remove(range);
        this.clearSelection();
      };
      Editor.prototype.duplicateSelection = function() {
        var selection = this.selection;
        var session = this.session;
        var range = selection.getRange();
        var reverse = selection.isBackwards();
        if (range.isEmpty()) {
          var row = range.start.row;
          session.duplicateLines(row, row);
        } else {
          var point = reverse ? range.start : range.end;
          var endPoint = session.insert(point, session.getTextRange(range));
          range.start = point;
          range.end = endPoint;
          selection.setSelectionRange(range, reverse);
        }
      };
      Editor.prototype.moveLinesDown = function() {
        var _this = this;
        this.$moveLines(function(firstRow, lastRow) {
          return _this.session.moveLinesDown(firstRow, lastRow);
        });
      };
      Editor.prototype.moveLinesUp = function() {
        this.$moveLines(function(firstRow, lastRow) {
          return this.session.moveLinesUp(firstRow, lastRow);
        });
      };
      Editor.prototype.moveText = function(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
      };
      Editor.prototype.copyLinesUp = function() {
        this.$moveLines(function(firstRow, lastRow) {
          this.session.duplicateLines(firstRow, lastRow);
          return 0;
        });
      };
      Editor.prototype.copyLinesDown = function() {
        this.$moveLines(function(firstRow, lastRow) {
          return this.session.duplicateLines(firstRow, lastRow);
        });
      };
      Editor.prototype.$moveLines = function(mover) {
        var selection = this.selection;
        if (!selection['inMultiSelectMode'] || this.inVirtualSelectionMode) {
          var range = selection.toOrientedRange();
          var selectedRows = this.$getSelectedRows();
          var linesMoved = mover.call(this, selectedRows.first, selectedRows.last);
          range.moveBy(linesMoved, 0);
          selection.fromOrientedRange(range);
        } else {
          var ranges = selection.rangeList.ranges;
          selection.rangeList.detach();
          for (var i = ranges.length; i--; ) {
            var rangeIndex = i;
            var collapsedRows = ranges[i].collapseRows();
            var last = collapsedRows.end.row;
            var first = collapsedRows.start.row;
            while (i--) {
              collapsedRows = ranges[i].collapseRows();
              if (first - collapsedRows.end.row <= 1)
                first = collapsedRows.end.row;
              else
                break;
            }
            i++;
            var linesMoved = mover.call(this, first, last);
            while (rangeIndex >= i) {
              ranges[rangeIndex].moveBy(linesMoved, 0);
              rangeIndex--;
            }
          }
          selection.fromOrientedRange(selection.ranges[0]);
          selection.rangeList.attach(this.session);
        }
      };
      Editor.prototype.$getSelectedRows = function() {
        var range = this.getSelectionRange().collapseRows();
        return {
          first: this.session.getRowFoldStart(range.start.row),
          last: this.session.getRowFoldEnd(range.end.row)
        };
      };
      Editor.prototype.onCompositionStart = function(text) {
        this.renderer.showComposition(this.getCursorPosition());
      };
      Editor.prototype.onCompositionUpdate = function(text) {
        this.renderer.setCompositionText(text);
      };
      Editor.prototype.onCompositionEnd = function() {
        this.renderer.hideComposition();
      };
      Editor.prototype.getFirstVisibleRow = function() {
        return this.renderer.getFirstVisibleRow();
      };
      Editor.prototype.getLastVisibleRow = function() {
        return this.renderer.getLastVisibleRow();
      };
      Editor.prototype.isRowVisible = function(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
      };
      Editor.prototype.isRowFullyVisible = function(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
      };
      Editor.prototype.$getVisibleRowCount = function() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
      };
      Editor.prototype.$moveByPage = function(direction, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = direction * Math.floor(config.height / config.lineHeight);
        this.$blockScrolling++;
        if (select === true) {
          this.selection.$moveSelection(function() {
            this.moveCursorBy(rows, 0);
          });
        } else if (select === false) {
          this.selection.moveCursorBy(rows, 0);
          this.selection.clearSelection();
        }
        this.$blockScrolling--;
        var scrollTop = renderer.scrollTop;
        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null) {
          renderer.scrollCursorIntoView(null, 0.5);
        }
        renderer.animateScrolling(scrollTop);
      };
      Editor.prototype.selectPageDown = function() {
        this.$moveByPage(+1, true);
      };
      Editor.prototype.selectPageUp = function() {
        this.$moveByPage(-1, true);
      };
      Editor.prototype.gotoPageDown = function() {
        this.$moveByPage(+1, false);
      };
      Editor.prototype.gotoPageUp = function() {
        this.$moveByPage(-1, false);
      };
      Editor.prototype.scrollPageDown = function() {
        this.$moveByPage(1);
      };
      Editor.prototype.scrollPageUp = function() {
        this.$moveByPage(-1);
      };
      Editor.prototype.scrollToRow = function(row) {
        this.renderer.scrollToRow(row);
      };
      Editor.prototype.scrollToLine = function(line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
      };
      Editor.prototype.centerSelection = function() {
        var range = this.getSelectionRange();
        var pos = {
          row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
          column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
      };
      Editor.prototype.getCursorPosition = function() {
        return this.selection.getCursor();
      };
      Editor.prototype.getCursorPositionScreen = function() {
        var cursor = this.getCursorPosition();
        return this.session.documentToScreenPosition(cursor.row, cursor.column);
      };
      Editor.prototype.getSelectionRange = function() {
        return this.selection.getRange();
      };
      Editor.prototype.selectAll = function() {
        this.$blockScrolling += 1;
        this.selection.selectAll();
        this.$blockScrolling -= 1;
      };
      Editor.prototype.clearSelection = function() {
        this.selection.clearSelection();
      };
      Editor.prototype.moveCursorTo = function(row, column, animate) {
        this.selection.moveCursorTo(row, column, animate);
      };
      Editor.prototype.moveCursorToPosition = function(position) {
        return this.selection.moveCursorToPosition(position);
      };
      Editor.prototype.jumpToMatching = function(select) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator_1.default(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var token = prevToken;
        if (!token)
          token = iterator.stepForward();
        if (!token)
          return;
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
          ")": "(",
          "(": "(",
          "]": "[",
          "[": "[",
          "{": "{",
          "}": "{"
        };
        do {
          if (token.value.match(/[{}()\[\]]/g)) {
            for (; i < token.value.length && !found; i++) {
              if (!brackets[token.value[i]]) {
                continue;
              }
              bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");
              if (isNaN(depth[bracketType])) {
                depth[bracketType] = 0;
              }
              switch (token.value[i]) {
                case '(':
                case '[':
                case '{':
                  depth[bracketType]++;
                  break;
                case ')':
                case ']':
                case '}':
                  depth[bracketType]--;
                  if (depth[bracketType] === -1) {
                    matchType = 'bracket';
                    found = true;
                  }
                  break;
              }
            }
          } else if (token && token.type.indexOf('tag-name') !== -1) {
            if (isNaN(depth[token.value])) {
              depth[token.value] = 0;
            }
            if (prevToken.value === '<') {
              depth[token.value]++;
            } else if (prevToken.value === '</') {
              depth[token.value]--;
            }
            if (depth[token.value] === -1) {
              matchType = 'tag';
              found = true;
            }
          }
          if (!found) {
            prevToken = token;
            token = iterator.stepForward();
            i = 0;
          }
        } while (token && !found);
        if (!matchType) {
          return;
        }
        var range;
        if (matchType === 'bracket') {
          range = this.session.getBracketRange(cursor);
          if (!range) {
            range = new Range_1.default(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
            if (!range)
              return;
            var pos = range.start;
            if (pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
              range = this.session.getBracketRange(pos);
          }
        } else if (matchType === 'tag') {
          if (token && token.type.indexOf('tag-name') !== -1)
            var tag = token.value;
          else
            return;
          var range = new Range_1.default(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
          if (range.compare(cursor.row, cursor.column) === 0) {
            found = false;
            do {
              token = prevToken;
              prevToken = iterator.stepBackward();
              if (prevToken) {
                if (prevToken.type.indexOf('tag-close') !== -1) {
                  range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                }
                if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                  if (prevToken.value === '<') {
                    depth[tag]++;
                  } else if (prevToken.value === '</') {
                    depth[tag]--;
                  }
                  if (depth[tag] === 0)
                    found = true;
                }
              }
            } while (prevToken && !found);
          }
          if (token && token.type.indexOf('tag-name')) {
            var pos = range.start;
            if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
              pos = range.end;
          }
        }
        pos = range && range['cursor'] || pos;
        if (pos) {
          if (select) {
            if (range && range.isEqual(this.getSelectionRange()))
              this.clearSelection();
            else
              this.selection.selectTo(pos.row, pos.column);
          } else {
            this.selection.moveTo(pos.row, pos.column);
          }
        }
      };
      Editor.prototype.gotoLine = function(lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({
          row: lineNumber - 1,
          column: column || 0
        });
        this.$blockScrolling += 1;
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);
        this.$blockScrolling -= 1;
        if (!this.isRowFullyVisible(lineNumber - 1)) {
          this.scrollToLine(lineNumber - 1, true, animate);
        }
      };
      Editor.prototype.navigateTo = function(row, column) {
        this.selection.moveTo(row, column);
      };
      Editor.prototype.navigateUp = function(times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
          var selectionStart = this.selection.anchor.getPosition();
          return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
      };
      Editor.prototype.navigateDown = function(times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
          var selectionEnd = this.selection.anchor.getPosition();
          return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
      };
      Editor.prototype.navigateLeft = function(times) {
        if (!this.selection.isEmpty()) {
          var selectionStart = this.getSelectionRange().start;
          this.moveCursorToPosition(selectionStart);
        } else {
          times = times || 1;
          while (times--) {
            this.selection.moveCursorLeft();
          }
        }
        this.clearSelection();
      };
      Editor.prototype.navigateRight = function(times) {
        if (!this.selection.isEmpty()) {
          var selectionEnd = this.getSelectionRange().end;
          this.moveCursorToPosition(selectionEnd);
        } else {
          times = times || 1;
          while (times--) {
            this.selection.moveCursorRight();
          }
        }
        this.clearSelection();
      };
      Editor.prototype.navigateLineStart = function() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
      };
      Editor.prototype.navigateLineEnd = function() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
      };
      Editor.prototype.navigateFileEnd = function() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
      };
      Editor.prototype.navigateFileStart = function() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
      };
      Editor.prototype.navigateWordRight = function() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
      };
      Editor.prototype.navigateWordLeft = function() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
      };
      Editor.prototype.replace = function(replacement, options) {
        if (options)
          this.$search.set(options);
        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
          return replaced;
        if (this.$tryReplace(range, replacement)) {
          replaced = 1;
        }
        if (range !== null) {
          this.selection.setSelectionRange(range);
          this.renderer.scrollSelectionIntoView(range.start, range.end);
        }
        return replaced;
      };
      Editor.prototype.replaceAll = function(replacement, options) {
        if (options) {
          this.$search.set(options);
        }
        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
          return replaced;
        this.$blockScrolling += 1;
        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);
        for (var i = ranges.length - 1; i >= 0; --i) {
          if (this.$tryReplace(ranges[i], replacement)) {
            replaced++;
          }
        }
        this.selection.setSelectionRange(selection);
        this.$blockScrolling -= 1;
        return replaced;
      };
      Editor.prototype.$tryReplace = function(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
          range.end = this.session.replace(range, replacement);
          return range;
        } else {
          return null;
        }
      };
      Editor.prototype.getLastSearchOptions = function() {
        return this.$search.getOptions();
      };
      Editor.prototype.findAll = function(needle, options, additive) {
        if (options === void 0) {
          options = {};
        }
        options.needle = needle || options.needle;
        if (options.needle == undefined) {
          var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
          options.needle = this.session.getTextRange(range);
        }
        this.$search.set(options);
        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
          return 0;
        this.$blockScrolling += 1;
        var selection = this.multiSelect;
        if (!additive)
          selection.toSingleRange(ranges[0]);
        for (var i = ranges.length; i--; )
          selection.addRange(ranges[i], true);
        if (range && selection.rangeList.rangeAtPoint(range.start)) {
          selection.addRange(range, true);
        }
        this.$blockScrolling -= 1;
        return ranges.length;
      };
      ;
      Editor.prototype.find = function(needle, options, animate) {
        if (options === void 0) {
          options = {};
        }
        if (typeof needle === "string" || needle instanceof RegExp) {
          options.needle = needle;
        } else if (typeof needle == "object") {
          oop_1.mixin(options, needle);
        }
        var range = this.selection.getRange();
        if (options.needle == null) {
          needle = this.session.getTextRange(range) || this.$search.$options.needle;
          if (!needle) {
            range = this.session.getWordRange(range.start.row, range.start.column);
            needle = this.session.getTextRange(range);
          }
          this.$search.set({needle: needle});
        }
        this.$search.set(options);
        if (!options.start) {
          this.$search.set({start: range.start});
        }
        var newRange = this.$search.find(this.session);
        if (options.preventScroll) {
          return newRange;
        }
        if (newRange) {
          this.revealRange(newRange, animate);
          return newRange;
        }
        if (options.backwards)
          range.start = range.end;
        else
          range.end = range.start;
        this.selection.setRange(range);
      };
      Editor.prototype.findNext = function(needle, animate) {
        this.find(needle, {
          skipCurrent: true,
          backwards: false
        }, animate);
      };
      Editor.prototype.findPrevious = function(needle, animate) {
        this.find(needle, {
          skipCurrent: true,
          backwards: true
        }, animate);
      };
      Editor.prototype.revealRange = function(range, animate) {
        this.$blockScrolling += 1;
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        this.$blockScrolling -= 1;
        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false) {
          this.renderer.animateScrolling(scrollTop);
        }
      };
      Editor.prototype.undo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().undo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(void 0, 0.5);
      };
      Editor.prototype.redo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().redo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(void 0, 0.5);
      };
      Editor.prototype.destroy = function() {
        this.renderer.destroy();
        this._signal("destroy", this);
      };
      Editor.prototype.setAutoScrollEditorIntoView = function(enable) {
        if (!enable)
          return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
          this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
          shouldScroll = true;
        });
        var onBeforeRender = this.renderer.on("beforeRender", function() {
          if (shouldScroll)
            rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
          if (shouldScroll && rect && self.isFocused()) {
            var renderer = self.renderer;
            var pos = renderer.$cursorLayer.$pixelPos;
            var config = renderer.layerConfig;
            var top = pos.top - config.offset;
            if (pos.top >= 0 && top + rect.top < 0) {
              shouldScroll = true;
            } else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) {
              shouldScroll = false;
            } else {
              shouldScroll = null;
            }
            if (shouldScroll != null) {
              scrollAnchor.style.top = top + "px";
              scrollAnchor.style.left = pos.left + "px";
              scrollAnchor.style.height = config.lineHeight + "px";
              scrollAnchor.scrollIntoView(shouldScroll);
            }
            shouldScroll = rect = null;
          }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
          if (enable)
            return;
          delete this.setAutoScrollEditorIntoView;
          this.removeEventListener("changeSelection", onChangeSelection);
          this.renderer.removeEventListener("afterRender", onAfterRender);
          this.renderer.removeEventListener("beforeRender", onBeforeRender);
        };
      };
      Editor.prototype.$resetCursorStyle = function() {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer) {
          return;
        }
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly && style !== "wide";
        cursorLayer.setCssClass("ace_slim-cursors", /slim/.test(style));
      };
      return Editor;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Editor;
    config_1.defineOptions(Editor.prototype, "editor", {
      selectionStyle: {
        set: function(style) {
          var that = this;
          that.$onSelectionChange(void 0, that.selection);
          that._signal("changeSelectionStyle", {data: style});
        },
        initialValue: "line"
      },
      highlightActiveLine: {
        set: function() {
          var that = this;
          that.$updateHighlightActiveLine();
        },
        initialValue: true
      },
      highlightSelectedWord: {
        set: function(shouldHighlight) {
          var that = this;
          that.$onSelectionChange(void 0, that.selection);
        },
        initialValue: true
      },
      readOnly: {
        set: function(readOnly) {
          this.$resetCursorStyle();
        },
        initialValue: false
      },
      cursorStyle: {
        set: function(val) {
          var that = this;
          that.$resetCursorStyle();
        },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
      },
      mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
      },
      behavioursEnabled: {initialValue: true},
      wrapBehavioursEnabled: {initialValue: true},
      autoScrollEditorIntoView: {set: function(enable) {
          var that = this;
          that.setAutoScrollEditorIntoView(enable);
        }},
      hScrollBarAlwaysVisible: "renderer",
      vScrollBarAlwaysVisible: "renderer",
      highlightGutterLine: "renderer",
      animatedScroll: "renderer",
      showInvisibles: "renderer",
      showPrintMargin: "renderer",
      printMarginColumn: "renderer",
      printMargin: "renderer",
      fadeFoldWidgets: "renderer",
      showFoldWidgets: "renderer",
      showLineNumbers: "renderer",
      showGutter: "renderer",
      displayIndentGuides: "renderer",
      fontSize: "renderer",
      fontFamily: "renderer",
      maxLines: "renderer",
      minLines: "renderer",
      scrollPastEnd: "renderer",
      fixedWidthGutter: "renderer",
      theme: "renderer",
      scrollSpeed: "$mouseHandler",
      dragDelay: "$mouseHandler",
      dragEnabled: "$mouseHandler",
      focusTimout: "$mouseHandler",
      tooltipFollowsMouse: "$mouseHandler",
      firstLineNumber: "session",
      overwrite: "session",
      newLineMode: "session",
      useWorker: "session",
      useSoftTabs: "session",
      tabSize: "session",
      wrap: "session",
      foldStyle: "session",
      mode: "session"
    });
    var FoldHandler = (function() {
      function FoldHandler(editor) {
        editor.on("click", function(e) {
          var position = e.getDocumentPosition();
          var session = editor.getSession();
          var fold = session.getFoldAt(position.row, position.column, 1);
          if (fold) {
            if (e.getAccelKey()) {
              session.removeFold(fold);
            } else {
              session.expandFold(fold);
            }
            e.stop();
          } else {}
        });
        editor.on('gutterclick', function(e) {
          var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
          if (gutterRegion === 'foldWidgets') {
            var row = e.getDocumentPosition().row;
            var session = editor.getSession();
            if (session['foldWidgets'] && session['foldWidgets'][row]) {
              session['onFoldWidgetClick'](row, e);
            }
            if (!editor.isFocused()) {
              editor.focus();
            }
            e.stop();
          }
        });
        editor.on('gutterdblclick', function(e) {
          var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
          if (gutterRegion == 'foldWidgets') {
            var row = e.getDocumentPosition().row;
            var session = editor.getSession();
            var data = session['getParentFoldRangeData'](row, true);
            var range = data.range || data.firstRange;
            if (range) {
              row = range.start.row;
              var fold = session.getFoldAt(row, session.getLine(row).length, 1);
              if (fold) {
                session.removeFold(fold);
              } else {
                session['addFold']("...", range);
                editor.renderer.scrollCursorIntoView({
                  row: range.start.row,
                  column: 0
                });
              }
            }
            e.stop();
          }
        });
      }
      return FoldHandler;
    }());
    var MouseHandler = (function() {
      function MouseHandler(editor) {
        this.$scrollSpeed = 2;
        this.$dragDelay = 0;
        this.$dragEnabled = true;
        this.$focusTimout = 0;
        this.$tooltipFollowsMouse = true;
        this.$clickSelection = null;
        var _self = this;
        this.editor = editor;
        editor.setDefaultHandler('mousedown', makeMouseDownHandler(editor, this));
        editor.setDefaultHandler('mousewheel', makeMouseWheelHandler(editor, this));
        editor.setDefaultHandler("dblclick", makeDoubleClickHandler(editor, this));
        editor.setDefaultHandler("tripleclick", makeTripleClickHandler(editor, this));
        editor.setDefaultHandler("quadclick", makeQuadClickHandler(editor, this));
        this.selectByLines = makeExtendSelectionBy(editor, this, "getLineRange");
        this.selectByWords = makeExtendSelectionBy(editor, this, "getWordRange");
        new GutterHandler(this);
        var onMouseDown = function(e) {
          if (!editor.isFocused() && editor.textInput) {
            editor.textInput.moveToMouse(e);
          }
          editor.focus();
        };
        var mouseTarget = editor.renderer.getMouseEventTarget();
        event_1.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
        event_1.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
        event_1.addMultiMouseDownListener(mouseTarget, [400, 300, 250], this, "onMouseEvent");
        if (editor.renderer.scrollBarV) {
          event_1.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [400, 300, 250], this, "onMouseEvent");
          event_1.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [400, 300, 250], this, "onMouseEvent");
          if (useragent_1.isIE) {
            event_1.addListener(editor.renderer.scrollBarV.element, "mousedown", onMouseDown);
            event_1.addListener(editor.renderer.scrollBarH.element, "mousemove", onMouseDown);
          }
        }
        event_1.addMouseWheelListener(editor.container, this.emitEditorMouseWheelEvent.bind(this, "mousewheel"));
        var gutterEl = editor.renderer.$gutter;
        event_1.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
        event_1.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
        event_1.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
        event_1.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));
        event_1.addListener(mouseTarget, "mousedown", onMouseDown);
        event_1.addListener(gutterEl, "mousedown", function(e) {
          editor.focus();
          return event_1.preventDefault(e);
        });
        editor.on('mousemove', function(e) {
          if (_self.state || _self.$dragDelay || !_self.$dragEnabled) {
            return;
          }
          var char = editor.renderer.screenToTextCoordinates(e.x, e.y);
          var range = editor.getSession().getSelection().getRange();
          var renderer = editor.renderer;
          if (!range.isEmpty() && range.insideStart(char.row, char.column)) {
            renderer.setCursorStyle('default');
          } else {
            renderer.setCursorStyle("");
          }
        });
      }
      MouseHandler.prototype.onMouseEvent = function(name, e) {
        this.editor._emit(name, new EditorMouseEvent(e, this.editor));
      };
      MouseHandler.prototype.onMouseMove = function(name, e) {
        if (this.editor.hasListeners('mousemove')) {
          this.editor._emit(name, new EditorMouseEvent(e, this.editor));
        }
      };
      MouseHandler.prototype.emitEditorMouseWheelEvent = function(name, e) {
        var mouseEvent = new EditorMouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e['wheelX'];
        mouseEvent.wheelY = e['wheelY'];
        this.editor._emit(name, mouseEvent);
      };
      MouseHandler.prototype.setState = function(state) {
        this.state = state;
      };
      MouseHandler.prototype.textCoordinates = function() {
        return this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
      };
      MouseHandler.prototype.captureMouse = function(ev, mouseMoveHandler) {
        this.clientX = ev.clientX;
        this.clientY = ev.clientY;
        this.isMousePressed = true;
        var renderer = this.editor.renderer;
        if (renderer.$keepTextAreaAtCursor) {
          renderer.$keepTextAreaAtCursor = null;
        }
        var onMouseMove = (function(editor, mouseHandler) {
          return function(mouseEvent) {
            if (!mouseEvent)
              return;
            if (useragent_1.isWebKit && !mouseEvent.which && mouseHandler.releaseMouse) {
              return mouseHandler.releaseMouse(undefined);
            }
            mouseHandler.clientX = mouseEvent.clientX;
            mouseHandler.clientY = mouseEvent.clientY;
            mouseMoveHandler && mouseMoveHandler(mouseEvent);
            mouseHandler.mouseEvent = new EditorMouseEvent(mouseEvent, editor);
            mouseHandler.$mouseMoved = true;
          };
        })(this.editor, this);
        var onCaptureEnd = (function(mouseHandler) {
          return function(e) {
            clearInterval(timerId);
            onCaptureInterval();
            mouseHandler[mouseHandler.state + "End"] && mouseHandler[mouseHandler.state + "End"](e);
            mouseHandler.state = "";
            if (renderer.$keepTextAreaAtCursor == null) {
              renderer.$keepTextAreaAtCursor = true;
              renderer.$moveTextAreaToCursor();
            }
            mouseHandler.isMousePressed = false;
            mouseHandler.$onCaptureMouseMove = mouseHandler.releaseMouse = null;
            e && mouseHandler.onMouseEvent("mouseup", e);
          };
        })(this);
        var onCaptureInterval = (function(mouseHandler) {
          return function() {
            mouseHandler[mouseHandler.state] && mouseHandler[mouseHandler.state]();
            mouseHandler.$mouseMoved = false;
          };
        })(this);
        if (useragent_1.isOldIE && ev.domEvent.type == "dblclick") {
          return setTimeout(function() {
            onCaptureEnd(ev);
          });
        }
        this.$onCaptureMouseMove = onMouseMove;
        this.releaseMouse = event_1.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
      };
      MouseHandler.prototype.cancelContextMenu = function() {
        var stop = function(e) {
          if (e && e.domEvent && e.domEvent.type != "contextmenu") {
            return;
          }
          this.editor.off("nativecontextmenu", stop);
          if (e && e.domEvent) {
            event_1.stopEvent(e.domEvent);
          }
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
      };
      MouseHandler.prototype.select = function() {
        var anchor;
        var cursor = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        if (this.$clickSelection) {
          var cmp = this.$clickSelection.comparePoint(cursor);
          if (cmp == -1) {
            anchor = this.$clickSelection.end;
          } else if (cmp == 1) {
            anchor = this.$clickSelection.start;
          } else {
            var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
            cursor = orientedRange.cursor;
            anchor = orientedRange.anchor;
          }
          this.editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        this.editor.selection.selectToPosition(cursor);
        this.editor.renderer.scrollCursorIntoView();
      };
      MouseHandler.prototype.selectByLinesEnd = function() {
        this.$clickSelection = null;
        this.editor.unsetStyle("ace_selecting");
        if (this.editor.renderer.scroller['releaseCapture']) {
          this.editor.renderer.scroller['releaseCapture']();
        }
      };
      MouseHandler.prototype.startSelect = function(pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        var editor = this.editor;
        if (this.mousedownEvent.getShiftKey()) {
          editor.selection.selectToPosition(pos);
        } else if (!waitForClickSelection) {
          editor.selection.moveToPosition(pos);
        }
        if (!waitForClickSelection) {
          this.select();
        }
        if (this.editor.renderer.scroller['setCapture']) {
          this.editor.renderer.scroller['setCapture']();
        }
        editor.setStyle("ace_selecting");
        this.setState("select");
      };
      MouseHandler.prototype.selectEnd = function() {
        this.selectByLinesEnd();
      };
      MouseHandler.prototype.selectAllEnd = function() {
        this.selectByLinesEnd();
      };
      MouseHandler.prototype.selectByWordsEnd = function() {
        this.selectByLinesEnd();
      };
      MouseHandler.prototype.focusWait = function() {
        var distance = calcDistance(this.mousedownEvent.clientX, this.mousedownEvent.clientY, this.clientX, this.clientY);
        var time = Date.now();
        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout) {
          this.startSelect(this.mousedownEvent.getDocumentPosition());
        }
      };
      return MouseHandler;
    }());
    config_1.defineOptions(MouseHandler.prototype, "mouseHandler", {
      scrollSpeed: {initialValue: 2},
      dragDelay: {initialValue: (useragent_1.isMac ? 150 : 0)},
      dragEnabled: {initialValue: true},
      focusTimout: {initialValue: 0},
      tooltipFollowsMouse: {initialValue: true}
    });
    var EditorMouseEvent = (function() {
      function EditorMouseEvent(domEvent, editor) {
        this.propagationStopped = false;
        this.defaultPrevented = false;
        this.getAccelKey = useragent_1.isMac ? function() {
          return this.domEvent.metaKey;
        } : function() {
          return this.domEvent.ctrlKey;
        };
        this.domEvent = domEvent;
        this.editor = editor;
        this.clientX = domEvent.clientX;
        this.clientY = domEvent.clientY;
        this.$pos = null;
        this.$inSelection = null;
      }
      Object.defineProperty(EditorMouseEvent.prototype, "toElement", {
        get: function() {
          return this.domEvent.toElement;
        },
        enumerable: true,
        configurable: true
      });
      EditorMouseEvent.prototype.stopPropagation = function() {
        event_1.stopPropagation(this.domEvent);
        this.propagationStopped = true;
      };
      EditorMouseEvent.prototype.preventDefault = function() {
        event_1.preventDefault(this.domEvent);
        this.defaultPrevented = true;
      };
      EditorMouseEvent.prototype.stop = function() {
        this.stopPropagation();
        this.preventDefault();
      };
      EditorMouseEvent.prototype.getDocumentPosition = function() {
        if (!this.$pos) {
          this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        }
        return this.$pos;
      };
      EditorMouseEvent.prototype.inSelection = function() {
        if (this.$inSelection !== null)
          return this.$inSelection;
        var editor = this.editor;
        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
          this.$inSelection = false;
        else {
          var pos = this.getDocumentPosition();
          this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }
        return this.$inSelection;
      };
      EditorMouseEvent.prototype.getButton = function() {
        return event_1.getButton(this.domEvent);
      };
      EditorMouseEvent.prototype.getShiftKey = function() {
        return this.domEvent.shiftKey;
      };
      return EditorMouseEvent;
    }());
    var DRAG_OFFSET = 0;
    function makeMouseDownHandler(editor, mouseHandler) {
      return function(ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        mouseHandler.mousedownEvent = ev;
        var button = ev.getButton();
        if (button !== 0) {
          var selectionRange = editor.getSelectionRange();
          var selectionEmpty = selectionRange.isEmpty();
          if (selectionEmpty)
            editor.selection.moveToPosition(pos);
          editor.textInput.onContextMenu(ev.domEvent);
          return;
        }
        mouseHandler.mousedownEvent.time = Date.now();
        if (inSelection && !editor.isFocused()) {
          editor.focus();
          if (mouseHandler.$focusTimout && !mouseHandler.$clickSelection && !editor.inMultiSelectMode) {
            mouseHandler.setState("focusWait");
            mouseHandler.captureMouse(ev);
            return;
          }
        }
        mouseHandler.captureMouse(ev);
        mouseHandler.startSelect(pos, ev.domEvent['_clicks'] > 1);
        return ev.preventDefault();
      };
    }
    function makeMouseWheelHandler(editor, mouseHandler) {
      return function(ev) {
        if (ev.getAccelKey()) {
          return;
        }
        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
          ev.wheelX = ev.wheelY;
          ev.wheelY = 0;
        }
        var t = ev.domEvent.timeStamp;
        var dt = t - (mouseHandler.$lastScrollTime || 0);
        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        if (isScrolable || dt < 200) {
          mouseHandler.$lastScrollTime = t;
          editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
          return ev.stop();
        }
      };
    }
    function makeDoubleClickHandler(editor, mouseHandler) {
      return function(editorMouseEvent) {
        var pos = editorMouseEvent.getDocumentPosition();
        var session = editor.getSession();
        var range = session.getBracketRange(pos);
        if (range) {
          if (range.isEmpty()) {
            range.start.column--;
            range.end.column++;
          }
          mouseHandler.setState("select");
        } else {
          range = editor.selection.getWordRange(pos.row, pos.column);
          mouseHandler.setState("selectByWords");
        }
        mouseHandler.$clickSelection = range;
        mouseHandler.select();
      };
    }
    function makeTripleClickHandler(editor, mouseHandler) {
      return function(editorMouseEvent) {
        var pos = editorMouseEvent.getDocumentPosition();
        mouseHandler.setState("selectByLines");
        var range = editor.getSelectionRange();
        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
          mouseHandler.$clickSelection = editor.selection.getLineRange(range.start.row);
          mouseHandler.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        } else {
          mouseHandler.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        mouseHandler.select();
      };
    }
    function makeQuadClickHandler(editor, mouseHandler) {
      return function(editorMouseEvent) {
        editor.selectAll();
        mouseHandler.$clickSelection = editor.getSelectionRange();
        mouseHandler.setState("selectAll");
      };
    }
    function makeExtendSelectionBy(editor, mouseHandler, unitName) {
      return function() {
        var anchor;
        var cursor = mouseHandler.textCoordinates();
        var range = editor.selection[unitName](cursor.row, cursor.column);
        if (mouseHandler.$clickSelection) {
          var cmpStart = mouseHandler.$clickSelection.comparePoint(range.start);
          var cmpEnd = mouseHandler.$clickSelection.comparePoint(range.end);
          if (cmpStart == -1 && cmpEnd <= 0) {
            anchor = mouseHandler.$clickSelection.end;
            if (range.end.row != cursor.row || range.end.column != cursor.column)
              cursor = range.start;
          } else if (cmpEnd == 1 && cmpStart >= 0) {
            anchor = mouseHandler.$clickSelection.start;
            if (range.start.row != cursor.row || range.start.column != cursor.column)
              cursor = range.end;
          } else if (cmpStart == -1 && cmpEnd == 1) {
            cursor = range.end;
            anchor = range.start;
          } else {
            var orientedRange = calcRangeOrientation(mouseHandler.$clickSelection, cursor);
            cursor = orientedRange.cursor;
            anchor = orientedRange.anchor;
          }
          editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.renderer.scrollCursorIntoView();
      };
    }
    function calcDistance(ax, ay, bx, by) {
      return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }
    function calcRangeOrientation(range, cursor) {
      if (range.start.row == range.end.row) {
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
      } else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column) {
        var cmp = cursor.column - 4;
      } else {
        var cmp = 2 * cursor.row - range.start.row - range.end.row;
      }
      if (cmp < 0) {
        return {
          cursor: range.start,
          anchor: range.end
        };
      } else {
        return {
          cursor: range.end,
          anchor: range.start
        };
      }
    }
    var GutterHandler = (function() {
      function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor.container);
        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
          if (!editor.isFocused() || e.getButton() != 0) {
            return;
          }
          var gutterRegion = gutter.getRegion(e);
          if (gutterRegion === "foldWidgets") {
            return;
          }
          var row = e.getDocumentPosition().row;
          var selection = editor.getSession().getSelection();
          if (e.getShiftKey()) {
            selection.selectTo(row, 0);
          } else {
            if (e.domEvent.detail == 2) {
              editor.selectAll();
              return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
          }
          mouseHandler.setState("selectByLines");
          mouseHandler.captureMouse(e);
          return e.preventDefault();
        });
        var tooltipTimeout;
        var mouseEvent;
        var tooltipAnnotation;
        function showTooltip() {
          var row = mouseEvent.getDocumentPosition().row;
          var annotation = gutter.$annotations[row];
          if (!annotation) {
            return hideTooltip(void 0, editor);
          }
          var session = editor.getSession();
          var maxRow = session.getLength();
          if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.clientY).row;
            var pos = mouseEvent.getDocumentPosition();
            if (screenRow > session.documentToScreenRow(pos.row, pos.column)) {
              return hideTooltip(void 0, editor);
            }
          }
          if (tooltipAnnotation == annotation) {
            return;
          }
          tooltipAnnotation = annotation.text.join("<br/>");
          tooltip.setHtml(tooltipAnnotation);
          tooltip.show();
          editor.on("mousewheel", hideTooltip);
          if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
          } else {
            var gutterElement = gutter.$cells[editor.getSession().documentToScreenRow(row, 0)].element;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
          }
        }
        function hideTooltip(event, editor) {
          if (tooltipTimeout) {
            clearTimeout(tooltipTimeout);
            tooltipTimeout = undefined;
          }
          if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor.off("mousewheel", hideTooltip);
          }
        }
        function moveTooltip(event) {
          tooltip.setPosition(event.clientX, event.clientY);
        }
        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
          var target = e.domEvent.target || e.domEvent.srcElement;
          if (dom_1.hasCssClass(target, "ace_fold-widget")) {
            return hideTooltip(void 0, editor);
          }
          if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(e);
          }
          mouseEvent = e;
          if (tooltipTimeout) {
            return;
          }
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
              showTooltip();
            else
              hideTooltip(void 0, editor);
          }, 50);
        });
        event_1.addListener(editor.renderer.$gutter, "mouseout", function(e) {
          mouseEvent = null;
          if (!tooltipAnnotation || tooltipTimeout)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip(void 0, editor);
          }, 50);
        });
        editor.on("changeSession", hideTooltip);
      }
      return GutterHandler;
    }());
    var GutterTooltip = (function(_super) {
      __extends(GutterTooltip, _super);
      function GutterTooltip(parent) {
        _super.call(this, parent);
      }
      GutterTooltip.prototype.setPosition = function(x, y) {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x += 15;
        y += 15;
        if (x + width > windowWidth) {
          x -= (x + width) - windowWidth;
        }
        if (y + height > windowHeight) {
          y -= 20 + height;
        }
        _super.prototype.setPosition.call(this, x, y);
      };
      return GutterTooltip;
    }(Tooltip_1.default));
    function addAltCursorListeners(editor) {
      var el = editor.textInput.getElement();
      var altCursor = false;
      event_1.addListener(el, "keydown", function(e) {
        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
        if (editor.$blockSelectEnabled && altDown) {
          if (!altCursor) {
            editor.renderer.setMouseCursor("crosshair");
            altCursor = true;
          }
        } else if (altCursor) {
          reset();
        }
      });
      event_1.addListener(el, "keyup", reset);
      event_1.addListener(el, "blur", reset);
      function reset() {
        if (altCursor) {
          editor.renderer.setMouseCursor("");
          altCursor = false;
        }
      }
    }
  });
  define('createEditor', ["require", "exports", './Editor'], function(require, exports, Editor_1) {
    "use strict";
    function createEditor(renderer, session) {
      return new Editor_1.default(renderer, session);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createEditor;
  });
  define('FoldLine', ["require", "exports", "./Range"], function(require, exports, Range_1) {
    "use strict";
    var FoldLine = (function() {
      function FoldLine(foldData, folds) {
        this.foldData = foldData;
        if (Array.isArray(folds)) {
          this.folds = folds;
        } else {
          throw new Error("folds must have type Fold[]");
        }
        var last = folds[folds.length - 1];
        this.range = new Range_1.default(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
        this.start = this.range.start;
        this.end = this.range.end;
        this.folds.forEach(function(fold) {
          fold.setFoldLine(this);
        }, this);
      }
      FoldLine.prototype.shiftRow = function(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
          fold.start.row += shift;
          fold.end.row += shift;
        });
      };
      FoldLine.prototype.addFold = function(fold) {
        if (fold.sameRow) {
          if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
            throw new Error("Can't add a fold to this FoldLine as it has no connection");
          }
          this.folds.push(fold);
          this.folds.sort(function(a, b) {
            return -a.range.compareEnd(b.start.row, b.start.column);
          });
          if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
          } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
          }
        } else if (fold.start.row == this.end.row) {
          this.folds.push(fold);
          this.end.row = fold.end.row;
          this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
          this.folds.unshift(fold);
          this.start.row = fold.start.row;
          this.start.column = fold.start.column;
        } else {
          throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
      };
      FoldLine.prototype.containsRow = function(row) {
        return row >= this.start.row && row <= this.end.row;
      };
      FoldLine.prototype.walk = function(callback, endRow, endColumn) {
        var lastEnd = 0,
            folds = this.folds,
            fold,
            cmp,
            stop,
            isNewRow = true;
        if (endRow == null) {
          endRow = this.end.row;
          endColumn = this.end.column;
        }
        for (var i = 0; i < folds.length; i++) {
          fold = folds[i];
          cmp = fold.range.compareStart(endRow, endColumn);
          if (cmp == -1) {
            callback(null, endRow, endColumn, lastEnd, isNewRow);
            return;
          }
          stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
          stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
          if (stop || cmp === 0) {
            return;
          }
          isNewRow = !fold.sameRow;
          lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
      };
      FoldLine.prototype.getNextFoldTo = function(row, column) {
        var fold;
        var cmp;
        for (var i = 0; i < this.folds.length; i++) {
          fold = this.folds[i];
          cmp = fold.range.compareEnd(row, column);
          if (cmp == -1) {
            return {
              fold: fold,
              kind: "after"
            };
          } else if (cmp === 0) {
            return {
              fold: fold,
              kind: "inside"
            };
          }
        }
        return null;
      };
      FoldLine.prototype.addRemoveChars = function(row, column, len) {
        var ret = this.getNextFoldTo(row, column);
        var fold;
        var folds;
        if (ret) {
          fold = ret.fold;
          if (ret.kind === "inside" && fold.start.column !== column && fold.start.row !== row) {
            window.console && window.console.warn(row, column, fold);
          } else if (fold.start.row == row) {
            folds = this.folds;
            var i = folds.indexOf(fold);
            if (i === 0) {
              this.start.column += len;
            }
            for (i; i < folds.length; i++) {
              fold = folds[i];
              fold.start.column += len;
              if (!fold.sameRow) {
                return;
              }
              fold.end.column += len;
            }
            this.end.column += len;
          }
        }
      };
      FoldLine.prototype.split = function(row, column) {
        var pos = this.getNextFoldTo(row, column);
        if (!pos || pos.kind == "inside")
          return null;
        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;
        folds = folds.splice(i, folds.length - i);
        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
      };
      FoldLine.prototype.merge = function(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
          this.addFold(folds[i]);
        }
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
      };
      FoldLine.prototype.toString = function() {
        var ret = [this.range.toString() + ": ["];
        this.folds.forEach(function(fold) {
          ret.push("  " + fold.toString());
        });
        ret.push("]");
        return ret.join("\n");
      };
      FoldLine.prototype.idxToPosition = function(idx) {
        var lastFoldEndColumn = 0;
        for (var i = 0; i < this.folds.length; i++) {
          var fold = this.folds[i];
          idx -= fold.start.column - lastFoldEndColumn;
          if (idx < 0) {
            return {
              row: fold.start.row,
              column: fold.start.column + idx
            };
          }
          idx -= fold.placeholder.length;
          if (idx < 0) {
            return fold.start;
          }
          lastFoldEndColumn = fold.end.column;
        }
        return {
          row: this.end.row,
          column: this.end.column + idx
        };
      };
      return FoldLine;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = FoldLine;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('Fold', ["require", "exports", "./RangeList"], function(require, exports, RangeList_1) {
    "use strict";
    var Fold = (function(_super) {
      __extends(Fold, _super);
      function Fold(range, placeholder) {
        _super.call(this);
        this.foldLine = null;
        this.placeholder = placeholder;
        this.range = range;
        this.start = range.start;
        this.end = range.end;
        this.sameRow = range.start.row === range.end.row;
        this.subFolds = this.ranges = [];
      }
      Fold.prototype.toString = function() {
        return '"' + this.placeholder + '" ' + this.range.toString();
      };
      Fold.prototype.setFoldLine = function(foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function(fold) {
          fold.setFoldLine(foldLine);
        });
      };
      Fold.prototype.clone = function() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
          fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
      };
      Fold.prototype.addSubFold = function(fold) {
        if (this.range.isEqual(fold))
          return;
        if (!this.range.containsRange(fold))
          throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
        consumeRange(fold, this.start);
        var row = fold.start.row,
            column = fold.start.column;
        for (var i = 0,
            cmp = -1; i < this.subFolds.length; i++) {
          cmp = this.subFolds[i].range.compare(row, column);
          if (cmp != 1)
            break;
        }
        var afterStart = this.subFolds[i];
        if (cmp == 0)
          return afterStart.addSubFold(fold);
        var row = fold.range.end.row,
            column = fold.range.end.column;
        for (var j = i,
            cmp = -1; j < this.subFolds.length; j++) {
          cmp = this.subFolds[j].range.compare(row, column);
          if (cmp != 1)
            break;
        }
        var afterEnd = this.subFolds[j];
        if (cmp == 0)
          throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        fold.setFoldLine(this.foldLine);
        return fold;
      };
      Fold.prototype.restoreRange = function(range) {
        return restoreRange(range, this.start);
      };
      return Fold;
    }(RangeList_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Fold;
    function consumePoint(point, anchor) {
      point.row -= anchor.row;
      if (point.row == 0)
        point.column -= anchor.column;
    }
    function consumeRange(range, anchor) {
      consumePoint(range.start, anchor);
      consumePoint(range.end, anchor);
    }
    function restorePoint(point, anchor) {
      if (point.row == 0)
        point.column += anchor.column;
      point.row += anchor.row;
    }
    function restoreRange(range, anchor) {
      restorePoint(range.start, anchor);
      restorePoint(range.end, anchor);
    }
  });
  define('BackgroundTokenizer', ["require", "exports", "./lib/EventEmitterClass"], function(require, exports, EventEmitterClass_1) {
    "use strict";
    var BackgroundTokenizer = (function() {
      function BackgroundTokenizer(tokenizer, session) {
        this.running = 0;
        this.lines = [];
        this.states = [];
        this.currentLine = 0;
        this.eventBus = new EventEmitterClass_1.default(this);
        this.tokenizer = tokenizer;
        var self = this;
        this.$worker = function() {
          if (!self.running) {
            return;
          }
          var workerStart = new Date();
          var currentLine = self.currentLine;
          var endLine = -1;
          var doc = self.doc;
          while (self.lines[currentLine]) {
            currentLine++;
          }
          var startLine = currentLine;
          var len = doc.getLength();
          var processedLines = 0;
          self.running = 0;
          while (currentLine < len) {
            self.tokenizeRow(currentLine);
            endLine = currentLine;
            do {
              currentLine++;
            } while (self.lines[currentLine]);
            processedLines++;
            if ((processedLines % 5 === 0) && (new Date().getTime() - workerStart.getTime()) > 20) {
              self.running = setTimeout(self.$worker, 20);
              break;
            }
          }
          self.currentLine = currentLine;
          if (startLine <= endLine) {
            self.fireUpdateEvent(startLine, endLine);
          }
        };
      }
      BackgroundTokenizer.prototype.fireUpdateEvent = function(firstRow, lastRow) {
        var data = {
          first: firstRow,
          last: lastRow
        };
        this.eventBus._signal("update", {data: data});
      };
      BackgroundTokenizer.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      BackgroundTokenizer.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      BackgroundTokenizer.prototype.getState = function(row) {
        if (this.currentLine === row) {
          this.tokenizeRow(row);
        }
        return this.states[row] || "start";
      };
      BackgroundTokenizer.prototype.getTokens = function(row) {
        return this.lines[row] || this.tokenizeRow(row);
      };
      BackgroundTokenizer.prototype.setDocument = function(doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];
        this.stop();
      };
      BackgroundTokenizer.prototype.setTokenizer = function(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];
        this.start(0);
      };
      BackgroundTokenizer.prototype.start = function(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);
        this.stop();
        this.running = setTimeout(this.$worker, 700);
      };
      BackgroundTokenizer.prototype.stop = function() {
        if (this.running) {
          clearTimeout(this.running);
        }
        this.running = 0;
      };
      BackgroundTokenizer.prototype.scheduleStart = function() {
        if (!this.running) {
          this.running = setTimeout(this.$worker, 700);
        }
      };
      BackgroundTokenizer.prototype.updateOnChange = function(delta) {
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;
        if (len === 0) {
          this.lines[startRow] = null;
        } else if (delta.action === "remove") {
          this.lines.splice(startRow, len + 1, null);
          this.states.splice(startRow, len + 1, null);
        } else {
          var args = Array(len + 1);
          args.unshift(startRow, 1);
          this.lines.splice.apply(this.lines, args);
          this.states.splice.apply(this.states, args);
        }
        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
        this.stop();
      };
      BackgroundTokenizer.prototype.tokenizeRow = function(row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];
        var data = this.tokenizer.getLineTokens(line, state);
        if (this.states[row] + "" !== data.state + "") {
          this.states[row] = data.state;
          this.lines[row + 1] = null;
          if (this.currentLine > row + 1) {
            this.currentLine = row + 1;
          }
        } else if (this.currentLine === row) {
          this.currentLine = row + 1;
        }
        return this.lines[row] = data.tokens;
      };
      return BackgroundTokenizer;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = BackgroundTokenizer;
  });
  define('SearchHighlight', ["require", "exports", "./lib/lang", "./Range"], function(require, exports, lang_1, Range_1) {
    "use strict";
    var MAX_RANGES = 500;
    var SearchHighlight = (function() {
      function SearchHighlight(regExp, clazz, type) {
        this.setRegexp(regExp);
        this.clazz = clazz;
        this.type = type || "text";
      }
      SearchHighlight.prototype.setRegexp = function(regExp) {
        if (this.regExp + "" == regExp + "") {
          return;
        }
        this.regExp = regExp;
        this.cache = [];
      };
      Object.defineProperty(SearchHighlight.prototype, "range", {
        get: function() {
          return this._range;
        },
        set: function(range) {
          this._range = range;
        },
        enumerable: true,
        configurable: true
      });
      SearchHighlight.prototype.update = function(html, markerLayer, session, config) {
        if (!this.regExp)
          return;
        var start = config.firstRow,
            end = config.lastRow;
        for (var i = start; i <= end; i++) {
          var ranges = this.cache[i];
          if (ranges == null) {
            var matches = lang_1.getMatchOffsets(session.getLine(i), this.regExp);
            if (matches.length > MAX_RANGES) {
              matches = matches.slice(0, MAX_RANGES);
            }
            ranges = matches.map(function(match) {
              return new Range_1.default(i, match.offset, i, match.offset + match.length);
            });
            this.cache[i] = ranges.length ? ranges : [];
          }
          for (var j = ranges.length; j--; ) {
            markerLayer.drawSingleLineMarker(html, session.documentToScreenRange(ranges[j]), this.clazz, config);
          }
        }
      };
      return SearchHighlight;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = SearchHighlight;
  });
  define('BracketMatch', ["require", "exports", "./TokenIterator", "./Range"], function(require, exports, TokenIterator_1, Range_1) {
    "use strict";
    var $brackets = {
      ")": "(",
      "(": ")",
      "]": "[",
      "[": "]",
      "{": "}",
      "}": "{"
    };
    var BracketMatch = (function() {
      function BracketMatch(editSession) {
        this.editSession = editSession;
      }
      BracketMatch.prototype.findMatchingBracket = function(position, chr) {
        if (position.column === 0)
          return null;
        var charBeforeCursor = chr || this.editSession.getLine(position.row).charAt(position.column - 1);
        if (charBeforeCursor === "")
          return null;
        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
          return null;
        if (match[1])
          return this.findClosingBracket(match[1], position);
        else
          return this.findOpeningBracket(match[2], position);
      };
      BracketMatch.prototype.getBracketRange = function(pos) {
        var line = this.editSession.getLine(pos.row);
        var before = true;
        var range;
        var chr = line.charAt(pos.column - 1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
          chr = line.charAt(pos.column);
          pos = {
            row: pos.row,
            column: pos.column + 1
          };
          match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          before = false;
        }
        if (!match)
          return null;
        if (match[1]) {
          var closingPos = this.findClosingBracket(match[1], pos);
          if (!closingPos)
            return null;
          range = Range_1.default.fromPoints(pos, closingPos);
          if (!before) {
            range.end.column++;
            range.start.column--;
          }
          range.cursor = range.end;
        } else {
          var openingPos = this.findOpeningBracket(match[2], pos);
          if (!openingPos)
            return null;
          range = Range_1.default.fromPoints(openingPos, pos);
          if (!before) {
            range.start.column++;
            range.end.column--;
          }
          range.cursor = range.start;
        }
        return range;
      };
      BracketMatch.prototype.findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = $brackets[bracket];
        var depth = 1;
        var iterator = new TokenIterator_1.default(this.editSession, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
          token = iterator.stepForward();
        if (!token)
          return;
        if (!typeRe) {
          typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end|start|begin)\b/, "") + ")+");
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        while (true) {
          while (valueIndex >= 0) {
            var chr = value.charAt(valueIndex);
            if (chr === openBracket) {
              depth -= 1;
              if (depth === 0) {
                return {
                  row: iterator.getCurrentTokenRow(),
                  column: valueIndex + iterator.getCurrentTokenColumn()
                };
              }
            } else if (chr === bracket) {
              depth += 1;
            }
            valueIndex -= 1;
          }
          do {
            token = iterator.stepBackward();
          } while (token && !typeRe.test(token.type));
          if (token === null)
            break;
          value = token.value;
          valueIndex = value.length - 1;
        }
        return null;
      };
      BracketMatch.prototype.findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = $brackets[bracket];
        var depth = 1;
        var iterator = new TokenIterator_1.default(this.editSession, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
          token = iterator.stepForward();
        if (!token)
          return;
        if (!typeRe) {
          typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:end|start|begin)\b/, "") + ")+");
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn();
        while (true) {
          var value = token.value;
          var valueLength = value.length;
          while (valueIndex < valueLength) {
            var chr = value.charAt(valueIndex);
            if (chr === closingBracket) {
              depth -= 1;
              if (depth === 0) {
                return {
                  row: iterator.getCurrentTokenRow(),
                  column: valueIndex + iterator.getCurrentTokenColumn()
                };
              }
            } else if (chr === bracket) {
              depth += 1;
            }
            valueIndex += 1;
          }
          do {
            token = iterator.stepForward();
          } while (token && !typeRe.test(token.type));
          if (token === null)
            break;
          valueIndex = 0;
        }
        return null;
      };
      return BracketMatch;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = BracketMatch;
  });
  define('mode/TextHighlightRules', ["require", "exports", "../lib/lang"], function(require, exports, lang_1) {
    "use strict";
    var TextHighlightRules = (function() {
      function TextHighlightRules() {
        this.$rules = {"start": [{
            token: "empty_line",
            regex: '^$'
          }, {defaultToken: "text"}]};
      }
      TextHighlightRules.prototype.addRules = function(rules, prefix) {
        if (!prefix) {
          for (var key in rules)
            this.$rules[key] = rules[key];
          return;
        }
        for (var key in rules) {
          var state = rules[key];
          for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.next || rule.onMatch) {
              if (typeof rule.next != "string") {
                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                  rule.nextState = prefix + rule.nextState;
              } else {
                if (rule.next.indexOf(prefix) !== 0)
                  rule.next = prefix + rule.next;
              }
            }
          }
          this.$rules[prefix + key] = state;
        }
      };
      TextHighlightRules.prototype.getRules = function() {
        return this.$rules;
      };
      TextHighlightRules.prototype.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = (typeof HighlightRules === "function") ? new HighlightRules().getRules() : HighlightRules;
        if (states) {
          for (var i = 0; i < states.length; i++)
            states[i] = prefix + states[i];
        } else {
          states = [];
          for (var key in embedRules)
            states.push(prefix + key);
        }
        this.addRules(embedRules, prefix);
        if (escapeRules) {
          var addRules = Array.prototype[append ? "push" : "unshift"];
          for (var i = 0; i < states.length; i++)
            addRules.apply(this.$rules[states[i]], lang_1.deepCopy(escapeRules));
        }
        if (!this.$embeds)
          this.$embeds = [];
        this.$embeds.push(prefix);
      };
      TextHighlightRules.prototype.getEmbeds = function() {
        return this.$embeds;
      };
      TextHighlightRules.prototype.normalizeRules = function() {
        var pushState = function(currentState, stack) {
          if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
          return this.nextState;
        };
        var popState = function(currentState, stack) {
          stack.shift();
          return stack.shift() || "start";
        };
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
          var state = rules[key];
          state.processed = true;
          for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (!rule.regex && rule.start) {
              rule.regex = rule.start;
              if (!rule.next)
                rule.next = [];
              rule.next.push({defaultToken: rule.token}, {
                token: rule.token + ".end",
                regex: rule.end || rule.start,
                next: "pop"
              });
              rule.token = rule.token + ".start";
              rule.push = true;
            }
            var next = rule.next || rule.push;
            if (next && Array.isArray(next)) {
              var stateName = rule.stateName;
              if (!stateName) {
                stateName = rule.token;
                if (typeof stateName != "string")
                  stateName = stateName[0] || "";
                if (rules[stateName])
                  stateName += id++;
              }
              rules[stateName] = next;
              rule.next = stateName;
              processState(stateName);
            } else if (next == "pop") {
              rule.next = popState;
            }
            if (rule.push) {
              rule.nextState = rule.next || rule.push;
              rule.next = pushState;
              delete rule.push;
            }
            if (rule.rules) {
              for (var r in rule.rules) {
                if (rules[r]) {
                  if (rules[r].push)
                    rules[r].push.apply(rules[r], rule.rules[r]);
                } else {
                  rules[r] = rule.rules[r];
                }
              }
            }
            if (rule.include || typeof rule === "string") {
              var includeName = rule.include || rule;
              var toInsert = rules[includeName];
            } else if (Array.isArray(rule))
              toInsert = rule;
            if (toInsert) {
              var args = [i, 1].concat(toInsert);
              if (rule.noEscape) {
                args = args.filter(function(x) {
                  return !x['next'];
                });
              }
              state.splice.apply(state, args);
              i--;
              toInsert = null;
            }
            if (rule.keywordMap) {
              rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
              delete rule.defaultToken;
            }
          }
        }
        Object.keys(rules).forEach(processState, this);
      };
      TextHighlightRules.prototype.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        Object.keys(map).forEach(function(className) {
          var a = map[className];
          if (ignoreCase)
            a = a.toLowerCase();
          var list = a.split(splitChar || "|");
          for (var i = list.length; i--; )
            keywords[list[i]] = className;
        });
        if (Object.getPrototypeOf(keywords)) {
          keywords.__proto__ = null;
        }
        this.$keywordList = Object.keys(keywords);
        map = null;
        return ignoreCase ? function(value) {
          return keywords[value.toLowerCase()] || defaultToken;
        } : function(value) {
          return keywords[value] || defaultToken;
        };
      };
      TextHighlightRules.prototype.getKeywords = function() {
        return this.$keywordList;
      };
      return TextHighlightRules;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = TextHighlightRules;
  });
  define('mode/Behaviour', ["require", "exports"], function(require, exports) {
    "use strict";
    var Behaviour = (function() {
      function Behaviour() {
        this.$behaviours = {};
      }
      Behaviour.prototype.add = function(name, action, callback) {
        switch (undefined) {
          case this.$behaviours:
            this.$behaviours = {};
          case this.$behaviours[name]:
            this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
      };
      Behaviour.prototype.addBehaviours = function(behaviours) {
        for (var key in behaviours) {
          for (var action in behaviours[key]) {
            this.add(key, action, behaviours[key][action]);
          }
        }
      };
      Behaviour.prototype.remove = function(name) {
        if (this.$behaviours && this.$behaviours[name]) {
          delete this.$behaviours[name];
        }
      };
      Behaviour.prototype.inherit = function(base, filter) {
        var behaviours = base.getBehaviours(filter);
        this.addBehaviours(behaviours);
      };
      Behaviour.prototype.getBehaviours = function(filter) {
        if (!filter) {
          return this.$behaviours;
        } else {
          var ret = {};
          for (var i = 0; i < filter.length; i++) {
            if (this.$behaviours[filter[i]]) {
              ret[filter[i]] = this.$behaviours[filter[i]];
            }
          }
          return ret;
        }
      };
      return Behaviour;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Behaviour;
  });
  define('unicode', ["require", "exports"], function(require, exports) {
    "use strict";
    exports.packages = {
      L: undefined,
      Mn: undefined,
      Mc: undefined,
      Nd: undefined,
      Pc: undefined
    };
    addUnicodePackage({
      L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
      Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
      Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
      Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
      Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
      Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
      M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
      Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
      Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
      Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
      N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
      Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
      Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
      No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
      P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
      Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
      Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
      Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
      Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
      Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
      Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
      Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
      S: "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
      Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
      Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
      Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
      So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
      Z: "002000A01680180E2000-200A20282029202F205F3000",
      Zs: "002000A01680180E2000-200A202F205F3000",
      Zl: "2028",
      Zp: "2029",
      C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
      Cc: "0000-001F007F-009F",
      Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
      Co: "E000-F8FF",
      Cs: "D800-DFFF",
      Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
    });
    function addUnicodePackage(pack) {
      var codePoint = /\w{4}/g;
      for (var name in pack)
        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
    }
  });
  define('mode/TextMode', ["require", "exports", "../Tokenizer", "./TextHighlightRules", "./Behaviour", "../unicode", "../lib/lang", "../TokenIterator", "../Range"], function(require, exports, Tokenizer_1, TextHighlightRules_1, Behaviour_1, unicode_1, lang_1, TokenIterator_1, Range_1) {
    "use strict";
    var TextMode = (function() {
      function TextMode(workerUrl, scriptImports) {
        this.HighlightRules = TextHighlightRules_1.default;
        this.$behaviour = new Behaviour_1.default();
        this.tokenRe = new RegExp("^[" + unicode_1.packages.L + unicode_1.packages.Mn + unicode_1.packages.Mc + unicode_1.packages.Nd + unicode_1.packages.Pc + "\\$_]+", "g");
        this.nonTokenRe = new RegExp("^(?:[^" + unicode_1.packages.L + unicode_1.packages.Mn + unicode_1.packages.Mc + unicode_1.packages.Nd + unicode_1.packages.Pc + "\\$_]|\\s])+", "g");
        this.lineCommentStart = "";
        this.$id = "ace/mode/text";
        this.scriptImports = [];
        if (typeof workerUrl === 'string') {
          this.workerUrl = workerUrl;
        } else {
          throw new TypeError("workerUrl must be a string.");
        }
        this.scriptImports = scriptImports;
      }
      TextMode.prototype.getTokenizer = function() {
        if (!this.$tokenizer) {
          this.$highlightRules = this.$highlightRules || new this.HighlightRules();
          this.$tokenizer = new Tokenizer_1.default(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
      };
      TextMode.prototype.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;
        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;
        if (!this.lineCommentStart) {
          if (!this.blockComment)
            return false;
          var lineCommentStart = this.blockComment.start;
          var lineCommentEnd = this.blockComment.end;
          var regexpStart = new RegExp("^(\\s*)(?:" + lang_1.escapeRegExp(lineCommentStart) + ")");
          var regexpEnd = new RegExp("(?:" + lang_1.escapeRegExp(lineCommentEnd) + ")\\s*$");
          var comment = function(line, i) {
            if (testRemove(line, i))
              return;
            if (!ignoreBlankLines || /\S/.test(line)) {
              doc.insertInLine({
                row: i,
                column: line.length
              }, lineCommentEnd);
              doc.insertInLine({
                row: i,
                column: minIndent
              }, lineCommentStart);
            }
          };
          var uncomment = function(line, i) {
            var m;
            if (m = line.match(regexpEnd))
              doc.removeInLine(i, line.length - m[0].length, line.length);
            if (m = line.match(regexpStart))
              doc.removeInLine(i, m[1].length, m[0].length);
          };
          var testRemove = function(line, row) {
            if (regexpStart.test(line))
              return true;
            var tokens = session.getTokens(row);
            for (var i = 0; i < tokens.length; i++) {
              if (tokens[i].type === 'comment')
                return true;
            }
          };
        } else {
          if (Array.isArray(this.lineCommentStart)) {
            var regexpStartString = this.lineCommentStart.map(lang_1.escapeRegExp).join("|");
            lineCommentStart = this.lineCommentStart[0];
          } else {
            var regexpStartString = lang_1.escapeRegExp(this.lineCommentStart);
            lineCommentStart = this.lineCommentStart;
          }
          regexpStart = new RegExp("^(\\s*)(?:" + regexpStartString + ") ?");
          insertAtTabStop = session.getUseSoftTabs();
          var uncomment = function(line, i) {
            var m = line.match(regexpStart);
            if (!m)
              return;
            var start = m[1].length,
                end = m[0].length;
            if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
              end--;
            doc.removeInLine(i, start, end);
          };
          var commentWithSpace = lineCommentStart + " ";
          var comment = function(line, i) {
            if (!ignoreBlankLines || /\S/.test(line)) {
              if (shouldInsertSpace(line, minIndent, minIndent))
                doc.insertInLine({
                  row: i,
                  column: minIndent
                }, commentWithSpace);
              else
                doc.insertInLine({
                  row: i,
                  column: minIndent
                }, lineCommentStart);
            }
          };
          var testRemove = function(line, i) {
            return regexpStart.test(line);
          };
          var shouldInsertSpace = function(line, before, after) {
            var spaces = 0;
            while (before-- && line.charAt(before) == " ")
              spaces++;
            if (spaces % tabSize != 0)
              return false;
            var spaces = 0;
            while (line.charAt(after++) == " ")
              spaces++;
            if (tabSize > 2)
              return spaces % tabSize != tabSize - 1;
            else
              return spaces % tabSize == 0;
          };
        }
        function iter(fun) {
          for (var i = startRow; i <= endRow; i++)
            fun(doc.getLine(i), i);
        }
        var minEmptyLength = Infinity;
        iter(function(line, row) {
          var indent = line.search(/\S/);
          if (indent !== -1) {
            if (indent < minIndent)
              minIndent = indent;
            if (shouldRemove && !testRemove(line, row))
              shouldRemove = false;
          } else if (minEmptyLength > line.length) {
            minEmptyLength = line.length;
          }
        });
        if (minIndent == Infinity) {
          minIndent = minEmptyLength;
          ignoreBlankLines = false;
          shouldRemove = false;
        }
        if (insertAtTabStop && minIndent % tabSize != 0)
          minIndent = Math.floor(minIndent / tabSize) * tabSize;
        iter(shouldRemove ? uncomment : comment);
      };
      TextMode.prototype.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
          return;
        if (!comment.start && comment[0])
          comment = comment[0];
        var iterator = new TokenIterator_1.default(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();
        var selection = session.getSelection();
        var initialRange = selection.toOrientedRange();
        var startRow,
            colDiff;
        if (token && /comment/.test(token.type)) {
          var startRange,
              endRange;
          while (token && /comment/.test(token.type)) {
            var i = token.value.indexOf(comment.start);
            if (i != -1) {
              var row = iterator.getCurrentTokenRow();
              var column = iterator.getCurrentTokenColumn() + i;
              startRange = new Range_1.default(row, column, row, column + comment.start.length);
              break;
            }
            token = iterator.stepBackward();
          }
          var iterator = new TokenIterator_1.default(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          while (token && /comment/.test(token.type)) {
            var i = token.value.indexOf(comment.end);
            if (i != -1) {
              var row = iterator.getCurrentTokenRow();
              var column = iterator.getCurrentTokenColumn() + i;
              endRange = new Range_1.default(row, column, row, column + comment.end.length);
              break;
            }
            token = iterator.stepForward();
          }
          if (endRange)
            session.remove(endRange);
          if (startRange) {
            session.remove(startRange);
            startRow = startRange.start.row;
            colDiff = -comment.start.length;
          }
        } else {
          colDiff = comment.start.length;
          startRow = range.start.row;
          session.insert(range.end, comment.end);
          session.insert(range.start, comment.start);
        }
        if (initialRange.start.row == startRow)
          initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
          initialRange.end.column += colDiff;
        session.getSelection().fromOrientedRange(initialRange);
      };
      TextMode.prototype.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
      };
      TextMode.prototype.checkOutdent = function(state, line, text) {
        return false;
      };
      TextMode.prototype.autoOutdent = function(state, session, row) {
        return 0;
      };
      TextMode.prototype.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
      };
      TextMode.prototype.createWorker = function(session) {
        return void 0;
      };
      TextMode.prototype.createModeDelegates = function(mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var p in mapping) {
          if (mapping[p]) {
            this.$embeds.push(p);
            this.$modes[p] = new mapping[p](this.workerUrl, this.scriptImports);
          }
        }
        var delegations = ['toggleBlockComment', 'toggleCommentLines', 'getNextLineIndent', 'checkOutdent', 'autoOutdent', 'transformAction', 'getCompletions'];
        for (var k = 0; k < delegations.length; k++) {
          (function(scope) {
            var functionName = delegations[k];
            var defaultHandler = scope[functionName];
            scope[delegations[k]] = function() {
              return this.$delegator(functionName, arguments, defaultHandler);
            };
          }(this));
        }
      };
      TextMode.prototype.$delegator = function(method, args, defaultHandler) {
        var state = args[0];
        if (typeof state != "string")
          state = state[0];
        for (var i = 0; i < this.$embeds.length; i++) {
          if (!this.$modes[this.$embeds[i]])
            continue;
          var split = state.split(this.$embeds[i]);
          if (!split[0] && split[1]) {
            args[0] = split[1];
            var mode = this.$modes[this.$embeds[i]];
            return mode[method].apply(mode, args);
          }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
      };
      TextMode.prototype.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
          var behaviours = this.$behaviour.getBehaviours();
          for (var key in behaviours) {
            if (behaviours[key][action]) {
              var ret = behaviours[key][action].apply(this, arguments);
              if (ret) {
                return ret;
              }
            }
          }
        }
      };
      TextMode.prototype.getKeywords = function(append) {
        if (!this.completionKeywords) {
          var rules = this.$tokenizer.states;
          var completionKeywords = [];
          for (var rule in rules) {
            var ruleItr = rules[rule];
            for (var r = 0,
                l = ruleItr.length; r < l; r++) {
              if (typeof ruleItr[r].token === "string") {
                if (/keyword|support|storage/.test(ruleItr[r].token))
                  completionKeywords.push(ruleItr[r].regex);
              } else if (typeof ruleItr[r].token === "object") {
                for (var a = 0,
                    aLength = ruleItr[r].token.length; a < aLength; a++) {
                  if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                    var matched = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                    completionKeywords.push(matched.substr(1, matched.length - 2));
                  }
                }
              }
            }
          }
          this.completionKeywords = completionKeywords;
        }
        if (!append) {
          return this.$keywordList;
        }
        return completionKeywords.concat(this.$keywordList || []);
      };
      TextMode.prototype.$createKeywordList = function() {
        if (!this.$highlightRules)
          this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
      };
      TextMode.prototype.getCompletions = function(state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
          return {
            name: word,
            value: word,
            score: 0,
            meta: "keyword"
          };
        });
      };
      return TextMode;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = TextMode;
  });
  define('EditSession', ["require", "exports", './lib/lang/createDelayedCall', "./lib/lang", "./config", "./lib/EventEmitterClass", "./FoldLine", "./Fold", "./Selection", "./Range", "./Document", "./BackgroundTokenizer", "./SearchHighlight", "./BracketMatch", './TokenIterator', "./mode/TextMode"], function(require, exports, createDelayedCall_1, lang_1, config_1, EventEmitterClass_1, FoldLine_1, Fold_1, Selection_1, Range_1, Document_1, BackgroundTokenizer_1, SearchHighlight_1, BracketMatch_1, TokenIterator_1, TextMode_1) {
    "use strict";
    var CHAR = 1,
        CHAR_EXT = 2,
        PLACEHOLDER_START = 3,
        PLACEHOLDER_BODY = 4,
        PUNCTUATION = 9,
        SPACE = 10,
        TAB = 11,
        TAB_SPACE = 12;
    function isFullWidth(c) {
      if (c < 0x1100)
        return false;
      return c >= 0x1100 && c <= 0x115F || c >= 0x11A3 && c <= 0x11A7 || c >= 0x11FA && c <= 0x11FF || c >= 0x2329 && c <= 0x232A || c >= 0x2E80 && c <= 0x2E99 || c >= 0x2E9B && c <= 0x2EF3 || c >= 0x2F00 && c <= 0x2FD5 || c >= 0x2FF0 && c <= 0x2FFB || c >= 0x3000 && c <= 0x303E || c >= 0x3041 && c <= 0x3096 || c >= 0x3099 && c <= 0x30FF || c >= 0x3105 && c <= 0x312D || c >= 0x3131 && c <= 0x318E || c >= 0x3190 && c <= 0x31BA || c >= 0x31C0 && c <= 0x31E3 || c >= 0x31F0 && c <= 0x321E || c >= 0x3220 && c <= 0x3247 || c >= 0x3250 && c <= 0x32FE || c >= 0x3300 && c <= 0x4DBF || c >= 0x4E00 && c <= 0xA48C || c >= 0xA490 && c <= 0xA4C6 || c >= 0xA960 && c <= 0xA97C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0xD7B0 && c <= 0xD7C6 || c >= 0xD7CB && c <= 0xD7FB || c >= 0xF900 && c <= 0xFAFF || c >= 0xFE10 && c <= 0xFE19 || c >= 0xFE30 && c <= 0xFE52 || c >= 0xFE54 && c <= 0xFE66 || c >= 0xFE68 && c <= 0xFE6B || c >= 0xFF01 && c <= 0xFF60 || c >= 0xFFE0 && c <= 0xFFE6;
    }
    var EditSession = (function() {
      function EditSession(doc) {
        this.$breakpoints = [];
        this.$decorations = [];
        this.$frontMarkers = {};
        this.$backMarkers = {};
        this.$markerId = 1;
        this.$undoSelect = true;
        this.$defaultUndoManager = {
          undo: function() {},
          redo: function() {},
          reset: function() {}
        };
        this.$overwrite = false;
        this.$modes = {};
        this.$mode = null;
        this.$modeId = null;
        this.$scrollTop = 0;
        this.$scrollLeft = 0;
        this.$wrapLimit = 80;
        this.$useWrapMode = false;
        this.$wrapLimitRange = {
          min: null,
          max: null
        };
        this.$onChange = this.onChange.bind(this);
        this.lineWidgets = null;
        this.$selectionMarker = null;
        this.$bracketMatcher = new BracketMatch_1.default(this);
        this.$foldStyles = {
          "manual": 1,
          "markbegin": 1,
          "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        if (!(doc instanceof Document_1.default)) {
          throw new TypeError('doc must be an Document');
        }
        this.$breakpoints = [];
        this.eventBus = new EventEmitterClass_1.default(this);
        this.$foldData = [];
        this.$foldData.toString = function() {
          return this.join("\n");
        };
        this.eventBus.on("changeFold", this.onChangeFold.bind(this));
        this.setDocument(doc);
        this.selection = new Selection_1.default(this);
        config_1.resetOptions(this);
        this.setLanguageMode(new TextMode_1.default('', []));
        this.eventBus._signal("session", this);
      }
      EditSession.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      EditSession.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      EditSession.prototype._emit = function(eventName, event) {
        this.eventBus._emit(eventName, event);
      };
      EditSession.prototype._signal = function(eventName, event) {
        this.eventBus._signal(eventName, event);
      };
      EditSession.prototype.setDocument = function(doc) {
        if (!(doc instanceof Document_1.default)) {
          throw new Error("doc must be a Document");
        }
        if (this.doc) {
          this.doc.removeChangeListener(this.$onChange);
        }
        this.doc = doc;
        this.doc.addChangeListener(this.$onChange);
        if (this.bgTokenizer) {
          this.bgTokenizer.setDocument(this.getDocument());
        }
        this.resetCaches();
      };
      EditSession.prototype.getDocument = function() {
        return this.doc;
      };
      EditSession.prototype.$resetRowCache = function(docRow) {
        if (!docRow) {
          this.$docRowCache = [];
          this.$screenRowCache = [];
          return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l > i) {
          this.$docRowCache.splice(i, l);
          this.$screenRowCache.splice(i, l);
        }
      };
      EditSession.prototype.$getRowCacheIndex = function(cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;
        while (low <= hi) {
          var mid = (low + hi) >> 1;
          var c = cacheArray[mid];
          if (val > c) {
            low = mid + 1;
          } else if (val < c) {
            hi = mid - 1;
          } else {
            return mid;
          }
        }
        return low - 1;
      };
      EditSession.prototype.resetCaches = function() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (this.bgTokenizer) {
          this.bgTokenizer.start(0);
        }
      };
      EditSession.prototype.onChangeFold = function(event) {
        var fold = event.data;
        this.$resetRowCache(fold.start.row);
      };
      EditSession.prototype.onChange = function(delta, doc) {
        this.$modified = true;
        this.$resetRowCache(delta.start.row);
        var removedFolds = this.$updateInternalDataOnChange(delta);
        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
          this.$deltasDoc.push(delta);
          if (removedFolds && removedFolds.length !== 0) {
            this.$deltasFold.push({
              action: "removeFolds",
              folds: removedFolds
            });
          }
          this.$informUndoManager.schedule();
        }
        if (this.bgTokenizer) {
          this.bgTokenizer.updateOnChange(delta);
        }
        this.eventBus._signal("change", delta);
      };
      EditSession.prototype.setValue = function(text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);
        this.$resetRowCache(0);
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
      };
      EditSession.prototype.toString = function() {
        return this.getValue();
      };
      EditSession.prototype.getValue = function() {
        return this.doc.getValue();
      };
      EditSession.prototype.getSelection = function() {
        return this.selection;
      };
      EditSession.prototype.setSelection = function(selection) {
        this.selection = selection;
      };
      EditSession.prototype.getState = function(row) {
        if (this.bgTokenizer) {
          return this.bgTokenizer.getState(row);
        } else {
          return void 0;
        }
      };
      EditSession.prototype.getTokens = function(row) {
        if (this.bgTokenizer) {
          return this.bgTokenizer.getTokens(row);
        } else {
          return void 0;
        }
      };
      EditSession.prototype.getTokenAt = function(row, column) {
        if (this.bgTokenizer) {
          var tokens = this.bgTokenizer.getTokens(row);
          var token;
          var c = 0;
          if (column == null) {
            i = tokens.length - 1;
            c = this.getLine(row).length;
          } else {
            for (var i = 0; i < tokens.length; i++) {
              c += tokens[i].value.length;
              if (c >= column)
                break;
            }
          }
          token = tokens[i];
          if (!token)
            return null;
          token.index = i;
          token.start = c - token.value.length;
          return token;
        } else {
          return void 0;
        }
      };
      EditSession.prototype.setUndoManager = function(undoManager) {
        this.$undoManager = undoManager;
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];
        if (this.$informUndoManager)
          this.$informUndoManager.cancel();
        if (undoManager) {
          var self = this;
          this.$syncInformUndoManager = function() {
            self.$informUndoManager.cancel();
            if (self.$deltasFold.length) {
              self.$deltas.push({
                group: "fold",
                deltas: self.$deltasFold
              });
              self.$deltasFold = [];
            }
            if (self.$deltasDoc.length) {
              self.$deltas.push({
                group: "doc",
                deltas: self.$deltasDoc
              });
              self.$deltasDoc = [];
            }
            if (self.$deltas.length > 0) {
              undoManager.execute({
                action: "aceupdate",
                args: [self.$deltas, self],
                merge: self.mergeUndoDeltas
              });
            }
            self.mergeUndoDeltas = false;
            self.$deltas = [];
          };
          this.$informUndoManager = createDelayedCall_1.default(this.$syncInformUndoManager);
        }
      };
      EditSession.prototype.markUndoGroup = function() {
        if (this.$syncInformUndoManager) {
          this.$syncInformUndoManager();
        }
      };
      EditSession.prototype.getUndoManager = function() {
        return this.$undoManager || this.$defaultUndoManager;
      };
      EditSession.prototype.getTabString = function() {
        if (this.getUseSoftTabs()) {
          return lang_1.stringRepeat(" ", this.getTabSize());
        } else {
          return "\t";
        }
      };
      EditSession.prototype.setUseSoftTabs = function(useSoftTabs) {
        this.setOption("useSoftTabs", useSoftTabs);
        return this;
      };
      EditSession.prototype.getUseSoftTabs = function() {
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
      };
      EditSession.prototype.setTabSize = function(tabSize) {
        this.setOption("tabSize", tabSize);
      };
      EditSession.prototype.getTabSize = function() {
        return this.$tabSize;
      };
      EditSession.prototype.isTabStop = function(position) {
        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
      };
      EditSession.prototype.setOverwrite = function(overwrite) {
        this.setOption("overwrite", overwrite);
      };
      EditSession.prototype.getOverwrite = function() {
        return this.$overwrite;
      };
      EditSession.prototype.toggleOverwrite = function() {
        this.setOverwrite(!this.$overwrite);
      };
      EditSession.prototype.addGutterDecoration = function(row, className) {
        if (!this.$decorations[row]) {
          this.$decorations[row] = "";
        }
        this.$decorations[row] += " " + className;
        this.eventBus._signal("changeBreakpoint", {});
      };
      EditSession.prototype.removeGutterDecoration = function(row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this.eventBus._signal("changeBreakpoint", {});
      };
      EditSession.prototype.getBreakpoints = function() {
        return this.$breakpoints;
      };
      EditSession.prototype.setBreakpoints = function(rows) {
        this.$breakpoints = [];
        for (var i = 0; i < rows.length; i++) {
          this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this.eventBus._signal("changeBreakpoint", {});
      };
      EditSession.prototype.clearBreakpoints = function() {
        this.$breakpoints = [];
        this.eventBus._signal("changeBreakpoint", {});
      };
      EditSession.prototype.setBreakpoint = function(row, className) {
        if (className === undefined)
          className = "ace_breakpoint";
        if (className)
          this.$breakpoints[row] = className;
        else
          delete this.$breakpoints[row];
        this.eventBus._signal("changeBreakpoint", {});
      };
      EditSession.prototype.clearBreakpoint = function(row) {
        delete this.$breakpoints[row];
        this.eventBus._signal("changeBreakpoint", {});
      };
      EditSession.prototype.addMarker = function(range, clazz, type, renderer, inFront) {
        if (type === void 0) {
          type = 'line';
        }
        var id = this.$markerId++;
        if (range) {
          if (typeof range.start.row !== 'number') {
            throw new TypeError();
          }
          if (typeof range.start.column !== 'number') {
            throw new TypeError();
          }
          if (typeof range.end.row !== 'number') {
            throw new TypeError();
          }
          if (typeof range.end.column !== 'number') {
            throw new TypeError();
          }
        }
        var marker = {
          range: range,
          type: type || "line",
          renderer: renderer,
          clazz: clazz,
          inFront: !!inFront,
          id: id
        };
        if (inFront) {
          this.$frontMarkers[id] = marker;
          this.eventBus._signal("changeFrontMarker");
        } else {
          this.$backMarkers[id] = marker;
          this.eventBus._signal("changeBackMarker");
        }
        return id;
      };
      EditSession.prototype.addDynamicMarker = function(marker, inFront) {
        if (!marker.update) {
          return;
        }
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;
        if (inFront) {
          this.$frontMarkers[id] = marker;
          this.eventBus._signal("changeFrontMarker");
        } else {
          this.$backMarkers[id] = marker;
          this.eventBus._signal("changeBackMarker");
        }
        return marker;
      };
      EditSession.prototype.removeMarker = function(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
          return;
        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        if (marker) {
          delete(markers[markerId]);
          this.eventBus._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        }
      };
      EditSession.prototype.getMarkers = function(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
      };
      EditSession.prototype.highlight = function(re) {
        if (!this.$searchHighlight) {
          var highlight = new SearchHighlight_1.default(null, "ace_selected-word", "text");
          this.addDynamicMarker(highlight);
          this.$searchHighlight = highlight;
        }
        this.$searchHighlight.setRegexp(re);
      };
      EditSession.prototype.highlightLines = function(startRow, endRow, clazz, inFront) {
        if (clazz === void 0) {
          clazz = "ace_step";
        }
        var range = new Range_1.default(startRow, 0, endRow, Infinity);
        range.markerId = this.addMarker(range, clazz, "fullLine", null, inFront);
        return range;
      };
      EditSession.prototype.setAnnotations = function(annotations) {
        this.$annotations = annotations;
        this.eventBus._signal("changeAnnotation", {});
      };
      EditSession.prototype.getAnnotations = function() {
        return this.$annotations || [];
      };
      EditSession.prototype.clearAnnotations = function() {
        this.setAnnotations([]);
      };
      EditSession.prototype.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
          this.$autoNewLine = match[1];
        } else {
          this.$autoNewLine = "\n";
        }
      };
      EditSession.prototype.getWordRange = function(row, column) {
        var line = this.getLine(row);
        var inToken = false;
        if (column > 0)
          inToken = !!line.charAt(column - 1).match(this.tokenRe);
        if (!inToken)
          inToken = !!line.charAt(column).match(this.tokenRe);
        if (inToken)
          var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
          var re = /\s/;
        else
          var re = this.nonTokenRe;
        var start = column;
        if (start > 0) {
          do {
            start--;
          } while (start >= 0 && line.charAt(start).match(re));
          start++;
        }
        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
          end++;
        }
        return new Range_1.default(row, start, row, end);
      };
      EditSession.prototype.getAWordRange = function(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);
        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
          wordRange.end.column += 1;
        }
        return wordRange;
      };
      EditSession.prototype.setNewLineMode = function(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
      };
      EditSession.prototype.getNewLineMode = function() {
        return this.doc.getNewLineMode();
      };
      EditSession.prototype.setUseWorker = function(useWorker) {
        this.setOption("useWorker", useWorker);
      };
      EditSession.prototype.getUseWorker = function() {
        return this.$useWorker;
      };
      EditSession.prototype.onReloadTokenizer = function(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this.eventBus._signal("tokenizerUpdate", e);
      };
      EditSession.prototype.setLanguageMode = function(mode) {
        return this.$onChangeMode(mode, false);
      };
      EditSession.prototype.setMode = function(modeName) {
        var _this = this;
        this.importMode(modeName).then(function(mode) {
          return _this.setLanguageMode(mode);
        }).catch(function(reason) {
          throw new Error("setMode failed. Reason: " + reason);
        });
      };
      EditSession.prototype.importMode = function(modeName, options) {
        if (typeof modeName !== 'string') {
          throw new TypeError("modeName must be a string");
        }
        if (!this.$mode) {
          this.$onChangeMode(new TextMode_1.default('', []), true);
        }
        var self = this;
        return new Promise(function(success, fail) {
          if (self.$modes[modeName] && !options) {
            success(self.$modes[modeName]);
          } else {
            if (self.$modes[modeName] && !options) {
              success(self.$modes[modeName]);
            }
            System.import(modeName).then(function(m) {
              if (m && m.default) {
                var newMode = new m.default(options);
                success(newMode);
              } else {
                fail(new Error(modeName + " does not define a default export (a LanguageMode class)."));
              }
            }).catch(function(reason) {
              fail(reason);
            });
          }
        });
      };
      EditSession.prototype.$onChangeMode = function(mode, isPlaceholder) {
        var _this = this;
        if (!isPlaceholder) {
          this.$modeId = mode.$id;
        }
        if (this.$mode === mode) {
          return;
        }
        this.$mode = mode;
        this.$stopWorker();
        if (this.$useWorker) {
          this.$startWorker();
        }
        var tokenizer = mode.getTokenizer();
        if (tokenizer['addEventListener'] !== undefined) {
          var onReloadTokenizer = this.onReloadTokenizer.bind(this);
          tokenizer['addEventListener']("update", onReloadTokenizer);
        }
        if (!this.bgTokenizer) {
          this.bgTokenizer = new BackgroundTokenizer_1.default(tokenizer, this);
          this.bgTokenizer.on("update", function(event, bg) {
            _this.eventBus._signal("tokenizerUpdate", event);
          });
        } else {
          this.bgTokenizer.setTokenizer(tokenizer);
        }
        this.bgTokenizer.setDocument(this.getDocument());
        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;
        if (!isPlaceholder) {
          this.$options.wrapMethod.set.call(this, this.$wrapMethod);
          this.$setFolding(mode.foldingRules);
          this.bgTokenizer.start(0);
          this.eventBus._emit("changeMode");
        }
      };
      EditSession.prototype.$stopWorker = function() {
        if (this.$worker) {
          this.$worker.terminate();
        }
        this.$worker = null;
      };
      EditSession.prototype.$startWorker = function() {
        try {
          this.$worker = this.$mode.createWorker(this);
        } catch (e) {
          this.$worker = null;
        }
      };
      EditSession.prototype.getMode = function() {
        return this.$mode;
      };
      EditSession.prototype.setScrollTop = function(scrollTop) {
        if (this.$scrollTop === scrollTop || isNaN(scrollTop)) {
          return;
        }
        this.$scrollTop = scrollTop;
        this.eventBus._signal("changeScrollTop", scrollTop);
      };
      EditSession.prototype.getScrollTop = function() {
        return this.$scrollTop;
      };
      EditSession.prototype.setScrollLeft = function(scrollLeft) {
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
          return;
        this.$scrollLeft = scrollLeft;
        this.eventBus._signal("changeScrollLeft", scrollLeft);
      };
      EditSession.prototype.getScrollLeft = function() {
        return this.$scrollLeft;
      };
      EditSession.prototype.getScreenWidth = function() {
        this.$computeWidth();
        if (this.lineWidgets)
          return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
      };
      EditSession.prototype.getLineWidgetMaxWidth = function() {
        if (this.lineWidgetsWidth != null)
          return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function(w) {
          if (w && w.screenWidth > width)
            width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
      };
      EditSession.prototype.$computeWidth = function(force) {
        if (this.$modified || force) {
          this.$modified = false;
          if (this.$useWrapMode) {
            return this.screenWidth = this.$wrapLimit;
          }
          var lines = this.doc.getAllLines();
          var cache = this.$rowLengthCache;
          var longestScreenLine = 0;
          var foldIndex = 0;
          var foldLine = this.$foldData[foldIndex];
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          var len = lines.length;
          for (var i = 0; i < len; i++) {
            if (i > foldStart) {
              i = foldLine.end.row + 1;
              if (i >= len)
                break;
              foldLine = this.$foldData[foldIndex++];
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (cache[i] == null)
              cache[i] = this.$getStringScreenWidth(lines[i])[0];
            if (cache[i] > longestScreenLine)
              longestScreenLine = cache[i];
          }
          this.screenWidth = longestScreenLine;
        }
      };
      EditSession.prototype.getLine = function(row) {
        return this.doc.getLine(row);
      };
      EditSession.prototype.getLines = function(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
      };
      EditSession.prototype.getLength = function() {
        return this.doc.getLength();
      };
      EditSession.prototype.getTextRange = function(range) {
        return this.doc.getTextRange(range || this.selection.getRange());
      };
      EditSession.prototype.insert = function(position, text) {
        return this.doc.insert(position, text);
      };
      EditSession.prototype.remove = function(range) {
        return this.doc.remove(range);
      };
      EditSession.prototype.removeFullLines = function(firstRow, lastRow) {
        return this.doc.removeFullLines(firstRow, lastRow);
      };
      EditSession.prototype.undoChanges = function(deltas, dontSelect) {
        var _this = this;
        if (!deltas.length)
          return;
        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = deltas.length - 1; i != -1; i--) {
          var delta = deltas[i];
          if (delta.group === "doc") {
            this.doc.revertDeltas(delta.deltas);
            lastUndoRange = this.$getUndoSelection(delta.deltas, true, lastUndoRange);
          } else {
            delta.deltas.forEach(function(foldDelta) {
              _this.addFolds(foldDelta.folds);
            }, this);
          }
        }
        this.$fromUndo = false;
        lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
      };
      EditSession.prototype.redoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
          return;
        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = 0; i < deltas.length; i++) {
          var delta = deltas[i];
          if (delta.group == "doc") {
            this.doc.applyDeltas(delta.deltas);
            lastUndoRange = this.$getUndoSelection(delta.deltas, false, lastUndoRange);
          }
        }
        this.$fromUndo = false;
        lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
      };
      EditSession.prototype.setUndoSelect = function(enable) {
        this.$undoSelect = enable;
      };
      EditSession.prototype.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
        function isInsert(delta) {
          return isUndo ? delta.action !== "insert" : delta.action === "insert";
        }
        var delta = deltas[0];
        var range;
        var point;
        var lastDeltaIsInsert = false;
        if (isInsert(delta)) {
          range = Range_1.default.fromPoints(delta.start, delta.end);
          lastDeltaIsInsert = true;
        } else {
          range = Range_1.default.fromPoints(delta.start, delta.start);
          lastDeltaIsInsert = false;
        }
        for (var i = 1; i < deltas.length; i++) {
          delta = deltas[i];
          if (isInsert(delta)) {
            point = delta.start;
            if (range.compare(point.row, point.column) == -1) {
              range.setStart(point.row, point.column);
            }
            point = delta.end;
            if (range.compare(point.row, point.column) == 1) {
              range.setEnd(point.row, point.column);
            }
            lastDeltaIsInsert = true;
          } else {
            point = delta.start;
            if (range.compare(point.row, point.column) == -1) {
              range = Range_1.default.fromPoints(delta.start, delta.start);
            }
            lastDeltaIsInsert = false;
          }
        }
        if (lastUndoRange != null) {
          if (Range_1.default.comparePoints(lastUndoRange.start, range.start) === 0) {
            lastUndoRange.start.column += range.end.column - range.start.column;
            lastUndoRange.end.column += range.end.column - range.start.column;
          }
          var cmp = lastUndoRange.compareRange(range);
          if (cmp == 1) {
            range.setStart(lastUndoRange.start.row, lastUndoRange.start.column);
          } else if (cmp == -1) {
            range.setEnd(lastUndoRange.end.row, lastUndoRange.end.column);
          }
        }
        return range;
      };
      EditSession.prototype.replace = function(range, text) {
        return this.doc.replace(range, text);
      };
      EditSession.prototype.moveText = function(fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);
        var rowDiff;
        var colDiff;
        var toRange = Range_1.default.fromPoints(toPosition, toPosition);
        if (!copy) {
          this.remove(fromRange);
          rowDiff = fromRange.start.row - fromRange.end.row;
          colDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
          if (colDiff) {
            if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column) {
              toRange.start.column += colDiff;
            }
            if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column) {
              toRange.end.column += colDiff;
            }
          }
          if (rowDiff && toRange.start.row >= fromRange.end.row) {
            toRange.start.row += rowDiff;
            toRange.end.row += rowDiff;
          }
        }
        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
          var oldStart = fromRange.start;
          var newStart = toRange.start;
          rowDiff = newStart.row - oldStart.row;
          colDiff = newStart.column - oldStart.column;
          this.addFolds(folds.map(function(x) {
            x = x.clone();
            if (x.start.row == oldStart.row) {
              x.start.column += colDiff;
            }
            if (x.end.row == oldStart.row) {
              x.end.column += colDiff;
            }
            x.start.row += rowDiff;
            x.end.row += rowDiff;
            return x;
          }));
        }
        return toRange;
      };
      EditSession.prototype.indentRows = function(startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row = startRow; row <= endRow; row++)
          this.insert({
            row: row,
            column: 0
          }, indentString);
      };
      EditSession.prototype.outdentRows = function(range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range_1.default(0, 0, 0, 0);
        var size = this.getTabSize();
        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
          var line = this.getLine(i);
          deleteRange.start.row = i;
          deleteRange.end.row = i;
          for (var j = 0; j < size; ++j)
            if (line.charAt(j) != ' ')
              break;
          if (j < size && line.charAt(j) == '\t') {
            deleteRange.start.column = j;
            deleteRange.end.column = j + 1;
          } else {
            deleteRange.start.column = 0;
            deleteRange.end.column = j;
          }
          this.remove(deleteRange);
        }
      };
      EditSession.prototype.$moveLines = function(firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
          var row = this.getRowFoldStart(firstRow + dir);
          if (row < 0)
            return 0;
          var diff = row - firstRow;
        } else if (dir > 0) {
          var row = this.getRowFoldEnd(lastRow + dir);
          if (row > this.doc.getLength() - 1)
            return 0;
          var diff = row - lastRow;
        } else {
          firstRow = this.$clipRowToDocument(firstRow);
          lastRow = this.$clipRowToDocument(lastRow);
          var diff = lastRow - firstRow + 1;
        }
        var range = new Range_1.default(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x) {
          x = x.clone();
          x.start.row += diff;
          x.end.row += diff;
          return x;
        });
        var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
        this.doc.insertFullLines(firstRow + diff, lines);
        folds.length && this.addFolds(folds);
        return diff;
      };
      EditSession.prototype.moveLinesUp = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
      };
      EditSession.prototype.moveLinesDown = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
      };
      EditSession.prototype.duplicateLines = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
      };
      EditSession.prototype.$clipRowToDocument = function(row) {
        return Math.max(0, Math.min(row, this.doc.getLength() - 1));
      };
      EditSession.prototype.$clipColumnToRow = function(row, column) {
        if (column < 0)
          return 0;
        return Math.min(this.doc.getLine(row).length, column);
      };
      EditSession.prototype.$clipPositionToDocument = function(row, column) {
        column = Math.max(0, column);
        if (row < 0) {
          row = 0;
          column = 0;
        } else {
          var len = this.doc.getLength();
          if (row >= len) {
            row = len - 1;
            column = this.doc.getLine(len - 1).length;
          } else {
            column = Math.min(this.doc.getLine(row).length, column);
          }
        }
        return {
          row: row,
          column: column
        };
      };
      EditSession.prototype.$clipRangeToDocument = function(range) {
        if (range.start.row < 0) {
          range.start.row = 0;
          range.start.column = 0;
        } else {
          range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
        }
        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
          range.end.row = len;
          range.end.column = this.doc.getLine(len).length;
        } else {
          range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
        }
        return range;
      };
      EditSession.prototype.setUseWrapMode = function(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
          this.$useWrapMode = useWrapMode;
          this.$modified = true;
          this.$resetRowCache(0);
          if (useWrapMode) {
            var len = this.getLength();
            this.$wrapData = Array(len);
            this.$updateWrapData(0, len - 1);
          }
          this.eventBus._signal("changeWrapMode");
        }
      };
      EditSession.prototype.getUseWrapMode = function() {
        return this.$useWrapMode;
      };
      EditSession.prototype.setWrapLimitRange = function(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
          this.$wrapLimitRange = {
            min: min,
            max: max
          };
          this.$modified = true;
          this.eventBus._signal("changeWrapMode");
        }
      };
      EditSession.prototype.adjustWrapLimit = function(desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max < 0)
          limits = {
            min: $printMargin,
            max: $printMargin
          };
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
          this.$wrapLimit = wrapLimit;
          this.$modified = true;
          if (this.$useWrapMode) {
            this.$updateWrapData(0, this.getLength() - 1);
            this.$resetRowCache(0);
            this.eventBus._signal("changeWrapLimit");
          }
          return true;
        }
        return false;
      };
      EditSession.prototype.$constrainWrapLimit = function(wrapLimit, min, max) {
        if (min)
          wrapLimit = Math.max(min, wrapLimit);
        if (max)
          wrapLimit = Math.min(max, wrapLimit);
        return wrapLimit;
      };
      EditSession.prototype.getWrapLimit = function() {
        return this.$wrapLimit;
      };
      EditSession.prototype.setWrapLimit = function(limit) {
        this.setWrapLimitRange(limit, limit);
      };
      EditSession.prototype.getWrapLimitRange = function() {
        return {
          min: this.$wrapLimitRange.min,
          max: this.$wrapLimitRange.max
        };
      };
      EditSession.prototype.$updateInternalDataOnChange = function(delta) {
        var useWrapMode = this.$useWrapMode;
        var action = delta.action;
        var start = delta.start;
        var end = delta.end;
        var firstRow = start.row;
        var lastRow = end.row;
        var len = lastRow - firstRow;
        var removedFolds = null;
        this.$updating = true;
        if (len != 0) {
          if (action === "remove") {
            this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
            var foldLines = this.$foldData;
            removedFolds = this.getFoldsInRange(delta);
            this.removeFolds(removedFolds);
            var foldLine = this.getFoldLine(end.row);
            var idx = 0;
            if (foldLine) {
              foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
              foldLine.shiftRow(-len);
              var foldLineBefore = this.getFoldLine(firstRow);
              if (foldLineBefore && foldLineBefore !== foldLine) {
                foldLineBefore.merge(foldLine);
                foldLine = foldLineBefore;
              }
              idx = foldLines.indexOf(foldLine) + 1;
            }
            for (idx; idx < foldLines.length; idx++) {
              var foldLine = foldLines[idx];
              if (foldLine.start.row >= end.row) {
                foldLine.shiftRow(-len);
              }
            }
            lastRow = firstRow;
          } else {
            var args = Array(len);
            args.unshift(firstRow, 0);
            var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
            arr.splice.apply(arr, args);
            var foldLines = this.$foldData;
            var foldLine = this.getFoldLine(firstRow);
            var idx = 0;
            if (foldLine) {
              var cmp = foldLine.range.compareInside(start.row, start.column);
              if (cmp == 0) {
                foldLine = foldLine.split(start.row, start.column);
                if (foldLine) {
                  foldLine.shiftRow(len);
                  foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                }
              } else if (cmp == -1) {
                foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                foldLine.shiftRow(len);
              }
              idx = foldLines.indexOf(foldLine) + 1;
            }
            for (idx; idx < foldLines.length; idx++) {
              var foldLine = foldLines[idx];
              if (foldLine.start.row >= firstRow) {
                foldLine.shiftRow(len);
              }
            }
          }
        } else {
          len = Math.abs(delta.start.column - delta.end.column);
          if (action === "remove") {
            removedFolds = this.getFoldsInRange(delta);
            this.removeFolds(removedFolds);
            len = -len;
          }
          var foldLine = this.getFoldLine(firstRow);
          if (foldLine) {
            foldLine.addRemoveChars(firstRow, start.column, len);
          }
        }
        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
          console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;
        if (useWrapMode)
          this.$updateWrapData(firstRow, lastRow);
        else
          this.$updateRowLengthCache(firstRow, lastRow);
        return removedFolds;
      };
      EditSession.prototype.$updateRowLengthCache = function(firstRow, lastRow, b) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
      };
      EditSession.prototype.$updateWrapData = function(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;
        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
          foldLine = this.getFoldLine(row, foldLine);
          if (!foldLine) {
            tokens = this.$getDisplayTokens(lines[row]);
            wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
            row++;
          } else {
            tokens = [];
            foldLine.walk(function(placeholder, row, column, lastColumn) {
              var walkTokens;
              if (placeholder != null) {
                walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                walkTokens[0] = PLACEHOLDER_START;
                for (var i = 1; i < walkTokens.length; i++) {
                  walkTokens[i] = PLACEHOLDER_BODY;
                }
              } else {
                walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
              }
              tokens = tokens.concat(walkTokens);
            }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
            wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
            row = foldLine.end.row + 1;
          }
        }
      };
      EditSession.prototype.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
        if (tokens.length == 0) {
          return [];
        }
        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0,
            lastDocSplit = 0;
        var isCode = this.$wrapAsCode;
        function addSplit(screenPos) {
          var displayed = tokens.slice(lastSplit, screenPos);
          var len = displayed.length;
          displayed.join("").replace(/12/g, function() {
            len -= 1;
            return void 0;
          }).replace(/2/g, function() {
            len -= 1;
            return void 0;
          });
          lastDocSplit += len;
          splits.push(lastDocSplit);
          lastSplit = screenPos;
        }
        while (displayLength - lastSplit > wrapLimit) {
          var split = lastSplit + wrapLimit;
          if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
            addSplit(split);
            continue;
          }
          if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
            for (split; split != lastSplit - 1; split--) {
              if (tokens[split] == PLACEHOLDER_START) {
                break;
              }
            }
            if (split > lastSplit) {
              addSplit(split);
              continue;
            }
            split = lastSplit + wrapLimit;
            for (split; split < tokens.length; split++) {
              if (tokens[split] != PLACEHOLDER_BODY) {
                break;
              }
            }
            if (split == tokens.length) {
              break;
            }
            addSplit(split);
            continue;
          }
          var minSplit = Math.max(split - (isCode ? 10 : wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
          while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
            split--;
          }
          if (isCode) {
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
              split--;
            }
            while (split > minSplit && tokens[split] == PUNCTUATION) {
              split--;
            }
          } else {
            while (split > minSplit && tokens[split] < SPACE) {
              split--;
            }
          }
          if (split > minSplit) {
            addSplit(++split);
            continue;
          }
          split = lastSplit + wrapLimit;
          addSplit(split);
        }
        return splits;
      };
      EditSession.prototype.$getDisplayTokens = function(str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;
        for (var i = 0; i < str.length; i++) {
          var c = str.charCodeAt(i);
          if (c == 9) {
            tabSize = this.getScreenTabSize(arr.length + offset);
            arr.push(TAB);
            for (var n = 1; n < tabSize; n++) {
              arr.push(TAB_SPACE);
            }
          } else if (c == 32) {
            arr.push(SPACE);
          } else if ((c > 39 && c < 48) || (c > 57 && c < 64)) {
            arr.push(PUNCTUATION);
          } else if (c >= 0x1100 && isFullWidth(c)) {
            arr.push(CHAR, CHAR_EXT);
          } else {
            arr.push(CHAR);
          }
        }
        return arr;
      };
      EditSession.prototype.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
          return [0, 0];
        if (maxScreenColumn == null)
          maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;
        var c;
        var column;
        for (column = 0; column < str.length; column++) {
          c = str.charCodeAt(column);
          if (c == 9) {
            screenColumn += this.getScreenTabSize(screenColumn);
          } else if (c >= 0x1100 && isFullWidth(c)) {
            screenColumn += 2;
          } else {
            screenColumn += 1;
          }
          if (screenColumn > maxScreenColumn) {
            break;
          }
        }
        return [screenColumn, column];
      };
      EditSession.prototype.getRowLength = function(row) {
        if (this.lineWidgets)
          var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else
          h = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
          return 1 + h;
        } else {
          return this.$wrapData[row].length + 1 + h;
        }
      };
      EditSession.prototype.getRowLineCount = function(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
          return 1;
        } else {
          return this.$wrapData[row].length + 1;
        }
      };
      EditSession.prototype.getRowWrapIndent = function(screenRow) {
        if (this.$useWrapMode) {
          var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
          var splits = this.$wrapData[pos.row];
          return splits.length && splits[0] < pos.column ? splits['indent'] : 0;
        } else {
          return 0;
        }
      };
      EditSession.prototype.getScreenLastRowColumn = function(screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
      };
      EditSession.prototype.getDocumentLastRowColumn = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
      };
      EditSession.prototype.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
      };
      EditSession.prototype.getRowSplitData = function(row) {
        if (!this.$useWrapMode) {
          return undefined;
        } else {
          return this.$wrapData[row];
        }
      };
      EditSession.prototype.getScreenTabSize = function(screenColumn) {
        return this.$tabSize - screenColumn % this.$tabSize;
      };
      EditSession.prototype.screenToDocumentRow = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
      };
      EditSession.prototype.screenToDocumentColumn = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
      };
      EditSession.prototype.screenToDocumentPosition = function(screenRow, screenColumn) {
        if (screenRow < 0) {
          return {
            row: 0,
            column: 0
          };
        }
        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;
        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l && i >= 0) {
          var row = rowCache[i];
          var docRow = this.$docRowCache[i];
          var doCache = screenRow > rowCache[l - 1];
        } else {
          var doCache = !l;
        }
        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (row <= screenRow) {
          rowLength = this.getRowLength(docRow);
          if (row + rowLength > screenRow || docRow >= maxRow) {
            break;
          } else {
            row += rowLength;
            docRow++;
            if (docRow > foldStart) {
              docRow = foldLine.end.row + 1;
              foldLine = this.getNextFoldLine(docRow, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
          }
          if (doCache) {
            this.$docRowCache.push(docRow);
            this.$screenRowCache.push(row);
          }
        }
        if (foldLine && foldLine.start.row <= docRow) {
          line = this.getFoldDisplayLine(foldLine);
          docRow = foldLine.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
          return {
            row: maxRow,
            column: this.getLine(maxRow).length
          };
        } else {
          line = this.getLine(docRow);
          foldLine = null;
        }
        if (this.$useWrapMode) {
          var splits = this.$wrapData[docRow];
          if (splits) {
            var splitIndex = Math.floor(screenRow - row);
            column = splits[splitIndex];
            if (splitIndex > 0 && splits.length) {
              docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
              line = line.substring(docColumn);
            }
          }
        }
        docColumn += this.$getStringScreenWidth(line, screenColumn)[1];
        if (this.$useWrapMode && docColumn >= column)
          docColumn = column - 1;
        if (foldLine)
          return foldLine.idxToPosition(docColumn);
        return {
          row: docRow,
          column: docColumn
        };
      };
      EditSession.prototype.documentToScreenPosition = function(docRow, docColumn) {
        if (typeof docRow !== 'number') {
          throw new TypeError("docRow must be a number");
        }
        if (typeof docColumn !== 'number') {
          throw new TypeError("docColumn must be a number");
        }
        var pos = this.$clipPositionToDocument(docRow, docColumn);
        docRow = pos.row;
        docColumn = pos.column;
        if (typeof docRow !== 'number') {
          throw new TypeError("docRow must be a number");
        }
        if (typeof docColumn !== 'number') {
          throw new TypeError("docColumn must be a number");
        }
        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
          docRow = fold.start.row;
          docColumn = fold.start.column;
        }
        var rowEnd;
        var row = 0;
        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l && i >= 0) {
          row = rowCache[i];
          screenRow = this.$screenRowCache[i];
          var doCache = docRow > rowCache[l - 1];
        } else {
          var doCache = !l;
        }
        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (row < docRow) {
          if (row >= foldStart) {
            rowEnd = foldLine.end.row + 1;
            if (rowEnd > docRow)
              break;
            foldLine = this.getNextFoldLine(rowEnd, foldLine);
            foldStart = foldLine ? foldLine.start.row : Infinity;
          } else {
            rowEnd = row + 1;
          }
          screenRow += this.getRowLength(row);
          row = rowEnd;
          if (doCache) {
            this.$docRowCache.push(row);
            this.$screenRowCache.push(screenRow);
          }
        }
        var textLine = "";
        if (foldLine && row >= foldStart) {
          textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
          foldStartRow = foldLine.start.row;
        } else {
          textLine = this.getLine(docRow).substring(0, docColumn);
          foldStartRow = docRow;
        }
        if (this.$useWrapMode) {
          var wrapRow = this.$wrapData[foldStartRow];
          if (wrapRow) {
            var screenRowOffset = 0;
            while (textLine.length >= wrapRow[screenRowOffset]) {
              screenRow++;
              screenRowOffset++;
            }
            textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
          }
        }
        return {
          row: screenRow,
          column: this.$getStringScreenWidth(textLine)[0]
        };
      };
      EditSession.prototype.documentToScreenColumn = function(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).column;
      };
      EditSession.prototype.documentToScreenRow = function(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
      };
      EditSession.prototype.documentToScreenRange = function(range) {
        var screenPosStart = this.documentToScreenPosition(range.start.row, range.start.column);
        var screenPosEnd = this.documentToScreenPosition(range.end.row, range.end.column);
        return new Range_1.default(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
      };
      EditSession.prototype.getScreenLength = function() {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
          screenRows = this.getLength();
          var foldData = this.$foldData;
          for (var i = 0; i < foldData.length; i++) {
            fold = foldData[i];
            screenRows -= fold.end.row - fold.start.row;
          }
        } else {
          var lastRow = this.$wrapData.length;
          var row = 0,
              i = 0;
          var fold = this.$foldData[i++];
          var foldStart = fold ? fold.start.row : Infinity;
          while (row < lastRow) {
            var splits = this.$wrapData[row];
            screenRows += splits ? splits.length + 1 : 1;
            row++;
            if (row > foldStart) {
              row = fold.end.row + 1;
              fold = this.$foldData[i++];
              foldStart = fold ? fold.start.row : Infinity;
            }
          }
        }
        if (this.lineWidgets) {
          screenRows += this.$getWidgetScreenLength();
        }
        return screenRows;
      };
      EditSession.prototype.$setFontMetrics = function(fm) {};
      EditSession.prototype.findMatchingBracket = function(position, chr) {
        return this.$bracketMatcher.findMatchingBracket(position, chr);
      };
      EditSession.prototype.getBracketRange = function(position) {
        return this.$bracketMatcher.getBracketRange(position);
      };
      EditSession.prototype.findOpeningBracket = function(bracket, position, typeRe) {
        return this.$bracketMatcher.findOpeningBracket(bracket, position, typeRe);
      };
      EditSession.prototype.findClosingBracket = function(bracket, position, typeRe) {
        return this.$bracketMatcher.findClosingBracket(bracket, position, typeRe);
      };
      EditSession.prototype.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
          return null;
        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
          var fold = folds[i];
          if (fold.range.contains(row, column)) {
            if (side === 1 && fold.range.isEnd(row, column)) {
              continue;
            } else if (side === -1 && fold.range.isStart(row, column)) {
              continue;
            }
            return fold;
          }
        }
      };
      EditSession.prototype.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];
        start.column += 1;
        end.column -= 1;
        for (var i = 0; i < foldLines.length; i++) {
          var cmp = foldLines[i].range.compareRange(range);
          if (cmp == 2) {
            continue;
          } else if (cmp == -2) {
            break;
          }
          var folds = foldLines[i].folds;
          for (var j = 0; j < folds.length; j++) {
            var fold = folds[j];
            cmp = fold.range.compareRange(range);
            if (cmp == -2) {
              break;
            } else if (cmp == 2) {
              continue;
            } else if (cmp == 42) {
              break;
            }
            foundFolds.push(fold);
          }
        }
        start.column -= 1;
        end.column += 1;
        return foundFolds;
      };
      EditSession.prototype.getFoldsInRangeList = function(ranges) {
        var _this = this;
        var folds = [];
        if (Array.isArray(ranges)) {
          ranges.forEach(function(range) {
            folds = folds.concat(_this.getFoldsInRange(range));
          });
        } else {
          throw new TypeError("ranges must be a RangeBasic[]");
        }
        return folds;
      };
      EditSession.prototype.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        for (var i = 0; i < foldLines.length; i++)
          for (var j = 0; j < foldLines[i].folds.length; j++)
            folds.push(foldLines[i].folds[j]);
        return folds;
      };
      EditSession.prototype.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
          return null;
        var lastFold = {end: {column: 0}};
        var str;
        var fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
          fold = foldLine.folds[i];
          var cmp = fold.range.compareEnd(row, column);
          if (cmp == -1) {
            str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
            break;
          } else if (cmp === 0) {
            return null;
          }
          lastFold = fold;
        }
        if (!str)
          str = this.getLine(fold.start.row).substring(lastFold.end.column);
        if (trim == -1)
          return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
          return str.substring(column - lastFold.end.column);
        else
          return str;
      };
      EditSession.prototype.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
          i = foldData.indexOf(startFoldLine);
        if (i == -1)
          i = 0;
        for (i; i < foldData.length; i++) {
          var foldLine = foldData[i];
          if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
            return foldLine;
          } else if (foldLine.end.row > docRow) {
            return null;
          }
        }
        return null;
      };
      EditSession.prototype.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
          i = foldData.indexOf(startFoldLine);
        if (i == -1)
          i = 0;
        for (i; i < foldData.length; i++) {
          var foldLine = foldData[i];
          if (foldLine.end.row >= docRow) {
            return foldLine;
          }
        }
        return null;
      };
      EditSession.prototype.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData;
        var rowCount = last - first + 1;
        for (var i = 0; i < foldData.length; i++) {
          var foldLine = foldData[i],
              end = foldLine.end.row,
              start = foldLine.start.row;
          if (end >= last) {
            if (start < last) {
              if (start >= first)
                rowCount -= last - start;
              else
                rowCount = 0;
            }
            break;
          } else if (end >= first) {
            if (start >= first)
              rowCount -= end - start;
            else
              rowCount -= end - first + 1;
          }
        }
        return rowCount;
      };
      EditSession.prototype.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
          return a.start.row - b.start.row;
        });
        return foldLine;
      };
      EditSession.prototype.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        if (placeholder instanceof Fold_1.default)
          fold = placeholder;
        else if (typeof placeholder === 'string') {
          fold = new Fold_1.default(range, placeholder);
          fold.collapseChildren = range.collapseChildren;
        } else {
          throw new Error("placeholder must be a string or a Fold.");
        }
        fold.range = this.$clipRangeToDocument(fold.range);
        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;
        if (!(startRow < endRow || startRow == endRow && startColumn <= endColumn - 2))
          throw new Error("The range has to be at least 2 characters width");
        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
          return startFold.addSubFold(fold);
        if ((startFold && !startFold.range.isStart(startRow, startColumn)) || (endFold && !endFold.range.isEnd(endRow, endColumn))) {
          throw new Error("A fold can't intersect already existing fold" + fold.range + startFold.range);
        }
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
          this.removeFolds(folds);
          folds.forEach(function(subFold) {
            fold.addSubFold(subFold);
          });
        }
        for (var i = 0; i < foldData.length; i++) {
          var foldLine = foldData[i];
          if (endRow == foldLine.start.row) {
            foldLine.addFold(fold);
            added = true;
            break;
          } else if (startRow == foldLine.end.row) {
            foldLine.addFold(fold);
            added = true;
            if (!fold.sameRow) {
              var foldLineNext = foldData[i + 1];
              if (foldLineNext && foldLineNext.start.row == endRow) {
                foldLine.merge(foldLineNext);
                break;
              }
            }
            break;
          } else if (endRow <= foldLine.start.row) {
            break;
          }
        }
        if (!added)
          foldLine = this.$addFoldLine(new FoldLine_1.default(this.$foldData, [fold]));
        if (this.$useWrapMode)
          this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
          this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
        this.setModified(true);
        var foldEvent = {
          data: fold,
          action: "add"
        };
        this.eventBus._emit("changeFold", foldEvent);
        return fold;
      };
      EditSession.prototype.setModified = function(modified) {};
      EditSession.prototype.addFolds = function(folds) {
        folds.forEach(function(fold) {
          this.addFold(fold);
        }, this);
      };
      EditSession.prototype.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;
        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        if (folds.length === 1) {
          foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
          folds.pop();
          foldLine.end.row = folds[folds.length - 1].end.row;
          foldLine.end.column = folds[folds.length - 1].end.column;
        } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
          folds.shift();
          foldLine.start.row = folds[0].start.row;
          foldLine.start.column = folds[0].start.column;
        } else if (fold.sameRow) {
          folds.splice(folds.indexOf(fold), 1);
        } else {
          var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
          folds = newFoldLine.folds;
          folds.shift();
          newFoldLine.start.row = folds[0].start.row;
          newFoldLine.start.column = folds[0].start.column;
        }
        if (!this.$updating) {
          if (this.$useWrapMode)
            this.$updateWrapData(startRow, endRow);
          else
            this.$updateRowLengthCache(startRow, endRow);
        }
        this.setModified(true);
        var foldEvent = {
          data: fold,
          action: "remove"
        };
        this.eventBus._emit("changeFold", foldEvent);
      };
      EditSession.prototype.removeFolds = function(folds) {
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
          cloneFolds.push(folds[i]);
        }
        cloneFolds.forEach(function(fold) {
          this.removeFold(fold);
        }, this);
        this.setModified(true);
      };
      EditSession.prototype.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
          fold.restoreRange(subFold);
          this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
          this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
        }
        fold.subFolds = [];
      };
      EditSession.prototype.expandFolds = function(folds) {
        folds.forEach(function(fold) {
          this.expandFold(fold);
        }, this);
      };
      EditSession.prototype.unfold = function(location, expandInner) {
        var range;
        var folds;
        if (location == null) {
          range = new Range_1.default(0, 0, this.getLength(), 0);
          expandInner = true;
        } else if (typeof location === "number")
          range = new Range_1.default(location, 0, location, this.getLine(location).length);
        else if ("row" in location)
          range = Range_1.default.fromPoints(location, location);
        else if (location instanceof Range_1.default) {
          range = location;
        } else {
          throw new TypeError("location must be one of number | Position | Range");
        }
        folds = this.getFoldsInRangeList([range]);
        if (expandInner) {
          this.removeFolds(folds);
        } else {
          var subFolds = folds;
          while (subFolds.length) {
            this.expandFolds(subFolds);
            subFolds = this.getFoldsInRangeList([range]);
          }
        }
        if (folds.length)
          return folds;
      };
      EditSession.prototype.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
      };
      EditSession.prototype.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
      };
      EditSession.prototype.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
      };
      EditSession.prototype.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
          startRow = foldLine.start.row;
        if (startColumn == null)
          startColumn = 0;
        if (endRow == null)
          endRow = foldLine.end.row;
        if (endColumn == null)
          endColumn = this.getLine(endRow).length;
        var self = this;
        var textLine = "";
        foldLine.walk(function(placeholder, row, column, lastColumn) {
          if (row < startRow)
            return;
          if (row == startRow) {
            if (column < startColumn)
              return;
            lastColumn = Math.max(startColumn, lastColumn);
          }
          if (placeholder != null) {
            textLine += placeholder;
          } else {
            textLine += self.getLine(row).substring(lastColumn, column);
          }
        }, endRow, endColumn);
        return textLine;
      };
      EditSession.prototype.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine) {
          var line;
          line = this.getLine(row);
          return line.substring(startColumn || 0, endColumn || line.length);
        } else {
          return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
        }
      };
      EditSession.prototype.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
          var folds = foldLine.folds.map(function(fold) {
            return fold.clone();
          });
          return new FoldLine_1.default(fd, folds);
        });
        return fd;
      };
      EditSession.prototype.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;
        if (range.isEmpty()) {
          var cursor = range.start;
          fold = this.getFoldAt(cursor.row, cursor.column);
          if (fold) {
            this.expandFold(fold);
            return;
          } else if (bracketPos = this.findMatchingBracket(cursor)) {
            if (range.comparePoint(bracketPos) == 1) {
              range.end = bracketPos;
            } else {
              range.start = bracketPos;
              range.start.column++;
              range.end.column--;
            }
          } else if (bracketPos = this.findMatchingBracket({
            row: cursor.row,
            column: cursor.column + 1
          })) {
            if (range.comparePoint(bracketPos) === 1)
              range.end = bracketPos;
            else
              range.start = bracketPos;
            range.start.column++;
          } else {
            range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
          }
        } else {
          var folds = this.getFoldsInRange(range);
          if (tryToUnfold && folds.length) {
            this.expandFolds(folds);
            return;
          } else if (folds.length == 1) {
            fold = folds[0];
          }
        }
        if (!fold)
          fold = this.getFoldAt(range.start.row, range.start.column);
        if (fold && fold.range.toString() == range.toString()) {
          this.expandFold(fold);
          return;
        }
        var placeholder = "...";
        if (!range.isMultiLine()) {
          placeholder = this.getTextRange(range);
          if (placeholder.length < 4)
            return;
          placeholder = placeholder.trim().substring(0, 2) + "..";
        }
        this.addFold(placeholder, range);
      };
      EditSession.prototype.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator_1.default(this, row, column);
        var token = iterator.getCurrentToken();
        if (token && /^comment|string/.test(token.type)) {
          var range = new Range_1.default(0, 0, 0, 0);
          var re = new RegExp(token.type.replace(/\..*/, "\\."));
          if (dir != 1) {
            do {
              token = iterator.stepBackward();
            } while (token && re.test(token.type));
            iterator.stepForward();
          }
          range.start.row = iterator.getCurrentTokenRow();
          range.start.column = iterator.getCurrentTokenColumn() + 2;
          iterator = new TokenIterator_1.default(this, row, column);
          if (dir != -1) {
            do {
              token = iterator.stepForward();
            } while (token && re.test(token.type));
            token = iterator.stepBackward();
          } else
            token = iterator.getCurrentToken();
          range.end.row = iterator.getCurrentTokenRow();
          range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
          return range;
        }
      };
      EditSession.prototype.foldAll = function(startRow, endRow, depth) {
        if (depth === void 0) {
          depth = 100000;
        }
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets) {
          return;
        }
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
          if (foldWidgets[row] == null)
            foldWidgets[row] = this.getFoldWidget(row);
          if (foldWidgets[row] != "start")
            continue;
          var range = this.getFoldWidgetRange(row);
          if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
            row = range.end.row;
            try {
              var fold = this.addFold("...", range);
              if (fold)
                fold.collapseChildren = depth;
            } catch (e) {}
          }
        }
      };
      EditSession.prototype.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
          throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        if (this.$foldStyle === style)
          return;
        this.$foldStyle = style;
        if (style === "manual")
          this.unfold();
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
      };
      EditSession.prototype.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
          return;
        this.$foldMode = foldMode;
        this.eventBus.off('change', this.$updateFoldWidgets);
        this.eventBus._emit("changeAnnotation");
        if (!foldMode || this.$foldStyle === "manual") {
          this.foldWidgets = null;
          return;
        }
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.eventBus.on('change', this.$updateFoldWidgets);
      };
      EditSession.prototype.getParentFoldRangeData = function(row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent && fw[row])) {
          return {};
        }
        var i = row - 1;
        var firstRange;
        while (i >= 0) {
          var c = fw[i];
          if (c == null)
            c = fw[i] = this.getFoldWidget(i);
          if (c == "start") {
            var range = this.getFoldWidgetRange(i);
            if (!firstRange)
              firstRange = range;
            if (range && range.end.row >= row)
              break;
          }
          i--;
        }
        return {
          range: i !== -1 && range,
          firstRange: firstRange
        };
      };
      EditSession.prototype.onFoldWidgetClick = function(row, e) {
        e = e.domEvent;
        var options = {
          children: e.shiftKey,
          all: e.ctrlKey || e.metaKey,
          siblings: e.altKey
        };
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
          var el = (e.target || e.srcElement);
          if (el && /ace_fold-widget/.test(el.className))
            el.className += " ace_invalid";
        }
      };
      EditSession.prototype.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
          return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);
        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
        if (fold) {
          if (options.children || options.all)
            this.removeFold(fold);
          else
            this.expandFold(fold);
          return;
        }
        var range = this.getFoldWidgetRange(row, true);
        if (range && !range.isMultiLine()) {
          fold = this.getFoldAt(range.start.row, range.start.column, 1);
          if (fold && range.isEqual(fold.range)) {
            this.removeFold(fold);
            return;
          }
        }
        if (options.siblings) {
          var data = this.getParentFoldRangeData(row);
          if (data.range) {
            var startRow = data.range.start.row + 1;
            var endRow = data.range.end.row;
          }
          this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        } else if (options.children) {
          endRow = range ? range.end.row : this.getLength();
          this.foldAll(row + 1, range.end.row, options.all ? 10000 : 0);
        } else if (range) {
          if (options.all) {
            range.collapseChildren = 10000;
          }
          this.addFold("...", range);
        }
        return range;
      };
      EditSession.prototype.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        if (range) {
          return;
        }
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        if (range) {
          row = range.start.row;
          var fold = this.getFoldAt(row, this.getLine(row).length, 1);
          if (fold) {
            this.removeFold(fold);
          } else {
            this.addFold("...", range);
          }
        }
      };
      EditSession.prototype.updateFoldWidgets = function(delta, editSession) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
          this.foldWidgets[firstRow] = null;
        } else if (delta.action === "remove") {
          this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
          var args = Array(len + 1);
          args.unshift(firstRow, 1);
          this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
      };
      return EditSession;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = EditSession;
    config_1.defineOptions(EditSession.prototype, "session", {
      wrap: {
        set: function(value) {
          if (!value || value == "off")
            value = false;
          else if (value == "free")
            value = true;
          else if (value == "printMargin")
            value = -1;
          else if (typeof value == "string")
            value = parseInt(value, 10) || false;
          if (this.$wrap == value)
            return;
          if (!value) {
            this.setUseWrapMode(false);
          } else {
            var col = typeof value == "number" ? value : null;
            this.setWrapLimitRange(col, col);
            this.setUseWrapMode(true);
          }
          this.$wrap = value;
        },
        get: function() {
          if (this.getUseWrapMode()) {
            if (this.$wrap == -1)
              return "printMargin";
            if (!this.getWrapLimitRange().min)
              return "free";
            return this.$wrap;
          }
          return "off";
        },
        handlesSet: true
      },
      wrapMethod: {
        set: function(val) {
          val = val == "auto" ? this.$mode.type != "text" : val != "text";
          if (val != this.$wrapAsCode) {
            this.$wrapAsCode = val;
            if (this.$useWrapMode) {
              this.$modified = true;
              this.$resetRowCache(0);
              this.$updateWrapData(0, this.getLength() - 1);
            }
          }
        },
        initialValue: "auto"
      },
      firstLineNumber: {
        set: function() {
          this._signal("changeBreakpoint");
        },
        initialValue: 1
      },
      useWorker: {
        set: function(useWorker) {
          this.$useWorker = useWorker;
          this.$stopWorker();
          if (useWorker) {
            this.$startWorker();
          }
        },
        initialValue: true
      },
      useSoftTabs: {initialValue: true},
      tabSize: {
        set: function(tabSize) {
          if (isNaN(tabSize) || this.$tabSize === tabSize)
            return;
          this.$modified = true;
          this.$rowLengthCache = [];
          this.$tabSize = tabSize;
          this._signal("changeTabSize");
        },
        initialValue: 4,
        handlesSet: true
      },
      overwrite: {
        set: function(val) {
          this._signal("changeOverwrite");
        },
        initialValue: false
      },
      newLineMode: {
        set: function(val) {
          this.doc.setNewLineMode(val);
        },
        get: function() {
          return this.doc.getNewLineMode();
        },
        handlesSet: true
      },
      mode: {
        set: function(val) {
          this.setMode(val);
        },
        get: function() {
          return this.$modeId;
        }
      }
    });
  });
  define('createEditSession', ["require", "exports", './EditSession'], function(require, exports, EditSession_1) {
    "use strict";
    function createEditSession(doc) {
      return new EditSession_1.default(doc);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createEditSession;
  });
  define('createFold', ["require", "exports", './Fold'], function(require, exports, Fold_1) {
    "use strict";
    function createFold(range, placeholder) {
      return new Fold_1.default(range, placeholder);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createFold;
  });
  define('createFoldLine', ["require", "exports", './FoldLine'], function(require, exports, FoldLine_1) {
    "use strict";
    function createFoldLine(foldData, folds) {
      return new FoldLine_1.default(foldData, folds);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createFoldLine;
  });
  define('createRange', ["require", "exports", './Range'], function(require, exports, Range_1) {
    "use strict";
    function createRange(startRow, startColumn, endRow, endColumn) {
      return new Range_1.default(startRow, startColumn, endRow, endColumn);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createRange;
  });
  define('dom/appendHTMLLinkElement', ["require", "exports", './getDocumentHead'], function(require, exports, getDocumentHead_1) {
    "use strict";
    function appendHTMLLinkElement(id, rel, type, href, doc) {
      var link = doc.createElement('link');
      link.id = id;
      link.rel = rel;
      if (typeof type === 'string') {
        link.type = type;
      }
      link.href = href;
      getDocumentHead_1.default(doc).appendChild(link);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = appendHTMLLinkElement;
  });
  define('dom/hasHTMLStyleElement', ["require", "exports"], function(require, exports) {
    "use strict";
    function hasHTMLStyleElement(id, doc) {
      var index = 0;
      var styles = doc.getElementsByTagName('style');
      if (styles) {
        while (index < styles.length) {
          if (styles[index++].id === id) {
            return true;
          }
        }
      }
      return false;
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = hasHTMLStyleElement;
  });
  define('dom/ensureHTMLStyleElement', ["require", "exports", './getDocumentHead', './hasHTMLStyleElement'], function(require, exports, getDocumentHead_1, hasHTMLStyleElement_1) {
    "use strict";
    function ensureHTMLStyleElement(cssText, id, doc) {
      if (id && hasHTMLStyleElement_1.default(id, doc)) {
        return;
      } else {
        var style = doc.createElement('style');
        style.appendChild(doc.createTextNode(cssText));
        if (id) {
          style.id = id;
        }
        getDocumentHead_1.default(doc).appendChild(style);
      }
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = ensureHTMLStyleElement;
  });
  define('dom/hasHTMLLinkElement', ["require", "exports"], function(require, exports) {
    "use strict";
    function hasHTMLLinkElement(id, doc) {
      var index = 0;
      var links = doc.getElementsByTagName('link');
      if (links) {
        while (index < links.length) {
          if (links[index++].id === id) {
            return true;
          }
        }
      }
      return false;
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = hasHTMLLinkElement;
  });
  define('layer/AbstractLayer', ["require", "exports", "../lib/dom"], function(require, exports, dom_1) {
    "use strict";
    var AbstractLayer = (function() {
      function AbstractLayer(parent, className) {
        this.element = dom_1.createElement('div');
        this.element.className = className;
        parent.appendChild(this.element);
      }
      AbstractLayer.prototype.setCssClass = function(className, include) {
        dom_1.setCssClass(this.element, className, include);
      };
      return AbstractLayer;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = AbstractLayer;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('layer/CursorLayer', ["require", "exports", "../lib/dom", './AbstractLayer'], function(require, exports, dom_1, AbstractLayer_1) {
    "use strict";
    var IE8;
    var CursorLayer = (function(_super) {
      __extends(CursorLayer, _super);
      function CursorLayer(parent) {
        _super.call(this, parent, "ace_layer ace_cursor-layer");
        this.isVisible = false;
        this.isBlinking = true;
        this.blinkInterval = 1000;
        this.smoothBlinking = false;
        this.cursors = [];
        this.$padding = 0;
        if (IE8 === void 0) {
          IE8 = "opacity" in this.element;
        }
        this.cursor = this.addCursor();
        dom_1.addCssClass(this.element, "ace_hidden-cursors");
        this.$updateCursors = this.$updateVisibility.bind(this);
      }
      CursorLayer.prototype.$updateVisibility = function(visible) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; ) {
          cursors[i].style.visibility = visible ? "" : "hidden";
        }
      };
      CursorLayer.prototype.$updateOpacity = function(opaque) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; ) {
          cursors[i].style.opacity = opaque ? "" : "0";
        }
      };
      CursorLayer.prototype.setPadding = function(padding) {
        if (typeof padding === 'number') {
          this.$padding = padding;
        } else {
          throw new TypeError("padding must be a number");
        }
      };
      CursorLayer.prototype.setSession = function(session) {
        this.session = session;
      };
      CursorLayer.prototype.setBlinking = function(blinking) {
        if (blinking !== this.isBlinking) {
          this.isBlinking = blinking;
          this.restartTimer();
        }
      };
      CursorLayer.prototype.setBlinkInterval = function(blinkInterval) {
        if (blinkInterval !== this.blinkInterval) {
          this.blinkInterval = blinkInterval;
          this.restartTimer();
        }
      };
      CursorLayer.prototype.setSmoothBlinking = function(smoothBlinking) {
        if (smoothBlinking !== this.smoothBlinking && !IE8) {
          this.smoothBlinking = smoothBlinking;
          dom_1.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
          this.$updateCursors(true);
          this.$updateCursors = (smoothBlinking ? this.$updateOpacity : this.$updateVisibility).bind(this);
          this.restartTimer();
        }
      };
      CursorLayer.prototype.addCursor = function() {
        var cursor = dom_1.createElement("div");
        cursor.className = "ace_cursor";
        this.element.appendChild(cursor);
        this.cursors.push(cursor);
        return cursor;
      };
      CursorLayer.prototype.removeCursor = function() {
        if (this.cursors.length > 1) {
          var cursor = this.cursors.pop();
          cursor.parentNode.removeChild(cursor);
          return cursor;
        }
      };
      CursorLayer.prototype.hideCursor = function() {
        this.isVisible = false;
        dom_1.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
      };
      CursorLayer.prototype.showCursor = function() {
        this.isVisible = true;
        dom_1.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
      };
      CursorLayer.prototype.restartTimer = function() {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        if (this.smoothBlinking) {
          dom_1.removeCssClass(this.element, "ace_smooth-blinking");
        }
        update(true);
        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
          return;
        if (this.smoothBlinking) {
          setTimeout(function() {
            dom_1.addCssClass(this.element, "ace_smooth-blinking");
          }.bind(this));
        }
        var blink = function() {
          this.timeoutId = setTimeout(function() {
            update(false);
          }, 0.6 * this.blinkInterval);
        }.bind(this);
        this.intervalId = setInterval(function() {
          update(true);
          blink();
        }, this.blinkInterval);
        blink();
      };
      CursorLayer.prototype.getPixelPosition = function(position, onScreen) {
        if (!this.config || !this.session) {
          return {
            left: 0,
            top: 0
          };
        }
        if (!position) {
          position = this.session.getSelection().getCursor();
        }
        var pos = this.session.documentToScreenPosition(position.row, position.column);
        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
        return {
          left: cursorLeft,
          top: cursorTop
        };
      };
      CursorLayer.prototype.update = function(config) {
        this.config = config;
        var selections = this.session.$selectionMarkers;
        var i = 0,
            cursorIndex = 0;
        if (selections === undefined || selections.length === 0) {
          selections = [{cursor: null}];
        }
        for (var i = 0,
            n = selections.length; i < n; i++) {
          var pixelPos = this.getPixelPosition(selections[i].cursor, true);
          if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
            continue;
          }
          var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
          style.left = pixelPos.left + "px";
          style.top = pixelPos.top + "px";
          style.width = config.characterWidth + "px";
          style.height = config.lineHeight + "px";
        }
        while (this.cursors.length > cursorIndex) {
          this.removeCursor();
        }
        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);
        this.$pixelPos = pixelPos;
        this.restartTimer();
      };
      CursorLayer.prototype.$setOverwrite = function(overwrite) {
        if (overwrite !== this.overwrite) {
          this.overwrite = overwrite;
          if (overwrite)
            dom_1.addCssClass(this.element, "ace_overwrite-cursors");
          else
            dom_1.removeCssClass(this.element, "ace_overwrite-cursors");
        }
      };
      CursorLayer.prototype.destroy = function() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
      };
      return CursorLayer;
    }(AbstractLayer_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = CursorLayer;
  });
  define('layer/FontMetrics', ["require", "exports", "../lib/dom", "../lib/lang", "../lib/useragent", "../lib/EventEmitterClass"], function(require, exports, dom_1, lang_1, useragent_1, EventEmitterClass_1) {
    "use strict";
    var CHAR_COUNT = 0;
    var FontMetrics = (function() {
      function FontMetrics(parent, pollingInterval) {
        this.$characterSize = {
          width: 0,
          height: 0
        };
        this.eventBus = new EventEmitterClass_1.default(this);
        this.el = dom_1.createElement("div");
        this.$setMeasureNodeStyles(this.el.style, true);
        this.$main = dom_1.createElement("div");
        this.$setMeasureNodeStyles(this.$main.style);
        this.$measureNode = dom_1.createElement("div");
        this.$setMeasureNodeStyles(this.$measureNode.style);
        this.el.appendChild(this.$main);
        this.el.appendChild(this.$measureNode);
        parent.appendChild(this.el);
        if (!CHAR_COUNT) {
          this.$testFractionalRect();
        }
        this.$measureNode.innerHTML = lang_1.stringRepeat("X", CHAR_COUNT);
        this.$characterSize = {
          width: 0,
          height: 0
        };
        this.checkForSizeChanges();
      }
      FontMetrics.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      FontMetrics.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      FontMetrics.prototype.$testFractionalRect = function() {
        var el = dom_1.createElement("div");
        this.$setMeasureNodeStyles(el.style);
        el.style.width = "0.2px";
        document.documentElement.appendChild(el);
        var w = el.getBoundingClientRect().width;
        if (w > 0 && w < 1) {
          CHAR_COUNT = 1;
        } else {
          CHAR_COUNT = 100;
        }
        el.parentNode.removeChild(el);
      };
      FontMetrics.prototype.$setMeasureNodeStyles = function(style, isRoot) {
        style.width = style.height = "auto";
        style.left = style.top = "-100px";
        style.visibility = "hidden";
        style.position = "fixed";
        style.whiteSpace = "pre";
        if (useragent_1.isIE < 8) {
          style["font-family"] = "inherit";
        } else {
          style.font = "inherit";
        }
        style.overflow = isRoot ? "hidden" : "visible";
      };
      FontMetrics.prototype.checkForSizeChanges = function() {
        var size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
          this.$measureNode.style.fontWeight = "bold";
          var boldSize = this.$measureSizes();
          this.$measureNode.style.fontWeight = "";
          this.$characterSize = size;
          this.charSizes = Object.create(null);
          this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
          this.eventBus._emit("changeCharacterSize", {data: size});
        }
      };
      FontMetrics.prototype.$pollSizeChanges = function() {
        if (this.$pollSizeChangesTimer) {
          return this.$pollSizeChangesTimer;
        }
        var self = this;
        return this.$pollSizeChangesTimer = setInterval(function() {
          self.checkForSizeChanges();
        }, 500);
      };
      FontMetrics.prototype.setPolling = function(val) {
        if (val) {
          this.$pollSizeChanges();
        } else {
          if (this.$pollSizeChangesTimer) {
            this.$pollSizeChangesTimer;
          }
        }
      };
      FontMetrics.prototype.$measureSizes = function() {
        if (CHAR_COUNT === 1) {
          var rect = null;
          try {
            rect = this.$measureNode.getBoundingClientRect();
          } catch (e) {
            rect = {
              width: 0,
              height: 0,
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            };
          }
          var size = {
            height: rect.height,
            width: rect.width
          };
        } else {
          var size = {
            height: this.$measureNode.clientHeight,
            width: this.$measureNode.clientWidth / CHAR_COUNT
          };
        }
        if (size.width === 0 || size.height === 0) {
          return null;
        }
        return size;
      };
      FontMetrics.prototype.$measureCharWidth = function(ch) {
        this.$main.innerHTML = lang_1.stringRepeat(ch, CHAR_COUNT);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / CHAR_COUNT;
      };
      FontMetrics.prototype.getCharacterWidth = function(ch) {
        var w = this.charSizes[ch];
        if (w === undefined) {
          this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
        }
        return w;
      };
      FontMetrics.prototype.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.el && this.el.parentNode) {
          this.el.parentNode.removeChild(this.el);
        }
      };
      return FontMetrics;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = FontMetrics;
  });
  define('lib/escapeHTML', ["require", "exports"], function(require, exports) {
    "use strict";
    function escapeHTML(str) {
      return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = escapeHTML;
    ;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('layer/GutterLayer', ["require", "exports", "../lib/dom", './AbstractLayer', "../lib/escapeHTML", "../lib/EventEmitterClass"], function(require, exports, dom_1, AbstractLayer_1, escapeHTML_1, EventEmitterClass_1) {
    "use strict";
    var GutterLayer = (function(_super) {
      __extends(GutterLayer, _super);
      function GutterLayer(parent) {
        _super.call(this, parent, "ace_layer ace_gutter-layer");
        this.gutterWidth = 0;
        this.$annotations = [];
        this.$cells = [];
        this.$fixedWidth = false;
        this.$showLineNumbers = true;
        this.$renderer = "";
        this.$showFoldWidgets = true;
        this.eventBus = new EventEmitterClass_1.default(this);
        this.setShowFoldWidgets(this.$showFoldWidgets);
        this.$updateAnnotations = this.$updateAnnotations.bind(this);
      }
      GutterLayer.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      GutterLayer.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      GutterLayer.prototype.setSession = function(session) {
        if (this.session) {
          this.session.off("change", this.$updateAnnotations);
        }
        this.session = session;
        session.on("change", this.$updateAnnotations);
      };
      GutterLayer.prototype.setAnnotations = function(annotations) {
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
          var annotation = annotations[i];
          var row = annotation.row;
          var rowInfo = this.$annotations[row];
          if (!rowInfo) {
            rowInfo = this.$annotations[row] = {text: []};
          }
          var annoText = annotation.text;
          annoText = annoText ? escapeHTML_1.default(annoText) : annotation.html || "";
          if (rowInfo.text.indexOf(annoText) === -1)
            rowInfo.text.push(annoText);
          var type = annotation.type;
          if (type === "error")
            rowInfo.className = " ace_error";
          else if (type === "warning" && rowInfo.className != " ace_error")
            rowInfo.className = " ace_warning";
          else if (type === "info" && (!rowInfo.className))
            rowInfo.className = " ace_info";
        }
      };
      GutterLayer.prototype.$updateAnnotations = function(delta, session) {
        if (!this.$annotations.length) {
          return;
        }
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {} else if (delta.action === "remove") {
          this.$annotations.splice(firstRow, len + 1, null);
        } else {
          var args = new Array(len + 1);
          args.unshift(firstRow, 1);
          this.$annotations.splice.apply(this.$annotations, args);
        }
      };
      GutterLayer.prototype.update = function(config) {
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset, session.getLength() - 1);
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var foldWidgets = this.$showFoldWidgets && session['foldWidgets'];
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var firstLineNumber = session['$firstLineNumber'];
        var lastLineNumber = 0;
        var gutterRenderer = session['gutterRenderer'] || this.$renderer;
        var cell = null;
        var index = -1;
        var row = firstRow;
        while (true) {
          if (row > foldStart) {
            row = fold.end.row + 1;
            fold = session.getNextFoldLine(row, fold);
            foldStart = fold ? fold.start.row : Infinity;
          }
          if (row > lastRow) {
            while (this.$cells.length > index + 1) {
              cell = this.$cells.pop();
              this.element.removeChild(cell.element);
            }
            break;
          }
          cell = this.$cells[++index];
          if (!cell) {
            cell = {
              element: null,
              textNode: null,
              foldWidget: null
            };
            cell.element = dom_1.createElement("div");
            cell.textNode = document.createTextNode('');
            cell.element.appendChild(cell.textNode);
            this.element.appendChild(cell.element);
            this.$cells[index] = cell;
          }
          var className = "ace_gutter-cell ";
          if (breakpoints[row])
            className += breakpoints[row];
          if (decorations[row])
            className += decorations[row];
          if (this.$annotations[row])
            className += this.$annotations[row].className;
          if (cell.element.className != className)
            cell.element.className = className;
          var height = session.getRowLength(row) * config.lineHeight + "px";
          if (height != cell.element.style.height)
            cell.element.style.height = height;
          if (foldWidgets) {
            var c = foldWidgets[row];
            if (c == null)
              c = foldWidgets[row] = session.getFoldWidget(row);
          }
          if (c) {
            if (!cell.foldWidget) {
              cell.foldWidget = dom_1.createElement("span");
              cell.element.appendChild(cell.foldWidget);
            }
            var className = "ace_fold-widget ace_" + c;
            if (c == "start" && row == foldStart && row < fold.end.row)
              className += " ace_closed";
            else
              className += " ace_open";
            if (cell.foldWidget.className != className)
              cell.foldWidget.className = className;
            var height = config.lineHeight + "px";
            if (cell.foldWidget.style.height != height)
              cell.foldWidget.style.height = height;
          } else {
            if (cell.foldWidget) {
              cell.element.removeChild(cell.foldWidget);
              cell.foldWidget = null;
            }
          }
          var text = lastLineNumber = gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber;
          if (text != cell.textNode.data)
            cell.textNode.data = text;
          row++;
        }
        this.element.style.height = config.minHeight + "px";
        if (this.$fixedWidth || session.$useWrapMode)
          lastLineNumber = session.getLength() + firstLineNumber;
        var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineNumber, config) : lastLineNumber.toString().length * config.characterWidth;
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
          this.gutterWidth = gutterWidth;
          this.element.style.width = Math.ceil(this.gutterWidth) + "px";
          this.eventBus._emit("changeGutterWidth", gutterWidth);
        }
      };
      GutterLayer.prototype.setShowLineNumbers = function(show) {
        this.$renderer = !show && {
          getWidth: function() {
            return "";
          },
          getText: function() {
            return "";
          }
        };
      };
      GutterLayer.prototype.getShowLineNumbers = function() {
        return this.$showLineNumbers;
      };
      GutterLayer.prototype.setShowFoldWidgets = function(show) {
        if (show)
          dom_1.addCssClass(this.element, "ace_folding-enabled");
        else
          dom_1.removeCssClass(this.element, "ace_folding-enabled");
        this.$showFoldWidgets = show;
        this.$padding = null;
      };
      GutterLayer.prototype.getShowFoldWidgets = function() {
        return this.$showFoldWidgets;
      };
      GutterLayer.prototype.$computePadding = function() {
        if (!this.element.firstChild) {
          return {
            left: 0,
            right: 0
          };
        }
        var style = window.getComputedStyle(this.element.firstChild);
        this.$padding = {};
        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
        this.$padding.right = parseInt(style.paddingRight) || 0;
        return this.$padding;
      };
      GutterLayer.prototype.getRegion = function(point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.clientX < padding.left + rect.left) {
          return "markers";
        }
        if (this.$showFoldWidgets && point.clientX > rect.right - padding.right) {
          return "foldWidgets";
        }
      };
      return GutterLayer;
    }(AbstractLayer_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = GutterLayer;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('layer/MarkerLayer', ["require", "exports", './AbstractLayer', "../Range"], function(require, exports, AbstractLayer_1, Range_1) {
    "use strict";
    var MarkerLayer = (function(_super) {
      __extends(MarkerLayer, _super);
      function MarkerLayer(parent) {
        _super.call(this, parent, "ace_layer ace_marker-layer");
        this.$padding = 0;
      }
      MarkerLayer.prototype.setPadding = function(padding) {
        this.$padding = padding;
      };
      MarkerLayer.prototype.setSession = function(session) {
        this.session = session;
      };
      MarkerLayer.prototype.setMarkers = function(markers) {
        this.markers = markers;
      };
      MarkerLayer.prototype.update = function(config) {
        var config = config || this.config;
        if (!config) {
          return;
        }
        this.config = config;
        var html = [];
        for (var id in this.markers) {
          var marker = this.markers[id];
          if (!marker.range) {
            marker.update(html, this, this.session, config);
            continue;
          }
          if (typeof marker.range.start.row !== 'number') {
            throw new TypeError();
          }
          if (typeof marker.range.start.column !== 'number') {
            throw new TypeError();
          }
          if (typeof marker.range.end.row !== 'number') {
            throw new TypeError();
          }
          if (typeof marker.range.end.row !== 'number') {
            throw new TypeError();
          }
          var range = marker.range.clipRows(config.firstRow, config.lastRow);
          if (range.isEmpty())
            continue;
          range = this.session.documentToScreenRange(range);
          if (marker.renderer) {
            var top = this.$getTop(range.start.row, config);
            var left = this.$padding + range.start.column * config.characterWidth;
            marker.renderer(html, range, left, top, config);
          } else if (marker.type === "fullLine") {
            this.drawFullLineMarker(html, range, marker.clazz, config);
          } else if (marker.type === "screenLine") {
            this.drawScreenLineMarker(html, range, marker.clazz, config);
          } else if (range.isMultiLine()) {
            if (marker.type === "text")
              this.drawTextMarker(html, range, marker.clazz, config);
            else
              this.drawMultiLineMarker(html, range, marker.clazz, config);
          } else {
            this.drawSingleLineMarker(html, range, marker.clazz + " ace_start ace_br15", config);
          }
        }
        this.element.innerHTML = html.join("");
      };
      MarkerLayer.prototype.$getTop = function(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
      };
      MarkerLayer.prototype.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
        function getBorderClass(tl, tr, br, bl) {
          return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
        }
        var session = this.session;
        var start = range.start.row;
        var end = range.end.row;
        var row = start;
        var prev = 0;
        var curr = 0;
        var next = session.getScreenLastRowColumn(row);
        var lineRange = new Range_1.default(row, range.start.column, row, curr);
        for (; row <= end; row++) {
          lineRange.start.row = lineRange.end.row = row;
          lineRange.start.column = row === start ? range.start.column : session.getRowWrapIndent(row);
          lineRange.end.column = next;
          prev = curr;
          curr = next;
          next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row === end ? 0 : range.end.column;
          this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row === start ? " ace_start" : "") + " ace_br" + getBorderClass(row === start || row === start + 1 && range.start.column !== 0, prev < curr, curr > next, row === end), layerConfig, row == end ? 0 : 1, extraStyle);
        }
      };
      MarkerLayer.prototype.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || "";
        stringBuilder.push("<div class='", clazz, " ace_br1 ace_start' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", left, "px;", extraStyle, "'></div>");
        top = this.$getTop(range.end.row, config);
        var width = range.end.column * config.characterWidth;
        stringBuilder.push("<div class='", clazz, " ace_br12' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height < 0) {
          return;
        }
        top = this.$getTop(range.start.row + 1, config);
        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
        stringBuilder.push("<div class='", clazz, (radiusClass ? " ace_br" + radiusClass : ""), "' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
      };
      MarkerLayer.prototype.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;
        stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", left, "px;", extraStyle || "", "'></div>");
      };
      MarkerLayer.prototype.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row !== range.end.row) {
          height += this.$getTop(range.end.row, config) - top;
        }
        stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
      };
      MarkerLayer.prototype.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
      };
      return MarkerLayer;
    }(AbstractLayer_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = MarkerLayer;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('layer/TextLayer', ["require", "exports", "../lib/dom", "../lib/lang", './AbstractLayer', "../lib/EventEmitterClass"], function(require, exports, dom_1, lang_1, AbstractLayer_1, EventEmitterClass_1) {
    "use strict";
    var TextLayer = (function(_super) {
      __extends(TextLayer, _super);
      function TextLayer(parent) {
        _super.call(this, parent, "ace_layer ace_text-layer");
        this.$padding = 0;
        this.EOF_CHAR = "\xB6";
        this.EOL_CHAR_LF = "\xAC";
        this.EOL_CHAR_CRLF = "\xa4";
        this.TAB_CHAR = "\u2192";
        this.SPACE_CHAR = "\xB7";
        this.showInvisibles = false;
        this.displayIndentGuides = true;
        this.$tabStrings = [];
        this.$textToken = {
          "text": true,
          "rparen": true,
          "lparen": true
        };
        this.eventBus = new EventEmitterClass_1.default(this);
        this.EOL_CHAR = this.EOL_CHAR_LF;
      }
      TextLayer.prototype.updateEolChar = function() {
        var EOL_CHAR = this.session.doc.getNewLineCharacter() === "\n" ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
          this.EOL_CHAR = EOL_CHAR;
          return true;
        } else {
          return false;
        }
      };
      TextLayer.prototype.setPadding = function(padding) {
        this.$padding = padding;
        this.element.style.padding = "0 " + padding + "px";
      };
      TextLayer.prototype.getLineHeight = function() {
        return this.$fontMetrics.$characterSize.height || 0;
      };
      TextLayer.prototype.getCharacterWidth = function() {
        return this.$fontMetrics.$characterSize.width || 0;
      };
      TextLayer.prototype.$setFontMetrics = function(measure) {
        var _this = this;
        this.$fontMetrics = measure;
        this.$fontMetrics.on("changeCharacterSize", function(e) {
          _this.eventBus._signal("changeCharacterSize", e);
        });
        this.$pollSizeChanges();
      };
      TextLayer.prototype.checkForSizeChanges = function() {
        this.$fontMetrics.checkForSizeChanges();
      };
      TextLayer.prototype.$pollSizeChanges = function() {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
      };
      TextLayer.prototype.setSession = function(session) {
        this.session = session;
        this.$computeTabString();
      };
      TextLayer.prototype.setShowInvisibles = function(showInvisibles) {
        if (this.showInvisibles === showInvisibles) {
          return false;
        } else {
          this.showInvisibles = showInvisibles;
          this.$computeTabString();
          return true;
        }
      };
      TextLayer.prototype.setDisplayIndentGuides = function(displayIndentGuides) {
        if (this.displayIndentGuides === displayIndentGuides) {
          return false;
        } else {
          this.displayIndentGuides = displayIndentGuides;
          this.$computeTabString();
          return true;
        }
      };
      TextLayer.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      TextLayer.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      TextLayer.prototype.onChangeTabSize = function() {
        this.$computeTabString();
      };
      TextLayer.prototype.$computeTabString = function() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        var tabStr = this.$tabStrings = ["0"];
        for (var i = 1; i < tabSize + 1; i++) {
          if (this.showInvisibles) {
            tabStr.push("<span class='ace_invisible ace_invisible_tab'>" + this.TAB_CHAR + lang_1.stringRepeat("\xa0", i - 1) + "</span>");
          } else {
            tabStr.push(lang_1.stringRepeat("\xa0", i));
          }
        }
        if (this.displayIndentGuides) {
          this.$indentGuideRe = /\s\S| \t|\t |\s$/;
          var className = "ace_indent-guide";
          var spaceClass = "";
          var tabClass = "";
          if (this.showInvisibles) {
            className += " ace_invisible";
            spaceClass = " ace_invisible_space";
            tabClass = " ace_invisible_tab";
            var spaceContent = lang_1.stringRepeat(this.SPACE_CHAR, this.tabSize);
            var tabContent = this.TAB_CHAR + lang_1.stringRepeat("\xa0", this.tabSize - 1);
          } else {
            var spaceContent = lang_1.stringRepeat("\xa0", this.tabSize);
            var tabContent = spaceContent;
          }
          this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
          this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
        }
      };
      TextLayer.prototype.updateLines = function(config, firstRow, lastRow) {
        if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
          this.scrollLines(config);
        }
        this.config = config;
        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);
        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;
        for (var row = config.firstRow; row < first; row++) {
          var foldLine = this.session.getFoldLine(row);
          if (foldLine) {
            if (foldLine.containsRow(first)) {
              first = foldLine.start.row;
              break;
            } else {
              row = foldLine.end.row;
            }
          }
          lineElementsIdx++;
        }
        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (true) {
          if (row > foldStart) {
            row = foldLine.end.row + 1;
            foldLine = this.session.getNextFoldLine(row, foldLine);
            foldStart = foldLine ? foldLine.start.row : Infinity;
          }
          if (row > last)
            break;
          var lineElement = lineElements[lineElementsIdx++];
          if (lineElement) {
            var html = [];
            this.$renderLine(html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false);
            lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
            lineElement.innerHTML = html.join("");
          }
          row++;
        }
      };
      TextLayer.prototype.scrollLines = function(config) {
        var oldConfig = this.config;
        this.config = config;
        if (!oldConfig || oldConfig.lastRow < config.firstRow)
          return this.update(config);
        if (config.lastRow < oldConfig.firstRow)
          return this.update(config);
        var el = this.element;
        if (oldConfig.firstRow < config.firstRow) {
          for (var row = this.session['getFoldedRowCount'](oldConfig.firstRow, config.firstRow - 1); row > 0; row--) {
            el.removeChild(el.firstChild);
          }
        }
        if (oldConfig.lastRow > config.lastRow) {
          for (var row = this.session['getFoldedRowCount'](config.lastRow + 1, oldConfig.lastRow); row > 0; row--) {
            el.removeChild(el.lastChild);
          }
        }
        if (config.firstRow < oldConfig.firstRow) {
          var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
          if (el.firstChild)
            el.insertBefore(fragment, el.firstChild);
          else
            el.appendChild(fragment);
        }
        if (config.lastRow > oldConfig.lastRow) {
          var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
          el.appendChild(fragment);
        }
      };
      TextLayer.prototype.$renderLinesFragment = function(config, firstRow, lastRow) {
        var fragment = this.element.ownerDocument.createDocumentFragment();
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (true) {
          if (row > foldStart) {
            row = foldLine.end.row + 1;
            foldLine = this.session.getNextFoldLine(row, foldLine);
            foldStart = foldLine ? foldLine.start.row : Infinity;
          }
          if (row > lastRow)
            break;
          var container = dom_1.createElement("div");
          var html = [];
          this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
          container.innerHTML = html.join("");
          if (this.$useLineGroups()) {
            container.className = 'ace_line_group';
            fragment.appendChild(container);
            container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
          } else {
            while (container.firstChild)
              fragment.appendChild(container.firstChild);
          }
          row++;
        }
        return fragment;
      };
      TextLayer.prototype.update = function(config) {
        this.config = config;
        var html = [];
        var firstRow = config.firstRow;
        var lastRow = config.lastRow;
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;
        while (true) {
          if (row > foldStart) {
            row = foldLine.end.row + 1;
            foldLine = this.session.getNextFoldLine(row, foldLine);
            foldStart = foldLine ? foldLine.start.row : Infinity;
          }
          if (row > lastRow)
            break;
          if (this.$useLineGroups())
            html.push("<div class='ace_line_group' style='height:", config.lineHeight * this.session.getRowLength(row), "px'>");
          this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
          if (this.$useLineGroups())
            html.push("</div>");
          row++;
        }
        this.element.innerHTML = html.join("");
      };
      TextLayer.prototype.$renderToken = function(stringBuilder, screenColumn, token, value) {
        var self = this;
        var replaceReg = /\t|&|<|( +)|([\x00-\x1f\x80-\xa0\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
        var replaceFunc = function(c, a, b, tabIdx, idx4) {
          if (a) {
            return self.showInvisibles ? "<span class='ace_invisible ace_invisible_space'>" + lang_1.stringRepeat(self.SPACE_CHAR, c.length) + "</span>" : lang_1.stringRepeat("\xa0", c.length);
          } else if (c == "&") {
            return "&#38;";
          } else if (c == "<") {
            return "&#60;";
          } else if (c == "\t") {
            var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
            screenColumn += tabSize - 1;
            return self.$tabStrings[tabSize];
          } else if (c == "\u3000") {
            var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
            var space = self.showInvisibles ? self.SPACE_CHAR : "";
            screenColumn += 1;
            return "<span class='" + classToUse + "' style='width:" + (self.config.characterWidth * 2) + "px'>" + space + "</span>";
          } else if (b) {
            return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
          } else {
            screenColumn += 1;
            return "<span class='ace_cjk' style='width:" + (self.config.characterWidth * 2) + "px'>" + c + "</span>";
          }
        };
        var output = value.replace(replaceReg, replaceFunc);
        if (!this.$textToken[token.type]) {
          var classes = "ace_" + token.type.replace(/\./g, " ace_");
          var style = "";
          if (token.type == "fold")
            style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
          stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
        } else {
          stringBuilder.push(output);
        }
        return screenColumn + value.length;
      };
      TextLayer.prototype.renderIndentGuide = function(stringBuilder, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
          return value;
        if (value[0] === " ") {
          cols -= cols % this.tabSize;
          stringBuilder.push(lang_1.stringRepeat(this.$tabStrings[" "], cols / this.tabSize));
          return value.substr(cols);
        } else if (value[0] == "\t") {
          stringBuilder.push(lang_1.stringRepeat(this.$tabStrings["\t"], cols));
          return value.substr(cols);
        }
        return value;
      };
      TextLayer.prototype.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          var value = token.value;
          if (i == 0 && this.displayIndentGuides) {
            chars = value.length;
            value = this.renderIndentGuide(stringBuilder, value, splitChars);
            if (!value)
              continue;
            chars -= value.length;
          }
          if (chars + value.length < splitChars) {
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
            chars += value.length;
          } else {
            while (chars + value.length >= splitChars) {
              screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value.substring(0, splitChars - chars));
              value = value.substring(splitChars - chars);
              chars = splitChars;
              if (!onlyContents) {
                stringBuilder.push("</div>", "<div class='ace_line' style='height:", this.config.lineHeight, "px'>");
              }
              split++;
              screenColumn = 0;
              splitChars = splits[split] || Number.MAX_VALUE;
            }
            if (value.length != 0) {
              chars += value.length;
              screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
            }
          }
        }
      };
      TextLayer.prototype.$renderSimpleLine = function(stringBuilder, tokens) {
        var screenColumn = 0;
        var token = tokens[0];
        var value = token.value;
        if (this.displayIndentGuides)
          value = this.renderIndentGuide(stringBuilder, value);
        if (value)
          screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        for (var i = 1; i < tokens.length; i++) {
          token = tokens[i];
          value = token.value;
          screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        }
      };
      TextLayer.prototype.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
        if (!foldLine && foldLine != false) {
          foldLine = this.session.getFoldLine(row);
        }
        if (foldLine)
          var tokens = this.$getFoldLineTokens(row, foldLine);
        else
          var tokens = this.session.getTokens(row);
        if (!onlyContents) {
          stringBuilder.push("<div class='ace_line' style='height:", this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)), "px'>");
        }
        if (tokens && tokens.length) {
          var splits = this.session.getRowSplitData(row);
          if (splits && splits.length)
            this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
          else
            this.$renderSimpleLine(stringBuilder, tokens);
        }
        if (this.showInvisibles) {
          if (foldLine)
            row = foldLine.end.row;
          stringBuilder.push("<span class='ace_invisible ace_invisible_eol'>", row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, "</span>");
        }
        if (!onlyContents)
          stringBuilder.push("</div>");
      };
      TextLayer.prototype.$getFoldLineTokens = function(row, foldLine) {
        var session = this.session;
        var renderTokens = [];
        function addTokens(tokens, from, to) {
          var idx = 0,
              col = 0;
          while ((col + tokens[idx].value.length) < from) {
            col += tokens[idx].value.length;
            idx++;
            if (idx == tokens.length)
              return;
          }
          if (col != from) {
            var value = tokens[idx].value.substring(from - col);
            if (value.length > (to - from))
              value = value.substring(0, to - from);
            renderTokens.push({
              type: tokens[idx].type,
              value: value
            });
            col = from + value.length;
            idx += 1;
          }
          while (col < to && idx < tokens.length) {
            var value = tokens[idx].value;
            if (value.length + col > to) {
              renderTokens.push({
                type: tokens[idx].type,
                value: value.substring(0, to - col)
              });
            } else
              renderTokens.push(tokens[idx]);
            col += value.length;
            idx += 1;
          }
        }
        var tokens = session.getTokens(row);
        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
          if (placeholder != null) {
            renderTokens.push({
              type: "fold",
              value: placeholder
            });
          } else {
            if (isNewRow)
              tokens = session.getTokens(row);
            if (tokens.length)
              addTokens(tokens, lastColumn, column);
          }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
        return renderTokens;
      };
      TextLayer.prototype.$useLineGroups = function() {
        return this.session.getUseWrapMode();
      };
      TextLayer.prototype.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$measureNode) {
          this.$measureNode.parentNode.removeChild(this.$measureNode);
        }
        delete this.$measureNode;
      };
      return TextLayer;
    }(AbstractLayer_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = TextLayer;
  });
  define('ScrollBar', ["require", "exports", "./lib/dom", "./lib/event", "./lib/EventEmitterClass"], function(require, exports, dom_1, event_1, EventEmitterClass_1) {
    "use strict";
    var ScrollBar = (function() {
      function ScrollBar(parent, classSuffix) {
        this.eventBus = new EventEmitterClass_1.default(this);
        this.element = dom_1.createElement("div");
        this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
        this.inner = dom_1.createElement("div");
        this.inner.className = "ace_scrollbar-inner";
        this.element.appendChild(this.inner);
        parent.appendChild(this.element);
        this.setVisible(false);
        this.skipEvent = false;
        event_1.addListener(this.element, "mousedown", event_1.preventDefault);
      }
      ScrollBar.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      ScrollBar.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      ScrollBar.prototype.setVisible = function(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        return this;
      };
      return ScrollBar;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = ScrollBar;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('VScrollBar', ["require", "exports", "./lib/event", './ScrollBar', "./lib/dom"], function(require, exports, event_1, ScrollBar_1, dom_1) {
    "use strict";
    var VScrollBar = (function(_super) {
      __extends(VScrollBar, _super);
      function VScrollBar(parent, renderer) {
        _super.call(this, parent, '-v');
        this._scrollTop = 0;
        renderer.$scrollbarWidth = this._width = dom_1.scrollbarWidth(parent.ownerDocument);
        this.inner.style.width = this.element.style.width = (this._width || 15) + 5 + "px";
        event_1.addListener(this.element, "scroll", this.onScroll.bind(this));
      }
      VScrollBar.prototype.onScroll = function() {
        if (!this.skipEvent) {
          this._scrollTop = this.element.scrollTop;
          this.eventBus._emit("scroll", {data: this._scrollTop});
        }
        this.skipEvent = false;
      };
      Object.defineProperty(VScrollBar.prototype, "width", {
        get: function() {
          return this.isVisible ? this._width : 0;
        },
        enumerable: true,
        configurable: true
      });
      VScrollBar.prototype.setHeight = function(height) {
        this.element.style.height = height + "px";
      };
      VScrollBar.prototype.setInnerHeight = function(height) {
        this.inner.style.height = height + "px";
      };
      VScrollBar.prototype.setScrollHeight = function(height) {
        this.inner.style.height = height + "px";
      };
      VScrollBar.prototype.setScrollTop = function(scrollTop) {
        if (this._scrollTop != scrollTop) {
          this.skipEvent = true;
          this._scrollTop = this.element.scrollTop = scrollTop;
        }
      };
      Object.defineProperty(VScrollBar.prototype, "scrollTop", {
        get: function() {
          return this._scrollTop;
        },
        enumerable: true,
        configurable: true
      });
      return VScrollBar;
    }(ScrollBar_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = VScrollBar;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('HScrollBar', ["require", "exports", "./lib/event", './ScrollBar'], function(require, exports, event_1, ScrollBar_1) {
    "use strict";
    var HScrollBar = (function(_super) {
      __extends(HScrollBar, _super);
      function HScrollBar(parent, renderer) {
        _super.call(this, parent, '-h');
        this._scrollLeft = 0;
        this._height = renderer.$scrollbarWidth;
        this.inner.style.height = this.element.style.height = (this._height || 15) + 5 + "px";
        event_1.addListener(this.element, "scroll", this.onScroll.bind(this));
      }
      HScrollBar.prototype.onScroll = function() {
        if (!this.skipEvent) {
          this._scrollLeft = this.element.scrollLeft;
          this.eventBus._emit("scroll", {data: this._scrollLeft});
        }
        this.skipEvent = false;
      };
      Object.defineProperty(HScrollBar.prototype, "height", {
        get: function() {
          return this.isVisible ? this._height : 0;
        },
        enumerable: true,
        configurable: true
      });
      HScrollBar.prototype.setWidth = function(width) {
        this.element.style.width = width + "px";
      };
      HScrollBar.prototype.setInnerWidth = function(width) {
        this.inner.style.width = width + "px";
      };
      HScrollBar.prototype.setScrollWidth = function(width) {
        this.inner.style.width = width + "px";
      };
      HScrollBar.prototype.setScrollLeft = function(scrollLeft) {
        if (this._scrollLeft != scrollLeft) {
          this.skipEvent = true;
          this._scrollLeft = this.element.scrollLeft = scrollLeft;
        }
      };
      return HScrollBar;
    }(ScrollBar_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = HScrollBar;
  });
  define('RenderLoop', ["require", "exports", './lib/event'], function(require, exports, event_1) {
    "use strict";
    var RenderLoop = (function() {
      function RenderLoop(onRender, $window) {
        if ($window === void 0) {
          $window = window;
        }
        this.pending = false;
        this.changes = 0;
        this.onRender = onRender;
        this.$window = $window;
      }
      RenderLoop.prototype.schedule = function(change) {
        this.changes = this.changes | change;
        if (!this.pending && this.changes) {
          this.pending = true;
          var self = this;
          event_1.requestAnimationFrame(function() {
            self.pending = false;
            var changes;
            while (changes = self.changes) {
              self.changes = 0;
              self.onRender(changes);
            }
          }, this.$window);
        }
      };
      return RenderLoop;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = RenderLoop;
  });
  define('Renderer', ["require", "exports", "./lib/dom", './dom/appendHTMLLinkElement', './dom/ensureHTMLStyleElement', './dom/hasHTMLLinkElement', "./config", "./lib/useragent", "./layer/CursorLayer", "./layer/FontMetrics", "./layer/GutterLayer", "./layer/MarkerLayer", "./layer/TextLayer", "./VScrollBar", "./HScrollBar", "./RenderLoop", "./lib/EventEmitterClass"], function(require, exports, dom_1, appendHTMLLinkElement_1, ensureHTMLStyleElement_1, hasHTMLLinkElement_1, config_1, useragent_1, CursorLayer_1, FontMetrics_1, GutterLayer_1, MarkerLayer_1, TextLayer_1, VScrollBar_1, HScrollBar_1, RenderLoop_1, EventEmitterClass_1) {
    "use strict";
    var CHANGE_CURSOR = 1;
    var CHANGE_MARKER = 2;
    var CHANGE_GUTTER = 4;
    var CHANGE_SCROLL = 8;
    var CHANGE_LINES = 16;
    var CHANGE_TEXT = 32;
    var CHANGE_SIZE = 64;
    var CHANGE_MARKER_BACK = 128;
    var CHANGE_MARKER_FRONT = 256;
    var CHANGE_FULL = 512;
    var CHANGE_H_SCROLL = 1024;
    var Renderer = (function() {
      function Renderer(container) {
        var _this = this;
        this.scrollLeft = 0;
        this.scrollTop = 0;
        this.layerConfig = {
          width: 1,
          padding: 0,
          firstRow: 0,
          firstRowScreen: 0,
          lastRow: 0,
          lineHeight: 0,
          characterWidth: 0,
          minHeight: 1,
          maxHeight: 1,
          offset: 0,
          height: 1,
          gutterOffset: 1
        };
        this.$padding = 0;
        this.$frozen = false;
        this.STEPS = 8;
        this.scrollMargin = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          v: 0,
          h: 0
        };
        this.$changes = 0;
        this.eventBus = new EventEmitterClass_1.default(this);
        this.container = container || dom_1.createElement("div");
        this.$keepTextAreaAtCursor = !useragent_1.isOldIE;
        dom_1.addCssClass(this.container, "ace_editor");
        this.$gutter = dom_1.createElement("div");
        this.$gutter.className = "ace_gutter";
        this.container.appendChild(this.$gutter);
        this.scroller = dom_1.createElement("div");
        this.scroller.className = "ace_scroller";
        this.container.appendChild(this.scroller);
        this.content = dom_1.createElement("div");
        this.content.className = "ace_content";
        this.scroller.appendChild(this.content);
        this.$gutterLayer = new GutterLayer_1.default(this.$gutter);
        this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
        this.$markerBack = new MarkerLayer_1.default(this.content);
        var textLayer = this.$textLayer = new TextLayer_1.default(this.content);
        this.canvas = textLayer.element;
        this.$markerFront = new MarkerLayer_1.default(this.content);
        this.$cursorLayer = new CursorLayer_1.default(this.content);
        this.$horizScroll = false;
        this.$vScroll = false;
        this.scrollBarV = new VScrollBar_1.default(this.container, this);
        this.scrollBarH = new HScrollBar_1.default(this.container, this);
        this.scrollBarV.on("scroll", function(event, scrollBar) {
          if (!_this.$scrollAnimation) {
            _this.session.setScrollTop(event.data - _this.scrollMargin.top);
          }
        });
        this.scrollBarH.on("scroll", function(event, scrollBar) {
          if (!_this.$scrollAnimation) {
            _this.session.setScrollLeft(event.data - _this.scrollMargin.left);
          }
        });
        this.cursorPos = {
          row: 0,
          column: 0
        };
        this.$fontMetrics = new FontMetrics_1.default(this.container, 500);
        this.$textLayer.$setFontMetrics(this.$fontMetrics);
        this.$textLayer.on("changeCharacterSize", function(event, text) {
          _this.updateCharacterSize();
          _this.onResize(true, _this.gutterWidth, _this.$size.width, _this.$size.height);
          _this.eventBus._signal("changeCharacterSize", event);
        });
        this.$size = {
          width: 0,
          height: 0,
          scrollerHeight: 0,
          scrollerWidth: 0,
          $dirty: true
        };
        this.$loop = new RenderLoop_1.default(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
        this.$loop.schedule(CHANGE_FULL);
        this.updateCharacterSize();
        this.setPadding(4);
        config_1.resetOptions(this);
      }
      Renderer.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      Renderer.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      Object.defineProperty(Renderer.prototype, "maxLines", {
        set: function(maxLines) {
          this.$maxLines = maxLines;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Renderer.prototype, "keepTextAreaAtCursor", {
        set: function(keepTextAreaAtCursor) {
          this.$keepTextAreaAtCursor = keepTextAreaAtCursor;
        },
        enumerable: true,
        configurable: true
      });
      Renderer.prototype.setDefaultCursorStyle = function() {
        this.content.style.cursor = "default";
      };
      Renderer.prototype.setCursorLayerOff = function() {
        var noop = function() {};
        this.$cursorLayer.restartTimer = noop;
        this.$cursorLayer.element.style.opacity = "0";
      };
      Renderer.prototype.updateCharacterSize = function() {
        if (this.$textLayer['allowBoldFonts'] !== this.$allowBoldFonts) {
          this.$allowBoldFonts = this.$textLayer['allowBoldFonts'];
          this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }
        this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
      };
      Renderer.prototype.setSession = function(session) {
        if (this.session) {
          this.session.doc.removeChangeNewLineModeListener(this.onChangeNewLineMode);
        }
        this.session = session;
        if (!session) {
          return;
        }
        if (this.scrollMargin.top && session.getScrollTop() <= 0) {
          session.setScrollTop(-this.scrollMargin.top);
        }
        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        this.$loop.schedule(CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);
        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode();
        this.session.doc.addChangeNewLineModeListener(this.onChangeNewLineMode);
      };
      Renderer.prototype.updateLines = function(firstRow, lastRow, force) {
        if (lastRow === undefined) {
          lastRow = Infinity;
        }
        if (!this.$changedLines) {
          this.$changedLines = {
            firstRow: firstRow,
            lastRow: lastRow
          };
        } else {
          if (this.$changedLines.firstRow > firstRow) {
            this.$changedLines.firstRow = firstRow;
          }
          if (this.$changedLines.lastRow < lastRow) {
            this.$changedLines.lastRow = lastRow;
          }
        }
        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
          if (force) {
            this.$changedLines.lastRow = this.layerConfig.lastRow;
          } else {
            return;
          }
        }
        if (this.$changedLines.firstRow > this.layerConfig.lastRow) {
          return;
        }
        this.$loop.schedule(CHANGE_LINES);
      };
      Renderer.prototype.onChangeNewLineMode = function() {
        this.$loop.schedule(CHANGE_TEXT);
        this.$textLayer.updateEolChar();
      };
      Renderer.prototype.onChangeTabSize = function() {
        if (this.$loop) {
          if (this.$loop.schedule) {
            this.$loop.schedule(CHANGE_TEXT | CHANGE_MARKER);
          }
        }
        if (this.$textLayer) {
          if (this.$textLayer.onChangeTabSize) {
            this.$textLayer.onChangeTabSize();
          }
        }
      };
      Renderer.prototype.updateText = function() {
        this.$loop.schedule(CHANGE_TEXT);
      };
      Renderer.prototype.updateFull = function(force) {
        if (force)
          this.$renderChanges(CHANGE_FULL, true);
        else
          this.$loop.schedule(CHANGE_FULL);
      };
      Renderer.prototype.updateFontSize = function() {
        this.$textLayer.checkForSizeChanges();
      };
      Renderer.prototype.$updateSizeAsync = function() {
        if (this.$loop.pending) {
          this.$size.$dirty = true;
        } else {
          this.onResize();
        }
      };
      Renderer.prototype.onResize = function(force, gutterWidth, width, height) {
        if (this.resizing > 2)
          return;
        else if (this.resizing > 0)
          this.resizing++;
        else
          this.resizing = force ? 1 : 0;
        var el = this.container;
        if (!height)
          height = el.clientHeight || el.scrollHeight;
        if (!width)
          width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);
        if (!this.$size.scrollerHeight || (!width && !height))
          return this.resizing = 0;
        if (force)
          this.$gutterLayer.$padding = null;
        if (force)
          this.$renderChanges(changes | this.$changes, true);
        else
          this.$loop.schedule(changes | this.$changes);
        if (this.resizing)
          this.resizing = 0;
      };
      Renderer.prototype.$updateCachedSize = function(force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
          width: size.width,
          height: size.height,
          scrollerHeight: size.scrollerHeight,
          scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height !== height)) {
          size.height = height;
          changes |= CHANGE_SIZE;
          size.scrollerHeight = size.height;
          if (this.$horizScroll)
            size.scrollerHeight -= this.scrollBarH.height;
          this.scrollBarV.element.style.bottom = this.scrollBarH.height + "px";
          changes = changes | CHANGE_SCROLL;
        }
        if (width && (force || size.width !== width)) {
          changes |= CHANGE_SIZE;
          size.width = width;
          if (gutterWidth == null)
            gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
          this.gutterWidth = gutterWidth;
          this.scrollBarH.element.style.left = this.scroller.style.left = gutterWidth + "px";
          size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.width);
          this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.width + "px";
          this.scroller.style.bottom = this.scrollBarH.height + "px";
          if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
            changes |= CHANGE_FULL;
        }
        size.$dirty = !width || !height;
        if (changes) {
          this.eventBus._signal("resize", oldSize);
        }
        return changes;
      };
      Renderer.prototype.onGutterResize = function() {
        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
        if (gutterWidth !== this.gutterWidth)
          this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
          this.$loop.schedule(CHANGE_FULL);
        } else if (this.$size.$dirty) {
          this.$loop.schedule(CHANGE_FULL);
        } else {
          this.$computeLayerConfig();
          this.$loop.schedule(CHANGE_MARKER);
        }
      };
      Renderer.prototype.adjustWrapLimit = function() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
      };
      Renderer.prototype.setAnimatedScroll = function(animatedScroll) {
        this.setOption("animatedScroll", animatedScroll);
      };
      Renderer.prototype.getAnimatedScroll = function() {
        return this.$animatedScroll;
      };
      Renderer.prototype.setShowInvisibles = function(showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
      };
      Renderer.prototype.getShowInvisibles = function() {
        return this.getOption("showInvisibles");
      };
      Renderer.prototype.getDisplayIndentGuides = function() {
        return this.getOption("displayIndentGuides");
      };
      Renderer.prototype.setDisplayIndentGuides = function(displayIndentGuides) {
        this.setOption("displayIndentGuides", displayIndentGuides);
      };
      Renderer.prototype.setShowPrintMargin = function(showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
      };
      Renderer.prototype.getShowPrintMargin = function() {
        return this.getOption("showPrintMargin");
      };
      Renderer.prototype.setPrintMarginColumn = function(printMarginColumn) {
        this.setOption("printMarginColumn", printMarginColumn);
      };
      Renderer.prototype.getPrintMarginColumn = function() {
        return this.getOption("printMarginColumn");
      };
      Renderer.prototype.getShowGutter = function() {
        return this.getOption("showGutter");
      };
      Renderer.prototype.setShowGutter = function(showGutter) {
        return this.setOption("showGutter", showGutter);
      };
      Renderer.prototype.getFadeFoldWidgets = function() {
        return this.getOption("fadeFoldWidgets");
      };
      Renderer.prototype.setFadeFoldWidgets = function(fadeFoldWidgets) {
        this.setOption("fadeFoldWidgets", fadeFoldWidgets);
      };
      Renderer.prototype.setHighlightGutterLine = function(highlightGutterLine) {
        this.setOption("highlightGutterLine", highlightGutterLine);
      };
      Renderer.prototype.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
      };
      Renderer.prototype.getPixelPosition = function(position, onScreen) {
        return this.$cursorLayer.getPixelPosition(position, onScreen);
      };
      Renderer.prototype.$updateGutterLineHighlight = function() {
        var pos = this.$cursorLayer.$pixelPos;
        var height = this.layerConfig.lineHeight;
        if (this.session.getUseWrapMode()) {
          var cursor = this.session.getSelection().getCursor();
          cursor.column = 0;
          pos = this.getPixelPosition(cursor, true);
          height *= this.session.getRowLength(cursor.row);
        }
        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
        this.$gutterLineHighlight.style.height = height + "px";
      };
      Renderer.prototype.$updatePrintMargin = function() {
        if (!this.$showPrintMargin && !this.$printMarginEl)
          return;
        if (!this.$printMarginEl) {
          var containerEl = dom_1.createElement("div");
          containerEl.className = "ace_layer ace_print-margin-layer";
          this.$printMarginEl = dom_1.createElement("div");
          this.$printMarginEl.className = "ace_print-margin";
          containerEl.appendChild(this.$printMarginEl);
          this.content.insertBefore(containerEl, this.content.firstChild);
        }
        var style = this.$printMarginEl.style;
        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
        if (this.session && this.session['$wrap'] === -1)
          this.adjustWrapLimit();
      };
      Renderer.prototype.getContainerElement = function() {
        return this.container;
      };
      Renderer.prototype.getMouseEventTarget = function() {
        return this.content;
      };
      Renderer.prototype.getTextAreaContainer = function() {
        return this.container;
      };
      Renderer.prototype.$moveTextAreaToCursor = function() {
        if (!this.$keepTextAreaAtCursor) {
          return;
        }
        var config = this.layerConfig;
        if (!this.$cursorLayer.$pixelPos) {
          console.warn("moveTextAreaToCursor bypassed because cursor layer is not working.");
          return;
        }
        var posTop = this.$cursorLayer.$pixelPos.top;
        var posLeft = this.$cursorLayer.$pixelPos.left;
        posTop -= config.offset;
        var h = this.lineHeight;
        if (posTop < 0 || posTop > config.height - h)
          return;
        var w = this.characterWidth;
        if (this.$composition) {
          var val = this.textarea.value.replace(/^\x01+/, "");
          w *= (this.session.$getStringScreenWidth(val)[0] + 2);
          h += 2;
          posTop -= 1;
        }
        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w)
          posLeft = this.$size.scrollerWidth - w;
        posLeft -= this.scrollBarV.width;
        this.textarea.style.height = h + "px";
        this.textarea.style.width = w + "px";
        this.textarea.style.right = Math.max(0, this.$size.scrollerWidth - posLeft - w) + "px";
        this.textarea.style.bottom = Math.max(0, this.$size.height - posTop - h) + "px";
      };
      Renderer.prototype.getFirstVisibleRow = function() {
        return this.layerConfig.firstRow;
      };
      Renderer.prototype.getFirstFullyVisibleRow = function() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
      };
      Renderer.prototype.getLastFullyVisibleRow = function() {
        var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);
        return this.layerConfig.firstRow - 1 + flint;
      };
      Renderer.prototype.getLastVisibleRow = function() {
        return this.layerConfig.lastRow;
      };
      Renderer.prototype.getPadding = function() {
        return this.$padding;
      };
      Renderer.prototype.setPadding = function(padding) {
        if (typeof padding !== 'number') {
          throw new TypeError("padding must be a number");
        }
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(CHANGE_FULL);
        this.$updatePrintMargin();
      };
      Renderer.prototype.setScrollMargin = function(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top | 0;
        sm.bottom = bottom | 0;
        sm.right = right | 0;
        sm.left = left | 0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
          this.session.setScrollTop(-sm.top);
        this.updateFull();
      };
      Renderer.prototype.getHScrollBarAlwaysVisible = function() {
        return this.$hScrollBarAlwaysVisible;
      };
      Renderer.prototype.setHScrollBarAlwaysVisible = function(hScrollBarAlwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", hScrollBarAlwaysVisible);
      };
      Renderer.prototype.getVScrollBarAlwaysVisible = function() {
        return this.$vScrollBarAlwaysVisible;
      };
      Renderer.prototype.setVScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
      };
      Renderer.prototype.$updateScrollBarV = function() {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines && this.$scrollPastEnd) {
          scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
          if (this.scrollTop > scrollHeight - scrollerHeight) {
            scrollHeight = this.scrollTop + scrollerHeight;
            this.scrollBarV.scrollTop = null;
          }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
      };
      Renderer.prototype.$updateScrollBarH = function() {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
      };
      Renderer.prototype.freeze = function() {
        this.$frozen = true;
      };
      Renderer.prototype.unfreeze = function() {
        this.$frozen = false;
      };
      Renderer.prototype.$renderChanges = function(changes, force) {
        if (this.$changes) {
          changes |= this.$changes;
          this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
          this.$changes |= changes;
          return;
        }
        if (this.$size.$dirty) {
          this.$changes |= changes;
          return this.onResize(true);
        }
        if (!this.lineHeight) {
          this.$textLayer.checkForSizeChanges();
        }
        this.eventBus._signal("beforeRender");
        var config = this.layerConfig;
        if (changes & CHANGE_FULL || changes & CHANGE_SIZE || changes & CHANGE_TEXT || changes & CHANGE_LINES || changes & CHANGE_SCROLL || changes & CHANGE_H_SCROLL) {
          changes |= this.$computeLayerConfig();
          if (config.firstRow !== this.layerConfig.firstRow && config.firstRowScreen === this.layerConfig.firstRowScreen) {
            this.scrollTop = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
            changes = changes | CHANGE_SCROLL;
            changes |= this.$computeLayerConfig();
          }
          config = this.layerConfig;
          this.$updateScrollBarV();
          if (changes & CHANGE_H_SCROLL)
            this.$updateScrollBarH();
          this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
          this.content.style.marginTop = (-config.offset) + "px";
          this.content.style.width = config.width + 2 * this.$padding + "px";
          this.content.style.height = config.minHeight + "px";
        }
        if (changes & CHANGE_H_SCROLL) {
          this.content.style.marginLeft = -this.scrollLeft + "px";
          this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
        }
        if (changes & CHANGE_FULL) {
          this.$textLayer.update(config);
          if (this.$showGutter) {
            this.$gutterLayer.update(config);
          }
          this.$markerBack.update(config);
          this.$markerFront.update(config);
          this.$cursorLayer.update(config);
          this.$moveTextAreaToCursor();
          if (this.$highlightGutterLine) {
            this.$updateGutterLineHighlight();
          }
          this.eventBus._signal("afterRender");
          return;
        }
        if (changes & CHANGE_SCROLL) {
          if (changes & CHANGE_TEXT || changes & CHANGE_LINES)
            this.$textLayer.update(config);
          else
            this.$textLayer.scrollLines(config);
          if (this.$showGutter)
            this.$gutterLayer.update(config);
          this.$markerBack.update(config);
          this.$markerFront.update(config);
          this.$cursorLayer.update(config);
          if (this.$highlightGutterLine) {
            this.$updateGutterLineHighlight();
          }
          this.$moveTextAreaToCursor();
          this.eventBus._signal("afterRender");
          return;
        }
        if (changes & CHANGE_TEXT) {
          this.$textLayer.update(config);
          if (this.$showGutter)
            this.$gutterLayer.update(config);
        } else if (changes & CHANGE_LINES) {
          if (this.$updateLines() || (changes & CHANGE_GUTTER) && this.$showGutter)
            this.$gutterLayer.update(config);
        } else if (changes & CHANGE_TEXT || changes & CHANGE_GUTTER) {
          if (this.$showGutter)
            this.$gutterLayer.update(config);
        }
        if (changes & CHANGE_CURSOR) {
          this.$cursorLayer.update(config);
          this.$moveTextAreaToCursor();
          if (this.$highlightGutterLine) {
            this.$updateGutterLineHighlight();
          }
        }
        if (changes & (CHANGE_MARKER | CHANGE_MARKER_FRONT)) {
          this.$markerFront.update(config);
        }
        if (changes & (CHANGE_MARKER | CHANGE_MARKER_BACK)) {
          this.$markerBack.update(config);
        }
        this.eventBus._signal("afterRender");
      };
      Renderer.prototype.$autosize = function() {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.max((this.$minLines || 1) * this.lineHeight, Math.min(maxHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
        var vScroll = height > maxHeight;
        if (desiredHeight !== this.desiredHeight || this.$size.height !== this.desiredHeight || vScroll !== this.$vScroll) {
          if (vScroll !== this.$vScroll) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
          }
          var w = this.container.clientWidth;
          this.container.style.height = desiredHeight + "px";
          this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
          this.desiredHeight = desiredHeight;
        }
      };
      Renderer.prototype.$computeLayerConfig = function() {
        if (this.$maxLines && this.lineHeight > 1) {
          this.$autosize();
        }
        var session = this.session;
        var size = this.$size;
        var hideScrollbars = size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;
        var offset = this.scrollTop % this.lineHeight;
        var minHeight = size.scrollerHeight + this.lineHeight;
        var longestLine = this.$getLongestLine();
        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
          this.$horizScroll = horizScroll;
          this.scrollBarH.setVisible(horizScroll);
        }
        if (!this.$maxLines && this.$scrollPastEnd) {
          maxHeight += (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
        }
        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight < 0);
        var vScrollChanged = this.$vScroll !== vScroll;
        if (vScrollChanged) {
          this.$vScroll = vScroll;
          this.scrollBarV.setVisible(vScroll);
        }
        this.session.setScrollTop(Math.max(-this.scrollMargin.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + this.scrollMargin.bottom)));
        this.session.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + this.scrollMargin.right)));
        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;
        var firstRowScreen,
            firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
          firstRow = foldLine.start.row;
        }
        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;
        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
        offset = this.scrollTop - firstRowScreen * lineHeight;
        var changes = 0;
        if (this.layerConfig.width !== longestLine)
          changes = CHANGE_H_SCROLL;
        if (hScrollChanged || vScrollChanged) {
          changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
          this.eventBus._signal("scrollbarVisibilityChanged");
          if (vScrollChanged)
            longestLine = this.$getLongestLine();
        }
        this.layerConfig = {
          width: longestLine,
          padding: this.$padding,
          firstRow: firstRow,
          firstRowScreen: firstRowScreen,
          lastRow: lastRow,
          lineHeight: lineHeight,
          characterWidth: this.characterWidth,
          minHeight: minHeight,
          maxHeight: maxHeight,
          offset: offset,
          gutterOffset: Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
          height: this.$size.scrollerHeight
        };
        return changes;
      };
      Renderer.prototype.$updateLines = function() {
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;
        var layerConfig = this.layerConfig;
        if (firstRow > layerConfig.lastRow + 1) {
          return;
        }
        if (lastRow < layerConfig.firstRow) {
          return;
        }
        if (lastRow === Infinity) {
          if (this.$showGutter)
            this.$gutterLayer.update(layerConfig);
          this.$textLayer.update(layerConfig);
          return;
        }
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
      };
      Renderer.prototype.$getLongestLine = function() {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
          charCount += 1;
        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
      };
      Renderer.prototype.updateFrontMarkers = function() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(CHANGE_MARKER_FRONT);
      };
      Renderer.prototype.updateBackMarkers = function() {
        this.$markerBack.setMarkers(this.session.getMarkers(false));
        this.$loop.schedule(CHANGE_MARKER_BACK);
      };
      Renderer.prototype.updateBreakpoints = function() {
        this.$loop.schedule(CHANGE_GUTTER);
      };
      Renderer.prototype.setAnnotations = function(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(CHANGE_GUTTER);
      };
      Renderer.prototype.updateCursor = function() {
        this.$loop.schedule(CHANGE_CURSOR);
      };
      Renderer.prototype.hideCursor = function() {
        this.$cursorLayer.hideCursor();
      };
      Renderer.prototype.showCursor = function() {
        this.$cursorLayer.showCursor();
      };
      Renderer.prototype.scrollSelectionIntoView = function(anchor, lead, offset) {
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
      };
      Renderer.prototype.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
        if (this.$size.scrollerHeight === 0)
          return;
        var pos = this.getPixelPosition(cursor, false);
        var left = pos.left;
        var top = pos.top;
        var topMargin = $viewMargin && $viewMargin.top || 0;
        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
        if (scrollTop + topMargin > top) {
          if (offset)
            top -= offset * this.$size.scrollerHeight;
          if (top === 0)
            top = -this.scrollMargin.top;
          this.session.setScrollTop(top);
        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
          if (offset)
            top += offset * this.$size.scrollerHeight;
          this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
        }
        var scrollLeft = this.scrollLeft;
        if (scrollLeft > left) {
          if (left < this.$padding + 2 * this.layerConfig.characterWidth)
            left = -this.scrollMargin.left;
          this.session.setScrollLeft(left);
        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
          this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
          this.session.setScrollLeft(0);
        }
      };
      Renderer.prototype.getScrollTop = function() {
        return this.session.getScrollTop();
      };
      Renderer.prototype.getScrollLeft = function() {
        return this.session.getScrollLeft();
      };
      Renderer.prototype.getScrollTopRow = function() {
        return this.scrollTop / this.lineHeight;
      };
      Renderer.prototype.getScrollBottomRow = function() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
      };
      Renderer.prototype.scrollToRow = function(row) {
        this.session.setScrollTop(row * this.lineHeight);
      };
      Renderer.prototype.alignCursor = function(cursor, alignment) {
        if (typeof cursor === "number")
          cursor = {
            row: cursor,
            column: 0
          };
        var pos = this.getPixelPosition(cursor, false);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);
        this.session.setScrollTop(offset);
        return offset;
      };
      Renderer.prototype.$calcSteps = function(fromValue, toValue) {
        var i = 0;
        var l = this.STEPS;
        var steps = [];
        var func = function(t, x_min, dx) {
          return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };
        for (i = 0; i < l; ++i) {
          steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
        }
        return steps;
      };
      Renderer.prototype.scrollToLine = function(line, center, animate, callback) {
        var pos = this.getPixelPosition({
          row: line,
          column: 0
        }, false);
        var offset = pos.top;
        if (center) {
          offset -= this.$size.scrollerHeight / 2;
        }
        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false) {
          this.animateScrolling(initialScroll, callback);
        }
      };
      Renderer.prototype.animateScrolling = function(fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll) {
          return;
        }
        var _self = this;
        if (fromValue === toValue)
          return;
        if (this.$scrollAnimation) {
          var oldSteps = this.$scrollAnimation.steps;
          if (oldSteps.length) {
            fromValue = oldSteps[0];
            if (fromValue === toValue)
              return;
          }
        }
        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = {
          from: fromValue,
          to: toValue,
          steps: steps
        };
        clearInterval(this.$timer);
        _self.session.setScrollTop(steps.shift());
        _self.session.$scrollTop = toValue;
        this.$timer = setInterval(function() {
          if (steps.length) {
            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
          } else if (toValue != null) {
            _self.session.$scrollTop = -1;
            _self.session.setScrollTop(toValue);
            toValue = null;
          } else {
            _self.$timer = clearInterval(_self.$timer);
            _self.$scrollAnimation = null;
            if (callback) {
              callback();
            }
          }
        }, 10);
      };
      Renderer.prototype.scrollToY = function(scrollTop) {
        if (this.scrollTop !== scrollTop) {
          this.scrollTop = scrollTop;
          this.$loop.schedule(CHANGE_SCROLL);
        }
      };
      Renderer.prototype.scrollToX = function(scrollLeft) {
        if (this.scrollLeft !== scrollLeft) {
          this.scrollLeft = scrollLeft;
          this.$loop.schedule(CHANGE_H_SCROLL);
        }
      };
      Renderer.prototype.scrollTo = function(x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(y);
      };
      Renderer.prototype.scrollBy = function(deltaX, deltaY) {
        if (deltaY) {
          this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        }
        if (deltaX) {
          this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
        }
      };
      Renderer.prototype.isScrollableBy = function(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
          return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
          return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
          return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
          return true;
      };
      Renderer.prototype.pixelToScreenCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = Math.round(offset);
        return {
          row: row,
          column: col,
          side: offset - col > 0 ? 1 : -1
        };
      };
      Renderer.prototype.screenToTextCoordinates = function(clientX, clientY) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var column = Math.round((clientX + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth);
        var row = (clientY + this.scrollTop - canvasPos.top) / this.lineHeight;
        return this.session.screenToDocumentPosition(row, Math.max(column, 0));
      };
      Renderer.prototype.textToScreenCoordinates = function(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);
        var x = this.$padding + Math.round(pos.column * this.characterWidth);
        var y = pos.row * this.lineHeight;
        return {
          pageX: canvasPos.left + x - this.scrollLeft,
          pageY: canvasPos.top + y - this.scrollTop
        };
      };
      Renderer.prototype.visualizeFocus = function() {
        dom_1.addCssClass(this.container, "ace_focus");
      };
      Renderer.prototype.visualizeBlur = function() {
        dom_1.removeCssClass(this.container, "ace_focus");
      };
      Renderer.prototype.showComposition = function(position) {
        if (!this.$composition)
          this.$composition = {
            keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
            cssText: this.textarea.style.cssText
          };
        this.$keepTextAreaAtCursor = true;
        dom_1.addCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = "";
        this.$moveTextAreaToCursor();
      };
      Renderer.prototype.setCompositionText = function(text) {
        this.$moveTextAreaToCursor();
      };
      Renderer.prototype.hideComposition = function() {
        if (!this.$composition) {
          return;
        }
        dom_1.removeCssClass(this.textarea, "ace_composition");
        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
        this.textarea.style.cssText = this.$composition.cssText;
        this.$composition = null;
      };
      Renderer.prototype.setTheme = function(modJs) {
        if (!modJs.cssClass) {
          return;
        }
        ensureHTMLStyleElement_1.default(modJs.cssText, modJs.cssClass, this.container.ownerDocument);
        if (this.theme) {
          dom_1.removeCssClass(this.container, this.theme.cssClass);
        }
        var padding = "padding" in modJs ? modJs.padding : "padding" in (this.theme || {}) ? 4 : this.$padding;
        if (this.$padding && padding !== this.$padding) {
          this.setPadding(padding);
        }
        this.theme = modJs;
        this.addCssClass(modJs.cssClass);
        this.setCssClass("ace_dark", modJs.isDark);
        if (this.$size) {
          this.$size.width = 0;
          this.$updateSizeAsync();
        }
        this.eventBus._emit('themeLoaded', {theme: modJs});
      };
      Renderer.prototype.addCssClass = function(cssClass) {
        dom_1.addCssClass(this.container, cssClass);
      };
      Renderer.prototype.setCssClass = function(className, include) {
        dom_1.setCssClass(this.container, className, include);
      };
      Renderer.prototype.setThemeCss = function(themeId, href) {
        if (href) {
          if (!hasHTMLLinkElement_1.default(themeId, this.container.ownerDocument)) {
            appendHTMLLinkElement_1.default(themeId, 'stylesheet', 'text/css', href, this.container.ownerDocument);
          }
        }
        this.addCssClass(themeId);
        this.themeId = themeId;
      };
      Renderer.prototype.setThemeDark = function(isDark) {
        this.setCssClass("ace_dark", isDark);
      };
      Renderer.prototype.getTheme = function() {
        return this.themeId;
      };
      Renderer.prototype.setStyle = function(style, include) {
        dom_1.setCssClass(this.container, style, include !== false);
      };
      Renderer.prototype.unsetStyle = function(style) {
        dom_1.removeCssClass(this.container, style);
      };
      Renderer.prototype.setCursorStyle = function(style) {
        if (this.content.style.cursor !== style) {
          this.content.style.cursor = style;
        }
      };
      Renderer.prototype.setMouseCursor = function(cursorStyle) {
        this.content.style.cursor = cursorStyle;
      };
      Renderer.prototype.destroy = function() {
        this.$textLayer.destroy();
        this.$cursorLayer.destroy();
      };
      return Renderer;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Renderer;
    config_1.defineOptions(Renderer.prototype, "renderer", {
      animatedScroll: {initialValue: false},
      showInvisibles: {
        set: function(value) {
          if (this.$textLayer.setShowInvisibles(value))
            this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
      },
      showPrintMargin: {
        set: function() {
          this.$updatePrintMargin();
        },
        initialValue: true
      },
      printMarginColumn: {
        set: function() {
          this.$updatePrintMargin();
        },
        initialValue: 80
      },
      printMargin: {
        set: function(value) {
          if (typeof value === "number")
            this.$printMarginColumn = value;
          this.$showPrintMargin = !!value;
          this.$updatePrintMargin();
        },
        get: function() {
          return this.$showPrintMargin && this.$printMarginColumn;
        }
      },
      showGutter: {
        set: function(show) {
          this.$gutter.style.display = show ? "block" : "none";
          this.$loop.schedule(this.CHANGE_FULL);
          this.onGutterResize();
        },
        initialValue: true
      },
      fadeFoldWidgets: {
        set: function(show) {
          dom_1.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
      },
      showFoldWidgets: {
        set: function(show) {
          this.$gutterLayer.setShowFoldWidgets(show);
        },
        initialValue: true
      },
      showLineNumbers: {
        set: function(show) {
          this.$gutterLayer.setShowLineNumbers(show);
          this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
      },
      displayIndentGuides: {
        set: function(show) {
          if (this.$textLayer.setDisplayIndentGuides(show))
            this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
      },
      highlightGutterLine: {
        set: function(shouldHighlight) {
          if (!this.$gutterLineHighlight) {
            this.$gutterLineHighlight = dom_1.createElement("div");
            this.$gutterLineHighlight.className = "ace_gutter-active-line";
            this.$gutter.appendChild(this.$gutterLineHighlight);
            return;
          }
          this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
          if (this.$cursorLayer.$pixelPos)
            this.$updateGutterLineHighlight();
        },
        initialValue: false,
        value: true
      },
      hScrollBarAlwaysVisible: {
        set: function(val) {
          if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
      },
      vScrollBarAlwaysVisible: {
        set: function(val) {
          if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
      },
      fontSize: {
        set: function(fontSize) {
          var that = this;
          that.container.style.fontSize = fontSize;
          that.updateFontSize();
        },
        initialValue: "12px"
      },
      fontFamily: {set: function(fontFamily) {
          var that = this;
          that.container.style.fontFamily = fontFamily;
          that.updateFontSize();
        }},
      maxLines: {set: function(val) {
          this.updateFull();
        }},
      minLines: {set: function(val) {
          this.updateFull();
        }},
      scrollPastEnd: {
        set: function(value) {
          value = +value || 0;
          if (this.$scrollPastEnd === value)
            return;
          this.$scrollPastEnd = value;
          this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
      },
      fixedWidthGutter: {set: function(val) {
          this.$gutterLayer.$fixedWidth = !!val;
          this.$loop.schedule(this.CHANGE_GUTTER);
        }},
      theme: {
        set: function(val) {
          this.setTheme(val);
        },
        get: function() {
          return this.themeId || this.theme;
        },
        initialValue: "./theme/textmate",
        handlesSet: true
      }
    });
  });
  define('createRenderer', ["require", "exports", './Renderer'], function(require, exports, Renderer_1) {
    "use strict";
    function createRenderer(container) {
      return new Renderer_1.default(container);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createRenderer;
  });
  define('createTokenizer', ["require", "exports", './Tokenizer'], function(require, exports, Tokenizer_1) {
    "use strict";
    function createTokenizer(rules) {
      return new Tokenizer_1.default(rules);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createTokenizer;
  });
  define('UndoManager', ["require", "exports"], function(require, exports) {
    "use strict";
    var UndoManager = (function() {
      function UndoManager() {
        this.reset();
      }
      UndoManager.prototype.execute = function(options) {
        var deltas = options.args[0];
        this._editSession = options.args[1];
        if (options.merge && this.hasUndo()) {
          this._dirtyCounter--;
          deltas = this.$undoStack.pop().concat(deltas);
        }
        this.$undoStack.push(deltas);
        this.$redoStack = [];
        if (this._dirtyCounter < 0) {
          this._dirtyCounter = NaN;
        }
        this._dirtyCounter++;
      };
      UndoManager.prototype.undo = function(dontSelect) {
        var deltas = this.$undoStack.pop();
        var undoSelectionRange = null;
        if (deltas) {
          undoSelectionRange = this._editSession.undoChanges(deltas, dontSelect);
          this.$redoStack.push(deltas);
          this._dirtyCounter--;
        }
        return undoSelectionRange;
      };
      UndoManager.prototype.redo = function(dontSelect) {
        var deltas = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltas) {
          redoSelectionRange = this._editSession.redoChanges(deltas, dontSelect);
          this.$undoStack.push(deltas);
          this._dirtyCounter++;
        }
        return redoSelectionRange;
      };
      UndoManager.prototype.reset = function() {
        this.$undoStack = [];
        this.$redoStack = [];
        this.markClean();
      };
      UndoManager.prototype.hasUndo = function() {
        return this.$undoStack.length > 0;
      };
      UndoManager.prototype.hasRedo = function() {
        return this.$redoStack.length > 0;
      };
      UndoManager.prototype.markClean = function() {
        this._dirtyCounter = 0;
      };
      UndoManager.prototype.isClean = function() {
        return this._dirtyCounter === 0;
      };
      return UndoManager;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = UndoManager;
  });
  define('createUndoManager', ["require", "exports", './UndoManager'], function(require, exports, UndoManager_1) {
    "use strict";
    function createUndoManager() {
      return new UndoManager_1.default();
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createUndoManager;
  });
  define('worker/WorkerClient', ["require", "exports", '../lib/net', '../lib/EventEmitterClass'], function(require, exports, net_1, EventEmitterClass_1) {
    "use strict";
    var WorkerClient = (function() {
      function WorkerClient(workerUrl) {
        this.callbacks = {};
        this.callbackId = 1;
        this.eventBus = new EventEmitterClass_1.default(this);
        this.sendDeltaQueue = this.sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);
        var workerUrl = net_1.qualifyURL(workerUrl);
        try {
          this.$worker = new Worker(workerUrl);
        } catch (e) {
          if (e instanceof window['DOMException']) {
            var blob = this.$workerBlob(workerUrl);
            var URL = window['URL'] || window['webkitURL'];
            var blobURL = URL.createObjectURL(blob);
            this.$worker = new Worker(blobURL);
            URL.revokeObjectURL(blobURL);
          } else {
            throw e;
          }
        }
        this.$worker.onmessage = this.onMessage;
      }
      WorkerClient.prototype.init = function(scriptImports, moduleName, className) {
        this.$worker.postMessage({
          init: true,
          scriptImports: scriptImports,
          moduleName: moduleName,
          className: className
        });
      };
      WorkerClient.prototype.onMessage = function(event) {
        var origin = event.origin;
        var source = event.source;
        var msg = event.data;
        switch (msg.type) {
          case "log":
            window.console && console.log && console.log.apply(console, msg.data);
            break;
          case "event":
            this.eventBus._signal(msg.name, {data: msg.data});
            break;
          case "call":
            var callback = this.callbacks[msg.id];
            if (callback) {
              callback(msg.data);
              delete this.callbacks[msg.id];
            }
            break;
        }
      };
      WorkerClient.prototype.$normalizePath = function(path) {
        return net_1.qualifyURL(path);
      };
      WorkerClient.prototype.terminate = function() {
        this.eventBus._signal("terminate", {});
        this.deltaQueue = void 0;
        this.$worker.terminate();
        this.$worker = void 0;
      };
      WorkerClient.prototype.send = function(cmd, args) {
        this.$worker.postMessage({
          command: cmd,
          args: args
        });
      };
      WorkerClient.prototype.call = function(cmd, args, callback) {
        if (callback) {
          var id = this.callbackId++;
          this.callbacks[id] = callback;
          args.push(id);
        }
        this.send(cmd, args);
      };
      WorkerClient.prototype.invoke = function(cmd, args) {
        var workerClient = this;
        return new Promise(function(resolve, reject) {
          workerClient.call(cmd, args, function(retval) {
            if (retval.err) {
              reject(retval.err);
            } else {
              resolve(retval.data);
            }
          });
        });
      };
      WorkerClient.prototype.emit = function(event, data) {
        try {
          if (this.$worker) {
            this.$worker.postMessage({
              event: event,
              data: {data: data.data}
            });
          }
        } catch (e) {
          console.error(e.stack);
        }
      };
      WorkerClient.prototype.attachToDocument = function(doc) {
        if (this.$doc) {
          if (this.$doc === doc) {
            return;
          } else {
            this.detachFromDocument();
          }
        }
        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.addChangeListener(this.changeListener);
      };
      WorkerClient.prototype.detachFromDocument = function() {
        if (this.$doc) {
          this.$doc.removeChangeListener(this.changeListener);
          this.$doc = null;
        }
      };
      WorkerClient.prototype.changeListener = function(delta, doc) {
        if (!this.deltaQueue) {
          this.deltaQueue = [delta];
          setTimeout(this.sendDeltaQueue, 0);
        } else {
          this.deltaQueue.push(delta);
        }
      };
      WorkerClient.prototype.on = function(eventName, callback) {
        this.eventBus.on(eventName, callback, false);
      };
      WorkerClient.prototype.off = function(eventName, callback) {
        this.eventBus.off(eventName, callback);
      };
      WorkerClient.prototype.sendDeltaQueue = function() {
        var doc = this.$doc;
        var queue = this.deltaQueue;
        if (!queue)
          return;
        this.deltaQueue = void 0;
        if (queue.length > 20 && queue.length > doc.getLength() >> 1) {
          this.call("setValue", [doc.getValue()]);
        } else {
          this.emit("change", {data: queue});
        }
      };
      WorkerClient.prototype.$workerBlob = function(workerUrl) {
        var script = "importScripts('" + net_1.qualifyURL(workerUrl) + "');";
        try {
          return new Blob([script], {"type": "application/javascript"});
        } catch (e) {
          var BlobBuilder = window['BlobBuilder'] || window['WebKitBlobBuilder'] || window['MozBlobBuilder'];
          var blobBuilder = new BlobBuilder();
          blobBuilder.append(script);
          return blobBuilder.getBlob("application/javascript");
        }
      };
      return WorkerClient;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = WorkerClient;
  });
  define('createWorkerClient', ["require", "exports", './worker/WorkerClient'], function(require, exports, WorkerClient_1) {
    "use strict";
    function createWorkerClient(workerUrl) {
      return new WorkerClient_1.default(workerUrl);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createWorkerClient;
  });
  define('CompletionList', ["require", "exports"], function(require, exports) {
    "use strict";
    var CompletionList = (function() {
      function CompletionList(all, filterText) {
        this.all = all;
        this.filtered = all;
        this.filterText = filterText || "";
      }
      CompletionList.prototype.setFilter = function(filterText) {
        var matches;
        if (filterText.length > this.filterText.length && filterText.lastIndexOf(this.filterText, 0) === 0) {
          matches = this.filtered;
        } else {
          matches = this.all;
        }
        this.filterText = filterText;
        matches = this.filterCompletions(matches, this.filterText);
        matches = matches.sort(function(a, b) {
          return b.exactMatch - a.exactMatch || b.score - a.score;
        });
        var prev = null;
        matches = matches.filter(function(item) {
          var caption = item.value || item.caption || item.snippet;
          if (caption === prev)
            return false;
          prev = caption;
          return true;
        });
        this.filtered = matches;
      };
      CompletionList.prototype.filterCompletions = function(items, needle) {
        var results = [];
        var upper = needle.toUpperCase();
        var lower = needle.toLowerCase();
        loop: for (var i = 0,
            length = items.length; i < length; i++) {
          var item = items[i];
          var caption = item.value || item.caption || item.snippet;
          if (!caption)
            continue;
          var lastIndex = -1;
          var matchMask = 0;
          var penalty = 0;
          var index;
          var distance;
          for (var j = 0; j < needle.length; j++) {
            var i1 = caption.indexOf(lower[j], lastIndex + 1);
            var i2 = caption.indexOf(upper[j], lastIndex + 1);
            index = (i1 >= 0) ? ((i2 < 0 || i1 < i2) ? i1 : i2) : i2;
            if (index < 0)
              continue loop;
            distance = index - lastIndex - 1;
            if (distance > 0) {
              if (lastIndex === -1)
                penalty += 10;
              penalty += distance;
            }
            matchMask = matchMask | (1 << index);
            lastIndex = index;
          }
          item.matchMask = matchMask;
          item.exactMatch = penalty ? 0 : 1;
          item.score = (item.score || 0) - penalty;
          results.push(item);
        }
        return results;
      };
      return CompletionList;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = CompletionList;
  });
  define('autocomplete/retrievePrecedingIdentifier', ["require", "exports"], function(require, exports) {
    'use strict';
    var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\uFFFF]/;
    function retrievePrecedingIdentifier(text, pos, regex) {
      regex = regex || ID_REGEX;
      var buf = [];
      for (var i = pos - 1; i >= 0; i--) {
        if (regex.test(text[i]))
          buf.push(text[i]);
        else
          break;
      }
      return buf.reverse().join("");
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = retrievePrecedingIdentifier;
  });
  define('autocomplete/getCompletionPrefix', ["require", "exports", './retrievePrecedingIdentifier'], function(require, exports, retrievePrecedingIdentifier_1) {
    "use strict";
    function getCompletionPrefix(editor) {
      var pos = editor.getCursorPosition();
      var line = editor.session.getLine(pos.row);
      var prefix;
      editor.completers.forEach(function(completer) {
        if (completer.identifierRegexps) {
          completer.identifierRegexps.forEach(function(identifierRegex) {
            if (!prefix && identifierRegex)
              prefix = retrievePrecedingIdentifier_1.default(line, pos.column, identifierRegex);
          });
        }
      });
      return prefix || retrievePrecedingIdentifier_1.default(line, pos.column);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = getCompletionPrefix;
  });
  define('autocomplete/ListViewPopup', ["require", "exports", '../createEditSession', "../Document", "../Renderer", "../Editor", "../Range", "../lib/event", "../lib/lang", "../lib/dom"], function(require, exports, createEditSession_1, Document_1, Renderer_1, Editor_1, Range_1, event_1, lang_1, dom_1) {
    "use strict";
    var noop = function() {};
    var ListViewPopup = (function() {
      function ListViewPopup(container) {
        var _this = this;
        this.$borderSize = 1;
        this.imageSize = 0;
        this.hoverMarker = new Range_1.default(-1, 0, -1, Infinity);
        this.selectionMarker = new Range_1.default(-1, 0, -1, Infinity);
        this.isOpen = false;
        this.isTopdown = false;
        this.data = [];
        function createEditor(el) {
          var renderer = new Renderer_1.default(el);
          renderer.content.style.cursor = "default";
          renderer.setStyle("ace_autocomplete");
          renderer.$cursorLayer.restartTimer = noop;
          renderer.$cursorLayer.element.style.opacity = "0";
          renderer.$maxLines = 8;
          renderer.$keepTextAreaAtCursor = false;
          var doc = new Document_1.default("");
          var editSession = createEditSession_1.default(doc);
          var editor = new Editor_1.default(renderer, editSession);
          editor.setHighlightActiveLine(false);
          editor.setShowPrintMargin(false);
          editor.renderer.setShowGutter(false);
          editor.renderer.setHighlightGutterLine(false);
          editor.setOption("displayIndentGuides", false);
          editor.setOption("dragDelay", 150);
          editor.focus = noop;
          editor.$isFocused = true;
          editor.setHighlightActiveLine(false);
          editor.getSession().$searchHighlight.clazz = "ace_highlight-marker";
          return editor;
        }
        var el = dom_1.createElement("div");
        this.editor = createEditor(el);
        if (container) {
          container.appendChild(el);
        }
        el.style.display = "none";
        this.editor.on("mousedown", function(e) {
          var pos = e.getDocumentPosition();
          _this.editor.selection.moveToPosition(pos);
          _this.selectionMarker.start.row = _this.selectionMarker.end.row = pos.row;
          e.stop();
        });
        this.selectionMarkerId = this.editor.getSession().addMarker(this.selectionMarker, "ace_active-line", "fullLine");
        this.setSelectOnHover(false);
        this.editor.on("mousemove", function(e) {
          if (!_this.lastMouseEvent) {
            _this.lastMouseEvent = e;
            return;
          }
          if (_this.lastMouseEvent.x === e.x && _this.lastMouseEvent.y === e.y) {
            return;
          }
          _this.lastMouseEvent = e;
          _this.lastMouseEventScrollTop = _this.editor.renderer.scrollTop;
          var row = _this.lastMouseEvent.getDocumentPosition().row;
          if (_this.hoverMarker.start.row !== row) {
            if (!_this.hoverMarkerId) {
              _this.setRow(row);
            }
            _this.setHoverMarker(row);
          }
        });
        this.editor.renderer.on("beforeRender", function() {
          if (_this.lastMouseEvent && _this.hoverMarker.start.row !== -1) {
            _this.lastMouseEvent.$pos = null;
            var row = _this.lastMouseEvent.getDocumentPosition().row;
            if (!_this.hoverMarkerId) {
              _this.setRow(row);
            }
            _this.setHoverMarker(row, true);
          }
        });
        this.editor.renderer.on("afterRender", function() {
          var row = _this.getRow();
          var t = _this.editor.renderer.$textLayer;
          var selected = t.element.childNodes[row - t.config.firstRow];
          if (selected === t.selectedNode)
            return;
          if (t.selectedNode)
            dom_1.removeCssClass(t.selectedNode, "ace_selected");
          t.selectedNode = selected;
          if (selected)
            dom_1.addCssClass(selected, "ace_selected");
        });
        var hideHoverMarker = function() {
          _this.setHoverMarker(-1);
        };
        event_1.addListener(this.editor.container, "mouseout", hideHoverMarker);
        this.editor.on("hide", hideHoverMarker);
        this.editor.on("changeSelection", hideHoverMarker);
        this.editor.getSession().doc.getLength = function() {
          return _this.data.length;
        };
        this.editor.getSession().doc.getLine = function(i) {
          var data = _this.data[i];
          return (data && data.value) || "";
        };
        var bgTokenizer = this.editor.getSession().bgTokenizer;
        bgTokenizer.tokenizeRow = function(row) {
          var data = _this.data[row];
          var tokens = [];
          if (!data)
            return tokens;
          if (!data.caption) {
            data.caption = data.value || data.name;
          }
          var last = -1;
          var flag;
          var c;
          for (var cIndex = 0,
              length = data.caption.length; cIndex < length; cIndex++) {
            c = data.caption[cIndex];
            flag = data.matchMask & (1 << cIndex) ? 1 : 0;
            if (last !== flag) {
              tokens.push({
                type: data.className || "" + (flag ? "completion-highlight" : ""),
                value: c
              });
              last = flag;
            } else {
              tokens[tokens.length - 1].value += c;
            }
          }
          if (data.meta) {
            var maxW = _this.editor.renderer.$size.scrollerWidth / _this.editor.renderer.layerConfig.characterWidth;
            if (data.meta.length + data.caption.length < maxW - 2) {
              tokens.push({
                type: "rightAlignedText",
                value: data.meta
              });
            }
          }
          return tokens;
        };
        bgTokenizer.updateOnChange = noop;
        bgTokenizer.start = noop;
        this.editor.getSession().$computeWidth = function() {
          return _this.screenWidth = 0;
        };
        this.editor.on("changeSelection", function() {
          if (this.isOpen) {
            this.setRow(this.popup.selection.lead.row);
          }
        });
      }
      ListViewPopup.prototype.show = function(pos, lineHeight, topdownOnly) {
        var el = this.editor.container;
        var screenHeight = window.innerHeight;
        var screenWidth = window.innerWidth;
        var renderer = this.editor.renderer;
        var maxH = renderer.$maxLines * lineHeight * 1.4;
        var top = pos.top + this.$borderSize;
        if (top + maxH > screenHeight - lineHeight && !topdownOnly) {
          el.style.top = "";
          el.style.bottom = screenHeight - top + "px";
          this.isTopdown = false;
        } else {
          top += lineHeight;
          el.style.top = top + "px";
          el.style.bottom = "";
          this.isTopdown = true;
        }
        el.style.display = "";
        renderer.$textLayer.checkForSizeChanges();
        var left = pos.left;
        if (left + el.offsetWidth > screenWidth) {
          left = screenWidth - el.offsetWidth;
        }
        el.style.left = left + "px";
        this.editor._signal("show");
        this.lastMouseEvent = null;
        this.isOpen = true;
      };
      ListViewPopup.prototype.hide = function() {
        this.editor.container.style.display = "none";
        this.editor._signal("hide");
        this.isOpen = false;
      };
      ListViewPopup.prototype.setData = function(items) {
        this.editor.setValue(lang_1.stringRepeat("\n", items.length), -1);
        this.data = items || [];
        this.setRow(0);
      };
      ListViewPopup.prototype.getData = function(row) {
        return this.data[row];
      };
      ListViewPopup.prototype.on = function(eventName, callback, capturing) {
        return this.editor.on(eventName, callback, capturing);
      };
      ListViewPopup.prototype.off = function(eventName, callback) {
        return this.editor.off(eventName, callback);
      };
      ListViewPopup.prototype.getTextLeftOffset = function() {
        return this.$borderSize + this.editor.renderer.getPadding() + this.imageSize;
      };
      ListViewPopup.prototype.setSelectOnHover = function(selectOnHover) {
        if (!selectOnHover) {
          this.hoverMarkerId = this.editor.getSession().addMarker(this.hoverMarker, "ace_line-hover", "fullLine");
        } else if (this.hoverMarkerId) {
          this.editor.getSession().removeMarker(this.hoverMarkerId);
          this.hoverMarkerId = null;
        }
      };
      ListViewPopup.prototype.setHoverMarker = function(row, suppressRedraw) {
        if (row !== this.hoverMarker.start.row) {
          this.hoverMarker.start.row = this.hoverMarker.end.row = row;
          if (!suppressRedraw) {
            this.editor.getSession()._emit("changeBackMarker");
          }
          this.editor._emit("changeHoverMarker");
        }
      };
      ListViewPopup.prototype.getHoveredRow = function() {
        return this.hoverMarker.start.row;
      };
      ListViewPopup.prototype.getRow = function() {
        return this.selectionMarker.start.row;
      };
      ListViewPopup.prototype.setRow = function(row) {
        row = Math.max(-1, Math.min(this.data.length, row));
        if (this.selectionMarker.start.row !== row) {
          this.editor.selection.clearSelection();
          this.selectionMarker.start.row = this.selectionMarker.end.row = row || 0;
          this.editor.getSession()._emit("changeBackMarker");
          this.editor.moveCursorTo(row || 0, 0);
          if (this.isOpen) {
            this.editor._signal("select");
          }
        }
      };
      ListViewPopup.prototype.setThemeCss = function(themeId, href) {
        this.editor.renderer.setThemeCss(themeId, href);
      };
      ListViewPopup.prototype.setThemeDark = function(isDark) {
        this.editor.renderer.setThemeDark(isDark);
      };
      ListViewPopup.prototype.setFontSize = function(fontSize) {
        this.editor.setFontSize(fontSize);
      };
      ListViewPopup.prototype.focus = function() {
        this.editor.focus();
      };
      ListViewPopup.prototype.getLength = function() {
        return this.editor.getSession().getLength();
      };
      Object.defineProperty(ListViewPopup.prototype, "container", {
        get: function() {
          return this.editor.container;
        },
        enumerable: true,
        configurable: true
      });
      return ListViewPopup;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = ListViewPopup;
  });
  define('autocomplete/CompletionManager', ["require", "exports", '../Anchor', '../CompletionList', '../lib/lang/createDelayedCall', './getCompletionPrefix', '../keyboard/KeyboardHandler', './ListViewPopup', '../Range', '../editor_protocol'], function(require, exports, Anchor_1, CompletionList_1, createDelayedCall_1, getCompletionPrefix_1, KeyboardHandler_1, ListViewPopup_1, Range_1, editor_protocol_1) {
    "use strict";
    var CompletionManager = (function() {
      function CompletionManager() {
        var _this = this;
        this.keyboardHandler = new KeyboardHandler_1.default();
        this.gatherCompletionsId = 0;
        this.autoInsert = false;
        this.autoSelect = true;
        this.exactMatch = false;
        var DETACH = function(editor) {
          _this.detach();
        };
        var DOWN = function(editor) {
          _this.down();
        };
        this.commands = {
          "Up": function(editor) {
            _this.goTo("up");
          },
          "Ctrl-Up|Ctrl-Home": function(editor) {
            _this.goTo("start");
          },
          "Ctrl-Down|Ctrl-End": function(editor) {
            _this.goTo("end");
          },
          "Space": function(editor) {
            _this.detach();
            editor.insert(" ", false);
          },
          "Return": function(editor) {
            return _this.insertMatch();
          },
          "Shift-Return": function(editor) {
            _this.insertMatch(true);
          },
          "Tab": function(editor) {
            var result = _this.insertMatch();
            if (!result && !editor.tabstopManager) {
              _this.goTo("down");
            } else
              return result;
          },
          "PageUp": function(editor) {
            _this.goTo('pageUp');
          },
          "PageDown": function(editor) {
            _this.goTo('pageDown');
          }
        };
        this.keyboardHandler.bindKey("Down", DOWN);
        this.keyboardHandler.bindKey("Esc", DETACH);
        this.keyboardHandler.bindKeys(this.commands);
        this.blurListener = function() {};
        this.blurListener = this.blurListener.bind(this);
        this.editorChangeSelectionListener = this.editorChangeSelectionListener.bind(this);
        this.mousedownListener = this.mousedownListener.bind(this);
        this.mousewheelListener = this.mousewheelListener.bind(this);
        this.changeTimer = createDelayedCall_1.default(function() {
          _this.updateCompletions(true);
        });
        this.tooltipTimer = createDelayedCall_1.default(function() {
          _this.updateDocTooltip();
        }, 50);
      }
      CompletionManager.prototype.attach = function(editor) {
        if (this.editor) {
          this.detach();
        }
        this.activated = true;
        this.editor = editor;
        if (editor.completionManager !== this) {
          if (editor.completionManager) {
            editor.completionManager.detach();
          }
          editor.completionManager = this;
        }
        editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        editor.on("changeSelection", this.editorChangeSelectionListener);
        editor.on("blur", this.blurListener);
        editor.on("mousedown", this.mousedownListener);
        editor.on("mousewheel", this.mousewheelListener);
        this.updateCompletions(false);
      };
      CompletionManager.prototype.detach = function() {
        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
        this.editor.off("changeSelection", this.editorChangeSelectionListener);
        this.editor.off("blur", this.blurListener);
        this.editor.off("mousedown", this.mousedownListener);
        this.editor.off("mousewheel", this.mousewheelListener);
        this.changeTimer.cancel();
        this.hideDocTooltip();
        this.gatherCompletionsId += 1;
        if (this.popup && this.popup.isOpen) {
          this.popup.hide();
        }
        if (this.base) {
          this.base.detach();
          this.base = null;
        }
        this.activated = false;
        this.completions = null;
      };
      CompletionManager.prototype.insertMatch = function(data) {
        if (!data) {
          data = this.popup.getData(this.popup.getRow());
        }
        if (!data) {
          return;
        }
        if (data.completer && data.completer.insertMatch) {
          data.completer.insertMatch(this.editor);
        } else {
          if (this.completions.filterText) {
            var ranges = this.editor.selection.getAllRanges();
            for (var i = 0,
                iLength = ranges.length; i < iLength; i++) {
              var range = ranges[i];
              range.start.column -= this.completions.filterText.length;
              this.editor.getSession().remove(range);
            }
          }
          if (data.snippet) {} else {
            var insertstringCommand = this.editor.commands.getCommandByName(editor_protocol_1.COMMAND_NAME_INSERT_STRING);
            this.editor.execCommand(insertstringCommand, data.value || data);
          }
        }
        this.detach();
      };
      CompletionManager.prototype.goTo = function(where) {
        var row = this.popup.getRow();
        var max = this.popup.getLength() - 1;
        switch (where) {
          case "up":
            row = row <= 0 ? max : row - 1;
            break;
          case "down":
            row = row >= max ? -1 : row + 1;
            break;
          case "start":
            row = 0;
            break;
          case "end":
            row = max;
            break;
          default:
            {}
        }
        this.popup.setRow(row);
      };
      CompletionManager.prototype.down = function() {
        var row = this.popup.getRow();
        var max = this.popup.getLength() - 1;
        row = row >= max ? -1 : row + 1;
        this.popup.setRow(row);
      };
      CompletionManager.prototype.gatherCompletions = function(editor, pos, prefix, callback) {
        var session = editor.getSession();
        this.base = new Anchor_1.default(session.doc, pos.row, pos.column - prefix.length);
        this.base.insertRight = true;
        var matches = [];
        var total = editor.completers.length;
        editor.completers.forEach(function(completer, index) {
          completer.getCompletions(editor, session, pos, prefix, function(err, results) {
            if (err) {
              callback(err);
            } else {
              if (results) {
                matches = matches.concat(results);
              }
              callback(null, {
                prefix: prefix,
                matches: matches,
                finished: (--total === 0)
              });
            }
          });
        });
        return true;
      };
      CompletionManager.prototype.updateCompletions = function(keepPopupPosition) {
        var _this = this;
        var editor = this.editor;
        var pos = editor.getCursorPosition();
        if (keepPopupPosition && this.base && this.completions) {
          var range = new Range_1.default(this.base.row, this.base.column, pos.row, pos.column);
          var prefix = editor.getSession().getTextRange(range);
          if (prefix === this.completions.filterText) {
            return;
          }
          this.completions.setFilter(prefix);
          if (!this.completions.filtered.length)
            return this.detach();
          if (this.completions.filtered.length === 1 && this.completions.filtered[0].value === prefix && !this.completions.filtered[0].snippet) {
            return this.detach();
          }
          this.openPopup(editor, prefix, keepPopupPosition);
        } else {
          var _id_1 = this.gatherCompletionsId;
          var prefix = getCompletionPrefix_1.default(editor);
          this.gatherCompletions(editor, pos, prefix, function(err, results) {
            if (err) {
              console.warn("gatherCompletions => " + err);
            } else {
              var detachIfFinished = function() {
                if (!results.finished)
                  return;
                return _this.detach();
              };
              var prefix_1 = results.prefix;
              var matches = results && results.matches;
              if (!matches || !matches.length)
                return detachIfFinished();
              if (prefix_1.indexOf(results.prefix) !== 0 || _id_1 !== _this.gatherCompletionsId) {
                return;
              }
              _this.completions = new CompletionList_1.default(matches);
              _this.completions.setFilter(prefix_1);
              var filtered = _this.completions.filtered;
              if (!filtered.length)
                return detachIfFinished();
              if (filtered.length === 1 && filtered[0].value === prefix_1 && !filtered[0].snippet)
                return detachIfFinished();
              if (_this.autoInsert && filtered.length === 1) {
                return _this.insertMatch(filtered[0]);
              }
              _this.openPopup(editor, prefix_1, keepPopupPosition);
            }
          });
        }
      };
      CompletionManager.prototype.openPopup = function(editor, prefix, keepPopupPosition) {
        var _this = this;
        if (!this.popup) {
          this.popup = new ListViewPopup_1.default(document.body || document.documentElement);
          this.popup.on("click", function(e) {
            _this.insertMatch();
            e.stop();
          });
          this.popup.focus = this.editor.focus.bind(this.editor);
          this.popup.on('show', this.tooltipTimer.bind(null, null));
          this.popup.on('select', this.tooltipTimer.bind(null, null));
          this.popup.on('changeHoverMarker', this.tooltipTimer.bind(null, null));
        }
        this.popup.setData(this.completions.filtered);
        this.popup.setRow(this.autoSelect ? 0 : -1);
        var renderer = editor.renderer;
        if (!keepPopupPosition) {
          this.popup.setThemeCss(editor.getTheme(), void 0);
          this.popup.setThemeDark(true);
          this.popup.setFontSize(editor.getFontSize());
          var lineHeight = renderer.layerConfig.lineHeight;
          var pos = renderer.getPixelPosition(this.base, true);
          pos.left -= this.popup.getTextLeftOffset();
          var rect = editor.container.getBoundingClientRect();
          pos.top += rect.top - renderer.layerConfig.offset;
          pos.left += rect.left - renderer.scrollLeft;
          pos.left += renderer.gutterWidth;
          this.popup.show(pos, lineHeight);
        } else if (keepPopupPosition && !prefix) {
          this.detach();
        }
      };
      CompletionManager.prototype.editorChangeSelectionListener = function(e) {
        var cursor = this.editor.selection.lead;
        if (cursor.row !== this.base.row || cursor.column < this.base.column) {
          this.detach();
        }
        if (this.activated) {
          this.changeTimer.schedule();
        } else {
          this.detach();
        }
      };
      CompletionManager.prototype.blurListener = function(e) {
        var el = document.activeElement;
        var textArea = this.editor.textInput.getElement();
        var fromTooltip = e.relatedTarget && e.relatedTarget === this.tooltipNode;
        var container = this.popup && this.popup.container;
        if (el !== textArea && el.parentNode !== container && !fromTooltip && el !== this.tooltipNode && e.relatedTarget !== textArea) {
          this.detach();
        }
      };
      CompletionManager.prototype.mousedownListener = function(e) {
        this.detach();
      };
      CompletionManager.prototype.mousewheelListener = function(e) {
        this.detach();
      };
      CompletionManager.prototype.cancelContextMenu = function() {
        this.editor.cancelMouseContextMenu();
      };
      CompletionManager.prototype.updateDocTooltip = function() {
        var popup = this.popup;
        var all = popup.data;
        var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);
        var doc = null;
        if (!selected || !this.editor || !this.popup.isOpen)
          return this.hideDocTooltip();
        this.editor.completers.some(function(completer) {
          if (completer.getDocTooltip) {
            doc = completer.getDocTooltip(selected);
          }
          return doc;
        });
        if (!doc)
          doc = selected;
        if (typeof doc === "string") {
          doc = {docText: doc};
        }
        if (!doc || !(doc.docHTML || doc.docText)) {
          return this.hideDocTooltip();
        }
        this.showDocTooltip(doc);
      };
      CompletionManager.prototype.showDocTooltip = function(item) {
        if (!this.tooltipNode) {
          this.tooltipNode = this.editor.container.ownerDocument.createElement('div');
          this.tooltipNode.className = "ace_tooltip ace_doc-tooltip";
          this.tooltipNode.style.margin = '0';
          this.tooltipNode.style.pointerEvents = "auto";
          this.tooltipNode.tabIndex = -1;
          this.tooltipNode.onblur = this.blurListener.bind(this);
        }
        var tooltipNode = this.tooltipNode;
        if (item.docHTML) {
          tooltipNode.innerHTML = item.docHTML;
        } else if (item.docText) {
          tooltipNode.textContent = item.docText;
        }
        if (!tooltipNode.parentNode) {
          document.body.appendChild(tooltipNode);
        }
        var popup = this.popup;
        var rect = popup.container.getBoundingClientRect();
        tooltipNode.style.top = popup.container.style.top;
        tooltipNode.style.bottom = popup.container.style.bottom;
        if (window.innerWidth - rect.right < 320) {
          tooltipNode.style.right = window.innerWidth - rect.left + "px";
          tooltipNode.style.left = "";
        } else {
          tooltipNode.style.left = (rect.right + 1) + "px";
          tooltipNode.style.right = "";
        }
        tooltipNode.style.display = "block";
      };
      CompletionManager.prototype.hideDocTooltip = function() {
        this.tooltipTimer.cancel();
        if (!this.tooltipNode)
          return;
        var el = this.tooltipNode;
        if (!this.editor.isFocused() && document.activeElement === el) {
          this.editor.focus();
        }
        this.tooltipNode = null;
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
      };
      return CompletionManager;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = CompletionManager;
  });
  define('autocomplete/AutoCompleteCommand', ["require", "exports", './CompletionManager', '../editor_protocol'], function(require, exports, CompletionManager_1, editor_protocol_1) {
    "use strict";
    var AutoCompleteCommand = (function() {
      function AutoCompleteCommand(name) {
        if (name === void 0) {
          name = editor_protocol_1.COMMAND_NAME_AUTO_COMPLETE;
        }
        this.name = name;
        this.bindKey = 'Ctrl-Space|Ctrl-Shift-Space|Alt-Space';
        this.exec = function(editor) {
          var manager = editor.completionManager;
          if (!manager) {
            manager = new CompletionManager_1.default();
            editor.completionManager = manager;
          }
          manager.autoInsert = true;
          manager.autoSelect = true;
          manager.attach(editor);
          manager.cancelContextMenu();
        };
      }
      return AutoCompleteCommand;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = AutoCompleteCommand;
  });
  define('workspace/getPosition', ["require", "exports"], function(require, exports) {
    "use strict";
    function getPosition(doc, chars) {
      var lines = doc.getAllLines();
      var count = 0;
      var row = 0;
      for (var i = 0,
          iLength = lines.length; i < iLength; i++) {
        var line = lines[i];
        if (chars < (count + (line.length + 1))) {
          return {
            column: chars - count,
            row: row
          };
        }
        count += line.length + 1;
        row += 1;
      }
      return {
        column: chars - count,
        row: row
      };
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = getPosition;
  });
  define('workspace/LanguageServiceProxy', ["require", "exports", '../worker/WorkerClient'], function(require, exports, WorkerClient_1) {
    "use strict";
    var LanguageServiceProxy = (function() {
      function LanguageServiceProxy(workerUrl) {
        var _this = this;
        this.callbacks = {};
        this.callbackId = 1;
        this.worker = new WorkerClient_1.default(workerUrl);
        this.worker.on('initAfter', function() {});
        this.worker.on('syntaxErrors', function(response) {
          var data = response.data;
          var errors = data.errors;
          var id = data.callbackId;
          var callback = _this.callbacks[id];
          delete _this.callbacks[id];
          callback(null, errors);
        });
        this.worker.on('semanticErrors', function(response) {
          var data = response.data;
          var errors = data.errors;
          var id = data.callbackId;
          var callback = _this.callbacks[id];
          delete _this.callbacks[id];
          callback(null, errors);
        });
        this.worker.on('completions', function(response) {
          var data = response.data;
          var id = data.callbackId;
          var callback = _this.callbacks[id];
          delete _this.callbacks[id];
          if ('err' in data) {
            callback(data.err);
          } else {
            callback(void 0, data.completions);
          }
        });
        this.worker.on('quickInfo', function(response) {
          var data = response.data;
          var id = data.callbackId;
          var callback = _this.callbacks[id];
          delete _this.callbacks[id];
          if ('err' in data) {
            callback(data.err);
          } else {
            callback(void 0, data.quickInfo);
          }
        });
        this.worker.on('outputFiles', function(response) {
          var data = response.data;
          var id = data.callbackId;
          var callback = _this.callbacks[id];
          delete _this.callbacks[id];
          if ('err' in data) {
            callback(data.err);
          } else {
            callback(void 0, data.outputFiles);
          }
        });
        this.worker.on('getModuleKind', function(response) {
          var data = response.data;
          var id = data.callbackId;
          var callback = _this.callbacks[id];
          delete _this.callbacks[id];
          if ('err' in data) {
            callback(data.err);
          } else {
            callback(void 0, data.moduleKind);
          }
        });
        this.worker.on('setModuleKind', function(response) {
          var data = response.data;
          var id = data.callbackId;
          var callback = _this.callbacks[id];
          delete _this.callbacks[id];
          if ('err' in data) {
            callback(data.err);
          } else {
            callback(void 0);
          }
        });
        this.worker.on('getScriptTarget', function(response) {
          var data = response.data;
          var id = data.callbackId;
          var callback = _this.callbacks[id];
          delete _this.callbacks[id];
          if ('err' in data) {
            callback(data.err);
          } else {
            callback(void 0, data.scriptTarget);
          }
        });
        this.worker.on('setScriptTarget', function(response) {
          var data = response.data;
          var id = data.callbackId;
          var callback = _this.callbacks[id];
          delete _this.callbacks[id];
          if ('err' in data) {
            callback(data.err);
          } else {
            callback(void 0);
          }
        });
      }
      LanguageServiceProxy.prototype.init = function(scriptImports) {
        this.worker.init(scriptImports, 'ace-workers.js', 'LanguageServiceWorker');
      };
      LanguageServiceProxy.prototype.terminate = function() {
        this.worker.terminate();
      };
      LanguageServiceProxy.prototype.setDefaultLibContent = function(content) {
        var message = {data: {'content': content.replace(/\r\n?/g, '\n')}};
        this.worker.emit("defaultLibContent", message);
      };
      LanguageServiceProxy.prototype.ensureScript = function(fileName, content) {
        var message = {data: {
            'fileName': fileName,
            'content': content.replace(/\r\n?/g, '\n')
          }};
        this.worker.emit("ensureScript", message);
      };
      LanguageServiceProxy.prototype.applyDelta = function(fileName, delta) {
        var message = {data: {
            'fileName': fileName,
            'delta': delta
          }};
        this.worker.emit("applyDelta", message);
      };
      LanguageServiceProxy.prototype.removeScript = function(fileName) {
        this.worker.emit("removeScript", {data: {'fileName': fileName}});
      };
      LanguageServiceProxy.prototype.getModuleKind = function(callback) {
        var callbackId = this.callbackId++;
        this.callbacks[callbackId] = callback;
        var message = {data: {callbackId: callbackId}};
        this.worker.emit("getModuleKind", message);
      };
      LanguageServiceProxy.prototype.setModuleKind = function(moduleKind, callback) {
        var callbackId = this.callbackId++;
        this.callbacks[callbackId] = callback;
        var message = {data: {
            moduleKind: moduleKind,
            callbackId: callbackId
          }};
        this.worker.emit("setModuleKind", message);
      };
      LanguageServiceProxy.prototype.getScriptTarget = function(callback) {
        var callbackId = this.callbackId++;
        this.callbacks[callbackId] = callback;
        var message = {data: {callbackId: callbackId}};
        this.worker.emit("getScriptTarget", message);
      };
      LanguageServiceProxy.prototype.setScriptTarget = function(scriptTarget, callback) {
        var callbackId = this.callbackId++;
        this.callbacks[callbackId] = callback;
        var message = {data: {
            scriptTarget: scriptTarget,
            callbackId: callbackId
          }};
        this.worker.emit("setScriptTarget", message);
      };
      LanguageServiceProxy.prototype.getSyntaxErrors = function(fileName, callback) {
        var id = this.callbackId++;
        this.callbacks[id] = callback;
        var message = {data: {
            fileName: fileName,
            callbackId: id
          }};
        this.worker.emit("getSyntaxErrors", message);
      };
      LanguageServiceProxy.prototype.getSemanticErrors = function(fileName, callback) {
        var id = this.callbackId++;
        this.callbacks[id] = callback;
        var message = {data: {
            fileName: fileName,
            callbackId: id
          }};
        this.worker.emit("getSemanticErrors", message);
      };
      LanguageServiceProxy.prototype._getCompletionsAtPosition = function(fileName, position, prefix, callback) {
        var id = this.callbackId++;
        this.callbacks[id] = callback;
        var message = {data: {
            fileName: fileName,
            position: position,
            prefix: prefix,
            callbackId: id
          }};
        this.worker.emit("getCompletionsAtPosition", message);
      };
      LanguageServiceProxy.prototype.getCompletionsAtPosition = function(fileName, position, prefix) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this._getCompletionsAtPosition(fileName, position, prefix, function(err, completions) {
            if (err) {
              reject(err);
            } else {
              resolve(completions);
            }
          });
        });
      };
      LanguageServiceProxy.prototype._getQuickInfoAtPosition = function(fileName, position, callback) {
        var id = this.callbackId++;
        this.callbacks[id] = callback;
        var message = {data: {
            fileName: fileName,
            position: position,
            callbackId: id
          }};
        this.worker.emit("getQuickInfoAtPosition", message);
      };
      LanguageServiceProxy.prototype.getQuickInfoAtPosition = function(fileName, position) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this._getQuickInfoAtPosition(fileName, position, function(err, quickInfo) {
            if (err) {
              reject(err);
            } else {
              resolve(quickInfo);
            }
          });
        });
      };
      LanguageServiceProxy.prototype.getOutputFiles = function(fileName) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var id = _this.callbackId++;
          _this.callbacks[id] = function(err, outputFiles) {
            if (err) {
              reject(err);
            } else {
              resolve(outputFiles);
            }
          };
          var message = {data: {
              fileName: fileName,
              callbackId: id
            }};
          _this.worker.emit("getOutputFiles", message);
        });
      };
      return LanguageServiceProxy;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = LanguageServiceProxy;
  });
  define('workspace/displayPartsToHtml', ["require", "exports", "../lib/escapeHTML"], function(require, exports, escapeHTML_1) {
    "use strict";
    function replaceNewLine(text) {
      return text.replace(/(?:\r\n|\r|\n)/g, '<br/>');
    }
    function displayPartsToHtml(displayParts) {
      if (displayParts) {
        return displayParts.map(function(displayPart) {
          return replaceNewLine(escapeHTML_1.default(displayPart.text));
        }).join("");
      } else {
        return "";
      }
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = displayPartsToHtml;
  });
  define('workspace/EditorPosition', ["require", "exports", '../Range', './getPosition'], function(require, exports, Range_1, getPosition_1) {
    "use strict";
    var EditorPosition = (function() {
      function EditorPosition(editor) {
        this.editor = editor;
      }
      EditorPosition.prototype.getPositionChars = function(pos) {
        var doc = this.editor.getSession().getDocument();
        return EditorPosition.getChars(doc, pos);
      };
      EditorPosition.prototype.getPositionFromChars = function(chars) {
        var doc = this.editor.getSession().getDocument();
        return getPosition_1.default(doc, chars);
      };
      EditorPosition.prototype.getCurrentPositionChars = function() {
        return this.getPositionChars(this.editor.getCursorPosition());
      };
      EditorPosition.prototype.getCurrentLeftChar = function() {
        return this.getPositionLeftChar(this.editor.getCursorPosition());
      };
      EditorPosition.prototype.getTextAtCursorPosition = function(cursor) {
        var range = new Range_1.default(cursor.row, cursor.column, cursor.row, cursor.column + 1);
        return this.editor.getSession().getDocument().getTextRange(range);
      };
      EditorPosition.prototype.getPositionLeftChar = function(cursor) {
        var range = new Range_1.default(cursor.row, cursor.column, cursor.row, cursor.column - 1);
        return this.editor.getSession().getDocument().getTextRange(range);
      };
      EditorPosition.getChars = function(doc, pos) {
        return EditorPosition.getLinesChars(doc.getLines(0, pos.row - 1)) + pos.column;
      };
      EditorPosition.getLinesChars = function(lines) {
        var count = 0;
        lines.forEach(function(line) {
          return count += line.length + 1;
        });
        return count;
      };
      EditorPosition.getPositionChars = function(editor, pos) {
        var doc = editor.getSession().getDocument();
        return EditorPosition.getChars(doc, pos);
      };
      return EditorPosition;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = EditorPosition;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('workspace/QuickInfoTooltip', ["require", "exports", './displayPartsToHtml', './EditorPosition', '../Tooltip'], function(require, exports, displayPartsToHtml_1, EditorPosition_1, Tooltip_1) {
    "use strict";
    function getDocumentPositionFromScreenOffset(editor, x, y) {
      var renderer = editor.renderer;
      var offset = (x - renderer.getPadding()) / renderer.characterWidth;
      var correction = renderer.scrollTop ? 7 : 0;
      var row = Math.floor((y + renderer.scrollTop - correction) / renderer.lineHeight);
      var col = Math.round(offset);
      return editor.getSession().screenToDocumentPosition(row, col);
    }
    var QuickInfoTooltip = (function(_super) {
      __extends(QuickInfoTooltip, _super);
      function QuickInfoTooltip(fileName, editor, workspace) {
        var _this = this;
        _super.call(this, editor.container);
        this.fileName = fileName;
        this.editor = editor;
        this.workspace = workspace;
        this.mouseHandler = function(event) {
          _this.hide();
          clearTimeout(_this.mouseMoveTimer);
          if (event.srcElement['className'] === 'ace_content') {
            _this.mouseMoveTimer = setTimeout(function() {
              var documentPosition = getDocumentPositionFromScreenOffset(_this.editor, event.offsetX, event.offsetY);
              var position = EditorPosition_1.default.getPositionChars(_this.editor, documentPosition);
              _this.workspace.getQuickInfoAtPosition(_this.fileName, position).then(function(quickInfo) {
                if (quickInfo) {
                  var tip = "<b>" + displayPartsToHtml_1.default(quickInfo.displayParts) + "</b>";
                  if (quickInfo.documentation) {
                    tip += "<br/><i>" + displayPartsToHtml_1.default(quickInfo.documentation) + "</i>";
                  }
                  if (tip.length > 0) {
                    _this.setHtml(tip);
                    _this.setPosition(event.x, event.y + 10);
                    _this.show();
                  }
                }
              }).catch(function(err) {});
            }, 800);
          }
        };
      }
      QuickInfoTooltip.prototype.init = function() {
        this.editor.container.addEventListener('mousemove', this.mouseHandler);
      };
      QuickInfoTooltip.prototype.terminate = function() {
        this.editor.container.removeEventListener('mousemove', this.mouseHandler);
      };
      return QuickInfoTooltip;
    }(Tooltip_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = QuickInfoTooltip;
  });
  define('workspace/WorkspaceCompleter', ["require", "exports", './EditorPosition'], function(require, exports, EditorPosition_1) {
    "use strict";
    var WorkspaceCompleter = (function() {
      function WorkspaceCompleter(fileName, workspace) {
        this.fileName = fileName;
        this.workspace = workspace;
      }
      WorkspaceCompleter.prototype.getCompletionsAtPosition = function(editor, position, prefix) {
        var _this = this;
        var offset = EditorPosition_1.default.getPositionChars(editor, position);
        return new Promise(function(resolve, reject) {
          _this.workspace.getCompletionsAtPosition(_this.fileName, offset, prefix).then(function(entries) {
            resolve(entries.map(function(entry) {
              return {
                caption: entry.name,
                value: entry.name,
                score: 0,
                meta: entry.kind
              };
            }));
          }).catch(function(err) {
            reject(err);
          });
        });
      };
      WorkspaceCompleter.prototype.getCompletions = function(editor, session, position, prefix, callback) {
        return this.getCompletionsAtPosition(editor, position, prefix).then(function(completions) {
          callback(void 0, completions);
        }).catch(function(err) {
          callback(err);
        });
      };
      return WorkspaceCompleter;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = WorkspaceCompleter;
  });
  define('workspace/Workspace', ["require", "exports", '../autocomplete/AutoCompleteCommand', './getPosition', './LanguageServiceProxy', './QuickInfoTooltip', '../Range', './WorkspaceCompleter', '../lib/net'], function(require, exports, AutoCompleteCommand_1, getPosition_1, LanguageServiceProxy_1, QuickInfoTooltip_1, Range_1, WorkspaceCompleter_1, net_1) {
    "use strict";
    function diagnosticToAnnotation(doc, diagnostic) {
      var minChar = diagnostic.start;
      var pos = getPosition_1.default(doc, minChar);
      return {
        row: pos.row,
        column: pos.column,
        text: diagnostic.message,
        type: 'error'
      };
    }
    var Workspace = (function() {
      function Workspace() {
        this.editors = {};
        this.quickin = {};
        this.annotationHandlers = {};
        this.changeHandlers = {};
        this.refMarkers = [];
        this.errorMarkerIds = [];
      }
      Workspace.prototype.init = function(workerUrl, scriptImports) {
        this.workerProxy = new LanguageServiceProxy_1.default(workerUrl);
        this.workerProxy.init(scriptImports);
      };
      Workspace.prototype.terminate = function() {
        this.detachEditors();
        this.workerProxy.terminate();
        this.workerProxy = void 0;
      };
      Workspace.prototype.setDefaultLibrary = function(url) {
        var _this = this;
        net_1.get(url, function(sourceCode) {
          if (_this.workerProxy) {
            _this.workerProxy.setDefaultLibContent(sourceCode);
          }
        });
      };
      Object.defineProperty(Workspace.prototype, "moduleKind", {
        get: function() {
          var _this = this;
          return new Promise(function(resolve, reject) {
            _this.getModuleKind(function(err, moduleKind) {
              if (err) {
                reject(err);
              } else {
                resolve(moduleKind);
              }
            });
          });
        },
        set: function(promise) {
          var _this = this;
          promise.then(function(moduleKind) {
            _this.setModuleKind(moduleKind, function(err) {
              if (err) {}
            });
          });
        },
        enumerable: true,
        configurable: true
      });
      Workspace.prototype.getModuleKind = function(callback) {
        if (this.workerProxy) {
          this.workerProxy.getModuleKind(callback);
        } else {
          callback(new Error("moduleKind is not available."));
        }
      };
      Workspace.prototype.setModuleKind = function(moduleKind, callback) {
        if (this.workerProxy) {
          this.workerProxy.setModuleKind(moduleKind, callback);
        } else {
          callback(new Error("moduleKind is not available."));
        }
      };
      Workspace.prototype.getScriptTarget = function(callback) {
        if (this.workerProxy) {
          this.workerProxy.getScriptTarget(callback);
        } else {
          callback(new Error("scriptTarget is not available."));
        }
      };
      Workspace.prototype.setScriptTarget = function(scriptTarget, callback) {
        if (this.workerProxy) {
          this.workerProxy.setScriptTarget(scriptTarget, callback);
        } else {
          callback(new Error("scriptTarget is not available."));
        }
      };
      Workspace.prototype.attachEditor = function(fileName, editor) {
        var _this = this;
        this.editors[fileName] = editor;
        this.workerProxy.ensureScript(fileName, editor.getValue());
        var changeHandler = function(delta, source) {
          _this.workerProxy.applyDelta(fileName, delta);
          _this.updateMarkerModels(fileName, delta);
        };
        editor.on('change', changeHandler);
        this.changeHandlers[fileName] = changeHandler;
        var annotationsHandler = function(event) {
          _this.semanticDiagnostics();
          _this.outputFiles();
        };
        editor.session.on('annotations', annotationsHandler);
        this.annotationHandlers[fileName] = annotationsHandler;
        editor.commands.addCommand(new AutoCompleteCommand_1.default());
        editor.completers.push(new WorkspaceCompleter_1.default(fileName, this));
        var quickInfo = new QuickInfoTooltip_1.default(fileName, editor, this);
        quickInfo.init();
        this.quickin[fileName] = quickInfo;
      };
      Workspace.prototype.detachEditor = function(fileName, editor) {
        if (this.editors[fileName]) {
          var quickInfo = this.quickin[fileName];
          quickInfo.terminate();
          delete this.quickin[fileName];
          var annotationHandler = this.annotationHandlers[fileName];
          editor.session.off('annotations', annotationHandler);
          delete this.annotationHandlers[fileName];
          var changeHandler = this.changeHandlers[fileName];
          editor.off('change', changeHandler);
          delete this.changeHandlers[fileName];
          this.workerProxy.removeScript(fileName);
          delete this.editors[fileName];
        }
      };
      Workspace.prototype.detachEditors = function() {
        var fileNames = Object.keys(this.editors);
        for (var i = 0,
            iLength = fileNames.length; i < iLength; i++) {
          var fileName = fileNames[i];
          var editor = this.editors[fileName];
          this.detachEditor(fileName, editor);
        }
      };
      Workspace.prototype.ensureScript = function(fileName, content) {
        return this.workerProxy.ensureScript(fileName, content);
      };
      Workspace.prototype.semanticDiagnostics = function() {
        var fileNames = Object.keys(this.editors);
        for (var i = 0; i < fileNames.length; i++) {
          var fileName = fileNames[i];
          var editor = this.editors[fileName];
          this.semanticDiagnosticsForEditor(fileName, editor);
        }
      };
      Workspace.prototype.updateEditor = function(errors, editor) {
        var _this = this;
        var session = editor.getSession();
        var doc = session.getDocument();
        var annotations = errors.map(function(error) {
          return diagnosticToAnnotation(editor.getSession().getDocument(), error);
        });
        session.setAnnotations(annotations);
        this.errorMarkerIds.forEach(function(markerId) {
          session.removeMarker(markerId);
        });
        errors.forEach(function(error) {
          var minChar = error.start;
          var limChar = minChar + error.length;
          var start = getPosition_1.default(doc, minChar);
          var end = getPosition_1.default(doc, limChar);
          var range = new Range_1.default(start.row, start.column, end.row, end.column);
          _this.errorMarkerIds.push(session.addMarker(range, "typescript-error", "text", null, true));
        });
      };
      Workspace.prototype.semanticDiagnosticsForEditor = function(fileName, editor) {
        var _this = this;
        this.workerProxy.getSyntaxErrors(fileName, function(err, syntaxErrors) {
          if (err) {
            console.warn("getSyntaxErrors(" + fileName + ") => " + err);
          } else {
            _this.updateEditor(syntaxErrors, editor);
            if (syntaxErrors.length === 0) {
              _this.workerProxy.getSemanticErrors(fileName, function(err, semanticErrors) {
                if (err) {
                  console.warn("getSemanticErrors(" + fileName + ") => " + err);
                } else {
                  _this.updateEditor(semanticErrors, editor);
                }
              });
            }
          }
        });
      };
      Workspace.prototype.outputFiles = function() {
        var fileNames = Object.keys(this.editors);
        for (var i = 0; i < fileNames.length; i++) {
          var fileName = fileNames[i];
          var editor = this.editors[fileName];
          this.outputFilesForEditor(fileName, editor);
        }
      };
      Workspace.prototype.outputFilesForEditor = function(fileName, editor) {
        var session = editor.getSession();
        this.workerProxy.getOutputFiles(fileName).then(function(outputFiles) {
          session._emit("outputFiles", {data: outputFiles});
        }).catch(function(err) {
          console.warn("getOutputFiles(" + fileName + ") => " + err);
        });
      };
      Workspace.prototype.getCompletionsAtPosition = function(fileName, position, prefix) {
        return this.workerProxy.getCompletionsAtPosition(fileName, position, prefix);
      };
      Workspace.prototype.getQuickInfoAtPosition = function(fileName, position) {
        return this.workerProxy.getQuickInfoAtPosition(fileName, position);
      };
      Workspace.prototype.removeScript = function(fileName) {
        return this.workerProxy.removeScript(fileName);
      };
      Workspace.prototype.updateMarkerModels = function(fileName, delta) {
        var editor = this.editors[fileName];
        var action = delta.action;
        var markers = editor.getSession().getMarkers(true);
        var line_count = 0;
        if (action === "insert") {
          line_count = delta.lines.length;
        } else if (action === "remove") {
          line_count = -delta.lines.length;
        } else {
          console.warn("updateMarkerModels(" + fileName + ", " + JSON.stringify(delta) + ")");
        }
        if (line_count !== 0) {
          var markerUpdate = function(markerId) {
            var marker = markers[markerId];
            var row = delta.start.row;
            if (line_count > 0) {
              row = +1;
            }
            if (marker && marker.range.start.row > row) {
              marker.range.start.row += line_count;
              marker.range.end.row += line_count;
            }
          };
          this.errorMarkerIds.forEach(markerUpdate);
          this.refMarkers.forEach(markerUpdate);
          editor.updateFrontMarkers();
        }
      };
      return Workspace;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = Workspace;
  });
  define('workspace/createWorkspace', ["require", "exports", './Workspace'], function(require, exports, Workspace_1) {
    "use strict";
    function createWorkspace() {
      return new Workspace_1.default();
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createWorkspace;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/CssHighlightRules', ["require", "exports", "./TextHighlightRules"], function(require, exports, TextHighlightRules_1) {
    "use strict";
    exports.supportType = "animation-fill-mode|alignment-adjust|alignment-baseline|animation-delay|animation-direction|animation-duration|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|animation|appearance|azimuth|backface-visibility|background-attachment|background-break|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|background|baseline-shift|binding|bleed|bookmark-label|bookmark-level|bookmark-state|bookmark-target|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|border|bottom|box-align|box-decoration-break|box-direction|box-flex-group|box-flex|box-lines|box-ordinal-group|box-orient|box-pack|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side|clear|clip|color-profile|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|crop|cue-after|cue-before|cue|cursor|direction|display|dominant-baseline|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust|drop-initial-before-align|drop-initial-size|drop-initial-value|elevation|empty-cells|fit|fit-position|float-offset|float|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|font|grid-columns|grid-rows|hanging-punctuation|height|hyphenate-after|hyphenate-before|hyphenate-character|hyphenate-lines|hyphenate-resource|hyphens|icon|image-orientation|image-rendering|image-resolution|inline-box-align|left|letter-spacing|line-height|line-stacking-ruby|line-stacking-shift|line-stacking-strategy|line-stacking|list-style-image|list-style-position|list-style-type|list-style|margin-bottom|margin-left|margin-right|margin-top|margin|mark-after|mark-before|mark|marks|marquee-direction|marquee-play-count|marquee-speed|marquee-style|max-height|max-width|min-height|min-width|move-to|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|orphans|outline-color|outline-offset|outline-style|outline-width|outline|overflow-style|overflow-x|overflow-y|overflow|padding-bottom|padding-left|padding-right|padding-top|padding|page-break-after|page-break-before|page-break-inside|page-policy|page|pause-after|pause-before|pause|perspective-origin|perspective|phonemes|pitch-range|pitch|play-during|pointer-events|position|presentation-level|punctuation-trim|quotes|rendering-intent|resize|rest-after|rest-before|rest|richness|right|rotation-point|rotation|ruby-align|ruby-overhang|ruby-position|ruby-span|size|speak-header|speak-numeral|speak-punctuation|speak|speech-rate|stress|string-set|table-layout|target-name|target-new|target-position|target|text-align-last|text-align|text-decoration|text-emphasis|text-height|text-indent|text-justify|text-outline|text-shadow|text-transform|text-wrap|top|transform-origin|transform-style|transform|transition-delay|transition-duration|transition-property|transition-timing-function|transition|unicode-bidi|vertical-align|visibility|voice-balance|voice-duration|voice-family|voice-pitch-range|voice-pitch|voice-rate|voice-stress|voice-volume|volume|white-space-collapse|white-space|widows|width|word-break|word-spacing|word-wrap|z-index";
    exports.supportFunction = "rgb|rgba|url|attr|counter|counters";
    exports.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero";
    exports.supportConstantColor = "aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow";
    exports.supportConstantFonts = "arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";
    exports.numRe = "\\-?(?:(?:[0-9]+)|(?:[0-9]*\\.[0-9]+))";
    exports.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
    exports.pseudoClasses = "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b";
    var CssHighlightRules = (function(_super) {
      __extends(CssHighlightRules, _super);
      function CssHighlightRules() {
        _super.call(this);
        var keywordMapper = this.createKeywordMapper({
          "support.function": exports.supportFunction,
          "support.constant": exports.supportConstant,
          "support.type": exports.supportType,
          "support.constant.color": exports.supportConstantColor,
          "support.constant.fonts": exports.supportConstantFonts
        }, "text", true);
        this.$rules = {
          "start": [{
            token: "comment",
            regex: "\\/\\*",
            push: "comment"
          }, {
            token: "paren.lparen",
            regex: "\\{",
            push: "ruleset"
          }, {
            token: "string",
            regex: "@.*?{",
            push: "media"
          }, {
            token: "keyword",
            regex: "#[a-z0-9-_]+"
          }, {
            token: "variable",
            regex: "\\.[a-z0-9-_]+"
          }, {
            token: "string",
            regex: ":[a-z0-9-_]+"
          }, {
            token: "constant",
            regex: "[a-z0-9-_]+"
          }, {caseInsensitive: true}],
          "media": [{
            token: "comment",
            regex: "\\/\\*",
            push: "comment"
          }, {
            token: "paren.lparen",
            regex: "\\{",
            push: "ruleset"
          }, {
            token: "string",
            regex: "\\}",
            next: "pop"
          }, {
            token: "keyword",
            regex: "#[a-z0-9-_]+"
          }, {
            token: "variable",
            regex: "\\.[a-z0-9-_]+"
          }, {
            token: "string",
            regex: ":[a-z0-9-_]+"
          }, {
            token: "constant",
            regex: "[a-z0-9-_]+"
          }, {caseInsensitive: true}],
          "comment": [{
            token: "comment",
            regex: "\\*\\/",
            next: "pop"
          }, {defaultToken: "comment"}],
          "ruleset": [{
            token: "paren.rparen",
            regex: "\\}",
            next: "pop"
          }, {
            token: "comment",
            regex: "\\/\\*",
            push: "comment"
          }, {
            token: "string",
            regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
          }, {
            token: "string",
            regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
          }, {
            token: ["constant.numeric", "keyword"],
            regex: "(" + exports.numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)"
          }, {
            token: "constant.numeric",
            regex: exports.numRe
          }, {
            token: "constant.numeric",
            regex: "#[a-f0-9]{6}"
          }, {
            token: "constant.numeric",
            regex: "#[a-f0-9]{3}"
          }, {
            token: ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
            regex: exports.pseudoElements
          }, {
            token: ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
            regex: exports.pseudoClasses
          }, {
            token: ["support.function", "string", "support.function"],
            regex: "(url\\()(.*)(\\))"
          }, {
            token: keywordMapper,
            regex: "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
          }, {caseInsensitive: true}]
        };
        this.normalizeRules();
      }
      return CssHighlightRules;
    }(TextHighlightRules_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = CssHighlightRules;
  });
  define('mode/MatchingBraceOutdent', ["require", "exports", "../Range"], function(require, exports, Range_1) {
    "use strict";
    var MatchingBraceOutdent = (function() {
      function MatchingBraceOutdent() {}
      MatchingBraceOutdent.prototype.checkOutdent = function(line, text) {
        if (!/^\s+$/.test(line)) {
          return false;
        }
        return /^\s*\}/.test(text);
      };
      MatchingBraceOutdent.prototype.autoOutdent = function(session, row) {
        var line = session.getLine(row);
        var match = line.match(/^(\s*\})/);
        if (!match)
          return 0;
        var column = match[1].length;
        var openBracePos = session.findMatchingBracket({
          row: row,
          column: column
        });
        if (!openBracePos || openBracePos.row == row)
          return 0;
        var indent = this.$getIndent(session.getLine(openBracePos.row));
        session.replace(new Range_1.default(row, 0, row, column - 1), indent);
      };
      MatchingBraceOutdent.prototype.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
      };
      return MatchingBraceOutdent;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = MatchingBraceOutdent;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/behaviour/CstyleBehaviour', ["require", "exports", "../Behaviour", "../../TokenIterator", "../../lib/lang"], function(require, exports, Behaviour_1, TokenIterator_1, lang_1) {
    "use strict";
    var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "punctuation.operator"];
    var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "punctuation.operator", "comment"];
    var context;
    var contextCache = {};
    var initContext = function(editor) {
      var id = -1;
      if (editor.multiSelect) {
        id = editor.selection['id'];
        if (contextCache.rangeCount != editor.multiSelect.rangeCount) {
          contextCache = {rangeCount: editor.multiSelect.rangeCount};
        }
      }
      if (contextCache[id]) {
        return context = contextCache[id];
      }
      context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
      };
    };
    var CstyleBehaviour = (function(_super) {
      __extends(CstyleBehaviour, _super);
      function CstyleBehaviour() {
        _super.call(this);
        this.add("braces", "insertion", function(state, action, editor, session, text) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (text === '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
              return {
                text: '{' + selected + '}',
                selection: void 0
              };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                return {
                  text: '{}',
                  selection: [1, 1]
                };
              } else {
                CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                return {
                  text: '{',
                  selection: [1, 1]
                };
              }
            }
          } else if (text === '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
              var matching = session.findOpeningBracket('}', {
                column: cursor.column + 1,
                row: cursor.row
              });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: '',
                  selection: [1, 1]
                };
              }
            }
          } else if (text === "\n" || text === "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
              closing = lang_1.stringRepeat("}", context.maybeInsertedBrackets);
              CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
              var openBracePos = session.findMatchingBracket({
                row: cursor.row,
                column: cursor.column + 1
              }, '}');
              if (!openBracePos)
                return null;
              var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
              var next_indent = this.$getIndent(line);
            } else {
              CstyleBehaviour.clearMaybeInsertedClosing();
              return;
            }
            var indent = next_indent + session.getTabString();
            return {
              text: '\n' + indent + '\n' + next_indent + closing,
              selection: [1, indent.length, 1, indent.length]
            };
          } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
          }
        });
        this.add("braces", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected === '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar === '}') {
              range.end.column++;
              return range;
            } else {
              context.maybeInsertedBrackets--;
            }
          }
        });
        this.add("parens", "insertion", function(state, action, editor, session, text) {
          if (text === '(') {
            initContext(editor);
            var selectionRange = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selectionRange);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return {
                text: '(' + selected + ')',
                selection: void 0
              };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, ")");
              return {
                text: '()',
                selection: [1, 1]
              };
            }
          } else if (text === ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === ')') {
              var matching = session.findOpeningBracket(')', {
                column: cursor.column + 1,
                row: cursor.row
              });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: '',
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("parens", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected === '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar === ')') {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("brackets", "insertion", function(state, action, editor, session, text) {
          if (text === '[') {
            initContext(editor);
            var selectionRange = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selectionRange);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return {
                text: '[' + selected + ']',
                selection: void 0
              };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, "]");
              return {
                text: '[]',
                selection: [1, 1]
              };
            }
          } else if (text === ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
              var matching = session.findOpeningBracket(']', {
                column: cursor.column + 1,
                row: cursor.row
              });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: '',
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("brackets", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected === '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar === ']') {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
          if (text === '"' || text === "'") {
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "'" && selected !== '"' && editor.getWrapBehavioursEnabled()) {
              return {
                text: quote + selected + quote,
                selection: void 0
              };
            } else {
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var leftChar = line.substring(cursor.column - 1, cursor.column);
              if (leftChar === '\\') {
                return null;
              }
              var tokens = session.getTokens(selection.start.row);
              var col = 0;
              var token;
              var quotepos = -1;
              for (var x = 0; x < tokens.length; x++) {
                token = tokens[x];
                if (token.type === "string") {
                  quotepos = -1;
                } else if (quotepos < 0) {
                  quotepos = token.value.indexOf(quote);
                }
                if ((token.value.length + col) > selection.start.column) {
                  break;
                }
                col += tokens[x].value.length;
              }
              if (!token || (quotepos < 0 && token.type !== "comment" && (token.type !== "string" || ((selection.start.column !== token.value.length + col - 1) && token.value.lastIndexOf(quote) === token.value.length - 1)))) {
                if (!CstyleBehaviour.isSaneInsertion(editor, session))
                  return;
                return {
                  text: quote + quote,
                  selection: [1, 1]
                };
              } else if (token && token.type === "string") {
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar == quote) {
                  return {
                    text: '',
                    selection: [1, 1]
                  };
                }
              }
            }
          }
        });
        this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && (selected === '"' || selected === "'")) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
              range.end.column++;
              return range;
            }
          }
        });
      }
      CstyleBehaviour.isSaneInsertion = function(editor, session) {
        var cursor = editor.getCursorPosition();
        var iterator = new TokenIterator_1.default(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
          var iterator2 = new TokenIterator_1.default(session, cursor.row, cursor.column + 1);
          if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
            return false;
          }
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
      };
      CstyleBehaviour.$matchTokenType = function(token, types) {
        if (typeof token === 'string') {
          return types.indexOf(token) > -1;
        } else {
          return types.indexOf(token.type) > -1;
        }
      };
      CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0])) {
          context.autoInsertedBrackets = 0;
        }
        context.autoInsertedRow = cursor.row;
        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
        context.autoInsertedBrackets++;
      };
      CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isMaybeInsertedClosing(cursor, line)) {
          context.maybeInsertedBrackets = 0;
        }
        context.maybeInsertedRow = cursor.row;
        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        context.maybeInsertedLineEnd = line.substr(cursor.column);
        context.maybeInsertedBrackets++;
      };
      CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
        return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
      };
      CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
        return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
      };
      CstyleBehaviour.popAutoInsertedClosing = function() {
        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
        context.autoInsertedBrackets--;
      };
      CstyleBehaviour.clearMaybeInsertedClosing = function() {
        if (context) {
          context.maybeInsertedBrackets = 0;
          context.maybeInsertedRow = -1;
        }
      };
      return CstyleBehaviour;
    }(Behaviour_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = CstyleBehaviour;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/behaviour/CssBehaviour', ["require", "exports", "./CstyleBehaviour", "../../TokenIterator"], function(require, exports, CstyleBehaviour_1, TokenIterator_1) {
    "use strict";
    var CssBehavior = (function(_super) {
      __extends(CssBehavior, _super);
      function CssBehavior() {
        _super.call(this);
        this.inherit(new CstyleBehaviour_1.default());
        this.add("colon", "insertion", function(state, action, editor, session, text) {
          if (text === ':') {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator_1.default(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
              token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
              var line = session.doc.getLine(cursor.row);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              if (rightChar === ':') {
                return {
                  text: '',
                  selection: [1, 1]
                };
              }
              if (!line.substring(cursor.column).match(/^\s*;/)) {
                return {
                  text: ':;',
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("colon", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected === ':') {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator_1.default(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
              token = iterator.stepBackward();
            }
            if (token && token.type === 'support.type') {
              var line = session.doc.getLine(range.start.row);
              var rightChar = line.substring(range.end.column, range.end.column + 1);
              if (rightChar === ';') {
                range.end.column++;
                return range;
              }
            }
          }
        });
        this.add("semicolon", "insertion", function(state, action, editor, session, text) {
          if (text === ';') {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === ';') {
              return {
                text: '',
                selection: [1, 1]
              };
            }
          }
        });
      }
      return CssBehavior;
    }(CstyleBehaviour_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = CssBehavior;
  });
  define('mode/folding/FoldMode', ["require", "exports", "../../Range"], function(require, exports, Range_1) {
    "use strict";
    var FoldMode = (function() {
      function FoldMode() {
        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
      }
      FoldMode.prototype.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line)) {
          return "start";
        }
        if (foldStyle === "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line)) {
          return "end";
        }
        return "";
      };
      FoldMode.prototype.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
      };
      FoldMode.prototype.indentationBlock = function(session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel === -1) {
          return;
        }
        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;
        while (++row < maxRow) {
          var level = session.getLine(row).search(re);
          if (level === -1) {
            continue;
          }
          if (level <= startLevel) {
            break;
          }
          endRow = row;
        }
        if (endRow > startRow) {
          var endColumn = session.getLine(endRow).length;
          return new Range_1.default(startRow, startColumn, endRow, endColumn);
        }
      };
      FoldMode.prototype.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = {
          row: row,
          column: column + 1
        };
        var end = session.findClosingBracket(bracket, start, typeRe);
        if (!end)
          return;
        var fw = session.foldWidgets[end.row];
        if (fw == null)
          fw = session.getFoldWidget(end.row);
        if (fw == "start" && end.row > start.row) {
          end.row--;
          end.column = session.getLine(end.row).length;
        }
        return Range_1.default.fromPoints(start, end);
      };
      FoldMode.prototype.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = {
          row: row,
          column: column
        };
        var start = session.findOpeningBracket(bracket, end);
        if (!start) {
          return;
        }
        start.column++;
        end.column--;
        return Range_1.default.fromPoints(start, end);
      };
      return FoldMode;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = FoldMode;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/folding/CstyleFoldMode', ["require", "exports", "../../Range", "./FoldMode"], function(require, exports, Range_1, FoldMode_1) {
    "use strict";
    var CstyleFoldMode = (function(_super) {
      __extends(CstyleFoldMode, _super);
      function CstyleFoldMode(commentRegex) {
        _super.call(this);
        this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
        this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
        if (commentRegex) {
          this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
          this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
        }
      }
      CstyleFoldMode.prototype.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        var match = line.match(this.foldingStartMarker);
        if (match) {
          var i = match.index;
          if (match[1])
            return this.openingBracketBlock(session, match[1], row, i);
          var range = session.getCommentFoldRange(row, i + match[0].length, 1);
          if (range && !range.isMultiLine()) {
            if (forceMultiline) {
              range = this.getSectionRange(session, row);
            } else if (foldStyle != "all")
              range = null;
          }
          return range;
        }
        if (foldStyle === "markbegin")
          return;
        var match = line.match(this.foldingStopMarker);
        if (match) {
          var i = match.index + match[0].length;
          if (match[1])
            return this.closingBracketBlock(session, match[1], row, i);
          return session.getCommentFoldRange(row, i, -1);
        }
      };
      CstyleFoldMode.prototype.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
          line = session.getLine(row);
          var indent = line.search(/\S/);
          if (indent === -1)
            continue;
          if (startIndent > indent)
            break;
          var subRange = this.getFoldWidgetRange(session, "all", row);
          if (subRange) {
            if (subRange.start.row <= startRow) {
              break;
            } else if (subRange.isMultiLine()) {
              row = subRange.end.row;
            } else if (startIndent == indent) {
              break;
            }
          }
          endRow = row;
        }
        return new Range_1.default(startRow, startColumn, endRow, session.getLine(endRow).length);
      };
      return CstyleFoldMode;
    }(FoldMode_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = CstyleFoldMode;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/CssMode', ["require", "exports", "./TextMode", "./CssHighlightRules", "./MatchingBraceOutdent", "../worker/WorkerClient", "./behaviour/CssBehaviour", "./folding/CstyleFoldMode"], function(require, exports, TextMode_1, CssHighlightRules_1, MatchingBraceOutdent_1, WorkerClient_1, CssBehaviour_1, CstyleFoldMode_1) {
    "use strict";
    var CssMode = (function(_super) {
      __extends(CssMode, _super);
      function CssMode(workerUrl, scriptImports) {
        _super.call(this, workerUrl, scriptImports);
        this.$id = "ace/mode/css";
        this.blockComment = {
          start: "/*",
          end: "*/"
        };
        this.HighlightRules = CssHighlightRules_1.default;
        this.$outdent = new MatchingBraceOutdent_1.default();
        this.$behaviour = new CssBehaviour_1.default();
        this.foldingRules = new CstyleFoldMode_1.default();
      }
      CssMode.prototype.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);
        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
        if (tokens.length && tokens[tokens.length - 1].type == "comment") {
          return indent;
        }
        var match = line.match(/^.*\{\s*$/);
        if (match) {
          indent += tab;
        }
        return indent;
      };
      CssMode.prototype.checkOutdent = function(state, line, text) {
        return this.$outdent.checkOutdent(line, text);
      };
      CssMode.prototype.autoOutdent = function(state, session, row) {
        return this.$outdent.autoOutdent(session, row);
      };
      CssMode.prototype.createWorker = function(session) {
        var workerUrl = this.workerUrl;
        var scriptImports = this.scriptImports;
        var worker = new WorkerClient_1.default(workerUrl);
        worker.on("initAfter", function() {
          worker.attachToDocument(session.getDocument());
        });
        worker.on("initFail", function(message) {});
        worker.on('annotations', function(event) {
          var annotations = event.data;
          if (annotations.length > 0) {
            session.setAnnotations(annotations);
          } else {
            session.clearAnnotations();
          }
          session._emit("annotations", {data: annotations});
        });
        worker.on("terminate", function() {
          worker.detachFromDocument();
          session.clearAnnotations();
        });
        worker.init(scriptImports, 'ace-workers.js', 'CssWorker');
        return worker;
      };
      return CssMode;
    }(TextMode_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = CssMode;
  });
  define('mode/createCssMode', ["require", "exports", './CssMode'], function(require, exports, CssMode_1) {
    "use strict";
    function createCssMode(workerUrl, scriptImports) {
      return new CssMode_1.default(workerUrl, scriptImports);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createCssMode;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/DocCommentHighlightRules', ["require", "exports", "./TextHighlightRules"], function(require, exports, TextHighlightRules_1) {
    "use strict";
    var DocCommentHighlightRules = (function(_super) {
      __extends(DocCommentHighlightRules, _super);
      function DocCommentHighlightRules() {
        _super.call(this);
        this.$rules = {"start": [{
            token: "comment.doc.tag",
            regex: "@[\\w\\d_]+"
          }, {
            token: "comment.doc.tag",
            regex: "\\bTODO\\b"
          }, {defaultToken: "comment.doc"}]};
      }
      DocCommentHighlightRules.getStartRule = function(start) {
        return {
          token: "comment.doc",
          regex: "\\/\\*(?=\\*)",
          next: start
        };
      };
      DocCommentHighlightRules.getEndRule = function(start) {
        return {
          token: "comment.doc",
          regex: "\\*\\/",
          next: start
        };
      };
      return DocCommentHighlightRules;
    }(TextHighlightRules_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = DocCommentHighlightRules;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/JavaScriptHighlightRules', ["require", "exports", "./DocCommentHighlightRules", "./TextHighlightRules"], function(require, exports, DocCommentHighlightRules_1, TextHighlightRules_1) {
    "use strict";
    var JavaScriptHighlightRules = (function(_super) {
      __extends(JavaScriptHighlightRules, _super);
      function JavaScriptHighlightRules(options) {
        _super.call(this);
        var keywordMapper = this.createKeywordMapper({
          "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|" + "Namespace|QName|XML|XMLList|" + "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" + "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" + "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + "SyntaxError|TypeError|URIError|" + "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + "isNaN|parseFloat|parseInt|" + "JSON|Math|" + "this|arguments|prototype|window|document",
          "keyword": "const|yield|import|get|set|" + "break|case|catch|continue|default|delete|do|else|finally|for|function|" + "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" + "__parent__|__count__|escape|unescape|with|__proto__|" + "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
          "storage.type": "const|let|var|function",
          "constant.language": "null|Infinity|NaN|undefined",
          "support.function": "alert",
          "constant.language.boolean": "true|false"
        }, "identifier");
        var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
        var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*\\b";
        var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + "u[0-9a-fA-F]{4}|" + "[0-2][0-7]{0,2}|" + "3[0-6][0-7]?|" + "37[0-7]?|" + "[4-7][0-7]?|" + ".)";
        this.$rules = {
          "no_regex": [{
            token: "comment",
            regex: "\\/\\/",
            next: "line_comment"
          }, DocCommentHighlightRules_1.default.getStartRule("doc-start"), {
            token: "comment",
            regex: /\/\*/,
            next: "comment"
          }, {
            token: "string",
            regex: "'(?=.)",
            next: "qstring"
          }, {
            token: "string",
            regex: '"(?=.)',
            next: "qqstring"
          }, {
            token: "constant.numeric",
            regex: /0[xX][0-9a-fA-F]+\b/
          }, {
            token: "constant.numeric",
            regex: /[+-]?\d+(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
          }, {
            token: ["storage.type", "punctuation.operator", "support.function", "punctuation.operator", "entity.name.function", "text", "keyword.operator"],
            regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
            next: "function_arguments"
          }, {
            token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
            regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
            next: "function_arguments"
          }, {
            token: ["entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
            regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
            next: "function_arguments"
          }, {
            token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
            regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
            next: "function_arguments"
          }, {
            token: ["storage.type", "text", "entity.name.function", "text", "paren.lparen"],
            regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
            next: "function_arguments"
          }, {
            token: ["entity.name.function", "text", "punctuation.operator", "text", "storage.type", "text", "paren.lparen"],
            regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
            next: "function_arguments"
          }, {
            token: ["text", "text", "storage.type", "text", "paren.lparen"],
            regex: "(:)(\\s*)(function)(\\s*)(\\()",
            next: "function_arguments"
          }, {
            token: "keyword",
            regex: "(?:" + kwBeforeRe + ")\\b",
            next: "start"
          }, {
            token: ["punctuation.operator", "support.function"],
            regex: /(\.)(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
          }, {
            token: ["punctuation.operator", "support.function.dom"],
            regex: /(\.)(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
          }, {
            token: ["punctuation.operator", "support.constant"],
            regex: /(\.)(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
          }, {
            token: ["support.constant"],
            regex: /that\b/
          }, {
            token: ["storage.type", "punctuation.operator", "support.function.firebug"],
            regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
          }, {
            token: keywordMapper,
            regex: identifierRe
          }, {
            token: "keyword.operator",
            regex: /--|\+\+|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\|\||\?\:|[!$%&*+\-~\/^]=?/,
            next: "start"
          }, {
            token: "punctuation.operator",
            regex: /[?:,;.]/,
            next: "start"
          }, {
            token: "paren.lparen",
            regex: /[\[({]/,
            next: "start"
          }, {
            token: "paren.rparen",
            regex: /[\])}]/
          }, {
            token: "comment",
            regex: /^#!.*$/
          }],
          "start": [DocCommentHighlightRules_1.default.getStartRule("doc-start"), {
            token: "comment",
            regex: "\\/\\*",
            next: "comment_regex_allowed"
          }, {
            token: "comment",
            regex: "\\/\\/",
            next: "line_comment_regex_allowed"
          }, {
            token: "string.regexp",
            regex: "\\/",
            next: "regex"
          }, {
            token: "text",
            regex: "\\s+|^$",
            next: "start"
          }, {
            token: "empty",
            regex: "",
            next: "no_regex"
          }],
          "regex": [{
            token: "regexp.keyword.operator",
            regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
          }, {
            token: "string.regexp",
            regex: "/[sxngimy]*",
            next: "no_regex"
          }, {
            token: "invalid",
            regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
          }, {
            token: "constant.language.escape",
            regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
          }, {
            token: "constant.language.delimiter",
            regex: /\|/
          }, {
            token: "constant.language.escape",
            regex: /\[\^?/,
            next: "regex_character_class"
          }, {
            token: "empty",
            regex: "$",
            next: "no_regex"
          }, {defaultToken: "string.regexp"}],
          "regex_character_class": [{
            token: "regexp.charclass.keyword.operator",
            regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
          }, {
            token: "constant.language.escape",
            regex: "]",
            next: "regex"
          }, {
            token: "constant.language.escape",
            regex: "-"
          }, {
            token: "empty",
            regex: "$",
            next: "no_regex"
          }, {defaultToken: "string.regexp.charachterclass"}],
          "function_arguments": [{
            token: "variable.parameter",
            regex: identifierRe
          }, {
            token: "punctuation.operator",
            regex: "[, ]+"
          }, {
            token: "punctuation.operator",
            regex: "$"
          }, {
            token: "empty",
            regex: "",
            next: "no_regex"
          }],
          "comment_regex_allowed": [{
            token: "comment",
            regex: "\\*\\/",
            next: "start"
          }, {defaultToken: "comment"}],
          "comment": [{
            token: "comment",
            regex: "\\*\\/",
            next: "no_regex"
          }, {defaultToken: "comment"}],
          "line_comment_regex_allowed": [{
            token: "comment",
            regex: "$|^",
            next: "start"
          }, {defaultToken: "comment"}],
          "line_comment": [{
            token: "comment",
            regex: "$|^",
            next: "no_regex"
          }, {defaultToken: "comment"}],
          "qqstring": [{
            token: "constant.language.escape",
            regex: escapedRe
          }, {
            token: "string",
            regex: "\\\\$",
            next: "qqstring"
          }, {
            token: "string",
            regex: '"|$',
            next: "no_regex"
          }, {defaultToken: "string"}],
          "qstring": [{
            token: "constant.language.escape",
            regex: escapedRe
          }, {
            token: "string",
            regex: "\\\\$",
            next: "qstring"
          }, {
            token: "string",
            regex: "'|$",
            next: "no_regex"
          }, {defaultToken: "string"}]
        };
        if (!options || !options.noES6) {
          this.$rules.no_regex.unshift({
            regex: "[{}]",
            onMatch: function(val, state, stack) {
              this.next = val == "{" ? this.nextState : "";
              if (val == "{" && stack.length) {
                stack.unshift("start", state);
                return "paren";
              }
              if (val == "}" && stack.length) {
                stack.shift();
                this.next = stack.shift();
                if (this.next.indexOf("string") != -1)
                  return "paren.quasi.end";
              }
              return val == "{" ? "paren.lparen" : "paren.rparen";
            },
            nextState: "start"
          }, {
            token: "string.quasi.start",
            regex: /`/,
            push: [{
              token: "constant.language.escape",
              regex: escapedRe
            }, {
              token: "paren.quasi.start",
              regex: /\${/,
              push: "start"
            }, {
              token: "string.quasi.end",
              regex: /`/,
              next: "pop"
            }, {defaultToken: "string.quasi"}]
          });
        }
        this.embedRules(DocCommentHighlightRules_1.default, "doc-", [DocCommentHighlightRules_1.default.getEndRule("no_regex")]);
        this.normalizeRules();
      }
      return JavaScriptHighlightRules;
    }(TextHighlightRules_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = JavaScriptHighlightRules;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/JavaScriptMode', ["require", "exports", "./TextMode", "./JavaScriptHighlightRules", "./MatchingBraceOutdent", "../worker/WorkerClient", "./behaviour/CstyleBehaviour", "./folding/CstyleFoldMode"], function(require, exports, TextMode_1, JavaScriptHighlightRules_1, MatchingBraceOutdent_1, WorkerClient_1, CstyleBehaviour_1, CstyleFoldMode_1) {
    "use strict";
    var JavaScriptMode = (function(_super) {
      __extends(JavaScriptMode, _super);
      function JavaScriptMode(workerUrl, scriptImports) {
        _super.call(this, workerUrl, scriptImports);
        this.HighlightRules = JavaScriptHighlightRules_1.default;
        this.$outdent = new MatchingBraceOutdent_1.default();
        this.$behaviour = new CstyleBehaviour_1.default();
        this.foldingRules = new CstyleFoldMode_1.default();
        this.lineCommentStart = "//";
        this.blockComment = {
          start: "/*",
          end: "*/"
        };
        this.$id = "ace/mode/javascript";
      }
      JavaScriptMode.prototype.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);
        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;
        if (tokens.length && tokens[tokens.length - 1].type === "comment") {
          return indent;
        }
        if (state === "start" || state === "no_regex") {
          var match = line.match(/^.*(?:\bcase\b.*\:|[\{\(\[])\s*$/);
          if (match) {
            indent += tab;
          }
        } else if (state === "doc-start") {
          if (endState == "start" || endState == "no_regex") {
            return "";
          }
          var match = line.match(/^\s*(\/?)\*/);
          if (match) {
            if (match[1]) {
              indent += " ";
            }
            indent += "* ";
          }
        }
        return indent;
      };
      JavaScriptMode.prototype.checkOutdent = function(state, line, text) {
        return this.$outdent.checkOutdent(line, text);
      };
      ;
      JavaScriptMode.prototype.autoOutdent = function(state, session, row) {
        return this.$outdent.autoOutdent(session, row);
      };
      ;
      JavaScriptMode.prototype.createWorker = function(session) {
        var worker = new WorkerClient_1.default(this.workerUrl);
        worker.on("initAfter", function() {
          worker.attachToDocument(session.getDocument());
        });
        worker.on("initFailed", function(event) {});
        worker.on('annotations', function(event) {
          var annotations = event.data;
          if (annotations.length > 0) {
            session.setAnnotations(annotations);
          } else {
            session.clearAnnotations();
          }
          session._emit("annotations", {data: annotations});
        });
        worker.on("terminate", function() {
          worker.detachFromDocument();
          session.clearAnnotations();
        });
        worker.init(this.scriptImports, 'ace-workers.js', 'JavaScriptWorker');
        return worker;
      };
      return JavaScriptMode;
    }(TextMode_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = JavaScriptMode;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/XmlHighlightRules', ["require", "exports", "./TextHighlightRules"], function(require, exports, TextHighlightRules_1) {
    "use strict";
    var XmlHighlightRules = (function(_super) {
      __extends(XmlHighlightRules, _super);
      function XmlHighlightRules(normalize) {
        _super.call(this);
        this.$rules = {
          start: [{
            token: "string.cdata.xml",
            regex: "<\\!\\[CDATA\\[",
            next: "cdata"
          }, {
            token: ["punctuation.xml-decl.xml", "keyword.xml-decl.xml"],
            regex: "(<\\?)(xml)(?=[\\s])",
            next: "xml_decl",
            caseInsensitive: true
          }, {
            token: ["punctuation.instruction.xml", "keyword.instruction.xml"],
            regex: "(<\\?)([-_a-zA-Z0-9]+)",
            next: "processing_instruction"
          }, {
            token: "comment.xml",
            regex: "<\\!--",
            next: "comment"
          }, {
            token: ["xml-pe.doctype.xml", "xml-pe.doctype.xml"],
            regex: "(<\\!)(DOCTYPE)(?=[\\s])",
            next: "doctype",
            caseInsensitive: true
          }, {include: "tag"}, {
            token: "text.end-tag-open.xml",
            regex: "</"
          }, {
            token: "text.tag-open.xml",
            regex: "<"
          }, {include: "reference"}, {defaultToken: "text.xml"}],
          xml_decl: [{
            token: "entity.other.attribute-name.decl-attribute-name.xml",
            regex: "(?:[-_a-zA-Z0-9]+:)?[-_a-zA-Z0-9]+"
          }, {
            token: "keyword.operator.decl-attribute-equals.xml",
            regex: "="
          }, {include: "whitespace"}, {include: "string"}, {
            token: "punctuation.xml-decl.xml",
            regex: "\\?>",
            next: "start"
          }],
          processing_instruction: [{
            token: "punctuation.instruction.xml",
            regex: "\\?>",
            next: "start"
          }, {defaultToken: "instruction.xml"}],
          doctype: [{include: "whitespace"}, {include: "string"}, {
            token: "xml-pe.doctype.xml",
            regex: ">",
            next: "start"
          }, {
            token: "xml-pe.xml",
            regex: "[-_a-zA-Z0-9:]+"
          }, {
            token: "punctuation.int-subset",
            regex: "\\[",
            push: "int_subset"
          }],
          int_subset: [{
            token: "text.xml",
            regex: "\\s+"
          }, {
            token: "punctuation.int-subset.xml",
            regex: "]",
            next: "pop"
          }, {
            token: ["punctuation.markup-decl.xml", "keyword.markup-decl.xml"],
            regex: "(<\\!)([-_a-zA-Z0-9]+)",
            push: [{
              token: "text",
              regex: "\\s+"
            }, {
              token: "punctuation.markup-decl.xml",
              regex: ">",
              next: "pop"
            }, {include: "string"}]
          }],
          cdata: [{
            token: "string.cdata.xml",
            regex: "\\]\\]>",
            next: "start"
          }, {
            token: "text.xml",
            regex: "\\s+"
          }, {
            token: "text.xml",
            regex: "(?:[^\\]]|\\](?!\\]>))+"
          }],
          comment: [{
            token: "comment.xml",
            regex: "-->",
            next: "start"
          }, {defaultToken: "comment.xml"}],
          reference: [{
            token: "constant.language.escape.reference.xml",
            regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
          }],
          attr_reference: [{
            token: "constant.language.escape.reference.attribute-value.xml",
            regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
          }],
          tag: [{
            token: ["meta.tag.punctuation.tag-open.xml", "meta.tag.punctuation.end-tag-open.xml", "meta.tag.tag-name.xml"],
            regex: "(?:(<)|(</))((?:[-_a-zA-Z0-9]+:)?[-_a-zA-Z0-9]+)",
            next: [{include: "attributes"}, {
              token: "meta.tag.punctuation.tag-close.xml",
              regex: "/?>",
              next: "start"
            }]
          }],
          tag_whitespace: [{
            token: "text.tag-whitespace.xml",
            regex: "\\s+"
          }],
          whitespace: [{
            token: "text.whitespace.xml",
            regex: "\\s+"
          }],
          string: [{
            token: "string.xml",
            regex: "'",
            push: [{
              token: "string.xml",
              regex: "'",
              next: "pop"
            }, {defaultToken: "string.xml"}]
          }, {
            token: "string.xml",
            regex: '"',
            push: [{
              token: "string.xml",
              regex: '"',
              next: "pop"
            }, {defaultToken: "string.xml"}]
          }],
          attributes: [{
            token: "entity.other.attribute-name.xml",
            regex: "(?:[-_a-zA-Z0-9]+:)?[-_a-zA-Z0-9]+"
          }, {
            token: "keyword.operator.attribute-equals.xml",
            regex: "="
          }, {include: "tag_whitespace"}, {include: "attribute_value"}],
          attribute_value: [{
            token: "string.attribute-value.xml",
            regex: "'",
            push: [{
              token: "string.attribute-value.xml",
              regex: "'",
              next: "pop"
            }, {include: "attr_reference"}, {defaultToken: "string.attribute-value.xml"}]
          }, {
            token: "string.attribute-value.xml",
            regex: '"',
            push: [{
              token: "string.attribute-value.xml",
              regex: '"',
              next: "pop"
            }, {include: "attr_reference"}, {defaultToken: "string.attribute-value.xml"}]
          }]
        };
        if (this.constructor === XmlHighlightRules)
          this.normalizeRules();
      }
      XmlHighlightRules.prototype.embedTagRules = function(HighlightRules, prefix, tag) {
        this.$rules.tag.unshift({
          token: ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
          regex: "(<)(" + tag + "(?=\\s|>|$))",
          next: [{include: "attributes"}, {
            token: "meta.tag.punctuation.tag-close.xml",
            regex: "/?>",
            next: prefix + "start"
          }]
        });
        this.$rules[tag + "-end"] = [{include: "attributes"}, {
          token: "meta.tag.punctuation.tag-close.xml",
          regex: "/?>",
          next: "start",
          onMatch: function(value, currentState, stack) {
            stack.splice(0);
            return this.token;
          }
        }];
        this.embedRules(HighlightRules, prefix, [{
          token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
          regex: "(</)(" + tag + "(?=\\s|>|$))",
          next: tag + "-end"
        }, {
          token: "string.cdata.xml",
          regex: "<\\!\\[CDATA\\["
        }, {
          token: "string.cdata.xml",
          regex: "\\]\\]>"
        }]);
      };
      return XmlHighlightRules;
    }(TextHighlightRules_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = XmlHighlightRules;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/HtmlHighlightRules', ["require", "exports", "../lib/lang", "./CssHighlightRules", "./JavaScriptHighlightRules", "./XmlHighlightRules"], function(require, exports, lang_1, CssHighlightRules_1, JavaScriptHighlightRules_1, XmlHighlightRules_1) {
    "use strict";
    var tagMap = lang_1.createMap({
      a: 'anchor',
      button: 'form',
      form: 'form',
      img: 'image',
      input: 'form',
      label: 'form',
      option: 'form',
      script: 'script',
      select: 'form',
      textarea: 'form',
      style: 'style',
      table: 'table',
      tbody: 'table',
      td: 'table',
      tfoot: 'table',
      th: 'table',
      tr: 'table'
    });
    var HtmlHighlightRules = (function(_super) {
      __extends(HtmlHighlightRules, _super);
      function HtmlHighlightRules() {
        _super.call(this);
        this.addRules({
          attributes: [{include: "tag_whitespace"}, {
            token: "entity.other.attribute-name.xml",
            regex: "[-_a-zA-Z0-9:]+"
          }, {
            token: "keyword.operator.attribute-equals.xml",
            regex: "=",
            push: [{include: "tag_whitespace"}, {
              token: "string.unquoted.attribute-value.html",
              regex: "[^<>='\"`\\s]+",
              next: "pop"
            }, {
              token: "empty",
              regex: "",
              next: "pop"
            }]
          }, {include: "attribute_value"}],
          tag: [{
            token: function(start, tag) {
              var group = tagMap[tag];
              return ["meta.tag.punctuation." + (start == "<" ? "" : "end-") + "tag-open.xml", "meta.tag" + (group ? "." + group : "") + ".tag-name.xml"];
            },
            regex: "(</?)([-_a-zA-Z0-9:]+)",
            next: "tag_stuff"
          }],
          tag_stuff: [{include: "attributes"}, {
            token: "meta.tag.punctuation.tag-close.xml",
            regex: "/?>",
            next: "start"
          }]
        });
        this.embedTagRules(CssHighlightRules_1.default, "css-", "style");
        this.embedTagRules(JavaScriptHighlightRules_1.default, "js-", "script");
        if (this.constructor === HtmlHighlightRules)
          this.normalizeRules();
      }
      return HtmlHighlightRules;
    }(XmlHighlightRules_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = HtmlHighlightRules;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/behaviour/XmlBehaviour', ["require", "exports", "../Behaviour", "../../TokenIterator"], function(require, exports, Behaviour_1, TokenIterator_1) {
    "use strict";
    function is(token, type) {
      return token.type.lastIndexOf(type + ".xml") > -1;
    }
    var XmlBehaviour = (function(_super) {
      __extends(XmlBehaviour, _super);
      function XmlBehaviour() {
        _super.call(this);
        this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
          if (text === '"' || text === "'") {
            var quote = text;
            var selected = session.doc.getTextRange(editor.getSelectionRange());
            if (selected !== "" && selected !== "'" && selected !== '"' && editor.getWrapBehavioursEnabled()) {
              return {
                text: quote + selected + quote,
                selection: void 0
              };
            }
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            var iterator = new TokenIterator_1.default(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (rightChar === quote && (is(token, "attribute-value") || is(token, "string"))) {
              return {
                text: "",
                selection: [1, 1]
              };
            }
            if (!token)
              token = iterator.stepBackward();
            if (!token)
              return;
            while (is(token, "tag-whitespace") || is(token, "whitespace")) {
              token = iterator.stepBackward();
            }
            var rightSpace = !rightChar || rightChar.match(/\s/);
            if (is(token, "attribute-equals") && (rightSpace || rightChar === '>') || (is(token, "decl-attribute-equals") && (rightSpace || rightChar == '?'))) {
              return {
                text: quote + quote,
                selection: [1, 1]
              };
            }
          }
        });
        this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && (selected === '"' || selected === "'")) {
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("autoclosing", "insertion", function(state, action, editor, session, text) {
          if (text === '>') {
            var position = editor.getCursorPosition();
            var iterator = new TokenIterator_1.default(session, position.row, position.column);
            var token = iterator.getCurrentToken() || iterator.stepBackward();
            if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value")))
              return;
            if (is(token, "reference.attribute-value"))
              return;
            if (is(token, "attribute-value")) {
              var firstChar = token.value.charAt(0);
              if (firstChar == '"' || firstChar == "'") {
                var lastChar = token.value.charAt(token.value.length - 1);
                var tokenEnd = iterator.getCurrentTokenColumn() + token.value.length;
                if (tokenEnd > position.column || tokenEnd == position.column && firstChar != lastChar)
                  return;
              }
            }
            while (!is(token, "tag-name")) {
              token = iterator.stepBackward();
            }
            var tokenRow = iterator.getCurrentTokenRow();
            var tokenColumn = iterator.getCurrentTokenColumn();
            if (is(iterator.stepBackward(), "end-tag-open"))
              return;
            var element = token.value;
            if (tokenRow == position.row)
              element = element.substring(0, position.column - tokenColumn);
            if (this.voidElements.hasOwnProperty(element.toLowerCase()))
              return;
            return {
              text: '>' + '</' + element + '>',
              selection: [1, 1]
            };
          }
        });
        this.add('autoindent', 'insertion', function(state, action, editor, session, text) {
          if (text === "\n") {
            var cursor = editor.getCursorPosition();
            var line = session.getLine(cursor.row);
            var rightChars = line.substring(cursor.column, cursor.column + 2);
            if (rightChars == '</') {
              var next_indent = this.$getIndent(line);
              var indent = next_indent + session.getTabString();
              return {
                text: '\n' + indent + '\n' + next_indent,
                selection: [1, indent.length, 1, indent.length]
              };
            }
          }
        });
      }
      return XmlBehaviour;
    }(Behaviour_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = XmlBehaviour;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/behaviour/HtmlBehaviour', ["require", "exports", "../behaviour/XmlBehaviour"], function(require, exports, XmlBehaviour_1) {
    "use strict";
    var HtmlBehaviour = (function(_super) {
      __extends(HtmlBehaviour, _super);
      function HtmlBehaviour() {
        _super.call(this);
      }
      return HtmlBehaviour;
    }(XmlBehaviour_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = HtmlBehaviour;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/folding/MixedFoldMode', ["require", "exports", "./FoldMode"], function(require, exports, FoldMode_1) {
    "use strict";
    var MixedFoldMode = (function(_super) {
      __extends(MixedFoldMode, _super);
      function MixedFoldMode(defaultMode, subModes) {
        _super.call(this);
        this.defaultMode = defaultMode;
        this.subModes = subModes;
      }
      MixedFoldMode.prototype.$getMode = function(state) {
        if (typeof state !== "string") {
          state = state[0];
        }
        for (var key in this.subModes) {
          if (state.indexOf(key) === 0)
            return this.subModes[key];
        }
        return null;
      };
      MixedFoldMode.prototype.$tryMode = function(state, session, foldStyle, row) {
        var mode = this.$getMode(state);
        return (mode ? mode.getFoldWidget(session, foldStyle, row) : "");
      };
      MixedFoldMode.prototype.getFoldWidget = function(session, foldStyle, row) {
        return (this.$tryMode(session.getState(row - 1), session, foldStyle, row) || this.$tryMode(session.getState(row), session, foldStyle, row) || this.defaultMode.getFoldWidget(session, foldStyle, row));
      };
      MixedFoldMode.prototype.getFoldWidgetRange = function(session, foldStyle, row) {
        var mode = this.$getMode(session.getState(row - 1));
        if (!mode || !mode.getFoldWidget(session, foldStyle, row)) {
          mode = this.$getMode(session.getState(row));
        }
        if (!mode || !mode.getFoldWidget(session, foldStyle, row)) {
          mode = this.defaultMode;
        }
        return mode.getFoldWidgetRange(session, foldStyle, row);
      };
      return MixedFoldMode;
    }(FoldMode_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = MixedFoldMode;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/folding/XmlFoldMode', ["require", "exports", "../../lib/oop", "../../Range", "./FoldMode", "../../TokenIterator"], function(require, exports, oop_1, Range_1, FoldMode_1, TokenIterator_1) {
    "use strict";
    var XmlFoldMode = (function(_super) {
      __extends(XmlFoldMode, _super);
      function XmlFoldMode(voidElements, optionalEndTags) {
        _super.call(this);
        this.voidElements = voidElements || {};
        this.optionalEndTags = oop_1.mixin({}, this.voidElements);
        if (optionalEndTags) {
          oop_1.mixin(this.optionalEndTags, optionalEndTags);
        }
      }
      XmlFoldMode.prototype.getFoldWidget = function(session, foldStyle, row) {
        var tag = this._getFirstTagInLine(session, row);
        if (!tag)
          return "";
        if (tag.closing || (!tag.tagName && tag.selfClosing))
          return foldStyle === "markbeginend" ? "end" : "";
        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
          return "";
        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
          return "";
        return "start";
      };
      XmlFoldMode.prototype._getFirstTagInLine = function(session, row) {
        var tokens = session.getTokens(row);
        var tag = new Tag();
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          if (is(token, "tag-open")) {
            tag.end.column = tag.start.column + token.value.length;
            tag.closing = is(token, "end-tag-open");
            token = tokens[++i];
            if (!token)
              return null;
            tag.tagName = token.value;
            tag.end.column += token.value.length;
            for (i++; i < tokens.length; i++) {
              token = tokens[i];
              tag.end.column += token.value.length;
              if (is(token, "tag-close")) {
                tag.selfClosing = token.value == '/>';
                break;
              }
            }
            return tag;
          } else if (is(token, "tag-close")) {
            tag.selfClosing = token.value == '/>';
            return tag;
          }
          tag.start.column += token.value.length;
        }
        return null;
      };
      XmlFoldMode.prototype._findEndTagInLine = function(session, row, tagName, startColumn) {
        var tokens = session.getTokens(row);
        var column = 0;
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          column += token.value.length;
          if (column < startColumn)
            continue;
          if (is(token, "end-tag-open")) {
            token = tokens[i + 1];
            if (token && token.value == tagName)
              return true;
          }
        }
        return false;
      };
      XmlFoldMode.prototype._readTagForward = function(iterator) {
        var token = iterator.getCurrentToken();
        if (!token)
          return null;
        var tag = new Tag();
        do {
          if (is(token, "tag-open")) {
            tag.closing = is(token, "end-tag-open");
            tag.start.row = iterator.getCurrentTokenRow();
            tag.start.column = iterator.getCurrentTokenColumn();
          } else if (is(token, "tag-name")) {
            tag.tagName = token.value;
          } else if (is(token, "tag-close")) {
            tag.selfClosing = token.value == "/>";
            tag.end.row = iterator.getCurrentTokenRow();
            tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
            iterator.stepForward();
            return tag;
          }
        } while (token = iterator.stepForward());
        return null;
      };
      XmlFoldMode.prototype._readTagBackward = function(iterator) {
        var token = iterator.getCurrentToken();
        if (!token)
          return null;
        var tag = new Tag();
        do {
          if (is(token, "tag-open")) {
            tag.closing = is(token, "end-tag-open");
            tag.start.row = iterator.getCurrentTokenRow();
            tag.start.column = iterator.getCurrentTokenColumn();
            iterator.stepBackward();
            return tag;
          } else if (is(token, "tag-name")) {
            tag.tagName = token.value;
          } else if (is(token, "tag-close")) {
            tag.selfClosing = token.value == "/>";
            tag.end.row = iterator.getCurrentTokenRow();
            tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
          }
        } while (token = iterator.stepBackward());
        return null;
      };
      XmlFoldMode.prototype._pop = function(stack, tag) {
        while (stack.length) {
          var top = stack[stack.length - 1];
          if (!tag || top.tagName == tag.tagName) {
            return stack.pop();
          } else if (this.optionalEndTags.hasOwnProperty(tag.tagName)) {
            return;
          } else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {
            stack.pop();
            continue;
          } else {
            return null;
          }
        }
      };
      XmlFoldMode.prototype.getFoldWidgetRange = function(session, foldStyle, row) {
        var firstTag = this._getFirstTagInLine(session, row);
        if (!firstTag) {
          return null;
        }
        var isBackward = firstTag.closing || firstTag.selfClosing;
        var stack = [];
        var tag;
        if (!isBackward) {
          var iterator = new TokenIterator_1.default(session, row, firstTag.start.column);
          var start = {
            row: row,
            column: firstTag.start.column + firstTag.tagName.length + 2
          };
          while (tag = this._readTagForward(iterator)) {
            if (tag.selfClosing) {
              if (!stack.length) {
                tag.start.column += tag.tagName.length + 2;
                tag.end.column -= 2;
                return Range_1.default.fromPoints(tag.start, tag.end);
              } else
                continue;
            }
            if (tag.closing) {
              this._pop(stack, tag);
              if (stack.length == 0)
                return Range_1.default.fromPoints(start, tag.start);
            } else {
              stack.push(tag);
            }
          }
        } else {
          var iterator = new TokenIterator_1.default(session, row, firstTag.end.column);
          var end = {
            row: row,
            column: firstTag.start.column
          };
          while (tag = this._readTagBackward(iterator)) {
            if (tag.selfClosing) {
              if (!stack.length) {
                tag.start.column += tag.tagName.length + 2;
                tag.end.column -= 2;
                return Range_1.default.fromPoints(tag.start, tag.end);
              } else {
                continue;
              }
            }
            if (!tag.closing) {
              this._pop(stack, tag);
              if (stack.length === 0) {
                tag.start.column += tag.tagName.length + 2;
                return Range_1.default.fromPoints(tag.start, end);
              }
            } else {
              stack.push(tag);
            }
          }
        }
      };
      return XmlFoldMode;
    }(FoldMode_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = XmlFoldMode;
    var Tag = (function() {
      function Tag() {
        this.tagName = "";
        this.closing = false;
        this.selfClosing = false;
        this.start = {
          row: 0,
          column: 0
        };
        this.end = {
          row: 0,
          column: 0
        };
      }
      return Tag;
    }());
    exports.Tag = Tag;
    function is(token, type) {
      return token.type.lastIndexOf(type + ".xml") > -1;
    }
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/folding/HtmlFoldMode', ["require", "exports", "./MixedFoldMode", "./XmlFoldMode", "./CstyleFoldMode"], function(require, exports, MixedFoldMode_1, XmlFoldMode_1, CstyleFoldMode_1) {
    "use strict";
    var HtmlFoldMode = (function(_super) {
      __extends(HtmlFoldMode, _super);
      function HtmlFoldMode(voidElements, optionalTags) {
        _super.call(this, new XmlFoldMode_1.default(voidElements, optionalTags), {
          "js-": new CstyleFoldMode_1.default(),
          "css-": new CstyleFoldMode_1.default()
        });
      }
      return HtmlFoldMode;
    }(MixedFoldMode_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = HtmlFoldMode;
  });
  define('mode/HtmlCompletions', ["require", "exports", "../TokenIterator"], function(require, exports, TokenIterator_1) {
    "use strict";
    var commonAttributes = ["accesskey", "class", "contenteditable", "contextmenu", "dir", "draggable", "dropzone", "hidden", "id", "inert", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "spellcheck", "style", "tabindex", "title", "translate"];
    var eventAttributes = ["onabort", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncontextmenu", "oncuechange", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreset", "onscroll", "onseeked", "onseeking", "onselect", "onshow", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "onvolumechange", "onwaiting"];
    var globalAttributes = commonAttributes.concat(eventAttributes);
    var attributeMap = {
      "html": ["manifest"],
      "head": [],
      "title": [],
      "base": ["href", "target"],
      "link": ["href", "hreflang", "rel", "media", "type", "sizes"],
      "meta": ["http-equiv", "name", "content", "charset"],
      "style": ["type", "media", "scoped"],
      "script": ["charset", "type", "src", "defer", "async"],
      "noscript": ["href"],
      "body": ["onafterprint", "onbeforeprint", "onbeforeunload", "onhashchange", "onmessage", "onoffline", "onpopstate", "onredo", "onresize", "onstorage", "onundo", "onunload"],
      "section": [],
      "nav": [],
      "article": ["pubdate"],
      "aside": [],
      "h1": [],
      "h2": [],
      "h3": [],
      "h4": [],
      "h5": [],
      "h6": [],
      "header": [],
      "footer": [],
      "address": [],
      "main": [],
      "p": [],
      "hr": [],
      "pre": [],
      "blockquote": ["cite"],
      "ol": ["start", "reversed"],
      "ul": [],
      "li": ["value"],
      "dl": [],
      "dt": [],
      "dd": [],
      "figure": [],
      "figcaption": [],
      "div": [],
      "a": ["href", "target", "ping", "rel", "media", "hreflang", "type"],
      "em": [],
      "strong": [],
      "small": [],
      "s": [],
      "cite": [],
      "q": ["cite"],
      "dfn": [],
      "abbr": [],
      "data": [],
      "time": ["datetime"],
      "code": [],
      "var": [],
      "samp": [],
      "kbd": [],
      "sub": [],
      "sup": [],
      "i": [],
      "b": [],
      "u": [],
      "mark": [],
      "ruby": [],
      "rt": [],
      "rp": [],
      "bdi": [],
      "bdo": [],
      "span": [],
      "br": [],
      "wbr": [],
      "ins": ["cite", "datetime"],
      "del": ["cite", "datetime"],
      "img": ["alt", "src", "height", "width", "usemap", "ismap"],
      "iframe": ["name", "src", "height", "width", "sandbox", "seamless"],
      "embed": ["src", "height", "width", "type"],
      "object": ["param", "data", "type", "height", "width", "usemap", "name", "form", "classid"],
      "param": ["name", "value"],
      "video": ["src", "autobuffer", "autoplay", "loop", "controls", "width", "height", "poster"],
      "audio": ["src", "autobuffer", "autoplay", "loop", "controls"],
      "source": ["src", "type", "media"],
      "track": ["kind", "src", "srclang", "label", "default"],
      "canvas": ["width", "height"],
      "map": ["name"],
      "area": ["shape", "coords", "href", "hreflang", "alt", "target", "media", "rel", "ping", "type"],
      "svg": [],
      "math": [],
      "table": ["summary"],
      "caption": [],
      "colgroup": ["span"],
      "col": ["span"],
      "tbody": [],
      "thead": [],
      "tfoot": [],
      "tr": [],
      "td": ["headers", "rowspan", "colspan"],
      "th": ["headers", "rowspan", "colspan", "scope"],
      "form": ["accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"],
      "fieldset": ["disabled", "form", "name"],
      "legend": [],
      "label": ["form", "for"],
      "input": ["type", "accept", "alt", "autocomplete", "checked", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "list", "max", "maxlength", "min", "multiple", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "width", "files", "value"],
      "button": ["autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "value", "type"],
      "select": ["autofocus", "disabled", "form", "multiple", "name", "size"],
      "datalist": [],
      "optgroup": ["disabled", "label"],
      "option": ["disabled", "selected", "label", "value"],
      "textarea": ["autofocus", "disabled", "form", "maxlength", "name", "placeholder", "readonly", "required", "rows", "cols", "wrap"],
      "keygen": ["autofocus", "challenge", "disabled", "form", "keytype", "name"],
      "output": ["for", "form", "name"],
      "progress": ["value", "max"],
      "meter": ["value", "min", "max", "low", "high", "optimum"],
      "details": ["open"],
      "summary": [],
      "command": ["type", "label", "icon", "disabled", "checked", "radiogroup", "command"],
      "menu": ["type", "label"],
      "dialog": ["open"]
    };
    var elements = Object.keys(attributeMap);
    function is(token, type) {
      return token.type.lastIndexOf(type + ".xml") > -1;
    }
    function findTagName(session, pos) {
      var iterator = new TokenIterator_1.default(session, pos.row, pos.column);
      var token = iterator.getCurrentToken();
      while (token && !is(token, "tag-name")) {
        token = iterator.stepBackward();
      }
      if (token)
        return token.value;
    }
    var HtmlCompletions = (function() {
      function HtmlCompletions() {}
      HtmlCompletions.prototype.getCompletions = function(state, session, pos, prefix) {
        var token = session.getTokenAt(pos.row, pos.column);
        if (!token)
          return [];
        if (is(token, "tag-name") || is(token, "tag-open") || is(token, "end-tag-open"))
          return this.getTagCompletions(state, session, pos, prefix);
        if (is(token, "tag-whitespace") || is(token, "attribute-name"))
          return this.getAttributeCompetions(state, session, pos, prefix);
        return [];
      };
      HtmlCompletions.prototype.getTagCompletions = function(state, session, pos, prefix) {
        return elements.map(function(element) {
          return {
            value: element,
            meta: "tag",
            score: Number.MAX_VALUE
          };
        });
      };
      HtmlCompletions.prototype.getAttributeCompetions = function(state, session, pos, prefix) {
        var tagName = findTagName(session, pos);
        if (!tagName)
          return [];
        var attributes = globalAttributes;
        if (tagName in attributeMap) {
          attributes = attributes.concat(attributeMap[tagName]);
        }
        return attributes.map(function(attribute) {
          return {
            caption: attribute,
            snippet: attribute + '="$0"',
            meta: "attribute",
            score: Number.MAX_VALUE
          };
        });
      };
      return HtmlCompletions;
    }());
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = HtmlCompletions;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/HtmlMode', ["require", "exports", "../lib/lang", "./TextMode", "./JavaScriptMode", "./CssMode", "./HtmlHighlightRules", "./behaviour/HtmlBehaviour", "./folding/HtmlFoldMode", "./HtmlCompletions", "../worker/WorkerClient"], function(require, exports, lang_1, TextMode_1, JavaScriptMode_1, CssMode_1, HtmlHighlightRules_1, HtmlBehaviour_1, HtmlFoldMode_1, HtmlCompletions_1, WorkerClient_1) {
    "use strict";
    var voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
    var optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];
    var HtmlMode = (function(_super) {
      __extends(HtmlMode, _super);
      function HtmlMode(workerUrl, scriptImports, options) {
        _super.call(this, workerUrl, scriptImports);
        this.blockComment = {
          start: "<!--",
          end: "-->"
        };
        this.voidElements = lang_1.arrayToMap(voidElements, 1);
        this.$id = "ace/mode/html";
        this.fragmentContext = options && options.fragmentContext;
        this.HighlightRules = HtmlHighlightRules_1.default;
        this.$behaviour = new HtmlBehaviour_1.default();
        this.$completer = new HtmlCompletions_1.default();
        var X = JavaScriptMode_1.default;
        this.createModeDelegates({
          "js-": JavaScriptMode_1.default,
          "css-": CssMode_1.default
        });
        this.foldingRules = new HtmlFoldMode_1.default(this.voidElements, lang_1.arrayToMap(optionalEndTags, 1));
      }
      HtmlMode.prototype.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
      };
      HtmlMode.prototype.checkOutdent = function(state, line, text) {
        return false;
      };
      HtmlMode.prototype.getCompletions = function(state, session, pos, prefix) {
        return this.$completer.getCompletions(state, session, pos, prefix);
      };
      HtmlMode.prototype.createWorker = function(session) {
        var workerUrl = this.workerUrl;
        var scriptImports = this.scriptImports;
        var mode = this;
        var worker = new WorkerClient_1.default(workerUrl);
        worker.on("initAfter", function() {
          worker.attachToDocument(session.getDocument());
          if (mode.fragmentContext) {
            worker.call("setOptions", [{context: mode.fragmentContext}]);
          }
        });
        worker.on("initFail", function(message) {});
        worker.on('annotations', function(event) {
          var annotations = event.data;
          if (annotations.length > 0) {
            session.setAnnotations(annotations);
          } else {
            session.clearAnnotations();
          }
          session._emit("annotations", {data: annotations});
        });
        worker.on("terminate", function() {
          worker.detachFromDocument();
          session.clearAnnotations();
        });
        worker.init(scriptImports, 'ace-workers.js', 'HtmlWorker');
        return worker;
      };
      ;
      return HtmlMode;
    }(TextMode_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = HtmlMode;
  });
  define('mode/createHtmlMode', ["require", "exports", './HtmlMode'], function(require, exports, HtmlMode_1) {
    "use strict";
    function createCssMode(workerUrl, scriptImports) {
      return new HtmlMode_1.default(workerUrl, scriptImports);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createCssMode;
  });
  define('mode/createTextMode', ["require", "exports", './TextMode'], function(require, exports, TextMode_1) {
    "use strict";
    function createCssMode(workerUrl, scriptImports) {
      return new TextMode_1.default(workerUrl, scriptImports);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createCssMode;
  });
  define('mode/createJavaScriptMode', ["require", "exports", './JavaScriptMode'], function(require, exports, JavaScriptMode_1) {
    "use strict";
    function createCssMode(workerUrl, scriptImports) {
      return new JavaScriptMode_1.default(workerUrl, scriptImports);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createCssMode;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/TypeScriptHighlightRules', ["require", "exports", "./JavaScriptHighlightRules"], function(require, exports, JavaScriptHighlightRules_1) {
    "use strict";
    var TypeScriptHighlightRiles = (function(_super) {
      __extends(TypeScriptHighlightRiles, _super);
      function TypeScriptHighlightRiles(options) {
        _super.call(this, options);
        var tsRules = [{
          token: ["keyword.operator.ts", "text", "variable.parameter.function.ts", "text"],
          regex: "\\b(module)(\\s*)([a-zA-Z0-9_?.$][\\w?.$]*)(\\s*\\{)"
        }, {
          token: ["storage.type.variable.ts", "text", "keyword.other.ts", "text"],
          regex: "(super)(\\s*\\()([a-zA-Z0-9,_?.$\\s]+\\s*)(\\))"
        }, {
          token: ["entity.name.function.ts", "paren.lparen", "paren.rparen"],
          regex: "([a-zA-Z_?.$][\\w?.$]*)(\\()(\\))"
        }, {
          token: ["variable.parameter.function.ts", "text", "variable.parameter.function.ts"],
          regex: "([a-zA-Z0-9_?.$][\\w?.$]*)(\\s*:\\s*)([a-zA-Z0-9_?.$][\\w?.$]*)"
        }, {
          token: ["keyword.operator.ts"],
          regex: "(?:\\b(constructor|declare|interface|as|AS|public|private|class|extends|export|super)\\b)"
        }, {
          token: ["storage.type.variable.ts"],
          regex: "(?:\\b(this\\.|string\\b|bool\\b|number)\\b)"
        }, {
          token: ["keyword.operator.ts", "storage.type.variable.ts", "keyword.operator.ts", "storage.type.variable.ts"],
          regex: "(class)(\\s+[a-zA-Z0-9_?.$][\\w?.$]*\\s+)(extends)(\\s+[a-zA-Z0-9_?.$][\\w?.$]*\\s+)?"
        }, {
          token: "keyword",
          regex: "(?:super|export|class|extends|import)\\b"
        }];
        var JSRules = new JavaScriptHighlightRules_1.default().getRules();
        JSRules.start = tsRules.concat(JSRules.start);
        this.$rules = JSRules;
      }
      return TypeScriptHighlightRiles;
    }(JavaScriptHighlightRules_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = TypeScriptHighlightRiles;
  });
  var __extends = (this && this.__extends) || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  define('mode/TypeScriptMode', ["require", "exports", "./JavaScriptMode", "./TypeScriptHighlightRules", "./behaviour/CstyleBehaviour", "./folding/CstyleFoldMode", "./MatchingBraceOutdent", "../worker/WorkerClient"], function(require, exports, JavaScriptMode_1, TypeScriptHighlightRules_1, CstyleBehaviour_1, CstyleFoldMode_1, MatchingBraceOutdent_1, WorkerClient_1) {
    "use strict";
    var TypeScriptMode = (function(_super) {
      __extends(TypeScriptMode, _super);
      function TypeScriptMode(workerUrl, scriptImports) {
        _super.call(this, workerUrl, scriptImports);
        this.$id = "ace/mode/typescript";
        this.HighlightRules = TypeScriptHighlightRules_1.default;
        this.$outdent = new MatchingBraceOutdent_1.default();
        this.$behaviour = new CstyleBehaviour_1.default();
        this.foldingRules = new CstyleFoldMode_1.default();
      }
      TypeScriptMode.prototype.createWorker = function(session) {
        var workerUrl = this.workerUrl;
        var scriptImports = this.scriptImports;
        var worker = new WorkerClient_1.default(workerUrl);
        worker.on("initAfter", function(event) {
          worker.attachToDocument(session.getDocument());
        });
        worker.on("initFail", function(message) {});
        worker.on("terminate", function() {
          worker.detachFromDocument();
          session.clearAnnotations();
        });
        worker.on('annotations', function(event) {
          var annotations = event.data;
          if (annotations.length > 0) {} else {}
          session._emit("annotations", {data: annotations});
        });
        worker.on("getFileNames", function(event) {
          session._emit("getFileNames", {data: event.data});
        });
        worker.init(scriptImports, 'ace-workers.js', 'TypeScriptWorker');
        return worker;
      };
      ;
      return TypeScriptMode;
    }(JavaScriptMode_1.default));
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = TypeScriptMode;
  });
  define('mode/createTypeScriptMode', ["require", "exports", './TypeScriptMode'], function(require, exports, TypeScriptMode_1) {
    "use strict";
    function createTypeScriptMode(workerUrl, scriptImports) {
      return new TypeScriptMode_1.default(workerUrl, scriptImports);
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = createTypeScriptMode;
  });
  define('edit', ["require", "exports", './createDocument', './createEditor', './createEditSession', './createRenderer', './createUndoManager'], function(require, exports, createDocument_1, createEditor_1, createEditSession_1, createRenderer_1, createUndoManager_1) {
    "use strict";
    function edit(container) {
      var text = "";
      if (container && /input|textarea/i.test(container.tagName)) {
        var oldNode = container;
        text = oldNode.value;
        container = container.ownerDocument.createElement('pre');
        oldNode.parentNode.replaceChild(container, oldNode);
      } else if (container) {
        text = container.innerHTML;
        container.innerHTML = "";
      }
      var doc = createDocument_1.default(text);
      var session = createEditSession_1.default(doc);
      var renderer = createRenderer_1.default(container);
      var editor = createEditor_1.default(renderer, session);
      var undoManager = createUndoManager_1.default();
      editor.getSession().setUndoManager(undoManager);
      return editor;
    }
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = edit;
  });
  define('ace', ["require", "exports", "./createAnchor", "./createDocument", "./createEditor", "./createEditSession", "./createFold", "./createFoldLine", "./createRange", "./createRenderer", "./createTokenizer", "./createUndoManager", "./createWorkerClient", "./workspace/createWorkspace", "./mode/createCssMode", "./mode/createHtmlMode", "./mode/createTextMode", "./mode/createJavaScriptMode", "./mode/createTypeScriptMode", "./edit"], function(require, exports, createAnchor_1, createDocument_1, createEditor_1, createEditSession_1, createFold_1, createFoldLine_1, createRange_1, createRenderer_1, createTokenizer_1, createUndoManager_1, createWorkerClient_1, createWorkspace_1, createCssMode_1, createHtmlMode_1, createTextMode_1, createJavaScriptMode_1, createTypeScriptMode_1, edit_1) {
    'use strict';
    var ace = {
      get createAnchor() {
        return createAnchor_1.default;
      },
      get createDocument() {
        return createDocument_1.default;
      },
      get createEditor() {
        return createEditor_1.default;
      },
      get createEditSession() {
        return createEditSession_1.default;
      },
      get createFold() {
        return createFold_1.default;
      },
      get createFoldLine() {
        return createFoldLine_1.default;
      },
      get createRange() {
        return createRange_1.default;
      },
      get createRenderer() {
        return createRenderer_1.default;
      },
      get createTokenizer() {
        return createTokenizer_1.default;
      },
      get createUndoManager() {
        return createUndoManager_1.default;
      },
      get createWorkerClient() {
        return createWorkerClient_1.default;
      },
      get createWorkspace() {
        return createWorkspace_1.default;
      },
      get edit() {
        return edit_1.default;
      },
      get createCssMode() {
        return createCssMode_1.default;
      },
      get createHtmlMode() {
        return createHtmlMode_1.default;
      },
      get createTextMode() {
        return createTextMode_1.default;
      },
      get createJavaScriptMode() {
        return createJavaScriptMode_1.default;
      },
      get createTypeScriptMode() {
        return createTypeScriptMode_1.default;
      }
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = ace;
  });
  var library = require('ace').default;
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = library;
  } else if (globalDefine) {
    (function(define) {
      define(function() {
        return library;
      });
    }(globalDefine));
  } else {
    global['ace'] = library;
  }
}(this));

})();
(function() {
var define = System.amdDefine;
define("github:ace2ts/ace@0.1.143.js", ["github:ace2ts/ace@0.1.143/dist/ace.js"], function(main) {
  return main;
});

})();
System.register("js/directives/workspace/detect1x.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function exists(fileName, doodle) {
    var file = doodle.files[fileName];
    return typeof file === 'object';
  }
  function detect1x(doodle) {
    if (exists('index.html', doodle) && exists('script.ts', doodle) && exists('extras.ts', doodle) && exists('style.less', doodle)) {
      var indexFile = doodle.files['index.html'];
      return indexFile.content.indexOf("// LIBS-MARKER") >= 0;
    } else {
      return false;
    }
  }
  exports_1("default", detect1x);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/utils/doodleGroom.js", ["../services/doodles/DoodleFile", "./modeFromName"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var DoodleFile_1,
      modeFromName_1;
  function isString(s) {
    return typeof s === 'string';
  }
  function migrate1xTo2x(doodle) {
    var FILENAME_HTML = 'index.html';
    var PROPERTY_HTML = 'html';
    var FILENAME_CODE = 'script.ts';
    var PROPERTY_CODE = 'code';
    var FILENAME_LIBS = 'extras.ts';
    var PROPERTY_LIBS = 'libs';
    var FILENAME_LESS = 'style.less';
    var PROPERTY_LESS = 'less';
    if (isString(doodle[PROPERTY_HTML]) && isString(doodle[PROPERTY_CODE]) && isString(doodle[PROPERTY_LIBS]) && isString(doodle[PROPERTY_LESS])) {
      doodle.files = {};
      doodle.files[FILENAME_HTML] = new DoodleFile_1.default();
      doodle.files[FILENAME_HTML].content = doodle[PROPERTY_HTML];
      doodle.files[FILENAME_HTML].language = modeFromName_1.default(FILENAME_HTML);
      delete doodle[PROPERTY_HTML];
      doodle.files[FILENAME_CODE] = new DoodleFile_1.default();
      doodle.files[FILENAME_CODE].content = doodle[PROPERTY_CODE];
      doodle.files[FILENAME_CODE].language = modeFromName_1.default(FILENAME_CODE);
      delete doodle[PROPERTY_CODE];
      doodle.files[FILENAME_LIBS] = new DoodleFile_1.default();
      doodle.files[FILENAME_LIBS].content = doodle[PROPERTY_LIBS];
      doodle.files[FILENAME_LIBS].language = modeFromName_1.default(FILENAME_LIBS);
      delete doodle[PROPERTY_LIBS];
      doodle.files[FILENAME_LESS] = new DoodleFile_1.default();
      doodle.files[FILENAME_LESS].content = doodle[PROPERTY_LESS];
      doodle.files[FILENAME_LESS].language = modeFromName_1.default(FILENAME_LESS);
      delete doodle[PROPERTY_LESS];
    }
    return doodle;
  }
  function default_1(doodle) {
    return migrate1xTo2x(doodle);
  }
  exports_1("default", default_1);
  return {
    setters: [function(DoodleFile_1_1) {
      DoodleFile_1 = DoodleFile_1_1;
    }, function(modeFromName_1_1) {
      modeFromName_1 = modeFromName_1_1;
    }],
    execute: function() {}
  };
});

System.register("js/utils/StringSet.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var StringSet;
  return {
    setters: [],
    execute: function() {
      StringSet = (function() {
        function StringSet() {
          this.data = {};
        }
        StringSet.prototype.add = function(member) {
          this.data[member] = true;
        };
        StringSet.prototype.size = function() {
          return Object.keys(this.data).length;
        };
        StringSet.prototype.each = function(callback) {
          for (var member in this.data) {
            if (this.data.hasOwnProperty(member)) {
              callback(member);
            }
          }
        };
        StringSet.prototype.toArray = function() {
          var members = [];
          for (var member in this.data) {
            if (this.data.hasOwnProperty(member)) {
              members.push(member);
            }
          }
          return members;
        };
        return StringSet;
      }());
      exports_1("default", StringSet);
    }
  };
});

System.registerDynamic("github:geometryzen/davinci-mathscript@1.0.11/dist/davinci-mathscript.min.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  !function(a, b) {
    var c,
        d,
        b,
        e = a.define;
    !function(a) {
      function e(a, b) {
        return u.call(a, b);
      }
      function f(a, b) {
        var c,
            d,
            e,
            f,
            g,
            h,
            i,
            j,
            k,
            l,
            m,
            n = b && b.split("/"),
            o = s.map,
            p = o && o["*"] || {};
        if (a && "." === a.charAt(0))
          if (b) {
            for (a = a.split("/"), g = a.length - 1, s.nodeIdCompat && w.test(a[g]) && (a[g] = a[g].replace(w, "")), a = n.slice(0, n.length - 1).concat(a), k = 0; k < a.length; k += 1)
              if (m = a[k], "." === m)
                a.splice(k, 1), k -= 1;
              else if (".." === m) {
                if (1 === k && (".." === a[2] || ".." === a[0]))
                  break;
                k > 0 && (a.splice(k - 1, 2), k -= 2);
              }
            a = a.join("/");
          } else
            0 === a.indexOf("./") && (a = a.substring(2));
        if ((n || p) && o) {
          for (c = a.split("/"), k = c.length; k > 0; k -= 1) {
            if (d = c.slice(0, k).join("/"), n)
              for (l = n.length; l > 0; l -= 1)
                if (e = o[n.slice(0, l).join("/")], e && (e = e[d])) {
                  f = e, h = k;
                  break;
                }
            if (f)
              break;
            !i && p && p[d] && (i = p[d], j = k);
          }
          !f && i && (f = i, h = j), f && (c.splice(0, h, f), a = c.join("/"));
        }
        return a;
      }
      function g(b, c) {
        return function() {
          var d = v.call(arguments, 0);
          return "string" != typeof d[0] && 1 === d.length && d.push(null), n.apply(a, d.concat([b, c]));
        };
      }
      function h(a) {
        return function(b) {
          return f(b, a);
        };
      }
      function i(a) {
        return function(b) {
          q[a] = b;
        };
      }
      function j(b) {
        if (e(r, b)) {
          var c = r[b];
          delete r[b], t[b] = !0, m.apply(a, c);
        }
        if (!e(q, b) && !e(t, b))
          throw new Error("No " + b);
        return q[b];
      }
      function k(a) {
        var b,
            c = a ? a.indexOf("!") : -1;
        return c > -1 && (b = a.substring(0, c), a = a.substring(c + 1, a.length)), [b, a];
      }
      function l(a) {
        return function() {
          return s && s.config && s.config[a] || {};
        };
      }
      var m,
          n,
          o,
          p,
          q = {},
          r = {},
          s = {},
          t = {},
          u = Object.prototype.hasOwnProperty,
          v = [].slice,
          w = /\.js$/;
      o = function(a, b) {
        var c,
            d = k(a),
            e = d[0];
        return a = d[1], e && (e = f(e, b), c = j(e)), e ? a = c && c.normalize ? c.normalize(a, h(b)) : f(a, b) : (a = f(a, b), d = k(a), e = d[0], a = d[1], e && (c = j(e))), {
          f: e ? e + "!" + a : a,
          n: a,
          pr: e,
          p: c
        };
      }, p = {
        require: function(a) {
          return g(a);
        },
        exports: function(a) {
          var b = q[a];
          return "undefined" != typeof b ? b : q[a] = {};
        },
        module: function(a) {
          return {
            id: a,
            uri: "",
            exports: q[a],
            config: l(a)
          };
        }
      }, m = function(b, c, d, f) {
        var h,
            k,
            l,
            m,
            n,
            s,
            u = [],
            v = typeof d;
        if (f = f || b, "undefined" === v || "function" === v) {
          for (c = !c.length && d.length ? ["require", "exports", "module"] : c, n = 0; n < c.length; n += 1)
            if (m = o(c[n], f), k = m.f, "require" === k)
              u[n] = p.require(b);
            else if ("exports" === k)
              u[n] = p.exports(b), s = !0;
            else if ("module" === k)
              h = u[n] = p.module(b);
            else if (e(q, k) || e(r, k) || e(t, k))
              u[n] = j(k);
            else {
              if (!m.p)
                throw new Error(b + " missing " + k);
              m.p.load(m.n, g(f, !0), i(k), {}), u[n] = q[k];
            }
          l = d ? d.apply(q[b], u) : void 0, b && (h && h.exports !== a && h.exports !== q[b] ? q[b] = h.exports : l === a && s || (q[b] = l));
        } else
          b && (q[b] = d);
      }, c = d = n = function(b, c, d, e, f) {
        if ("string" == typeof b)
          return p[b] ? p[b](c) : j(o(b, c).f);
        if (!b.splice) {
          if (s = b, s.deps && n(s.deps, s.callback), !c)
            return;
          c.splice ? (b = c, c = d, d = null) : b = a;
        }
        return c = c || function() {}, "function" == typeof d && (d = e, e = f), e ? m(a, b, c, d) : setTimeout(function() {
          m(a, b, c, d);
        }, 4), n;
      }, n.config = function(a) {
        return n(a);
      }, c._defined = q, b = function(a, b, c) {
        if ("string" != typeof a)
          throw new Error("See almond README: incorrect module build, no module name");
        b.splice || (c = b, b = []), e(q, a) || e(r, a) || (r[a] = [a, b, c]);
      }, b.amd = {jQuery: !0};
    }(), b("../vendor/almond/almond", function() {}), b("davinci-mathscript/core", ["require", "exports"], function() {
      var a = {VERSION: "1.0.11"};
      return a;
    }), b("davinci-mathscript/esprima", ["require", "exports"], function() {
      function a(a, b) {
        if (!a)
          throw new Error("ASSERT: " + b);
      }
      function b(a) {
        return a >= 48 && 57 >= a;
      }
      function c(a) {
        return "0123456789abcdefABCDEF".indexOf(a) >= 0;
      }
      function d(a) {
        return "01234567".indexOf(a) >= 0;
      }
      function e(a) {
        return 32 === a || 9 === a || 11 === a || 12 === a || 160 === a || a >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(a) >= 0;
      }
      function f(a) {
        return 10 === a || 13 === a || 8232 === a || 8233 === a;
      }
      function g(a) {
        return 36 === a || 95 === a || a >= 65 && 90 >= a || a >= 97 && 122 >= a || 92 === a || a >= 128 && ub.NonAsciiIdentifierStart.test(String.fromCharCode(a));
      }
      function h(a) {
        return 36 === a || 95 === a || a >= 65 && 90 >= a || a >= 97 && 122 >= a || a >= 48 && 57 >= a || 92 === a || a >= 128 && ub.NonAsciiIdentifierPart.test(String.fromCharCode(a));
      }
      function i(a) {
        switch (a) {
          case "class":
          case "enum":
          case "export":
          case "extends":
          case "import":
          case "super":
            return !0;
          default:
            return !1;
        }
      }
      function j(a) {
        switch (a) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "yield":
          case "let":
            return !0;
          default:
            return !1;
        }
      }
      function k(a) {
        return "eval" === a || "arguments" === a;
      }
      function l(a) {
        if (wb && j(a))
          return !0;
        switch (a.length) {
          case 2:
            return "if" === a || "in" === a || "do" === a;
          case 3:
            return "var" === a || "for" === a || "new" === a || "try" === a || "let" === a;
          case 4:
            return "this" === a || "else" === a || "case" === a || "void" === a || "with" === a || "enum" === a;
          case 5:
            return "while" === a || "break" === a || "catch" === a || "throw" === a || "const" === a || "yield" === a || "class" === a || "super" === a;
          case 6:
            return "return" === a || "typeof" === a || "delete" === a || "switch" === a || "export" === a || "import" === a;
          case 7:
            return "default" === a || "finally" === a || "extends" === a;
          case 8:
            return "function" === a || "continue" === a || "debugger" === a;
          case 10:
            return "instanceof" === a;
          default:
            return !1;
        }
      }
      function m(b, c, d, e, f) {
        var g;
        a("number" == typeof d, "Comment must have valid position"), Cb.lastCommentStart >= d || (Cb.lastCommentStart = d, g = {
          type: b,
          value: c
        }, Db.range && (g.range = [d, e]), Db.loc && (g.loc = f), Db.comments.push(g), Db.attachComment && (Db.leadingComments.push(g), Db.trailingComments.push(g)));
      }
      function n(a) {
        var b,
            c,
            d,
            e;
        for (b = xb - a, c = {start: {
            line: yb,
            column: xb - zb - a
          }}; Ab > xb; )
          if (d = vb.charCodeAt(xb), ++xb, f(d))
            return Db.comments && (e = vb.slice(b + a, xb - 1), c.end = {
              line: yb,
              column: xb - zb - 1
            }, m("Line", e, b, xb - 1, c)), 13 === d && 10 === vb.charCodeAt(xb) && ++xb, ++yb, void(zb = xb);
        Db.comments && (e = vb.slice(b + a, xb), c.end = {
          line: yb,
          column: xb - zb
        }, m("Line", e, b, xb, c));
      }
      function o() {
        var a,
            b,
            c,
            d;
        for (Db.comments && (a = xb - 2, b = {start: {
            line: yb,
            column: xb - zb - 2
          }}); Ab > xb; )
          if (c = vb.charCodeAt(xb), f(c))
            13 === c && 10 === vb.charCodeAt(xb + 1) && ++xb, ++yb, ++xb, zb = xb, xb >= Ab && X();
          else if (42 === c) {
            if (47 === vb.charCodeAt(xb + 1))
              return ++xb, ++xb, void(Db.comments && (d = vb.slice(a + 2, xb - 2), b.end = {
                line: yb,
                column: xb - zb
              }, m("Block", d, a, xb, b)));
            ++xb;
          } else
            ++xb;
        X();
      }
      function p() {
        var a,
            b;
        for (b = 0 === xb; Ab > xb; )
          if (a = vb.charCodeAt(xb), e(a))
            ++xb;
          else if (f(a))
            ++xb, 13 === a && 10 === vb.charCodeAt(xb) && ++xb, ++yb, zb = xb, b = !0;
          else if (47 === a)
            if (a = vb.charCodeAt(xb + 1), 47 === a)
              ++xb, ++xb, n(2), b = !0;
            else {
              if (42 !== a)
                break;
              ++xb, ++xb, o();
            }
          else if (b && 45 === a) {
            if (45 !== vb.charCodeAt(xb + 1) || 62 !== vb.charCodeAt(xb + 2))
              break;
            xb += 3, n(3);
          } else {
            if (60 !== a)
              break;
            if ("!--" !== vb.slice(xb + 1, xb + 4))
              break;
            ++xb, ++xb, ++xb, ++xb, n(4);
          }
      }
      function q(a) {
        var b,
            d,
            e,
            f = 0;
        for (d = "u" === a ? 4 : 2, b = 0; d > b; ++b) {
          if (!(Ab > xb && c(vb[xb])))
            return "";
          e = vb[xb++], f = 16 * f + "0123456789abcdef".indexOf(e.toLowerCase());
        }
        return String.fromCharCode(f);
      }
      function r() {
        var a,
            b,
            d,
            e;
        for (a = vb[xb], b = 0, "}" === a && X(); Ab > xb && (a = vb[xb++], c(a)); )
          b = 16 * b + "0123456789abcdef".indexOf(a.toLowerCase());
        return (b > 1114111 || "}" !== a) && X(), 65535 >= b ? String.fromCharCode(b) : (d = (b - 65536 >> 10) + 55296, e = (b - 65536 & 1023) + 56320, String.fromCharCode(d, e));
      }
      function s() {
        var a,
            b;
        for (a = vb.charCodeAt(xb++), b = String.fromCharCode(a), 92 === a && (117 !== vb.charCodeAt(xb) && X(), ++xb, a = q("u"), a && "\\" !== a && g(a.charCodeAt(0)) || X(), b = a); Ab > xb && (a = vb.charCodeAt(xb), h(a)); )
          ++xb, b += String.fromCharCode(a), 92 === a && (b = b.substr(0, b.length - 1), 117 !== vb.charCodeAt(xb) && X(), ++xb, a = q("u"), a && "\\" !== a && h(a.charCodeAt(0)) || X(), b += a);
        return b;
      }
      function t() {
        var a,
            b;
        for (a = xb++; Ab > xb; ) {
          if (b = vb.charCodeAt(xb), 92 === b)
            return xb = a, s();
          if (!h(b))
            break;
          ++xb;
        }
        return vb.slice(a, xb);
      }
      function u() {
        var a,
            b,
            c;
        return a = xb, b = 92 === vb.charCodeAt(xb) ? s() : t(), c = 1 === b.length ? nb.Identifier : l(b) ? nb.Keyword : "null" === b ? nb.NullLiteral : "true" === b || "false" === b ? nb.BooleanLiteral : nb.Identifier, {
          type: c,
          value: b,
          lineNumber: yb,
          lineStart: zb,
          start: a,
          end: xb
        };
      }
      function v() {
        var a,
            b,
            c,
            d,
            e = xb,
            f = vb.charCodeAt(xb),
            g = vb[xb];
        switch (f) {
          case 46:
          case 40:
          case 41:
          case 59:
          case 44:
          case 123:
          case 125:
          case 91:
          case 93:
          case 58:
          case 63:
          case 126:
            return ++xb, Db.tokenize && (40 === f ? Db.openParenToken = Db.tokens.length : 123 === f && (Db.openCurlyToken = Db.tokens.length)), {
              type: nb.Punctuator,
              value: String.fromCharCode(f),
              lineNumber: yb,
              lineStart: zb,
              start: e,
              end: xb
            };
          default:
            if (a = vb.charCodeAt(xb + 1), 61 === a)
              switch (f) {
                case 43:
                case 45:
                case 47:
                case 60:
                case 62:
                case 94:
                case 124:
                case 37:
                case 38:
                case 42:
                  return xb += 2, {
                    type: nb.Punctuator,
                    value: String.fromCharCode(f) + String.fromCharCode(a),
                    lineNumber: yb,
                    lineStart: zb,
                    start: e,
                    end: xb
                  };
                case 33:
                case 61:
                  return xb += 2, 61 === vb.charCodeAt(xb) && ++xb, {
                    type: nb.Punctuator,
                    value: vb.slice(e, xb),
                    lineNumber: yb,
                    lineStart: zb,
                    start: e,
                    end: xb
                  };
              }
        }
        return d = vb.substr(xb, 4), ">>>=" === d ? (xb += 4, {
          type: nb.Punctuator,
          value: d,
          lineNumber: yb,
          lineStart: zb,
          start: e,
          end: xb
        }) : (c = d.substr(0, 3), ">>>" === c || "<<=" === c || ">>=" === c ? (xb += 3, {
          type: nb.Punctuator,
          value: c,
          lineNumber: yb,
          lineStart: zb,
          start: e,
          end: xb
        }) : (b = c.substr(0, 2), g === b[1] && "+-<>&|".indexOf(g) >= 0 || "=>" === b ? (xb += 2, {
          type: nb.Punctuator,
          value: b,
          lineNumber: yb,
          lineStart: zb,
          start: e,
          end: xb
        }) : "<>=!+-*%&|^/".indexOf(g) >= 0 ? (++xb, {
          type: nb.Punctuator,
          value: g,
          lineNumber: yb,
          lineStart: zb,
          start: e,
          end: xb
        }) : void X()));
      }
      function w(a) {
        for (var b = ""; Ab > xb && c(vb[xb]); )
          b += vb[xb++];
        return 0 === b.length && X(), g(vb.charCodeAt(xb)) && X(), {
          type: nb.NumericLiteral,
          value: parseInt("0x" + b, 16),
          lineNumber: yb,
          lineStart: zb,
          start: a,
          end: xb
        };
      }
      function x(a) {
        var c,
            d;
        for (d = ""; Ab > xb && (c = vb[xb], "0" === c || "1" === c); )
          d += vb[xb++];
        return 0 === d.length && X(), Ab > xb && (c = vb.charCodeAt(xb), (g(c) || b(c)) && X()), {
          type: nb.NumericLiteral,
          value: parseInt(d, 2),
          lineNumber: yb,
          lineStart: zb,
          start: a,
          end: xb
        };
      }
      function y(a, c) {
        var e,
            f;
        for (d(a) ? (f = !0, e = "0" + vb[xb++]) : (f = !1, ++xb, e = ""); Ab > xb && d(vb[xb]); )
          e += vb[xb++];
        return f || 0 !== e.length || X(), (g(vb.charCodeAt(xb)) || b(vb.charCodeAt(xb))) && X(), {
          type: nb.NumericLiteral,
          value: parseInt(e, 8),
          octal: f,
          lineNumber: yb,
          lineStart: zb,
          start: c,
          end: xb
        };
      }
      function z() {
        var a,
            b;
        for (a = xb + 1; Ab > a; ++a) {
          if (b = vb[a], "8" === b || "9" === b)
            return !1;
          if (!d(b))
            return !0;
        }
        return !0;
      }
      function A() {
        var c,
            e,
            f;
        if (f = vb[xb], a(b(f.charCodeAt(0)) || "." === f, "Numeric literal must start with a decimal digit or a decimal point"), e = xb, c = "", "." !== f) {
          if (c = vb[xb++], f = vb[xb], "0" === c) {
            if ("x" === f || "X" === f)
              return ++xb, w(e);
            if ("b" === f || "B" === f)
              return ++xb, x(e);
            if ("o" === f || "O" === f)
              return y(f, e);
            if (d(f) && z())
              return y(f, e);
          }
          for (; b(vb.charCodeAt(xb)); )
            c += vb[xb++];
          f = vb[xb];
        }
        if ("." === f) {
          for (c += vb[xb++]; b(vb.charCodeAt(xb)); )
            c += vb[xb++];
          f = vb[xb];
        }
        if ("e" === f || "E" === f)
          if (c += vb[xb++], f = vb[xb], ("+" === f || "-" === f) && (c += vb[xb++]), b(vb.charCodeAt(xb)))
            for (; b(vb.charCodeAt(xb)); )
              c += vb[xb++];
          else
            X();
        return g(vb.charCodeAt(xb)) && X(), {
          type: nb.NumericLiteral,
          value: parseFloat(c),
          lineNumber: yb,
          lineStart: zb,
          start: e,
          end: xb
        };
      }
      function B() {
        var b,
            c,
            e,
            g,
            h,
            i,
            j,
            k,
            l = "",
            m = !1;
        for (j = yb, k = zb, b = vb[xb], a("'" === b || '"' === b, "String literal must starts with a quote"), c = xb, ++xb; Ab > xb; ) {
          if (e = vb[xb++], e === b) {
            b = "";
            break;
          }
          if ("\\" === e)
            if (e = vb[xb++], e && f(e.charCodeAt(0)))
              ++yb, "\r" === e && "\n" === vb[xb] && ++xb, zb = xb;
            else
              switch (e) {
                case "u":
                case "x":
                  "{" === vb[xb] ? (++xb, l += r()) : (i = xb, h = q(e), h ? l += h : (xb = i, l += e));
                  break;
                case "n":
                  l += "\n";
                  break;
                case "r":
                  l += "\r";
                  break;
                case "t":
                  l += "	";
                  break;
                case "b":
                  l += "\b";
                  break;
                case "f":
                  l += "\f";
                  break;
                case "v":
                  l += "";
                  break;
                default:
                  d(e) ? (g = "01234567".indexOf(e), 0 !== g && (m = !0), Ab > xb && d(vb[xb]) && (m = !0, g = 8 * g + "01234567".indexOf(vb[xb++]), "0123".indexOf(e) >= 0 && Ab > xb && d(vb[xb]) && (g = 8 * g + "01234567".indexOf(vb[xb++]))), l += String.fromCharCode(g)) : l += e;
              }
          else {
            if (f(e.charCodeAt(0)))
              break;
            l += e;
          }
        }
        return "" !== b && X(), {
          type: nb.StringLiteral,
          value: l,
          octal: m,
          startLineNumber: j,
          startLineStart: k,
          lineNumber: yb,
          lineStart: zb,
          start: c,
          end: xb
        };
      }
      function C(a, b) {
        var c,
            d = a;
        b.indexOf("u") >= 0 && (d = d.replace(/\\u\{([0-9a-fA-F]+)\}/g, function(a, b) {
          return parseInt(b, 16) <= 1114111 ? "x" : void U(tb.InvalidRegExp);
        }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"));
        try {
          c = new RegExp(d);
        } catch (e) {
          U(tb.InvalidRegExp);
        }
        try {
          return new RegExp(a, b);
        } catch (f) {
          return null;
        }
      }
      function D() {
        var b,
            c,
            d,
            e,
            g;
        for (b = vb[xb], a("/" === b, "Regular expression literal must start with a slash"), c = vb[xb++], d = !1, e = !1; Ab > xb; )
          if (b = vb[xb++], c += b, "\\" === b)
            b = vb[xb++], f(b.charCodeAt(0)) && U(tb.UnterminatedRegExp), c += b;
          else if (f(b.charCodeAt(0)))
            U(tb.UnterminatedRegExp);
          else if (d)
            "]" === b && (d = !1);
          else {
            if ("/" === b) {
              e = !0;
              break;
            }
            "[" === b && (d = !0);
          }
        return e || U(tb.UnterminatedRegExp), g = c.substr(1, c.length - 2), {
          value: g,
          literal: c
        };
      }
      function E() {
        var a,
            b,
            c,
            d;
        for (b = "", c = ""; Ab > xb && (a = vb[xb], h(a.charCodeAt(0))); )
          if (++xb, "\\" === a && Ab > xb)
            if (a = vb[xb], "u" === a) {
              if (++xb, d = xb, a = q("u"))
                for (c += a, b += "\\u"; xb > d; ++d)
                  b += vb[d];
              else
                xb = d, c += "u", b += "\\u";
              Y();
            } else
              b += "\\", Y();
          else
            c += a, b += a;
        return {
          value: c,
          literal: b
        };
      }
      function F() {
        var a,
            b,
            c,
            d;
        return Bb = null, p(), a = xb, b = D(), c = E(), d = C(b.value, c.value), Db.tokenize ? {
          type: nb.RegularExpression,
          value: d,
          regex: {
            pattern: b.value,
            flags: c.value
          },
          lineNumber: yb,
          lineStart: zb,
          start: a,
          end: xb
        } : {
          literal: b.literal + c.literal,
          value: d,
          regex: {
            pattern: b.value,
            flags: c.value
          },
          start: a,
          end: xb
        };
      }
      function G() {
        var a,
            b,
            c,
            d;
        return p(), a = xb, b = {start: {
            line: yb,
            column: xb - zb
          }}, c = F(), b.end = {
          line: yb,
          column: xb - zb
        }, Db.tokenize || (Db.tokens.length > 0 && (d = Db.tokens[Db.tokens.length - 1], d.range[0] === a && "Punctuator" === d.type && ("/" === d.value || "/=" === d.value) && Db.tokens.pop()), Db.tokens.push({
          type: "RegularExpression",
          value: c.literal,
          regex: c.regex,
          range: [a, xb],
          loc: b
        })), c;
      }
      function H(a) {
        return a.type === nb.Identifier || a.type === nb.Keyword || a.type === nb.BooleanLiteral || a.type === nb.NullLiteral;
      }
      function I() {
        var a,
            b;
        if (a = Db.tokens[Db.tokens.length - 1], !a)
          return G();
        if ("Punctuator" === a.type) {
          if ("]" === a.value)
            return v();
          if (")" === a.value)
            return b = Db.tokens[Db.openParenToken - 1], !b || "Keyword" !== b.type || "if" !== b.value && "while" !== b.value && "for" !== b.value && "with" !== b.value ? v() : G();
          if ("}" === a.value) {
            if (Db.tokens[Db.openCurlyToken - 3] && "Keyword" === Db.tokens[Db.openCurlyToken - 3].type) {
              if (b = Db.tokens[Db.openCurlyToken - 4], !b)
                return v();
            } else {
              if (!Db.tokens[Db.openCurlyToken - 4] || "Keyword" !== Db.tokens[Db.openCurlyToken - 4].type)
                return v();
              if (b = Db.tokens[Db.openCurlyToken - 5], !b)
                return G();
            }
            return pb.indexOf(b.value) >= 0 ? v() : G();
          }
          return G();
        }
        return "Keyword" === a.type && "this" !== a.value ? G() : v();
      }
      function J() {
        var a;
        return p(), xb >= Ab ? {
          type: nb.EOF,
          lineNumber: yb,
          lineStart: zb,
          start: xb,
          end: xb
        } : (a = vb.charCodeAt(xb), g(a) ? u() : 40 === a || 41 === a || 59 === a ? v() : 39 === a || 34 === a ? B() : 46 === a ? b(vb.charCodeAt(xb + 1)) ? A() : v() : b(a) ? A() : Db.tokenize && 47 === a ? I() : v());
      }
      function K() {
        var a,
            b,
            c,
            d;
        return p(), a = {start: {
            line: yb,
            column: xb - zb
          }}, b = J(), a.end = {
          line: yb,
          column: xb - zb
        }, b.type !== nb.EOF && (c = vb.slice(b.start, b.end), d = {
          type: ob[b.type],
          value: c,
          range: [b.start, b.end],
          loc: a
        }, b.regex && (d.regex = {
          pattern: b.regex.pattern,
          flags: b.regex.flags
        }), Db.tokens.push(d)), b;
      }
      function L() {
        var a;
        return a = Bb, xb = a.end, yb = a.lineNumber, zb = a.lineStart, Bb = "undefined" != typeof Db.tokens ? K() : J(), xb = a.end, yb = a.lineNumber, zb = a.lineStart, a;
      }
      function M() {
        var a,
            b,
            c;
        a = xb, b = yb, c = zb, Bb = "undefined" != typeof Db.tokens ? K() : J(), xb = a, yb = b, zb = c;
      }
      function N() {
        this.line = yb, this.column = xb - zb;
      }
      function O() {
        this.start = new N, this.end = null;
      }
      function P(a) {
        this.start = a.type === nb.StringLiteral ? {
          line: a.startLineNumber,
          column: a.start - a.startLineStart
        } : {
          line: a.lineNumber,
          column: a.start - a.lineStart
        }, this.end = null;
      }
      function Q() {
        xb = Bb.start, Bb.type === nb.StringLiteral ? (yb = Bb.startLineNumber, zb = Bb.startLineStart) : (yb = Bb.lineNumber, zb = Bb.lineStart), Db.range && (this.range = [xb, 0]), Db.loc && (this.loc = new O);
      }
      function R(a) {
        Db.range && (this.range = [a.start, 0]), Db.loc && (this.loc = new P(a));
      }
      function S() {
        var a,
            b,
            c,
            d;
        return a = xb, b = yb, c = zb, p(), d = yb !== b, xb = a, yb = b, zb = c, d;
      }
      function T(a, b, c) {
        var d = new Error("Line " + a + ": " + c),
            e = d;
        return e.index = b, e.lineNumber = a, e.column = b - zb + 1, e.description = c, d;
      }
      function U(b) {
        var c,
            d;
        throw c = Array.prototype.slice.call(arguments, 1), d = b.replace(/%(\d)/g, function(b, d) {
          return a(d < c.length, "Message reference must be in range"), c[d];
        }), T(yb, xb, d);
      }
      function V(b) {
        var c,
            d,
            e;
        if (c = Array.prototype.slice.call(arguments, 1), d = b.replace(/%(\d)/g, function(b, d) {
          return a(d < c.length, "Message reference must be in range"), c[d];
        }), e = T(yb, xb, d), !Db.errors)
          throw e;
        Db.errors.push(e);
      }
      function W(a, b) {
        var c = tb.UnexpectedToken;
        return a && (c = b ? b : a.type === nb.EOF ? tb.UnexpectedEOS : a.type === nb.Identifier ? tb.UnexpectedIdentifier : a.type === nb.NumericLiteral ? tb.UnexpectedNumber : a.type === nb.StringLiteral ? tb.UnexpectedString : tb.UnexpectedToken, a.type === nb.Keyword && (i(a.value) ? c = tb.UnexpectedReserved : wb && j(a.value) && (c = tb.StrictReservedWord))), c = c.replace("%0", a ? a.value : "ILLEGAL"), a && "number" == typeof a.lineNumber ? T(a.lineNumber, a.start, c) : T(yb, xb, c);
      }
      function X(a, b) {
        throw W(a, b);
      }
      function Y(a, b) {
        var c = W(a, b);
        if (!Db.errors)
          throw c;
        Db.errors.push(c);
      }
      function Z(a) {
        var b = L();
        (b.type !== nb.Punctuator || b.value !== a) && X(b);
      }
      function $() {
        var a;
        Db.errors ? (a = Bb, a.type === nb.Punctuator && "," === a.value ? L() : a.type === nb.Punctuator && ";" === a.value ? (L(), Y(a)) : Y(a, tb.UnexpectedToken)) : Z(",");
      }
      function _(a) {
        var b = L();
        (b.type !== nb.Keyword || b.value !== a) && X(b);
      }
      function aa(a) {
        return Bb.type === nb.Punctuator && Bb.value === a;
      }
      function ba(a) {
        return Bb.type === nb.Keyword && Bb.value === a;
      }
      function ca() {
        var a;
        return Bb.type !== nb.Punctuator ? !1 : (a = Bb.value, "=" === a || "*=" === a || "/=" === a || "%=" === a || "+=" === a || "-=" === a || "<<=" === a || ">>=" === a || ">>>=" === a || "&=" === a || "^=" === a || "|=" === a);
      }
      function da() {
        var a,
            b = xb,
            c = yb,
            d = zb,
            e = Bb;
        return 59 === vb.charCodeAt(xb) || aa(";") ? void L() : (a = yb, p(), yb !== a ? (xb = b, yb = c, zb = d, void(Bb = e)) : void(Bb.type === nb.EOF || aa("}") || X(Bb)));
      }
      function ea(a) {
        return a.type === qb.Identifier || a.type === qb.MemberExpression;
      }
      function fa() {
        var a = [],
            b = new Q;
        for (Z("["); !aa("]"); )
          aa(",") ? (L(), a.push(null)) : (a.push(Ca()), aa("]") || Z(","));
        return L(), b.finishArrayExpression(a);
      }
      function ga(a, b) {
        var c,
            d,
            e = new Q;
        return c = wb, d = bb(), b && wb && k(a[0].name) && Y(b, tb.StrictParamName), wb = c, e.finishFunctionExpression(null, a, [], d);
      }
      function ha() {
        var a,
            b,
            c;
        return a = wb, wb = !0, b = eb(), c = ga(b.params), wb = a, c;
      }
      function ia() {
        var a,
            b = new Q;
        return a = L(), a.type === nb.StringLiteral || a.type === nb.NumericLiteral ? (wb && a.octal && Y(a, tb.StrictOctalLiteral), b.finishLiteral(a)) : b.finishIdentifier(a.value);
      }
      function ja() {
        var a,
            b,
            c,
            d,
            e,
            f = new Q;
        if (a = Bb, a.type === nb.Identifier)
          return c = ia(), "get" !== a.value || aa(":") || aa("(") ? "set" !== a.value || aa(":") || aa("(") ? aa(":") ? (L(), d = Ca(), f.finishProperty("init", c, d, !1, !1)) : aa("(") ? (d = ha(), f.finishProperty("init", c, d, !0, !1)) : (d = c, f.finishProperty("init", c, d, !1, !0)) : (b = ia(), Z("("), a = Bb, a.type !== nb.Identifier ? (Z(")"), Y(a), d = ga([])) : (e = [Ga()], Z(")"), d = ga(e, a)), f.finishProperty("set", b, d, !1, !1)) : (b = ia(), Z("("), Z(")"), d = ga([]), f.finishProperty("get", b, d, !1, !1));
        if (a.type === nb.EOF || a.type === nb.Punctuator)
          X(a);
        else {
          if (b = ia(), aa(":"))
            return L(), d = Ca(), f.finishProperty("init", b, d, !1, !1);
          if (aa("("))
            return d = ha(), f.finishProperty("init", b, d, !0, !1);
          X(L());
        }
      }
      function ka() {
        var a,
            b,
            c,
            d,
            e = [],
            f = {},
            g = String,
            h = new Q;
        for (Z("{"); !aa("}"); )
          a = ja(), b = a.key.type === qb.Identifier ? a.key.name : g(a.key.value), d = "init" === a.kind ? sb.Data : "get" === a.kind ? sb.Get : sb.Set, c = "$" + b, Object.prototype.hasOwnProperty.call(f, c) ? (f[c] === sb.Data ? wb && d === sb.Data ? V(tb.StrictDuplicateProperty) : d !== sb.Data && V(tb.AccessorDataProperty) : d === sb.Data ? V(tb.AccessorDataProperty) : f[c] & d && V(tb.AccessorGetSet), f[c] |= d) : f[c] = d, e.push(a), aa("}") || $();
        return Z("}"), h.finishObjectExpression(e);
      }
      function la() {
        var a;
        return Z("("), aa(")") ? (L(), rb.ArrowParameterPlaceHolder) : (++Cb.parenthesisCount, a = Da(), Z(")"), a);
      }
      function ma() {
        var a,
            b,
            c,
            d;
        if (aa("("))
          return la();
        if (aa("["))
          return fa();
        if (aa("{"))
          return ka();
        if (a = Bb.type, d = new Q, a === nb.Identifier)
          c = d.finishIdentifier(L().value);
        else if (a === nb.StringLiteral || a === nb.NumericLiteral)
          wb && Bb.octal && Y(Bb, tb.StrictOctalLiteral), c = d.finishLiteral(L());
        else if (a === nb.Keyword) {
          if (ba("function"))
            return gb();
          ba("this") ? (L(), c = d.finishThisExpression()) : X(L());
        } else
          a === nb.BooleanLiteral ? (b = L(), b.value = "true" === b.value, c = d.finishLiteral(b)) : a === nb.NullLiteral ? (b = L(), b.value = null, c = d.finishLiteral(b)) : aa("/") || aa("/=") ? (c = d.finishLiteral("undefined" != typeof Db.tokens ? G() : F()), M()) : X(L());
        return c;
      }
      function na() {
        var a = [];
        if (Z("("), !aa(")"))
          for (; Ab > xb && (a.push(Ca()), !aa(")")); )
            $();
        return Z(")"), a;
      }
      function oa() {
        var a,
            b = new Q;
        return a = L(), H(a) || X(a), b.finishIdentifier(a.value);
      }
      function pa() {
        return Z("."), oa();
      }
      function qa() {
        var a;
        return Z("["), a = Da(), Z("]"), a;
      }
      function ra() {
        var a,
            b,
            c = new Q;
        return _("new"), a = ta(), b = aa("(") ? na() : [], c.finishNewExpression(a, b);
      }
      function sa() {
        var a,
            b,
            c,
            d,
            e = Cb.allowIn;
        for (d = Bb, Cb.allowIn = !0, a = ba("new") ? ra() : ma(); ; )
          if (aa("."))
            c = pa(), a = new R(d).finishMemberExpression(".", a, c);
          else if (aa("("))
            b = na(), a = new R(d).finishCallExpression(a, b);
          else {
            if (!aa("["))
              break;
            c = qa(), a = new R(d).finishMemberExpression("[", a, c);
          }
        return Cb.allowIn = e, a;
      }
      function ta() {
        var b,
            c,
            d;
        for (a(Cb.allowIn, "callee of new expression always allow in keyword."), d = Bb, b = ba("new") ? ra() : ma(); ; )
          if (aa("["))
            c = qa(), b = new R(d).finishMemberExpression("[", b, c);
          else {
            if (!aa("."))
              break;
            c = pa(), b = new R(d).finishMemberExpression(".", b, c);
          }
        return b;
      }
      function ua() {
        var a,
            b,
            c = Bb;
        return a = sa(), Bb.type === nb.Punctuator && (!aa("++") && !aa("--") || S() || (wb && a.type === qb.Identifier && k(a.name) && V(tb.StrictLHSPostfix), ea(a) || V(tb.InvalidLHSInAssignment), b = L(), a = new R(c).finishPostfixExpression(b.value, a))), a;
      }
      function va() {
        var a,
            b,
            c;
        return Bb.type !== nb.Punctuator && Bb.type !== nb.Keyword ? b = ua() : aa("++") || aa("--") ? (c = Bb, a = L(), b = va(), wb && b.type === qb.Identifier && k(b.name) && V(tb.StrictLHSPrefix), ea(b) || V(tb.InvalidLHSInAssignment), b = new R(c).finishUnaryExpression(a.value, b)) : aa("+") || aa("-") || aa("~") || aa("!") ? (c = Bb, a = L(), b = va(), b = new R(c).finishUnaryExpression(a.value, b)) : ba("delete") || ba("void") || ba("typeof") ? (c = Bb, a = L(), b = va(), b = new R(c).finishUnaryExpression(a.value, b), wb && "delete" === b.operator && b.argument.type === qb.Identifier && V(tb.StrictDelete)) : b = ua(), b;
      }
      function wa(a, b) {
        var c = 0;
        if (a.type !== nb.Punctuator && a.type !== nb.Keyword)
          return 0;
        switch (a.value) {
          case "||":
            c = 1;
            break;
          case "&&":
            c = 2;
            break;
          case "&":
            c = 3;
            break;
          case "==":
          case "!=":
          case "===":
          case "!==":
            c = 4;
            break;
          case "<":
          case ">":
          case "<=":
          case ">=":
          case "instanceof":
            c = 5;
            break;
          case "in":
            c = b ? 6 : 0;
            break;
          case ">>>":
            c = 7;
            break;
          case "+":
          case "-":
            c = 8;
            break;
          case "*":
          case "/":
            c = 9;
            break;
          case "^":
            c = 10;
            break;
          case "|":
            c = 11;
            break;
          case "%":
          case "<<":
          case ">>":
            c = 12;
        }
        return c;
      }
      function xa() {
        var a,
            b,
            c,
            d,
            e,
            f,
            g,
            h,
            i,
            j;
        if (a = Bb, i = va(), i === rb.ArrowParameterPlaceHolder)
          return i;
        if (d = Bb, e = wa(d, Cb.allowIn), 0 === e)
          return i;
        for (d.prec = e, L(), b = [a, Bb], g = va(), f = [i, d, g]; (e = wa(Bb, Cb.allowIn)) > 0; ) {
          for (; f.length > 2 && e <= f[f.length - 2].prec; )
            g = f.pop(), h = f.pop().value, i = f.pop(), b.pop(), c = new R(b[b.length - 1]).finishBinaryExpression(h, i, g), f.push(c);
          d = L(), d.prec = e, f.push(d), b.push(Bb), c = va(), f.push(c);
        }
        for (j = f.length - 1, c = f[j], b.pop(); j > 1; )
          c = new R(b.pop()).finishBinaryExpression(f[j - 1].value, f[j - 2], c), j -= 2;
        return c;
      }
      function ya() {
        var a,
            b,
            c,
            d,
            e;
        return e = Bb, a = xa(), a === rb.ArrowParameterPlaceHolder ? a : (aa("?") && (L(), b = Cb.allowIn, Cb.allowIn = !0, c = Ca(), Cb.allowIn = b, Z(":"), d = Ca(), a = new R(e).finishConditionalExpression(a, c, d)), a);
      }
      function za() {
        return aa("{") ? bb() : Ca();
      }
      function Aa(a) {
        var b,
            c,
            d,
            e,
            f,
            g,
            h,
            i,
            j;
        for (e = [], f = [], g = 0, i = null, h = {paramSet: {}}, b = 0, c = a.length; c > b; b += 1)
          if (d = a[b], d.type === qb.Identifier)
            e.push(d), f.push(null), cb(h, d, d.name);
          else {
            if (d.type !== qb.AssignmentExpression)
              return null;
            e.push(d.left), f.push(d.right), ++g, cb(h, d.left, d.left.name);
          }
        return h.message === tb.StrictParamDupe && (j = wb ? h.stricted : h.firstRestricted, X(j, h.message)), 0 === g && (f = []), {
          params: e,
          defaults: f,
          rest: i,
          stricted: h.stricted,
          firstRestricted: h.firstRestricted,
          message: h.message
        };
      }
      function Ba(a, b) {
        var c,
            d;
        return Z("=>"), c = wb, d = za(), wb && a.firstRestricted && X(a.firstRestricted, a.message), wb && a.stricted && Y(a.stricted, a.message), wb = c, b.finishArrowFunctionExpression(a.params, a.defaults, d, d.type !== qb.BlockStatement);
      }
      function Ca() {
        var a,
            b,
            c,
            d,
            e,
            f;
        return a = Cb.parenthesisCount, f = Bb, b = Bb, c = ya(), c !== rb.ArrowParameterPlaceHolder && !aa("=>") || Cb.parenthesisCount !== a && Cb.parenthesisCount !== a + 1 || (c.type === qb.Identifier ? e = Aa([c]) : c.type === qb.AssignmentExpression ? e = Aa([c]) : c.type === qb.SequenceExpression ? e = Aa(c.expressions) : c === rb.ArrowParameterPlaceHolder && (e = Aa([])), !e) ? (ca() && (ea(c) || V(tb.InvalidLHSInAssignment), wb && c.type === qb.Identifier && k(c.name) && Y(b, tb.StrictLHSAssignment), b = L(), d = Ca(), c = new R(f).finishAssignmentExpression(b.value, c, d)), c) : Ba(e, new R(f));
      }
      function Da() {
        var a,
            b,
            c = Bb;
        if (a = Ca(), aa(",")) {
          for (b = [a]; Ab > xb && aa(","); )
            L(), b.push(Ca());
          a = new R(c).finishSequenceExpression(b);
        }
        return a;
      }
      function Ea() {
        for (var a,
            b = []; Ab > xb && !aa("}") && (a = hb(), "undefined" != typeof a); )
          b.push(a);
        return b;
      }
      function Fa() {
        var a,
            b = new Q;
        return Z("{"), a = Ea(), Z("}"), b.finishBlockStatement(a);
      }
      function Ga() {
        var a,
            b = new Q;
        return a = L(), a.type !== nb.Identifier && (wb && a.type === nb.Keyword && j(a.value) ? Y(a, tb.StrictReservedWord) : X(a)), b.finishIdentifier(a.value);
      }
      function Ha(a) {
        var b,
            c = null,
            d = new Q;
        return b = Ga(), wb && k(b.name) && V(tb.StrictVarName), "const" === a ? (Z("="), c = Ca()) : aa("=") && (L(), c = Ca()), d.finishVariableDeclarator(b, c);
      }
      function Ia(a) {
        var b = [];
        do {
          if (b.push(Ha(a)), !aa(","))
            break;
          L();
        } while (Ab > xb);
        return b;
      }
      function Ja(a) {
        var b;
        return _("var"), b = Ia(), da(), a.finishVariableDeclaration(b, "var");
      }
      function Ka(a) {
        var b,
            c = new Q;
        return _(a), b = Ia(a), da(), c.finishVariableDeclaration(b, a);
      }
      function La() {
        var a = new Q;
        return Z(";"), a.finishEmptyStatement();
      }
      function Ma(a) {
        var b = Da();
        return da(), a.finishExpressionStatement(b);
      }
      function Na(a) {
        var b,
            c,
            d;
        return _("if"), Z("("), b = Da(), Z(")"), c = ab(), ba("else") ? (L(), d = ab()) : d = null, a.finishIfStatement(b, c, d);
      }
      function Oa(a) {
        var b,
            c,
            d;
        return _("do"), d = Cb.inIteration, Cb.inIteration = !0, b = ab(), Cb.inIteration = d, _("while"), Z("("), c = Da(), Z(")"), aa(";") && L(), a.finishDoWhileStatement(b, c);
      }
      function Pa(a) {
        var b,
            c,
            d;
        return _("while"), Z("("), b = Da(), Z(")"), d = Cb.inIteration, Cb.inIteration = !0, c = ab(), Cb.inIteration = d, a.finishWhileStatement(b, c);
      }
      function Qa() {
        var a,
            b,
            c = new Q;
        return a = L(), b = Ia(), c.finishVariableDeclaration(b, a.value);
      }
      function Ra(a) {
        var b,
            c,
            d,
            e,
            f,
            g,
            h,
            i = Cb.allowIn;
        return b = c = d = null, _("for"), Z("("), aa(";") ? L() : (ba("var") || ba("let") ? (Cb.allowIn = !1, b = Qa(), Cb.allowIn = i, 1 === b.declarations.length && ba("in") && (L(), e = b, f = Da(), b = null)) : (Cb.allowIn = !1, b = Da(), Cb.allowIn = i, ba("in") && (ea(b) || V(tb.InvalidLHSInForIn), L(), e = b, f = Da(), b = null)), "undefined" == typeof e && Z(";")), "undefined" == typeof e && (aa(";") || (c = Da()), Z(";"), aa(")") || (d = Da())), Z(")"), h = Cb.inIteration, Cb.inIteration = !0, g = ab(), Cb.inIteration = h, "undefined" == typeof e ? a.finishForStatement(b, c, d, g) : a.finishForInStatement(e, f, g);
      }
      function Sa(a) {
        var b,
            c = null;
        return _("continue"), 59 === vb.charCodeAt(xb) ? (L(), Cb.inIteration || U(tb.IllegalContinue), a.finishContinueStatement(null)) : S() ? (Cb.inIteration || U(tb.IllegalContinue), a.finishContinueStatement(null)) : (Bb.type === nb.Identifier && (c = Ga(), b = "$" + c.name, Object.prototype.hasOwnProperty.call(Cb.labelSet, b) || U(tb.UnknownLabel, c.name)), da(), null !== c || Cb.inIteration || U(tb.IllegalContinue), a.finishContinueStatement(c));
      }
      function Ta(a) {
        var b,
            c = null;
        return _("break"), 59 === vb.charCodeAt(xb) ? (L(), Cb.inIteration || Cb.inSwitch || U(tb.IllegalBreak), a.finishBreakStatement(null)) : S() ? (Cb.inIteration || Cb.inSwitch || U(tb.IllegalBreak), a.finishBreakStatement(null)) : (Bb.type === nb.Identifier && (c = Ga(), b = "$" + c.name, Object.prototype.hasOwnProperty.call(Cb.labelSet, b) || U(tb.UnknownLabel, c.name)), da(), null !== c || Cb.inIteration || Cb.inSwitch || U(tb.IllegalBreak), a.finishBreakStatement(c));
      }
      function Ua(a) {
        var b = null;
        return _("return"), Cb.inFunctionBody || V(tb.IllegalReturn), 32 === vb.charCodeAt(xb) && g(vb.charCodeAt(xb + 1)) ? (b = Da(), da(), a.finishReturnStatement(b)) : S() ? a.finishReturnStatement(null) : (aa(";") || aa("}") || Bb.type === nb.EOF || (b = Da()), da(), a.finishReturnStatement(b));
      }
      function Va(a) {
        var b,
            c;
        return wb && (p(), V(tb.StrictModeWith)), _("with"), Z("("), b = Da(), Z(")"), c = ab(), a.finishWithStatement(b, c);
      }
      function Wa() {
        var a,
            b,
            c = [],
            d = new Q;
        for (ba("default") ? (L(), a = null) : (_("case"), a = Da()), Z(":"); Ab > xb && !(aa("}") || ba("default") || ba("case")); )
          b = ab(), c.push(b);
        return d.finishSwitchCase(a, c);
      }
      function Xa(a) {
        var b,
            c,
            d,
            e,
            f;
        if (_("switch"), Z("("), b = Da(), Z(")"), Z("{"), c = [], aa("}"))
          return L(), a.finishSwitchStatement(b, c);
        for (e = Cb.inSwitch, Cb.inSwitch = !0, f = !1; Ab > xb && !aa("}"); )
          d = Wa(), null === d.test && (f && U(tb.MultipleDefaultsInSwitch), f = !0), c.push(d);
        return Cb.inSwitch = e, Z("}"), a.finishSwitchStatement(b, c);
      }
      function Ya(a) {
        var b;
        return _("throw"), S() && U(tb.NewlineAfterThrow), b = Da(), da(), a.finishThrowStatement(b);
      }
      function Za() {
        var a,
            b,
            c = new Q;
        return _("catch"), Z("("), aa(")") && X(Bb), a = Ga(), wb && k(a.name) && V(tb.StrictCatchVariable), Z(")"), b = Fa(), c.finishCatchClause(a, b);
      }
      function $a(a) {
        var b,
            c = [],
            d = null;
        return _("try"), b = Fa(), ba("catch") && c.push(Za()), ba("finally") && (L(), d = Fa()), 0 !== c.length || d || U(tb.NoCatchOrFinally), a.finishTryStatement(b, [], c, d);
      }
      function _a(a) {
        return _("debugger"), da(), a.finishDebuggerStatement();
      }
      function ab() {
        var a,
            b,
            c,
            d,
            e = Bb.type;
        if (e === nb.EOF && X(Bb), e === nb.Punctuator && "{" === Bb.value)
          return Fa();
        if (d = new Q, e === nb.Punctuator)
          switch (Bb.value) {
            case ";":
              return La(d);
            case "(":
              return Ma(d);
          }
        else if (e === nb.Keyword)
          switch (Bb.value) {
            case "break":
              return Ta(d);
            case "continue":
              return Sa(d);
            case "debugger":
              return _a(d);
            case "do":
              return Oa(d);
            case "for":
              return Ra(d);
            case "function":
              return fb(d);
            case "if":
              return Na(d);
            case "return":
              return Ua(d);
            case "switch":
              return Xa(d);
            case "throw":
              return Ya(d);
            case "try":
              return $a(d);
            case "var":
              return Ja(d);
            case "while":
              return Pa(d);
            case "with":
              return Va(d);
          }
        return a = Da(), a.type === qb.Identifier && aa(":") ? (L(), c = "$" + a.name, Object.prototype.hasOwnProperty.call(Cb.labelSet, c) && U(tb.Redeclaration, "Label", a.name), Cb.labelSet[c] = !0, b = ab(), delete Cb.labelSet[c], d.finishLabeledStatement(a, b)) : (da(), d.finishExpressionStatement(a));
      }
      function bb() {
        var a,
            b,
            c,
            d,
            e,
            f,
            g,
            h,
            i,
            j = [],
            k = new Q;
        for (Z("{"); Ab > xb && Bb.type === nb.StringLiteral && (b = Bb, a = hb(), j.push(a), a.expression.type === qb.Literal); )
          c = vb.slice(b.start + 1, b.end - 1), "use strict" === c ? (wb = !0, d && Y(d, tb.StrictOctalLiteral)) : !d && b.octal && (d = b);
        for (e = Cb.labelSet, f = Cb.inIteration, g = Cb.inSwitch, h = Cb.inFunctionBody, i = Cb.parenthesizedCount, Cb.labelSet = {}, Cb.inIteration = !1, Cb.inSwitch = !1, Cb.inFunctionBody = !0, Cb.parenthesizedCount = 0; Ab > xb && !aa("}") && (a = hb(), "undefined" != typeof a); )
          j.push(a);
        return Z("}"), Cb.labelSet = e, Cb.inIteration = f, Cb.inSwitch = g, Cb.inFunctionBody = h, Cb.parenthesizedCount = i, k.finishBlockStatement(j);
      }
      function cb(a, b, c) {
        var d = "$" + c;
        wb ? (k(c) && (a.stricted = b, a.message = tb.StrictParamName), Object.prototype.hasOwnProperty.call(a.paramSet, d) && (a.stricted = b, a.message = tb.StrictParamDupe)) : a.firstRestricted || (k(c) ? (a.firstRestricted = b, a.message = tb.StrictParamName) : j(c) ? (a.firstRestricted = b, a.message = tb.StrictReservedWord) : Object.prototype.hasOwnProperty.call(a.paramSet, d) && (a.firstRestricted = b, a.message = tb.StrictParamDupe)), a.paramSet[d] = !0;
      }
      function db(a) {
        var b,
            c,
            d;
        return b = Bb, c = Ga(), cb(a, b, b.value), aa("=") && (L(), d = Ca(), ++a.defaultCount), a.params.push(c), a.defaults.push(d), !aa(")");
      }
      function eb(a) {
        var b;
        if (b = {
          params: [],
          defaultCount: 0,
          defaults: [],
          firstRestricted: a
        }, Z("("), !aa(")"))
          for (b.paramSet = {}; Ab > xb && db(b); )
            Z(",");
        return Z(")"), 0 === b.defaultCount && (b.defaults = []), {
          params: b.params,
          defaults: b.defaults,
          stricted: b.stricted,
          firstRestricted: b.firstRestricted,
          message: b.message
        };
      }
      function fb() {
        var a,
            b,
            c,
            d,
            e,
            f,
            g,
            h,
            i = [],
            l = [],
            m = new Q;
        return _("function"), c = Bb, a = Ga(), wb ? k(c.value) && Y(c, tb.StrictFunctionName) : k(c.value) ? (f = c, g = tb.StrictFunctionName) : j(c.value) && (f = c, g = tb.StrictReservedWord), e = eb(f), i = e.params, l = e.defaults, d = e.stricted, f = e.firstRestricted, e.message && (g = e.message), h = wb, b = bb(), wb && f && X(f, g), wb && d && Y(d, g), wb = h, m.finishFunctionDeclaration(a, i, l, b);
      }
      function gb() {
        var a,
            b,
            c,
            d,
            e,
            f,
            g,
            h = null,
            i = [],
            l = [],
            m = new Q;
        return _("function"), aa("(") || (a = Bb, h = Ga(), wb ? k(a.value) && Y(a, tb.StrictFunctionName) : k(a.value) ? (c = a, d = tb.StrictFunctionName) : j(a.value) && (c = a, d = tb.StrictReservedWord)), e = eb(c), i = e.params, l = e.defaults, b = e.stricted, c = e.firstRestricted, e.message && (d = e.message), g = wb, f = bb(), wb && c && X(c, d), wb && b && Y(b, d), wb = g, m.finishFunctionExpression(h, i, l, f);
      }
      function hb() {
        if (Bb.type === nb.Keyword)
          switch (Bb.value) {
            case "const":
            case "let":
              return Ka(Bb.value);
            case "function":
              return fb();
            default:
              return ab();
          }
        return Bb.type !== nb.EOF ? ab() : void 0;
      }
      function ib() {
        for (var a,
            b,
            c,
            d,
            e = []; Ab > xb && (b = Bb, b.type === nb.StringLiteral) && (a = hb(), e.push(a), a.expression.type === qb.Literal); )
          c = vb.slice(b.start + 1, b.end - 1), "use strict" === c ? (wb = !0, d && Y(d, tb.StrictOctalLiteral)) : !d && b.octal && (d = b);
        for (; Ab > xb && (a = hb(), "undefined" != typeof a); )
          e.push(a);
        return e;
      }
      function jb() {
        var a,
            b;
        return p(), M(), b = new Q, wb = !1, a = ib(), b.finishProgram(a);
      }
      function kb() {
        var a,
            b,
            c,
            d = [];
        for (a = 0; a < Db.tokens.length; ++a)
          b = Db.tokens[a], c = {
            type: b.type,
            value: b.value
          }, b.regex && (c.regex = {
            pattern: b.regex.pattern,
            flags: b.regex.flags
          }), Db.range && (c.range = b.range), Db.loc && (c.loc = b.loc), d.push(c);
        Db.tokens = d;
      }
      function lb(a, b) {
        var c,
            d;
        c = String, "string" == typeof a || a instanceof String || (a = c(a)), vb = a, xb = 0, yb = vb.length > 0 ? 1 : 0, zb = 0, Ab = vb.length, Bb = null, Cb = {
          allowIn: !0,
          labelSet: {},
          inFunctionBody: !1,
          inIteration: !1,
          inSwitch: !1,
          lastCommentStart: -1
        }, Db = {}, b = b || {}, b.tokens = !0, Db.tokens = [], Db.tokenize = !0, Db.openParenToken = -1, Db.openCurlyToken = -1, Db.range = "boolean" == typeof b.range && b.range, Db.loc = "boolean" == typeof b.loc && b.loc, "boolean" == typeof b.comment && b.comment && (Db.comments = []), "boolean" == typeof b.tolerant && b.tolerant && (Db.errors = []);
        try {
          if (M(), Bb.type === nb.EOF)
            return Db.tokens;
          for (L(); Bb.type !== nb.EOF; )
            try {
              L();
            } catch (e) {
              if (Db.errors) {
                Db.errors.push(e);
                break;
              }
              throw e;
            }
          kb(), d = Db.tokens, "undefined" != typeof Db.comments && (d.comments = Db.comments), "undefined" != typeof Db.errors && (d.errors = Db.errors);
        } catch (f) {
          throw f;
        } finally {
          Db = {};
        }
        return d;
      }
      function mb(a, b) {
        var c,
            d;
        d = String, "string" == typeof a || a instanceof String || (a = d(a)), vb = a, xb = 0, yb = vb.length > 0 ? 1 : 0, zb = 0, Ab = vb.length, Bb = null, Cb = {
          allowIn: !0,
          labelSet: {},
          parenthesisCount: 0,
          inFunctionBody: !1,
          inIteration: !1,
          inSwitch: !1,
          lastCommentStart: -1
        }, Db = {}, "undefined" != typeof b && (Db.range = "boolean" == typeof b.range && b.range, Db.loc = "boolean" == typeof b.loc && b.loc, Db.attachComment = "boolean" == typeof b.attachComment && b.attachComment, Db.loc && null !== b.source && void 0 !== b.source && (Db.source = d(b.source)), "boolean" == typeof b.tokens && b.tokens && (Db.tokens = []), "boolean" == typeof b.comment && b.comment && (Db.comments = []), "boolean" == typeof b.tolerant && b.tolerant && (Db.errors = []), Db.attachComment && (Db.range = !0, Db.comments = [], Db.bottomRightStack = [], Db.trailingComments = [], Db.leadingComments = []));
        try {
          c = jb(), "undefined" != typeof Db.comments && (c.comments = Db.comments), "undefined" != typeof Db.tokens && (kb(), c.tokens = Db.tokens), "undefined" != typeof Db.errors && (c.errors = Db.errors);
        } catch (e) {
          throw e;
        } finally {
          Db = {};
        }
        return c;
      }
      var nb,
          ob,
          pb,
          qb,
          rb,
          sb,
          tb,
          ub,
          vb,
          wb,
          xb,
          yb,
          zb,
          Ab,
          Bb,
          Cb,
          Db;
      nb = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
      }, ob = {}, ob[nb.BooleanLiteral] = "Boolean", ob[nb.EOF] = "<end>", ob[nb.Identifier] = "Identifier", ob[nb.Keyword] = "Keyword", ob[nb.NullLiteral] = "Null", ob[nb.NumericLiteral] = "Numeric", ob[nb.Punctuator] = "Punctuator", ob[nb.StringLiteral] = "String", ob[nb.RegularExpression] = "RegularExpression", pb = ["(", "{", "[", "in", "typeof", "instanceof", "new", "return", "case", "delete", "throw", "void", "=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ",", "+", "-", "*", "/", "%", "++", "--", "<<", ">>", ">>>", "&", "|", "^", "!", "~", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!=="], qb = {
        AssignmentExpression: "AssignmentExpression",
        ArrayExpression: "ArrayExpression",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DoWhileStatement: "DoWhileStatement",
        DebuggerStatement: "DebuggerStatement",
        EmptyStatement: "EmptyStatement",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        Program: "Program",
        Property: "Property",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement"
      }, rb = {ArrowParameterPlaceHolder: {type: "ArrowParameterPlaceHolder"}}, sb = {
        Data: 1,
        Get: 2,
        Set: 4
      }, tb = {
        UnexpectedToken: "Unexpected token %0",
        UnexpectedNumber: "Unexpected number",
        UnexpectedString: "Unexpected string",
        UnexpectedIdentifier: "Unexpected identifier",
        UnexpectedReserved: "Unexpected reserved word",
        UnexpectedEOS: "Unexpected end of input",
        NewlineAfterThrow: "Illegal newline after throw",
        InvalidRegExp: "Invalid regular expression",
        UnterminatedRegExp: "Invalid regular expression: missing /",
        InvalidLHSInAssignment: "Invalid left-hand side in assignment",
        InvalidLHSInForIn: "Invalid left-hand side in for-in",
        MultipleDefaultsInSwitch: "More than one default clause in switch statement",
        NoCatchOrFinally: "Missing catch or finally after try",
        UnknownLabel: "Undefined label '%0'",
        Redeclaration: "%0 '%1' has already been declared",
        IllegalContinue: "Illegal continue statement",
        IllegalBreak: "Illegal break statement",
        IllegalReturn: "Illegal return statement",
        StrictModeWith: "Strict mode code may not include a with statement",
        StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
        StrictVarName: "Variable name may not be eval or arguments in strict mode",
        StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
        StrictParamDupe: "Strict mode function may not have duplicate parameter names",
        StrictFunctionName: "Function name may not be eval or arguments in strict mode",
        StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
        StrictDelete: "Delete of an unqualified identifier in strict mode.",
        StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
        AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
        AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
        StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
        StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
        StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
        StrictReservedWord: "Use of future reserved word in strict mode"
      }, ub = {
        NonAsciiIdentifierStart: new RegExp("[ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢲऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]"),
        NonAsciiIdentifierPart: new RegExp("[ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮ̀-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁ҃-҇Ҋ-ԯԱ-Ֆՙա-և֑-ׇֽֿׁׂׅׄא-תװ-ײؐ-ؚؠ-٩ٮ-ۓە-ۜ۟-۪ۨ-ۼۿܐ-݊ݍ-ޱ߀-ߵߺࠀ-࠭ࡀ-࡛ࢠ-ࢲࣤ-ॣ०-९ॱ-ঃঅ-ঌএঐও-নপ-রলশ-হ়-ৄেৈো-ৎৗড়ঢ়য়-ৣ০-ৱਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹ਼ਾ-ੂੇੈੋ-੍ੑਖ਼-ੜਫ਼੦-ੵઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હ઼-ૅે-ૉો-્ૐૠ-ૣ૦-૯ଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହ଼-ୄେୈୋ-୍ୖୗଡ଼ଢ଼ୟ-ୣ୦-୯ୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-்ௐௗ௦-௯ఀ-ఃఅ-ఌఎ-ఐఒ-నప-హఽ-ౄె-ైొ-్ౕౖౘౙౠ-ౣ౦-౯ಁ-ಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ಼-ೄೆ-ೈೊ-್ೕೖೞೠ-ೣ೦-೯ೱೲഁ-ഃഅ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൎൗൠ-ൣ൦-൯ൺ-ൿංඃඅ-ඖක-නඳ-රලව-ෆ්ා-ුූෘ-ෟ෦-෯ෲෳก-ฺเ-๎๐-๙ກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ູົ-ຽເ-ໄໆ່-ໍ໐-໙ໜ-ໟༀ༘༙༠-༩༹༵༷༾-ཇཉ-ཬཱ-྄྆-ྗྙ-ྼ࿆က-၉ၐ-ႝႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፝-፟ᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-᜔ᜠ-᜴ᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-៓ៗៜ៝០-៩᠋-᠍᠐-᠙ᠠ-ᡷᢀ-ᢪᢰ-ᣵᤀ-ᤞᤠ-ᤫᤰ-᤻᥆-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉ᧐-᧙ᨀ-ᨛᨠ-ᩞ᩠-᩿᩼-᪉᪐-᪙ᪧ᪰-᪽ᬀ-ᭋ᭐-᭙᭫-᭳ᮀ-᯳ᰀ-᰷᱀-᱉ᱍ-ᱽ᳐-᳔᳒-ᳶ᳸᳹ᴀ-᷵᷼-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼ‌‍‿⁀⁔ⁱⁿₐ-ₜ⃐-⃥⃜⃡-⃰ℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯ⵿-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⷠ-ⷿⸯ々-〇〡-〯〱-〵〸-〼ぁ-ゖ゙゚ゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘫꙀ-꙯ꙴ-꙽ꙿ-ꚝꚟ-꛱ꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠧꡀ-ꡳꢀ-꣄꣐-꣙꣠-ꣷꣻ꤀-꤭ꤰ-꥓ꥠ-ꥼꦀ-꧀ꧏ-꧙ꧠ-ꧾꨀ-ꨶꩀ-ꩍ꩐-꩙ꩠ-ꩶꩺ-ꫂꫛ-ꫝꫠ-ꫯꫲ-꫶ꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯪ꯬꯭꯰-꯹가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻ︀-️︠-︭︳︴﹍-﹏ﹰ-ﹴﹶ-ﻼ０-９Ａ-Ｚ＿ａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]")
      }, R.prototype = Q.prototype = {
        processComment: function() {
          var a,
              b,
              c,
              d,
              e,
              f = Db.bottomRightStack,
              g = f[f.length - 1];
          if (!(this.type === qb.Program && this.body.length > 0)) {
            if (Db.trailingComments.length > 0) {
              for (c = [], d = Db.trailingComments.length - 1; d >= 0; --d)
                e = Db.trailingComments[d], e.range[0] >= this.range[1] && (c.unshift(e), Db.trailingComments.splice(d, 1));
              Db.trailingComments = [];
            } else
              g && g.trailingComments && g.trailingComments[0].range[0] >= this.range[1] && (c = g.trailingComments, delete g.trailingComments);
            if (g)
              for (; g && g.range[0] >= this.range[0]; )
                a = g, g = f.pop();
            if (a)
              a.leadingComments && a.leadingComments[a.leadingComments.length - 1].range[1] <= this.range[0] && (this.leadingComments = a.leadingComments, a.leadingComments = void 0);
            else if (Db.leadingComments.length > 0)
              for (b = [], d = Db.leadingComments.length - 1; d >= 0; --d)
                e = Db.leadingComments[d], e.range[1] <= this.range[0] && (b.unshift(e), Db.leadingComments.splice(d, 1));
            b && b.length > 0 && (this.leadingComments = b), c && c.length > 0 && (this.trailingComments = c), f.push(this);
          }
        },
        finish: function() {
          Db.range && (this.range[1] = xb), Db.loc && (this.loc.end = new N, Db.source && (this.loc.source = Db.source)), Db.attachComment && this.processComment();
        },
        finishArrayExpression: function(a) {
          return this.type = qb.ArrayExpression, this.elements = a, this.finish(), this;
        },
        finishArrowFunctionExpression: function(a, b, c, d) {
          return this.type = qb.ArrowFunctionExpression, this.id = null, this.params = a, this.defaults = b, this.body = c, this.rest = null, this.generator = !1, this.expression = d, this.finish(), this;
        },
        finishAssignmentExpression: function(a, b, c) {
          return this.type = qb.AssignmentExpression, this.operator = a, this.left = b, this.right = c, this.finish(), this;
        },
        finishBinaryExpression: function(a, b, c) {
          return this.type = "||" === a || "&&" === a ? qb.LogicalExpression : qb.BinaryExpression, this.operator = a, this.left = b, this.right = c, this.finish(), this;
        },
        finishBlockStatement: function(a) {
          return this.type = qb.BlockStatement, this.body = a, this.finish(), this;
        },
        finishBreakStatement: function(a) {
          return this.type = qb.BreakStatement, this.label = a, this.finish(), this;
        },
        finishCallExpression: function(a, b) {
          return this.type = qb.CallExpression, this.callee = a, this.arguments = b, this.finish(), this;
        },
        finishCatchClause: function(a, b) {
          return this.type = qb.CatchClause, this.param = a, this.body = b, this.finish(), this;
        },
        finishConditionalExpression: function(a, b, c) {
          return this.type = qb.ConditionalExpression, this.test = a, this.consequent = b, this.alternate = c, this.finish(), this;
        },
        finishContinueStatement: function(a) {
          return this.type = qb.ContinueStatement, this.label = a, this.finish(), this;
        },
        finishDebuggerStatement: function() {
          return this.type = qb.DebuggerStatement, this.finish(), this;
        },
        finishDoWhileStatement: function(a, b) {
          return this.type = qb.DoWhileStatement, this.body = a, this.test = b, this.finish(), this;
        },
        finishEmptyStatement: function() {
          return this.type = qb.EmptyStatement, this.finish(), this;
        },
        finishExpressionStatement: function(a) {
          return this.type = qb.ExpressionStatement, this.expression = a, this.finish(), this;
        },
        finishForStatement: function(a, b, c, d) {
          return this.type = qb.ForStatement, this.init = a, this.test = b, this.update = c, this.body = d, this.finish(), this;
        },
        finishForInStatement: function(a, b, c) {
          return this.type = qb.ForInStatement, this.left = a, this.right = b, this.body = c, this.each = !1, this.finish(), this;
        },
        finishFunctionDeclaration: function(a, b, c, d) {
          return this.type = qb.FunctionDeclaration, this.id = a, this.params = b, this.defaults = c, this.body = d, this.rest = null, this.generator = !1, this.expression = !1, this.finish(), this;
        },
        finishFunctionExpression: function(a, b, c, d) {
          return this.type = qb.FunctionExpression, this.id = a, this.params = b, this.defaults = c, this.body = d, this.rest = null, this.generator = !1, this.expression = !1, this.finish(), this;
        },
        finishIdentifier: function(a) {
          return this.type = qb.Identifier, this.name = a, this.finish(), this;
        },
        finishIfStatement: function(a, b, c) {
          return this.type = qb.IfStatement, this.test = a, this.consequent = b, this.alternate = c, this.finish(), this;
        },
        finishLabeledStatement: function(a, b) {
          return this.type = qb.LabeledStatement, this.label = a, this.body = b, this.finish(), this;
        },
        finishLiteral: function(a) {
          return this.type = qb.Literal, this.value = a.value, this.raw = vb.slice(a.start, a.end), a.regex && (this.regex = a.regex), this.finish(), this;
        },
        finishMemberExpression: function(a, b, c) {
          return this.type = qb.MemberExpression, this.computed = "[" === a, this.object = b, this.property = c, this.finish(), this;
        },
        finishNewExpression: function(a, b) {
          return this.type = qb.NewExpression, this.callee = a, this.arguments = b, this.finish(), this;
        },
        finishObjectExpression: function(a) {
          return this.type = qb.ObjectExpression, this.properties = a, this.finish(), this;
        },
        finishPostfixExpression: function(a, b) {
          return this.type = qb.UpdateExpression, this.operator = a, this.argument = b, this.prefix = !1, this.finish(), this;
        },
        finishProgram: function(a) {
          return this.type = qb.Program, this.body = a, this.finish(), this;
        },
        finishProperty: function(a, b, c, d, e) {
          return this.type = qb.Property, this.key = b, this.value = c, this.kind = a, this.method = d, this.shorthand = e, this.finish(), this;
        },
        finishReturnStatement: function(a) {
          return this.type = qb.ReturnStatement, this.argument = a, this.finish(), this;
        },
        finishSequenceExpression: function(a) {
          return this.type = qb.SequenceExpression, this.expressions = a, this.finish(), this;
        },
        finishSwitchCase: function(a, b) {
          return this.type = qb.SwitchCase, this.test = a, this.consequent = b, this.finish(), this;
        },
        finishSwitchStatement: function(a, b) {
          return this.type = qb.SwitchStatement, this.discriminant = a, this.cases = b, this.finish(), this;
        },
        finishThisExpression: function() {
          return this.type = qb.ThisExpression, this.finish(), this;
        },
        finishThrowStatement: function(a) {
          return this.type = qb.ThrowStatement, this.argument = a, this.finish(), this;
        },
        finishTryStatement: function(a, b, c, d) {
          return this.type = qb.TryStatement, this.block = a, this.guardedHandlers = b, this.handlers = c, this.finalizer = d, this.finish(), this;
        },
        finishUnaryExpression: function(a, b) {
          return this.type = "++" === a || "--" === a ? qb.UpdateExpression : qb.UnaryExpression, this.operator = a, this.argument = b, this.prefix = !0, this.finish(), this;
        },
        finishVariableDeclaration: function(a, b) {
          return this.type = qb.VariableDeclaration, this.declarations = a, this.kind = b, this.finish(), this;
        },
        finishVariableDeclarator: function(a, b) {
          return this.type = qb.VariableDeclarator, this.id = a, this.init = b, this.finish(), this;
        },
        finishWhileStatement: function(a, b) {
          return this.type = qb.WhileStatement, this.test = a, this.body = b, this.finish(), this;
        },
        finishWithStatement: function(a, b) {
          return this.type = qb.WithStatement, this.object = a, this.body = b, this.finish(), this;
        }
      };
      var Eb = function() {
        var a,
            b = {};
        "function" == typeof Object.create && (b = Object.create(null));
        for (a in qb)
          qb.hasOwnProperty(a) && (b[a] = qb[a]);
        return "function" == typeof Object.freeze && Object.freeze(b), b;
      }(),
          Fb = {
            tokenize: lb,
            parse: mb,
            Synatax: Eb
          };
      return Fb;
    }), b("davinci-mathscript/estraverse", ["require", "exports"], function() {
      function a() {}
      function b(a) {
        var c,
            d,
            e = {};
        for (c in a)
          a.hasOwnProperty(c) && (d = a[c], e[c] = "object" == typeof d && null !== d ? b(d) : d);
        return e;
      }
      function c(a) {
        var b,
            c = {};
        for (b in a)
          a.hasOwnProperty(b) && (c[b] = a[b]);
        return c;
      }
      function d(a, b) {
        var c,
            d,
            e,
            f;
        for (d = a.length, e = 0; d; )
          c = d >>> 1, f = e + c, b(a[f]) ? d = c : (e = f + 1, d -= c + 1);
        return e;
      }
      function e(a, b) {
        var c,
            d,
            e,
            f;
        for (d = a.length, e = 0; d; )
          c = d >>> 1, f = e + c, b(a[f]) ? (e = f + 1, d -= c + 1) : d = c;
        return e;
      }
      function f(a, b) {
        var c,
            d,
            e,
            f = u(b);
        for (d = 0, e = f.length; e > d; d += 1)
          c = f[d], a[c] = b[c];
        return a;
      }
      function g(a, b) {
        this.parent = a, this.key = b;
      }
      function h(a, b, c, d) {
        this.node = a, this.path = b, this.wrap = c, this.ref = d;
      }
      function i() {}
      function j(a) {
        return null == a ? !1 : "object" == typeof a && "string" == typeof a.type;
      }
      function k(a, b) {
        return (a === p.ObjectExpression || a === p.ObjectPattern) && "properties" === b;
      }
      function l(a, b) {
        var c = new i;
        return c.traverse(a, b);
      }
      function m(a, b) {
        var c = new i;
        return c.replace(a, b);
      }
      function n(a, b) {
        var c;
        return c = d(b, function(b) {
          return b.range[0] > a.range[0];
        }), a.extendedRange = [a.range[0], a.range[1]], c !== b.length && (a.extendedRange[1] = b[c].range[0]), c -= 1, c >= 0 && (a.extendedRange[0] = b[c].range[1]), a;
      }
      function o(a, c, d) {
        var e,
            f,
            g,
            h,
            i = [];
        if (!a.range)
          throw new Error("attachComments needs range information");
        if (!d.length) {
          if (c.length) {
            for (g = 0, f = c.length; f > g; g += 1)
              e = b(c[g]), e.extendedRange = [0, a.range[0]], i.push(e);
            a.leadingComments = i;
          }
          return a;
        }
        for (g = 0, f = c.length; f > g; g += 1)
          i.push(n(b(c[g]), d));
        return h = 0, l(a, {enter: function(a) {
            for (var b; h < i.length && (b = i[h], !(b.extendedRange[1] > a.range[0])); )
              b.extendedRange[1] === a.range[0] ? (a.leadingComments || (a.leadingComments = []), a.leadingComments.push(b), i.splice(h, 1)) : h += 1;
            return h === i.length ? r.Break : i[h].extendedRange[0] > a.range[1] ? r.Skip : void 0;
          }}), h = 0, l(a, {leave: function(a) {
            for (var b; h < i.length && (b = i[h], !(a.range[1] < b.extendedRange[0])); )
              a.range[1] === b.extendedRange[0] ? (a.trailingComments || (a.trailingComments = []), a.trailingComments.push(b), i.splice(h, 1)) : h += 1;
            return h === i.length ? r.Break : i[h].extendedRange[0] > a.range[1] ? r.Skip : void 0;
          }}), a;
      }
      var p,
          q,
          r,
          s,
          t,
          u,
          v,
          w,
          x;
      q = Array.isArray, q || (q = function(a) {
        return "[object Array]" === Object.prototype.toString.call(a);
      }), a(c), a(e), t = Object.create || function() {
        function a() {}
        return function(b) {
          return a.prototype = b, new a;
        };
      }(), u = Object.keys || function(a) {
        var b,
            c = [];
        for (b in a)
          c.push(b);
        return c;
      }, p = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        ComprehensionExpression: "ComprehensionExpression",
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        Program: "Program",
        Property: "Property",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        SuperExpression: "SuperExpression",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      }, s = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        ComprehensionExpression: ["blocks", "filter", "body"],
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        Program: ["body"],
        Property: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        SuperExpression: ["super"],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      }, v = {}, w = {}, x = {}, r = {
        Break: v,
        Skip: w,
        Remove: x
      }, g.prototype.replace = function(a) {
        this.parent[this.key] = a;
      }, g.prototype.remove = function() {
        return q(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
      }, i.prototype.path = function() {
        function a(a, b) {
          if (q(b))
            for (d = 0, e = b.length; e > d; ++d)
              a.push(b[d]);
          else
            a.push(b);
        }
        var b,
            c,
            d,
            e,
            f,
            g;
        if (!this.__current.path)
          return null;
        for (f = [], b = 2, c = this.__leavelist.length; c > b; ++b)
          g = this.__leavelist[b], a(f, g.path);
        return a(f, this.__current.path), f;
      }, i.prototype.type = function() {
        var a = this.current();
        return a.type || this.__current.wrap;
      }, i.prototype.parents = function() {
        var a,
            b,
            c;
        for (c = [], a = 1, b = this.__leavelist.length; b > a; ++a)
          c.push(this.__leavelist[a].node);
        return c;
      }, i.prototype.current = function() {
        return this.__current.node;
      }, i.prototype.__execute = function(a, b) {
        var c,
            d;
        return d = void 0, c = this.__current, this.__current = b, this.__state = null, a && (d = a.call(this, b.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = c, d;
      }, i.prototype.notify = function(a) {
        this.__state = a;
      }, i.prototype.skip = function() {
        this.notify(w);
      }, i.prototype["break"] = function() {
        this.notify(v);
      }, i.prototype.remove = function() {
        this.notify(x);
      }, i.prototype.__initialize = function(a, b) {
        this.visitor = b, this.root = a, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = "iteration" === b.fallback, this.__keys = s, b.keys && (this.__keys = f(t(this.__keys), b.keys));
      }, i.prototype.traverse = function(a, b) {
        var c,
            d,
            e,
            f,
            g,
            i,
            l,
            m,
            n,
            o,
            p,
            r;
        for (this.__initialize(a, b), r = {}, c = this.__worklist, d = this.__leavelist, c.push(new h(a, null, null, null)), d.push(new h(null, null, null, null)); c.length; )
          if (e = c.pop(), e !== r) {
            if (e.node) {
              if (i = this.__execute(b.enter, e), this.__state === v || i === v)
                return;
              if (c.push(r), d.push(e), this.__state === w || i === w)
                continue;
              if (f = e.node, g = e.wrap || f.type, o = this.__keys[g], !o) {
                if (!this.__fallback)
                  throw new Error("Unknown node type " + g + ".");
                o = u(f);
              }
              for (m = o.length; (m -= 1) >= 0; )
                if (l = o[m], p = f[l])
                  if (q(p)) {
                    for (n = p.length; (n -= 1) >= 0; )
                      if (p[n]) {
                        if (k(g, o[m]))
                          e = new h(p[n], [l, n], "Property", null);
                        else {
                          if (!j(p[n]))
                            continue;
                          e = new h(p[n], [l, n], null, null);
                        }
                        c.push(e);
                      }
                  } else
                    j(p) && c.push(new h(p, l, null, null));
            }
          } else if (e = d.pop(), i = this.__execute(b.leave, e), this.__state === v || i === v)
            return;
      }, i.prototype.replace = function(a, b) {
        function c(a) {
          var b,
              c,
              e,
              f;
          if (a.ref.remove())
            for (c = a.ref.key, f = a.ref.parent, b = d.length; b--; )
              if (e = d[b], e.ref && e.ref.parent === f) {
                if (e.ref.key < c)
                  break;
                --e.ref.key;
              }
        }
        var d,
            e,
            f,
            i,
            l,
            m,
            n,
            o,
            p,
            r,
            s,
            t,
            y;
        for (this.__initialize(a, b), s = {}, d = this.__worklist, e = this.__leavelist, t = {root: a}, m = new h(a, null, null, new g(t, "root")), d.push(m), e.push(m); d.length; )
          if (m = d.pop(), m !== s) {
            if (l = this.__execute(b.enter, m), void 0 !== l && l !== v && l !== w && l !== x && (m.ref.replace(l), m.node = l), (this.__state === x || l === x) && (c(m), m.node = null), this.__state === v || l === v)
              return t.root;
            if (f = m.node, f && (d.push(s), e.push(m), this.__state !== w && l !== w)) {
              if (i = m.wrap || f.type, p = this.__keys[i], !p) {
                if (!this.__fallback)
                  throw new Error("Unknown node type " + i + ".");
                p = u(f);
              }
              for (n = p.length; (n -= 1) >= 0; )
                if (y = p[n], r = f[y])
                  if (q(r)) {
                    for (o = r.length; (o -= 1) >= 0; )
                      if (r[o]) {
                        if (k(i, p[n]))
                          m = new h(r[o], [y, o], "Property", new g(r, o));
                        else {
                          if (!j(r[o]))
                            continue;
                          m = new h(r[o], [y, o], null, new g(r, o));
                        }
                        d.push(m);
                      }
                  } else
                    j(r) && d.push(new h(r, y, null, new g(f, y)));
            }
          } else if (m = e.pop(), l = this.__execute(b.leave, m), void 0 !== l && l !== v && l !== w && l !== x && m.ref.replace(l), (this.__state === x || l === x) && c(m), this.__state === v || l === v)
            return t.root;
        return t.root;
      };
      var y = {
        Syntax: p,
        traverse: l,
        replace: m,
        attachComments: o,
        VisitorKeys: s,
        VisitorOption: r,
        Controller: i
      };
      return y;
    }), b("davinci-mathscript/ast", ["require", "exports"], function() {
      function a(a) {
        if (null == a)
          return !1;
        switch (a.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return !0;
        }
        return !1;
      }
      function b(a) {
        if (null == a)
          return !1;
        switch (a.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return !0;
        }
        return !1;
      }
      function c(a) {
        if (null == a)
          return !1;
        switch (a.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return !0;
        }
        return !1;
      }
      function d(a) {
        return c(a) || null != a && "FunctionDeclaration" === a.type;
      }
      function e(a) {
        switch (a.type) {
          case "IfStatement":
            return null != a.alternate ? a.alternate : a.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return a.body;
        }
        return null;
      }
      function f(a) {
        var b;
        if ("IfStatement" !== a.type)
          return !1;
        if (null == a.alternate)
          return !1;
        b = a.consequent;
        do {
          if ("IfStatement" === b.type && null == b.alternate)
            return !0;
          b = e(b);
        } while (b);
        return !1;
      }
      var g = {
        isExpression: a,
        isStatement: c,
        isIterationStatement: b,
        isSourceElement: d,
        isProblematicIfStatement: f,
        trailingStatement: e
      };
      return g;
    }), b("davinci-mathscript/code", ["require", "exports"], function() {
      function a(a) {
        return a >= 48 && 57 >= a;
      }
      function b(a) {
        return a >= 48 && 57 >= a || a >= 97 && 102 >= a || a >= 65 && 70 >= a;
      }
      function c(a) {
        return a >= 48 && 55 >= a;
      }
      function d(a) {
        return 32 === a || 9 === a || 11 === a || 12 === a || 160 === a || a >= 5760 && m.indexOf(a) >= 0;
      }
      function e(a) {
        return 10 === a || 13 === a || 8232 === a || 8233 === a;
      }
      function f(a) {
        if (65535 >= a)
          return String.fromCharCode(a);
        var b = String.fromCharCode(Math.floor((a - 65536) / 1024) + 55296),
            c = String.fromCharCode((a - 65536) % 1024 + 56320);
        return b + c;
      }
      function g(a) {
        return 128 > a ? n[a] : l.NonAsciiIdentifierStart.test(f(a));
      }
      function h(a) {
        return 128 > a ? o[a] : l.NonAsciiIdentifierPart.test(f(a));
      }
      function i(a) {
        return 128 > a ? n[a] : k.NonAsciiIdentifierStart.test(f(a));
      }
      function j(a) {
        return 128 > a ? o[a] : k.NonAsciiIdentifierPart.test(f(a));
      }
      var k,
          l,
          m,
          n,
          o,
          p;
      for (l = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      }, k = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      }, m = [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], n = new Array(128), p = 0; 128 > p; ++p)
        n[p] = p >= 97 && 122 >= p || p >= 65 && 90 >= p || 36 === p || 95 === p;
      for (o = new Array(128), p = 0; 128 > p; ++p)
        o[p] = p >= 97 && 122 >= p || p >= 65 && 90 >= p || p >= 48 && 57 >= p || 36 === p || 95 === p;
      var q = {
        isDecimalDigit: a,
        isHexDigit: b,
        isOctalDigit: c,
        isWhiteSpace: d,
        isLineTerminator: e,
        isIdentifierStartES5: g,
        isIdentifierPartES5: h,
        isIdentifierStartES6: i,
        isIdentifierPartES6: j,
        isIdentifierStart: i,
        isIdentifierPart: j
      };
      return q;
    }), b("davinci-mathscript/keyword", ["require", "exports", "davinci-mathscript/code"], function(a, b, c) {
      function d(a) {
        switch (a) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return !0;
          default:
            return !1;
        }
      }
      function e(a, b) {
        return b || "yield" !== a ? f(a, b) : !1;
      }
      function f(a, b) {
        if (b && d(a))
          return !0;
        switch (a.length) {
          case 2:
            return "if" === a || "in" === a || "do" === a;
          case 3:
            return "var" === a || "for" === a || "new" === a || "try" === a;
          case 4:
            return "this" === a || "else" === a || "case" === a || "void" === a || "with" === a || "enum" === a;
          case 5:
            return "while" === a || "break" === a || "catch" === a || "throw" === a || "const" === a || "yield" === a || "class" === a || "super" === a;
          case 6:
            return "return" === a || "typeof" === a || "delete" === a || "switch" === a || "export" === a || "import" === a;
          case 7:
            return "default" === a || "finally" === a || "extends" === a;
          case 8:
            return "function" === a || "continue" === a || "debugger" === a;
          case 10:
            return "instanceof" === a;
          default:
            return !1;
        }
      }
      function g(a, b) {
        return "null" === a || "true" === a || "false" === a || e(a, b);
      }
      function h(a, b) {
        return "null" === a || "true" === a || "false" === a || f(a, b);
      }
      function i(a) {
        return "eval" === a || "arguments" === a;
      }
      function j(a) {
        var b,
            d,
            e;
        if (0 === a.length)
          return !1;
        if (e = a.charCodeAt(0), !c.isIdentifierStartES5(e))
          return !1;
        for (b = 1, d = a.length; d > b; ++b)
          if (e = a.charCodeAt(b), !c.isIdentifierPartES5(e))
            return !1;
        return !0;
      }
      function k(a, b) {
        return 1024 * (a - 55296) + (b - 56320) + 65536;
      }
      function l(a) {
        var b,
            d,
            e,
            f,
            g;
        if (0 === a.length)
          return !1;
        for (g = c.isIdentifierStartES6, b = 0, d = a.length; d > b; ++b) {
          if (e = a.charCodeAt(b), e >= 55296 && 56319 >= e) {
            if (++b, b >= d)
              return !1;
            if (f = a.charCodeAt(b), !(f >= 56320 && 57343 >= f))
              return !1;
            e = k(e, f);
          }
          if (!g(e))
            return !1;
          g = c.isIdentifierPartES6;
        }
        return !0;
      }
      function m(a, b) {
        return j(a) && !g(a, b);
      }
      function n(a, b) {
        return l(a) && !h(a, b);
      }
      var o = {
        isKeywordES5: e,
        isKeywordES6: f,
        isReservedWordES5: g,
        isReservedWordES6: h,
        isRestrictedWord: i,
        isIdentifierNameES5: j,
        isIdentifierNameES6: l,
        isIdentifierES5: m,
        isIdentifierES6: n
      };
      return o;
    }), b("davinci-mathscript/esutils", ["require", "exports", "davinci-mathscript/ast", "davinci-mathscript/code", "davinci-mathscript/keyword"], function(a, b, c, d, e) {
      var f = {
        ast: c,
        code: d,
        keyword: e
      };
      return f;
    }), b("davinci-mathscript/escodegen", ["require", "exports", "davinci-mathscript/estraverse", "davinci-mathscript/esutils"], function(a, b, c, d) {
      function e(a) {
        return Ba.Expression.hasOwnProperty(a.type);
      }
      function f(a) {
        return Ba.Statement.hasOwnProperty(a.type);
      }
      function g() {
        return {
          indent: null,
          base: null,
          parse: null,
          comment: !1,
          format: {
            indent: {
              style: "    ",
              base: 0,
              adjustMultilineComment: !1
            },
            newline: "\n",
            space: " ",
            json: !1,
            renumber: !1,
            hexadecimal: !1,
            quotes: "single",
            escapeless: !1,
            compact: !1,
            parentheses: !0,
            semicolons: !0,
            safeConcatenation: !1,
            preserveBlankLines: !1
          },
          moz: {
            comprehensionExpressionStartsWithAssignment: !1,
            starlessGenerator: !1
          },
          sourceMap: null,
          sourceMapRoot: null,
          sourceMapWithCode: !1,
          directive: !1,
          raw: !0,
          verbatim: null,
          sourceCode: null
        };
      }
      function h(a, b) {
        var c = "";
        for (b |= 0; b > 0; b >>>= 1, a += a)
          1 & b && (c += a);
        return c;
      }
      function i(a) {
        return /[\r\n]/g.test(a);
      }
      function j(a) {
        var b = a.length;
        return b && d.code.isLineTerminator(a.charCodeAt(b - 1));
      }
      function k(a, b) {
        var c;
        for (c in b)
          b.hasOwnProperty(c) && (a[c] = b[c]);
        return a;
      }
      function l(a, b) {
        function c(a) {
          return "object" == typeof a && a instanceof Object && !(a instanceof RegExp);
        }
        var d,
            e;
        for (d in b)
          b.hasOwnProperty(d) && (e = b[d], c(e) ? c(a[d]) ? l(a[d], e) : a[d] = l({}, e) : a[d] = e);
        return a;
      }
      function m(a) {
        var b,
            c,
            d,
            e,
            f;
        if (a !== a)
          throw new Error("Numeric literal whose value is NaN");
        if (0 > a || 0 === a && 0 > 1 / a)
          throw new Error("Numeric literal whose value is negative");
        if (a === 1 / 0)
          return U ? "null" : V ? "1e400" : "1e+400";
        if (b = "" + a, !V || b.length < 3)
          return b;
        for (c = b.indexOf("."), U || 48 !== b.charCodeAt(0) || 1 !== c || (c = 0, b = b.slice(1)), d = b, b = b.replace("e+", "e"), e = 0, (f = d.indexOf("e")) > 0 && (e = +d.slice(f + 1), d = d.slice(0, f)), c >= 0 && (e -= d.length - c - 1, d = +(d.slice(0, c) + d.slice(c + 1)) + ""), f = 0; 48 === d.charCodeAt(d.length + f - 1); )
          --f;
        return 0 !== f && (e -= f, d = d.slice(0, f)), 0 !== e && (d += "e" + e), (d.length < b.length || W && a > 1e12 && Math.floor(a) === a && (d = "0x" + a.toString(16)).length < b.length) && +d === a && (b = d), b;
      }
      function n(a, b) {
        return 8232 === (-2 & a) ? (b ? "u" : "\\u") + (8232 === a ? "2028" : "2029") : 10 === a || 13 === a ? (b ? "" : "\\") + (10 === a ? "n" : "r") : String.fromCharCode(a);
      }
      function o(a) {
        var b,
            c,
            d,
            e,
            f,
            g,
            h,
            i;
        if (c = a.toString(), a.source) {
          if (b = c.match(/\/([^/]*)$/), !b)
            return c;
          for (d = b[1], c = "", h = !1, i = !1, e = 0, f = a.source.length; f > e; ++e)
            g = a.source.charCodeAt(e), i ? (c += n(g, i), i = !1) : (h ? 93 === g && (h = !1) : 47 === g ? c += "\\" : 91 === g && (h = !0), c += n(g, i), i = 92 === g);
          return "/" + c + "/" + d;
        }
        return c;
      }
      function p(a, b) {
        var c;
        return 8 === a ? "\\b" : 12 === a ? "\\f" : 9 === a ? "\\t" : (c = a.toString(16).toUpperCase(), U || a > 255 ? "\\u" + "0000".slice(c.length) + c : 0 !== a || d.code.isDecimalDigit(b) ? 11 === a ? "\\x0B" : "\\x" + "00".slice(c.length) + c : "\\0");
      }
      function q(a) {
        if (92 === a)
          return "\\\\";
        if (10 === a)
          return "\\n";
        if (13 === a)
          return "\\r";
        if (8232 === a)
          return "\\u2028";
        if (8233 === a)
          return "\\u2029";
        throw new Error("Incorrectly classified character");
      }
      function r(a) {
        var b,
            c,
            d,
            e;
        for (e = "double" === X ? '"' : "'", b = 0, c = a.length; c > b; ++b) {
          if (d = a.charCodeAt(b), 39 === d) {
            e = '"';
            break;
          }
          if (34 === d) {
            e = "'";
            break;
          }
          92 === d && ++b;
        }
        return e + a + e;
      }
      function s(a) {
        var b,
            c,
            e,
            f,
            g,
            h = "",
            i = 0,
            j = 0;
        for (b = 0, c = a.length; c > b; ++b) {
          if (e = a.charCodeAt(b), 39 === e)
            ++i;
          else if (34 === e)
            ++j;
          else if (47 === e && U)
            h += "\\";
          else {
            if (d.code.isLineTerminator(e) || 92 === e) {
              h += q(e);
              continue;
            }
            if (U && 32 > e || !(U || Y || e >= 32 && 126 >= e)) {
              h += p(e, a.charCodeAt(b + 1));
              continue;
            }
          }
          h += String.fromCharCode(e);
        }
        if (f = !("double" === X || "auto" === X && i > j), g = f ? "'" : '"', !(f ? i : j))
          return g + h + g;
        for (a = h, h = g, b = 0, c = a.length; c > b; ++b)
          e = a.charCodeAt(b), (39 === e && f || 34 === e && !f) && (h += "\\"), h += String.fromCharCode(e);
        return h + g;
      }
      function t(a) {
        var b,
            c,
            d,
            e = "";
        for (b = 0, c = a.length; c > b; ++b)
          d = a[b], e += R(d) ? t(d) : d;
        return e;
      }
      function u(a, b) {
        if (!fa)
          return R(a) ? t(a) : a;
        if (null == b) {
          if (a instanceof Q)
            return a;
          b = {};
        }
        return null == b.loc ? new Q(null, null, fa, a, b.name || null) : new Q(b.loc.start.line, b.loc.start.column, fa === !0 ? b.loc.source || null : fa, a, b.name || null);
      }
      function v() {
        return $ ? $ : " ";
      }
      function w(a, b) {
        var c,
            e,
            f,
            g;
        return c = u(a).toString(), 0 === c.length ? [b] : (e = u(b).toString(), 0 === e.length ? [a] : (f = c.charCodeAt(c.length - 1), g = e.charCodeAt(0), (43 === f || 45 === f) && f === g || d.code.isIdentifierPart(f) && d.code.isIdentifierPart(g) || 47 === f && 105 === g ? [a, v(), b] : d.code.isWhiteSpace(f) || d.code.isLineTerminator(f) || d.code.isWhiteSpace(g) || d.code.isLineTerminator(g) ? [a, b] : [a, $, b]));
      }
      function x(a) {
        return [S, a];
      }
      function y(a) {
        var b;
        b = S, S += T, a(S), S = b;
      }
      function z(a) {
        var b;
        for (b = a.length - 1; b >= 0 && !d.code.isLineTerminator(a.charCodeAt(b)); --b)
          ;
        return a.length - 1 - b;
      }
      function A(a, b) {
        var c,
            e,
            f,
            g,
            h,
            i,
            j,
            k;
        for (c = a.split(/\r\n|[\r\n]/), i = Number.MAX_VALUE, e = 1, f = c.length; f > e; ++e) {
          for (g = c[e], h = 0; h < g.length && d.code.isWhiteSpace(g.charCodeAt(h)); )
            ++h;
          i > h && (i = h);
        }
        for ("undefined" != typeof b ? (j = S, "*" === c[1][i] && (b += " "), S = b) : (1 & i && --i, j = S), e = 1, f = c.length; f > e; ++e)
          k = u(x(c[e].slice(i))), c[e] = fa ? k.join("") : k;
        return S = j, c.join("\n");
      }
      function B(a, b) {
        if ("Line" === a.type) {
          if (j(a.value))
            return "//" + a.value;
          var c = "//" + a.value;
          return ha || (c += "\n"), c;
        }
        return da.format.indent.adjustMultilineComment && /[\n\r]/.test(a.value) ? A("/*" + a.value + "*/", b) : "/*" + a.value + "*/";
      }
      function C(a, b) {
        var c,
            d,
            e,
            f,
            g,
            i,
            k,
            l,
            m,
            n,
            o,
            p,
            q,
            r;
        if (a.leadingComments && a.leadingComments.length > 0) {
          if (f = b, ha) {
            for (e = a.leadingComments[0], b = [], l = e.extendedRange, m = e.range, o = ga.substring(l[0], m[0]), r = (o.match(/\n/g) || []).length, r > 0 ? (b.push(h("\n", r)), b.push(x(B(e)))) : (b.push(o), b.push(B(e))), n = m, c = 1, d = a.leadingComments.length; d > c; c++)
              e = a.leadingComments[c], m = e.range, p = ga.substring(n[1], m[0]), r = (p.match(/\n/g) || []).length, b.push(h("\n", r)), b.push(x(B(e))), n = m;
            q = ga.substring(m[1], l[1]), r = (q.match(/\n/g) || []).length, b.push(h("\n", r));
          } else
            for (e = a.leadingComments[0], b = [], ba && a.type === N.Program && 0 === a.body.length && b.push("\n"), b.push(B(e)), j(u(b).toString()) || b.push("\n"), c = 1, d = a.leadingComments.length; d > c; ++c)
              e = a.leadingComments[c], k = [B(e)], j(u(k).toString()) || k.push("\n"), b.push(x(k));
          b.push(x(f));
        }
        if (a.trailingComments)
          if (ha)
            e = a.trailingComments[0], l = e.extendedRange, m = e.range, o = ga.substring(l[0], m[0]), r = (o.match(/\n/g) || []).length, r > 0 ? (b.push(h("\n", r)), b.push(x(B(e)))) : (b.push(o), b.push(B(e)));
          else
            for (g = !j(u(b).toString()), i = h(" ", z(u([S, b, T]).toString())), c = 0, d = a.trailingComments.length; d > c; ++c)
              e = a.trailingComments[c], g ? (b = 0 === c ? [b, T] : [b, i], b.push(B(e, i))) : b = [b, x(B(e))], c === d - 1 || j(u(b).toString()) || (b = [b, "\n"]);
        return b;
      }
      function D(a, b, c) {
        var d,
            e = 0;
        for (d = a; b > d; d++)
          "\n" === ga[d] && e++;
        for (d = 1; e > d; d++)
          c.push(Z);
      }
      function E(a, b, c) {
        return c > b ? ["(", a, ")"] : a;
      }
      function F(a) {
        var b,
            c,
            d;
        for (d = a.split(/\r\n|\n/), b = 1, c = d.length; c > b; b++)
          d[b] = Z + S + d[b];
        return d;
      }
      function G(a, b) {
        var c,
            d,
            e;
        return c = a[da.verbatim], "string" == typeof c ? d = E(F(c), O.Sequence, b) : (d = F(c.content), e = null != c.precedence ? c.precedence : O.Sequence, d = E(d, e, b)), u(d, a);
      }
      function H(a) {
        return u(a.name, a);
      }
      function I(a, b) {
        return a.async ? "async" + (b ? v() : $) : "";
      }
      function J(a) {
        var b = a.generator && !da.moz.starlessGenerator;
        return b ? "*" + $ : "";
      }
      function K(a) {
        var b = a.value;
        return b.async ? I(b, !a.computed) : J(b) ? "*" : "";
      }
      function L(a) {
        var b;
        if (b = new Ba, f(a))
          return b.generateStatement(a, wa);
        if (e(a))
          return b.generateExpression(a, O.Sequence, sa);
        throw new Error("Unknown node type: " + a.type);
      }
      function M(a, b) {
        var c,
            d,
            e = g();
        return null != b ? ("string" == typeof b.indent && (e.format.indent.style = b.indent), "number" == typeof b.base && (e.format.indent.base = b.base), b = l(e, b), T = b.format.indent.style, S = "string" == typeof b.base ? b.base : h(T, b.format.indent.base)) : (b = e, T = b.format.indent.style, S = h(T, b.format.indent.base)), U = b.format.json, V = b.format.renumber, W = U ? !1 : b.format.hexadecimal, X = U ? "double" : b.format.quotes, Y = b.format.escapeless, Z = b.format.newline, $ = b.format.space, b.format.compact && (Z = $ = T = S = ""), _ = b.format.parentheses, aa = b.format.semicolons, ba = b.format.safeConcatenation, ca = b.directive, ea = U ? null : b.parse, fa = b.sourceMap, ga = b.sourceCode, ha = b.format.preserveBlankLines && null !== ga, da = b, c = L(a), fa ? (d = c.toStringWithSourceMap({
          file: b.file,
          sourceRoot: b.sourceMapRoot
        }), b.sourceContent && d.map.setSourceContent(b.sourceMap, b.sourceContent), b.sourceMapWithCode ? d : d.map.toString()) : (d = {
          code: c.toString(),
          map: null
        }, b.sourceMapWithCode ? d : d.code);
      }
      var N,
          O,
          P,
          Q,
          R,
          S,
          T,
          U,
          V,
          W,
          X,
          Y,
          Z,
          $,
          _,
          aa,
          ba,
          ca,
          da,
          ea,
          fa,
          ga,
          ha,
          ia,
          ja;
      N = c.Syntax, O = {
        Sequence: 0,
        Yield: 1,
        Await: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        TaggedTemplate: 17,
        Member: 18,
        Primary: 19
      }, P = {
        "||": O.LogicalOR,
        "&&": O.LogicalAND,
        "|": O.BitwiseOR,
        "^": O.BitwiseXOR,
        "&": O.BitwiseAND,
        "==": O.Equality,
        "!=": O.Equality,
        "===": O.Equality,
        "!==": O.Equality,
        is: O.Equality,
        isnt: O.Equality,
        "<": O.Relational,
        ">": O.Relational,
        "<=": O.Relational,
        ">=": O.Relational,
        "in": O.Relational,
        "instanceof": O.Relational,
        "<<": O.BitwiseSHIFT,
        ">>": O.BitwiseSHIFT,
        ">>>": O.BitwiseSHIFT,
        "+": O.Additive,
        "-": O.Additive,
        "*": O.Multiplicative,
        "%": O.Multiplicative,
        "/": O.Multiplicative
      };
      var ka = 1,
          la = 2,
          ma = 4,
          na = 8,
          oa = 16,
          pa = 32,
          qa = la | ma,
          ra = ka | la,
          sa = ka | la | ma,
          ta = ka,
          ua = ma,
          va = ka | ma,
          wa = ka,
          xa = ka | pa,
          ya = 0,
          za = ka | oa,
          Aa = ka | na;
      R = Array.isArray, R || (R = function(a) {
        return "[object Array]" === Object.prototype.toString.call(a);
      });
      var Ba = function() {
        function a() {}
        return a.prototype.generateFunctionParams = function(a) {
          var b,
              c,
              d,
              e;
          if (e = !1, a.type !== N.ArrowFunctionExpression || a.rest || a.defaults && 0 !== a.defaults.length || 1 !== a.params.length || a.params[0].type !== N.Identifier) {
            for (d = a.type === N.ArrowFunctionExpression ? [I(a, !1)] : [], d.push("("), a.defaults && (e = !0), b = 0, c = a.params.length; c > b; ++b)
              d.push(e && a.defaults[b] ? this.generateAssignment(a.params[b], a.defaults[b], "=", O.Assignment, sa) : this.generatePattern(a.params[b], O.Assignment, sa)), c > b + 1 && d.push("," + $);
            a.rest && (a.params.length && d.push("," + $), d.push("..."), d.push(H(a.rest))), d.push(")");
          } else
            d = [I(a, !0), H(a.params[0])];
          return d;
        }, a.prototype.generatePattern = function(a, b, c) {
          return a.type === N.Identifier ? H(a) : this.generateExpression(a, b, c);
        }, a.prototype.generateStatement = function(a, b) {
          var c,
              d;
          return c = this[a.type](a, b), da.comment && (c = C(a, c)), d = u(c).toString(), a.type !== N.Program || ba || "" !== Z || "\n" !== d.charAt(d.length - 1) || (c = fa ? u(c).replaceRight(/\s+$/, "") : d.replace(/\s+$/, "")), u(c, a);
        }, a.prototype.generateExpression = function(a, b, c) {
          var d,
              e;
          return e = a.type || N.Property, da.verbatim && a.hasOwnProperty(da.verbatim) ? G(a, b) : (d = this[e](a, b, c), da.comment && (d = C(a, d)), u(d, a));
        }, a.prototype.maybeBlock = function(a, b) {
          var c,
              d,
              e = this;
          return d = !da.comment || !a.leadingComments, a.type === N.BlockStatement && d ? [$, this.generateStatement(a, b)] : a.type === N.EmptyStatement && d ? ";" : (y(function() {
            c = [Z, x(e.generateStatement(a, b))];
          }), c);
        }, a.prototype.maybeBlockSuffix = function(a, b) {
          var c = j(u(b).toString());
          return a.type !== N.BlockStatement || da.comment && a.leadingComments || c ? c ? [b, S] : [b, Z, S] : [b, $];
        }, a.prototype.generateFunctionBody = function(a) {
          var b,
              c;
          return b = this.generateFunctionParams(a), a.type === N.ArrowFunctionExpression && (b.push($), b.push("=>")), a.expression ? (b.push($), c = this.generateExpression(a.body, O.Assignment, sa), "{" === c.toString().charAt(0) && (c = ["(", c, ")"]), b.push(c)) : b.push(this.maybeBlock(a.body, Aa)), b;
        }, a.prototype.generateIterationForStatement = function(a, b, c) {
          var d = ["for" + $ + "("],
              e = this;
          return y(function() {
            b.left.type === N.VariableDeclaration ? y(function() {
              d.push(b.left.kind + v()), d.push(e.generateStatement(b.left.declarations[0], ya));
            }) : d.push(e.generateExpression(b.left, O.Call, sa)), d = w(d, a), d = [w(d, e.generateExpression(b.right, O.Sequence, sa)), ")"];
          }), d.push(this.maybeBlock(b.body, c)), d;
        }, a.prototype.generatePropertyKey = function(a, b) {
          var c = [];
          return b && c.push("["), c.push(this.generateExpression(a, O.Sequence, sa)), b && c.push("]"), c;
        }, a.prototype.generateAssignment = function(a, b, c, d, e) {
          return O.Assignment < d && (e |= ka), E([this.generateExpression(a, O.Call, e), $ + c + $, this.generateExpression(b, O.Assignment, e)], O.Assignment, d);
        }, a.prototype.semicolon = function(a) {
          return !aa && a & pa ? "" : ";";
        }, a;
      }();
      Ba.Statement = {
        BlockStatement: function(a, b) {
          var c,
              d,
              e = ["{", Z],
              f = this;
          return y(function() {
            0 === a.body.length && ha && (c = a.range, c[1] - c[0] > 2 && (d = ga.substring(c[0] + 1, c[1] - 1), "\n" === d[0] && (e = ["{"]), e.push(d)));
            var g,
                h,
                i,
                k;
            for (k = wa, b & na && (k |= oa), g = 0, h = a.body.length; h > g; ++g)
              ha && (0 === g && (a.body[0].leadingComments && (c = a.body[0].leadingComments[0].extendedRange, d = ga.substring(c[0], c[1]), "\n" === d[0] && (e = ["{"])), a.body[0].leadingComments || D(a.range[0], a.body[0].range[0], e)), g > 0 && (a.body[g - 1].trailingComments || a.body[g].leadingComments || D(a.body[g - 1].range[1], a.body[g].range[0], e))), g === h - 1 && (k |= pa), i = a.body[g].leadingComments && ha ? f.generateStatement(a.body[g], k) : x(f.generateStatement(a.body[g], k)), e.push(i), j(u(i).toString()) || (ha && h - 1 > g ? a.body[g + 1].leadingComments || e.push(Z) : e.push(Z)), ha && g === h - 1 && (a.body[g].trailingComments || D(a.body[g].range[1], a.range[1], e));
          }), e.push(x("}")), e;
        },
        BreakStatement: function(a, b) {
          return a.label ? "break " + a.label.name + this.semicolon(b) : "break" + this.semicolon(b);
        },
        ContinueStatement: function(a, b) {
          return a.label ? "continue " + a.label.name + this.semicolon(b) : "continue" + this.semicolon(b);
        },
        ClassBody: function(a) {
          var b = ["{", Z],
              c = this;
          return y(function(d) {
            var e,
                f;
            for (e = 0, f = a.body.length; f > e; ++e)
              b.push(d), b.push(c.generateExpression(a.body[e], O.Sequence, sa)), f > e + 1 && b.push(Z);
          }), j(u(b).toString()) || b.push(Z), b.push(S), b.push("}"), b;
        },
        ClassDeclaration: function(a) {
          var b,
              c;
          return b = ["class " + a.id.name], a.superClass && (c = w("extends", this.generateExpression(a.superClass, O.Assignment, sa)), b = w(b, c)), b.push($), b.push(this.generateStatement(a.body, xa)), b;
        },
        DirectiveStatement: function(a, b) {
          return da.raw && a.raw ? a.raw + this.semicolon(b) : r(a.directive) + this.semicolon(b);
        },
        DoWhileStatement: function(a, b) {
          var c = w("do", this.maybeBlock(a.body, wa));
          return c = this.maybeBlockSuffix(a.body, c), w(c, ["while" + $ + "(", this.generateExpression(a.test, O.Sequence, sa), ")" + this.semicolon(b)]);
        },
        CatchClause: function(a) {
          var b,
              c = this;
          return y(function() {
            var d;
            b = ["catch" + $ + "(", c.generateExpression(a.param, O.Sequence, sa), ")"], a.guard && (d = c.generateExpression(a.guard, O.Sequence, sa), b.splice(2, 0, " if ", d));
          }), b.push(this.maybeBlock(a.body, wa)), b;
        },
        DebuggerStatement: function(a, b) {
          return "debugger" + this.semicolon(b);
        },
        EmptyStatement: function() {
          return ";";
        },
        ExportDeclaration: function(a, b) {
          var c,
              d = ["export"],
              e = this;
          return c = b & pa ? xa : wa, a["default"] ? (d = w(d, "default"), d = f(a.declaration) ? w(d, this.generateStatement(a.declaration, c)) : w(d, this.generateExpression(a.declaration, O.Assignment, sa) + this.semicolon(b))) : a.declaration ? w(d, this.generateStatement(a.declaration, c)) : (a.specifiers && (0 === a.specifiers.length ? d = w(d, "{" + $ + "}") : a.specifiers[0].type === N.ExportBatchSpecifier ? d = w(d, this.generateExpression(a.specifiers[0], O.Sequence, sa)) : (d = w(d, "{"), y(function(b) {
            var c,
                f;
            for (d.push(Z), c = 0, f = a.specifiers.length; f > c; ++c)
              d.push(b), d.push(e.generateExpression(a.specifiers[c], O.Sequence, sa)), f > c + 1 && d.push("," + Z);
          }), j(u(d).toString()) || d.push(Z), d.push(S + "}")), a.source ? d = w(d, ["from" + $, this.generateExpression(a.source, O.Sequence, sa), this.semicolon(b)]) : d.push(this.semicolon(b))), d);
        },
        ExpressionStatement: function(a, b) {
          function c(a) {
            var b;
            return "class" !== a.slice(0, 5) ? !1 : (b = a.charCodeAt(5), 123 === b || d.code.isWhiteSpace(b) || d.code.isLineTerminator(b));
          }
          function e(a) {
            var b;
            return "function" !== a.slice(0, 8) ? !1 : (b = a.charCodeAt(8), 40 === b || d.code.isWhiteSpace(b) || 42 === b || d.code.isLineTerminator(b));
          }
          function f(a) {
            var b,
                c,
                e;
            if ("async" !== a.slice(0, 5))
              return !1;
            if (!d.code.isWhiteSpace(a.charCodeAt(5)))
              return !1;
            for (c = 6, e = a.length; e > c && d.code.isWhiteSpace(a.charCodeAt(c)); ++c)
              ;
            return c === e ? !1 : "function" !== a.slice(c, c + 8) ? !1 : (b = a.charCodeAt(c + 8), 40 === b || d.code.isWhiteSpace(b) || 42 === b || d.code.isLineTerminator(b));
          }
          var g,
              h;
          return g = [this.generateExpression(a.expression, O.Sequence, sa)], h = u(g).toString(), 123 === h.charCodeAt(0) || c(h) || e(h) || f(h) || ca && b & oa && a.expression.type === N.Literal && "string" == typeof a.expression.value ? g = ["(", g, ")" + this.semicolon(b)] : g.push(this.semicolon(b)), g;
        },
        ImportDeclaration: function(a, b) {
          var c,
              d,
              e = this;
          return 0 === a.specifiers.length ? ["import", $, this.generateExpression(a.source, O.Sequence, sa), this.semicolon(b)] : (c = ["import"], d = 0, a.specifiers[d].type === N.ImportDefaultSpecifier && (c = w(c, [this.generateExpression(a.specifiers[d], O.Sequence, sa)]), ++d), a.specifiers[d] && (0 !== d && c.push(","), a.specifiers[d].type === N.ImportNamespaceSpecifier ? c = w(c, [$, this.generateExpression(a.specifiers[d], O.Sequence, sa)]) : (c.push($ + "{"), a.specifiers.length - d === 1 ? (c.push($), c.push(this.generateExpression(a.specifiers[d], O.Sequence, sa)), c.push($ + "}" + $)) : (y(function(b) {
            var f,
                g;
            for (c.push(Z), f = d, g = a.specifiers.length; g > f; ++f)
              c.push(b), c.push(e.generateExpression(a.specifiers[f], O.Sequence, sa)), g > f + 1 && c.push("," + Z);
          }), j(u(c).toString()) || c.push(Z), c.push(S + "}" + $)))), c = w(c, ["from" + $, this.generateExpression(a.source, O.Sequence, sa), this.semicolon(b)]));
        },
        VariableDeclarator: function(a, b) {
          var c = b & ka ? sa : qa;
          return a.init ? [this.generateExpression(a.id, O.Assignment, c), $, "=", $, this.generateExpression(a.init, O.Assignment, c)] : this.generatePattern(a.id, O.Assignment, c);
        },
        VariableDeclaration: function(a, b) {
          function c() {
            for (g = a.declarations[0], da.comment && g.leadingComments ? (d.push("\n"), d.push(x(i.generateStatement(g, h)))) : (d.push(v()), d.push(i.generateStatement(g, h))), e = 1, f = a.declarations.length; f > e; ++e)
              g = a.declarations[e], da.comment && g.leadingComments ? (d.push("," + Z), d.push(x(i.generateStatement(g, h)))) : (d.push("," + $), d.push(i.generateStatement(g, h)));
          }
          var d,
              e,
              f,
              g,
              h,
              i = this;
          return d = [a.kind], h = b & ka ? wa : ya, a.declarations.length > 1 ? y(c) : c(), d.push(this.semicolon(b)), d;
        },
        ThrowStatement: function(a, b) {
          return [w("throw", this.generateExpression(a.argument, O.Sequence, sa)), this.semicolon(b)];
        },
        TryStatement: function(a) {
          var b,
              c,
              d,
              e;
          if (b = ["try", this.maybeBlock(a.block, wa)], b = this.maybeBlockSuffix(a.block, b), a.handlers)
            for (c = 0, d = a.handlers.length; d > c; ++c)
              b = w(b, this.generateStatement(a.handlers[c], wa)), (a.finalizer || c + 1 !== d) && (b = this.maybeBlockSuffix(a.handlers[c].body, b));
          else {
            for (e = a.guardedHandlers || [], c = 0, d = e.length; d > c; ++c)
              b = w(b, this.generateStatement(e[c], wa)), (a.finalizer || c + 1 !== d) && (b = this.maybeBlockSuffix(e[c].body, b));
            if (a.handler)
              if (R(a.handler))
                for (c = 0, d = a.handler.length; d > c; ++c)
                  b = w(b, this.generateStatement(a.handler[c], wa)), (a.finalizer || c + 1 !== d) && (b = this.maybeBlockSuffix(a.handler[c].body, b));
              else
                b = w(b, this.generateStatement(a.handler, wa)), a.finalizer && (b = this.maybeBlockSuffix(a.handler.body, b));
          }
          return a.finalizer && (b = w(b, ["finally", this.maybeBlock(a.finalizer, wa)])), b;
        },
        SwitchStatement: function(a) {
          var b,
              c,
              d,
              e,
              f,
              g = this;
          if (y(function() {
            b = ["switch" + $ + "(", g.generateExpression(a.discriminant, O.Sequence, sa), ")" + $ + "{" + Z];
          }), a.cases)
            for (f = wa, d = 0, e = a.cases.length; e > d; ++d)
              d === e - 1 && (f |= pa), c = x(this.generateStatement(a.cases[d], f)), b.push(c), j(u(c).toString()) || b.push(Z);
          return b.push(x("}")), b;
        },
        SwitchCase: function(a, b) {
          var c,
              d,
              e,
              f,
              g,
              h = this;
          return y(function() {
            for (c = a.test ? [w("case", h.generateExpression(a.test, O.Sequence, sa)), ":"] : ["default:"], e = 0, f = a.consequent.length, f && a.consequent[0].type === N.BlockStatement && (d = h.maybeBlock(a.consequent[0], wa), c.push(d), e = 1), e === f || j(u(c).toString()) || c.push(Z), g = wa; f > e; ++e)
              e === f - 1 && b & pa && (g |= pa), d = x(h.generateStatement(a.consequent[e], g)), c.push(d), e + 1 === f || j(u(d).toString()) || c.push(Z);
          }), c;
        },
        IfStatement: function(a, b) {
          var c,
              d,
              e,
              f = this;
          return y(function() {
            c = ["if" + $ + "(", f.generateExpression(a.test, O.Sequence, sa), ")"];
          }), e = b & pa, d = wa, e && (d |= pa), a.alternate ? (c.push(this.maybeBlock(a.consequent, wa)), c = this.maybeBlockSuffix(a.consequent, c), c = a.alternate.type === N.IfStatement ? w(c, ["else ", this.generateStatement(a.alternate, d)]) : w(c, w("else", this.maybeBlock(a.alternate, d)))) : c.push(this.maybeBlock(a.consequent, d)), c;
        },
        ForStatement: function(a, b) {
          var c,
              d = this;
          return y(function() {
            c = ["for" + $ + "("], a.init ? a.init.type === N.VariableDeclaration ? c.push(d.generateStatement(a.init, ya)) : (c.push(d.generateExpression(a.init, O.Sequence, qa)), c.push(";")) : c.push(";"), a.test ? (c.push($), c.push(d.generateExpression(a.test, O.Sequence, sa)), c.push(";")) : c.push(";"), a.update ? (c.push($), c.push(d.generateExpression(a.update, O.Sequence, sa)), c.push(")")) : c.push(")");
          }), c.push(this.maybeBlock(a.body, b & pa ? xa : wa)), c;
        },
        ForInStatement: function(a, b) {
          return this.generateIterationForStatement("in", a, b & pa ? xa : wa);
        },
        ForOfStatement: function(a, b) {
          return this.generateIterationForStatement("of", a, b & pa ? xa : wa);
        },
        LabeledStatement: function(a, b) {
          return [a.label.name + ":", this.maybeBlock(a.body, b & pa ? xa : wa)];
        },
        Program: function(a) {
          var b,
              c,
              d,
              e,
              f;
          for (e = a.body.length, b = [ba && e > 0 ? "\n" : ""], f = za, d = 0; e > d; ++d)
            ba || d !== e - 1 || (f |= pa), ha && (0 === d && (a.body[0].leadingComments || D(a.range[0], a.body[d].range[0], b)), d > 0 && (a.body[d - 1].trailingComments || a.body[d].leadingComments || D(a.body[d - 1].range[1], a.body[d].range[0], b))), c = x(this.generateStatement(a.body[d], f)), b.push(c), e > d + 1 && !j(u(c).toString()) && (ha ? a.body[d + 1].leadingComments || b.push(Z) : b.push(Z)), ha && d === e - 1 && (a.body[d].trailingComments || D(a.body[d].range[1], a.range[1], b));
          return b;
        },
        FunctionDeclaration: function(a) {
          return [I(a, !0), "function", J(a) || v(), H(a.id), this.generateFunctionBody(a)];
        },
        ReturnStatement: function(a, b) {
          return a.argument ? [w("return", this.generateExpression(a.argument, O.Sequence, sa)), this.semicolon(b)] : ["return" + this.semicolon(b)];
        },
        WhileStatement: function(a, b) {
          var c,
              d = this;
          return y(function() {
            c = ["while" + $ + "(", d.generateExpression(a.test, O.Sequence, sa), ")"];
          }), c.push(this.maybeBlock(a.body, b & pa ? xa : wa)), c;
        },
        WithStatement: function(a, b) {
          var c,
              d = this;
          return y(function() {
            c = ["with" + $ + "(", d.generateExpression(a.object, O.Sequence, sa), ")"];
          }), c.push(this.maybeBlock(a.body, b & pa ? xa : wa)), c;
        }
      }, k(Ba.prototype, Ba.Statement), Ba.Expression = {
        SequenceExpression: function(a, b, c) {
          var d,
              e,
              f;
          for (O.Sequence < b && (c |= ka), d = [], e = 0, f = a.expressions.length; f > e; ++e)
            d.push(this.generateExpression(a.expressions[e], O.Assignment, c)), f > e + 1 && d.push("," + $);
          return E(d, O.Sequence, b);
        },
        AssignmentExpression: function(a, b, c) {
          return this.generateAssignment(a.left, a.right, a.operator, b, c);
        },
        ArrowFunctionExpression: function(a, b) {
          return E(this.generateFunctionBody(a), O.ArrowFunction, b);
        },
        ConditionalExpression: function(a, b, c) {
          return O.Conditional < b && (c |= ka), E([this.generateExpression(a.test, O.LogicalOR, c), $ + "?" + $, this.generateExpression(a.consequent, O.Assignment, c), $ + ":" + $, this.generateExpression(a.alternate, O.Assignment, c)], O.Conditional, b);
        },
        LogicalExpression: function(a, b, c) {
          return this.BinaryExpression(a, b, c);
        },
        BinaryExpression: function(a, b, c) {
          var e,
              f,
              g,
              h;
          return f = P[a.operator], b > f && (c |= ka), g = this.generateExpression(a.left, f, c), h = g.toString(), e = 47 === h.charCodeAt(h.length - 1) && d.code.isIdentifierPart(a.operator.charCodeAt(0)) ? [g, v(), a.operator] : w(g, a.operator), g = this.generateExpression(a.right, f + 1, c), "/" === a.operator && "/" === g.toString().charAt(0) || "<" === a.operator.slice(-1) && "!--" === g.toString().slice(0, 3) ? (e.push(v()), e.push(g)) : e = w(e, g), "in" !== a.operator || c & ka ? E(e, f, b) : ["(", e, ")"];
        },
        CallExpression: function(a, b, c) {
          var d,
              e,
              f;
          for (d = [this.generateExpression(a.callee, O.Call, ra)], d.push("("), e = 0, f = a.arguments.length; f > e; ++e)
            d.push(this.generateExpression(a.arguments[e], O.Assignment, sa)), f > e + 1 && d.push("," + $);
          return d.push(")"), c & la ? E(d, O.Call, b) : ["(", d, ")"];
        },
        NewExpression: function(a, b, c) {
          var d,
              e,
              f,
              g,
              h;
          if (e = a.arguments.length, h = c & ma && !_ && 0 === e ? va : ta, d = w("new", this.generateExpression(a.callee, O.New, h)), !(c & ma) || _ || e > 0) {
            for (d.push("("), f = 0, g = e; g > f; ++f)
              d.push(this.generateExpression(a.arguments[f], O.Assignment, sa)), g > f + 1 && d.push("," + $);
            d.push(")");
          }
          return E(d, O.New, b);
        },
        MemberExpression: function(a, b, c) {
          var e,
              f;
          return e = [this.generateExpression(a.object, O.Call, c & la ? ra : ta)], a.computed ? (e.push("["), e.push(this.generateExpression(a.property, O.Sequence, c & la ? sa : va)), e.push("]")) : (a.object.type === N.Literal && "number" == typeof a.object.value && (f = u(e).toString(), f.indexOf(".") < 0 && !/[eExX]/.test(f) && d.code.isDecimalDigit(f.charCodeAt(f.length - 1)) && !(f.length >= 2 && 48 === f.charCodeAt(0)) && e.push(".")), e.push("."), e.push(H(a.property))), E(e, O.Member, b);
        },
        UnaryExpression: function(a, b) {
          var c,
              e,
              f,
              g,
              h;
          return e = this.generateExpression(a.argument, O.Unary, sa), "" === $ ? c = w(a.operator, e) : (c = [a.operator], a.operator.length > 2 ? c = w(c, e) : (g = u(c).toString(), h = g.charCodeAt(g.length - 1), f = e.toString().charCodeAt(0), (43 === h || 45 === h) && h === f || d.code.isIdentifierPart(h) && d.code.isIdentifierPart(f) ? (c.push(v()), c.push(e)) : c.push(e))), E(c, O.Unary, b);
        },
        YieldExpression: function(a, b) {
          var c;
          return c = a.delegate ? "yield*" : "yield", a.argument && (c = w(c, this.generateExpression(a.argument, O.Yield, sa))), E(c, O.Yield, b);
        },
        AwaitExpression: function(a, b) {
          var c = w(a.delegate ? "await*" : "await", this.generateExpression(a.argument, O.Await, sa));
          return E(c, O.Await, b);
        },
        UpdateExpression: function(a, b) {
          return a.prefix ? E([a.operator, this.generateExpression(a.argument, O.Unary, sa)], O.Unary, b) : E([this.generateExpression(a.argument, O.Postfix, sa), a.operator], O.Postfix, b);
        },
        FunctionExpression: function(a) {
          var b = [I(a, !0), "function"];
          return a.id ? (b.push(J(a) || v()), b.push(H(a.id))) : b.push(J(a) || $), b.push(this.generateFunctionBody(a)), b;
        },
        ExportBatchSpecifier: function() {
          return "*";
        },
        ArrayPattern: function(a, b, c) {
          return this.ArrayExpression(a, b, c);
        },
        ArrayExpression: function(a) {
          var b,
              c,
              d = this;
          return a.elements.length ? (c = a.elements.length > 1, b = ["[", c ? Z : ""], y(function(e) {
            var f,
                g;
            for (f = 0, g = a.elements.length; g > f; ++f)
              a.elements[f] ? (b.push(c ? e : ""), b.push(d.generateExpression(a.elements[f], O.Assignment, sa))) : (c && b.push(e), f + 1 === g && b.push(",")), g > f + 1 && b.push("," + (c ? Z : $));
          }), c && !j(u(b).toString()) && b.push(Z), b.push(c ? S : ""), b.push("]"), b) : "[]";
        },
        ClassExpression: function(a) {
          var b,
              c;
          return b = ["class"], a.id && (b = w(b, this.generateExpression(a.id, O.Sequence, sa))), a.superClass && (c = w("extends", this.generateExpression(a.superClass, O.Assignment, sa)), b = w(b, c)), b.push($), b.push(this.generateStatement(a.body, xa)), b;
        },
        MethodDefinition: function(a) {
          var b,
              c;
          return b = a["static"] ? ["static" + $] : [], c = "get" === a.kind || "set" === a.kind ? [w(a.kind, this.generatePropertyKey(a.key, a.computed)), this.generateFunctionBody(a.value)] : [K(a), this.generatePropertyKey(a.key, a.computed), this.generateFunctionBody(a.value)], w(b, c);
        },
        Property: function(a) {
          return "get" === a.kind || "set" === a.kind ? [a.kind, v(), this.generatePropertyKey(a.key, a.computed), this.generateFunctionBody(a.value)] : a.shorthand ? this.generatePropertyKey(a.key, a.computed) : a.method ? [K(a), this.generatePropertyKey(a.key, a.computed), this.generateFunctionBody(a.value)] : [this.generatePropertyKey(a.key, a.computed), ":" + $, this.generateExpression(a.value, O.Assignment, sa)];
        },
        ObjectExpression: function(a) {
          var b,
              c,
              d,
              e = this;
          return a.properties.length ? (b = a.properties.length > 1, y(function() {
            d = e.generateExpression(a.properties[0], O.Sequence, sa);
          }), b || i(u(d).toString()) ? (y(function(f) {
            var g,
                h;
            if (c = ["{", Z, f, d], b)
              for (c.push("," + Z), g = 1, h = a.properties.length; h > g; ++g)
                c.push(f), c.push(e.generateExpression(a.properties[g], O.Sequence, sa)), h > g + 1 && c.push("," + Z);
          }), j(u(c).toString()) || c.push(Z), c.push(S), c.push("}"), c) : ["{", $, d, $, "}"]) : "{}";
        },
        ObjectPattern: function(a) {
          var b,
              c,
              d,
              e,
              f,
              g = this;
          if (!a.properties.length)
            return "{}";
          if (e = !1, 1 === a.properties.length)
            f = a.properties[0], f.value.type !== N.Identifier && (e = !0);
          else
            for (c = 0, d = a.properties.length; d > c; ++c)
              if (f = a.properties[c], !f.shorthand) {
                e = !0;
                break;
              }
          return b = ["{", e ? Z : ""], y(function(c) {
            var d,
                f;
            for (d = 0, f = a.properties.length; f > d; ++d)
              b.push(e ? c : ""), b.push(g.generateExpression(a.properties[d], O.Sequence, sa)), f > d + 1 && b.push("," + (e ? Z : $));
          }), e && !j(u(b).toString()) && b.push(Z), b.push(e ? S : ""), b.push("}"), b;
        },
        ThisExpression: function() {
          return "this";
        },
        Identifier: function(a) {
          return H(a);
        },
        ImportDefaultSpecifier: function(a) {
          return H(a.id);
        },
        ImportNamespaceSpecifier: function(a) {
          var b = ["*"];
          return a.id && b.push($ + "as" + v() + H(a.id)), b;
        },
        ImportSpecifier: function(a, b, c) {
          return this.ExportSpecifier(a, b, c);
        },
        ExportSpecifier: function(a) {
          var b = [a.id.name];
          return a.name && b.push(v() + "as" + v() + H(a.name)), b;
        },
        Literal: function(a) {
          var b;
          if (a.hasOwnProperty("raw") && ea && da.raw)
            try {
              if (b = ea(a.raw).body[0].expression, b.type === N.Literal && b.value === a.value)
                return a.raw;
            } catch (c) {}
          return null === a.value ? "null" : "string" == typeof a.value ? s(a.value) : "number" == typeof a.value ? m(a.value) : "boolean" == typeof a.value ? a.value ? "true" : "false" : o(a.value);
        },
        GeneratorExpression: function(a, b, c) {
          return this.ComprehensionExpression(a, b, c);
        },
        ComprehensionExpression: function(a) {
          var b,
              c,
              d,
              e,
              f = this;
          return b = a.type === N.GeneratorExpression ? ["("] : ["["], da.moz.comprehensionExpressionStartsWithAssignment && (e = this.generateExpression(a.body, O.Assignment, sa), b.push(e)), a.blocks && y(function() {
            for (c = 0, d = a.blocks.length; d > c; ++c)
              e = f.generateExpression(a.blocks[c], O.Sequence, sa), c > 0 || da.moz.comprehensionExpressionStartsWithAssignment ? b = w(b, e) : b.push(e);
          }), a.filter && (b = w(b, "if" + $), e = this.generateExpression(a.filter, O.Sequence, sa), b = w(b, ["(", e, ")"])), da.moz.comprehensionExpressionStartsWithAssignment || (e = this.generateExpression(a.body, O.Assignment, sa), b = w(b, e)), b.push(a.type === N.GeneratorExpression ? ")" : "]"), b;
        },
        ComprehensionBlock: function(a) {
          var b;
          return b = a.left.type === N.VariableDeclaration ? [a.left.kind, v(), this.generateStatement(a.left.declarations[0], ya)] : this.generateExpression(a.left, O.Call, sa), b = w(b, a.of ? "of" : "in"), b = w(b, this.generateExpression(a.right, O.Sequence, sa)), ["for" + $ + "(", b, ")"];
        },
        SpreadElement: function(a) {
          return ["...", this.generateExpression(a.argument, O.Assignment, sa)];
        },
        TaggedTemplateExpression: function(a, b, c) {
          var d = ra;
          c & la || (d = ta);
          var e = [this.generateExpression(a.tag, O.Call, d), this.generateExpression(a.quasi, O.Primary, ua)];
          return E(e, O.TaggedTemplate, b);
        },
        TemplateElement: function(a) {
          return a.value.raw;
        },
        TemplateLiteral: function(a) {
          var b,
              c,
              d;
          for (b = ["`"], c = 0, d = a.quasis.length; d > c; ++c)
            b.push(this.generateExpression(a.quasis[c], O.Primary, sa)), d > c + 1 && (b.push("${" + $), b.push(this.generateExpression(a.expressions[c], O.Sequence, sa)), b.push($ + "}"));
          return b.push("`"), b;
        },
        ModuleSpecifier: function(a, b, c) {
          return this.Literal(a, b, c);
        }
      }, k(Ba.prototype, Ba.Expression), ia = {
        indent: {
          style: "",
          base: 0
        },
        renumber: !0,
        hexadecimal: !0,
        quotes: "auto",
        escapeless: !0,
        compact: !0,
        parentheses: !1,
        semicolons: !1
      }, ja = g().format;
      var Ca = {
        generate: M,
        Precedence: l({}, O),
        FORMAT_MINIFY: ia,
        FORMAT_DEFAULT: ja
      };
      return Ca;
    }), b("davinci-mathscript", ["require", "exports", "davinci-mathscript/core", "davinci-mathscript/esprima", "davinci-mathscript/escodegen"], function(a, b, c, d, e) {
      function f(a, b) {
        var c = d.parse(a, b);
        return h(c), c;
      }
      function g(a, b) {
        var c = f(a, b);
        return e.generate(c, null);
      }
      function h(a) {
        if (a && a.type)
          switch (a.type) {
            case "BlockStatement":
              a.body.forEach(function(a) {
                h(a);
              });
              break;
            case "FunctionDeclaration":
              a.params.forEach(function(a) {
                h(a);
              }), h(a.body);
              break;
            case "Program":
              a.body.forEach(function(a) {
                h(a);
              });
              break;
            case "VariableDeclaration":
              a.declarations.forEach(function(a) {
                h(a);
              });
              break;
            case "VariableDeclarator":
              a.init && h(a.init);
              break;
            case "ConditionalExpression":
              h(a.test), h(a.consequent), h(a.alternate);
              break;
            case "BinaryExpression":
            case "LogicalExpression":
              a.operator && B[a.operator] ? (a.type = "CallExpression", a.callee = {
                type: "MemberExpression",
                computed: !1,
                object: {
                  type: "Identifier",
                  name: A
                },
                property: {
                  type: "Identifier",
                  name: B[a.operator]
                }
              }, h(a.left), h(a.right), a.arguments = [a.left, a.right]) : (h(a.left), h(a.right));
              break;
            case "ExpressionStatement":
              h(a.expression);
              break;
            case "ForStatement":
              h(a.init), h(a.test), h(a.update), h(a.body);
              break;
            case "ForInStatement":
              h(a.left), h(a.right), h(a.body);
              break;
            case "IfStatement":
              h(a.test), h(a.consequent), h(a.alternate);
              break;
            case "ArrayExpression":
              a.elements.forEach(function(a) {
                h(a);
              });
              break;
            case "AssignmentExpression":
              a.operator && B[a.operator] ? (h(a.left), h(a.right)) : (h(a.left), h(a.right));
              break;
            case "CallExpression":
              h(a.callee), a.arguments.forEach(function(a) {
                h(a);
              });
              break;
            case "CatchClause":
              h(a.param), h(a.body);
              break;
            case "FunctionExpression":
              h(a.body);
              break;
            case "MemberExpression":
              h(a.object);
              break;
            case "NewExpression":
              h(a.callee), a.arguments.forEach(function(a) {
                h(a);
              });
              break;
            case "ObjectExpression":
              a.properties.forEach(function(a) {
                h(a);
              });
              break;
            case "ReturnStatement":
              h(a.argument);
              break;
            case "SequenceExpression":
              a.expressions.forEach(function(a) {
                h(a);
              });
              break;
            case "SwitchCase":
              h(a.test), a.consequent.forEach(function(a) {
                h(a);
              });
              break;
            case "SwitchStatement":
              h(a.discriminant), a.cases.forEach(function(a) {
                h(a);
              });
              break;
            case "ThrowStatement":
              h(a.argument);
              break;
            case "TryStatement":
              h(a.block), a.guardedHandlers.forEach(function(a) {
                h(a);
              }), a.handlers.forEach(function(a) {
                h(a);
              }), h(a.finalizer);
              break;
            case "UnaryExpression":
              a.operator && C[a.operator] ? (a.type = "CallExpression", a.callee = {
                type: "MemberExpression",
                computed: !1,
                object: {
                  type: "Identifier",
                  name: A
                },
                property: {
                  type: "Identifier",
                  name: C[a.operator]
                }
              }, h(a.argument), a.arguments = [a.argument]) : h(a.argument);
              break;
            case "UpdateExpression":
              a.operator && C[a.operator] ? (a.type = "CallExpression", a.callee = {
                type: "MemberExpression",
                computed: !1,
                object: {
                  type: "Identifier",
                  name: A
                },
                property: {
                  type: "Identifier",
                  name: C[a.operator]
                }
              }, h(a.argument), a.arguments = [a.argument]) : h(a.argument);
              break;
            case "Property":
              h(a.key), h(a.value);
              break;
            case "WhileStatement":
              h(a.test), h(a.body);
              break;
            case "BreakStatement":
            case "EmptyStatement":
            case "Literal":
            case "Identifier":
            case "ThisExpression":
            case "DebuggerStatement":
              break;
            default:
              console.log(JSON.stringify(a, null, 2));
          }
      }
      function i(a, b) {
        return null !== a && "object" == typeof a && "function" == typeof a[b];
      }
      function j(a, b, c, d, e) {
        var f;
        if (i(a, c)) {
          if (f = a[c](b), "undefined" != typeof f)
            return f;
          if (i(b, d) && (f = b[d](a), "undefined" != typeof f))
            return f;
        } else if (i(b, d) && (f = b[d](a), "undefined" != typeof f))
          return f;
        return e(a, b);
      }
      function k(a, b) {
        return j(a, b, "__add__", "__radd__", function(a, b) {
          return a + b;
        });
      }
      function l(a, b) {
        return j(a, b, "__sub__", "__rsub__", function(a, b) {
          return a - b;
        });
      }
      function m(a, b) {
        return j(a, b, "__mul__", "__rmul__", function(a, b) {
          return a * b;
        });
      }
      function n(a, b) {
        return j(a, b, "__div__", "__rdiv__", function(a, b) {
          return a / b;
        });
      }
      function o(a, b) {
        return j(a, b, "__mod__", "__rmod__", function(a, b) {
          return a % b;
        });
      }
      function p(a, b) {
        return j(a, b, "__vbar__", "__rvbar__", function(a, b) {
          return a | b;
        });
      }
      function q(a, b) {
        return j(a, b, "__wedge__", "__rwedge__", function(a, b) {
          return a ^ b;
        });
      }
      function r(a, b) {
        return j(a, b, "__lshift__", "__rlshift__", function(a, b) {
          return a << b;
        });
      }
      function s(a, b) {
        return j(a, b, "__rshift__", "__rrshift__", function(a, b) {
          return a >> b;
        });
      }
      function t(a, b) {
        return j(a, b, "__eq__", "__req__", function(a, b) {
          return a === b;
        });
      }
      function u(a, b) {
        return j(a, b, "__ne__", "__rne__", function(a, b) {
          return a !== b;
        });
      }
      function v(a) {
        if (i(a, "__exp__"))
          return a.__exp__();
        var b = a,
            c = Math.exp(b);
        return c;
      }
      function w(a) {
        return i(a, "__neg__") ? a.__neg__() : -a;
      }
      function x(a) {
        return i(a, "__pos__") ? a.__pos__() : +a;
      }
      function y(a) {
        return i(a, "__bang__") ? a.__bang__() : !a;
      }
      function z(a) {
        return i(a, "__tilde__") ? a.__tilde__() : ~a;
      }
      var A = "Ms",
          B = {
            "+": "add",
            "-": "sub",
            "*": "mul",
            "/": "div",
            "|": "vbar",
            "^": "wedge",
            "<<": "lshift",
            ">>": "rshift",
            "%": "mod",
            "===": "eq",
            "!==": "ne"
          },
          C = {
            "+": "pos",
            "-": "neg",
            "!": "bang",
            "~": "tilde"
          },
          D = {
            VERSION: c.VERSION,
            parse: f,
            transpile: g,
            add: k,
            sub: l,
            mul: m,
            div: n,
            vbar: p,
            wedge: q,
            lshift: r,
            rshift: s,
            mod: o,
            eq: t,
            ne: u,
            neg: w,
            pos: x,
            bang: y,
            tilde: z,
            exp: v
          };
      return D;
    });
    var f = d("davinci-mathscript");
    "undefined" != typeof module && module.exports ? module.exports = f : e ? !function(a) {
      a(function() {
        return f;
      });
    }(e) : a.Ms = f;
  }(this);
  return module.exports;
});

System.registerDynamic("github:geometryzen/davinci-mathscript@1.0.11.js", ["github:geometryzen/davinci-mathscript@1.0.11/dist/davinci-mathscript.min.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:geometryzen/davinci-mathscript@1.0.11/dist/davinci-mathscript.min.js');
  return module.exports;
});

System.register("js/directives/workspace/WorkspaceController.js", ["ace.js", "./detect1x", "../../utils/doodleGroom", "../../utils/StringSet", "davinci-mathscript"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var ace_js_1,
      detect1x_1,
      doodleGroom_1,
      StringSet_1,
      davinci_mathscript_1;
  var WAIT_NO_MORE,
      WAIT_FOR_MORE_CODE_KEYSTROKES,
      WAIT_FOR_MORE_OTHER_KEYSTROKES,
      WorkspaceController;
  function namesToOptions(names, options) {
    return options.filter(function(option) {
      return names.indexOf(option.name) >= 0;
    });
  }
  function optionsToNames(options) {
    return options.map(function(option) {
      return option.name;
    });
  }
  function closure(options, manager) {
    var nameSet = new StringSet_1.default();
    options.forEach(function(option) {
      nameSet.add(option.name);
    });
    var done = false;
    while (!done) {
      var size = nameSet.size();
      namesToOptions(nameSet.toArray(), manager).forEach(function(option) {
        for (var name_1 in option.dependencies) {
          if (option.dependencies.hasOwnProperty(name_1)) {
            nameSet.add(name_1);
          }
        }
      });
      done = size === nameSet.size();
    }
    return namesToOptions(nameSet.toArray(), manager);
  }
  function fileContent(fileName, doodle) {
    var file = doodle.files[fileName];
    if (file) {
      return file.content;
    } else {
      console.warn("fileContent(" + fileName + "), " + fileName + " does not exist.");
      return void 0;
    }
  }
  function currentJavaScript(fileName, doodle) {
    var code = doodle.lastKnownJs[fileName];
    if (code) {
      if (doodle.operatorOverloading) {
        try {
          return davinci_mathscript_1.default.transpile(code);
        } catch (e) {
          console.error(e);
          return code;
        }
      } else {
        return code;
      }
    } else {
      return "";
    }
  }
  function startsWith(sourceString, searchString, position) {
    if (position === void 0) {
      position = 0;
    }
    return sourceString.indexOf(searchString, position) === position;
  }
  function scriptURL(domain, fileName, VENDOR_FOLDER_MARKER) {
    if (startsWith(fileName, VENDOR_FOLDER_MARKER)) {
      return domain + '/vendor' + fileName.substring(VENDOR_FOLDER_MARKER.length);
    } else {
      return domain + '/js/' + fileName;
    }
  }
  function bubbleIframeMouseMove(iframe) {
    var existingOnMouseMove = iframe.contentWindow.onmousemove;
    iframe.contentWindow.onmousemove = function(e) {
      if (existingOnMouseMove)
        existingOnMouseMove(e);
      var evt = document.createEvent("MouseEvents");
      var boundingClientRect = iframe.getBoundingClientRect();
      evt.initMouseEvent("mousemove", true, false, window, e.detail, e.screenX, e.screenY, e.clientX + boundingClientRect.left, e.clientY + boundingClientRect.top, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, null);
      iframe.dispatchEvent(evt);
    };
  }
  return {
    setters: [function(ace_js_1_1) {
      ace_js_1 = ace_js_1_1;
    }, function(detect1x_1_1) {
      detect1x_1 = detect1x_1_1;
    }, function(doodleGroom_1_1) {
      doodleGroom_1 = doodleGroom_1_1;
    }, function(StringSet_1_1) {
      StringSet_1 = StringSet_1_1;
    }, function(davinci_mathscript_1_1) {
      davinci_mathscript_1 = davinci_mathscript_1_1;
    }],
    execute: function() {
      WAIT_NO_MORE = 0;
      WAIT_FOR_MORE_CODE_KEYSTROKES = 1500;
      WAIT_FOR_MORE_OTHER_KEYSTROKES = 350;
      WorkspaceController = (function() {
        function WorkspaceController($scope, $state, $stateParams, $http, $location, $timeout, $window, github, authManager, cloud, cookie, templates, uuid4, ga, doodlesKey, doodles, options, FILENAME_META, FILENAME_HTML, FILENAME_CODE, FILENAME_LIBS, FILENAME_LESS, FILENAME_MATHSCRIPT_CURRENT_LIB_MIN_JS, FILENAME_TYPESCRIPT_CURRENT_LIB_DTS, STATE_GISTS, STYLE_MARKER, SCRIPTS_MARKER, CODE_MARKER, LIBS_MARKER, VENDOR_FOLDER_MARKER, settings) {
          var _this = this;
          this.$scope = $scope;
          this.$http = $http;
          this.$location = $location;
          this.$timeout = $timeout;
          this.$window = $window;
          this.doodles = doodles;
          this.options = options;
          this.FILENAME_HTML = FILENAME_HTML;
          this.FILENAME_CODE = FILENAME_CODE;
          this.FILENAME_LIBS = FILENAME_LIBS;
          this.FILENAME_LESS = FILENAME_LESS;
          this.FILENAME_MATHSCRIPT_CURRENT_LIB_MIN_JS = FILENAME_MATHSCRIPT_CURRENT_LIB_MIN_JS;
          this.FILENAME_TYPESCRIPT_CURRENT_LIB_DTS = FILENAME_TYPESCRIPT_CURRENT_LIB_DTS;
          this.STYLE_MARKER = STYLE_MARKER;
          this.SCRIPTS_MARKER = SCRIPTS_MARKER;
          this.CODE_MARKER = CODE_MARKER;
          this.LIBS_MARKER = LIBS_MARKER;
          this.VENDOR_FOLDER_MARKER = VENDOR_FOLDER_MARKER;
          this.olds = [];
          this.workspace = ace_js_1.default.createWorkspace();
          this.outputFilesEventHandlers = {};
          this.changeHandlers = {};
          this.editors = {};
          var systemImports = ['/jspm_packages/system.js', '/jspm.config.js'];
          var workerImports = systemImports.concat(['/js/ace-workers.js']);
          var typescriptServices = ['/js/typescriptServices.js'];
          this.workspace.init('/js/worker.js', workerImports.concat(typescriptServices));
          this.workspace.setDefaultLibrary('/typings/lib.es6.d.ts');
          var rebuildPromise;
          $scope.updatePreview = function(delay) {
            if (rebuildPromise) {
              $timeout.cancel(rebuildPromise);
            }
            rebuildPromise = $timeout(function() {
              _this.rebuildPreview();
              rebuildPromise = undefined;
            }, delay);
          };
          var TEXT_CODE_HIDE = "View";
          var TEXT_CODE_SHOW = "Edit";
          function setEditMode(editMode) {
            $scope.isEditMode = editMode;
            $scope.toggleText = editMode ? TEXT_CODE_HIDE : TEXT_CODE_SHOW;
          }
          var setViewMode = function(isViewVisible) {
            $scope.isViewVisible = isViewVisible;
          };
          $scope.toggleMode = function(label, value) {
            ga('send', 'event', 'doodle', 'toggleMode', label, value);
            setEditMode(!$scope.isEditMode);
            if (!$scope.isEditMode) {
              setViewMode(true);
              $scope.updatePreview(WAIT_NO_MORE);
            } else {
              if ($scope.isViewVisible) {
                $scope.updatePreview(WAIT_NO_MORE);
              }
            }
          };
          $scope.toggleView = function(label, value) {
            ga('send', 'event', 'doodle', 'toggleView', label, value);
            setViewMode(!$scope.isViewVisible);
            $scope.updatePreview(WAIT_NO_MORE);
          };
          $scope.updateView = function() {
            _this.updateWorkspace();
            setEditMode(doodles.current().isCodeVisible);
            setViewMode(false);
            $window.document.title = doodles.current().description;
          };
          if (doodles.length === 0) {
            doodles.createDoodle($scope.templates[0], "My Math Doodle");
          }
          var doodle = doodleGroom_1.default(doodles.current());
          var moduleKind = detect1x_1.default(doodle) ? 'none' : 'system';
          this.workspace.setModuleKind(moduleKind, function(err) {
            if (err) {
              console.warn("setModuleKind('" + moduleKind + "') => " + err);
            }
          });
          var scriptTarget = detect1x_1.default(doodle) ? 'es5' : 'es5';
          this.workspace.setScriptTarget(scriptTarget, function(err) {
            if (err) {
              console.warn("setScriptTarget('" + scriptTarget + "') => " + err);
            }
          });
          doodle.isCodeVisible = true;
          doodles.updateStorage();
          var GITHUB_TOKEN_COOKIE_NAME = 'github-token';
          var gistId = $stateParams['gistId'];
          if (gistId) {
            if (doodles.current().gistId !== gistId) {
              var token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
              cloud.downloadGist(token, gistId, function(err, doodle) {
                if (!err) {
                  doodles.deleteDoodle(doodle.uuid);
                  doodles.unshift(doodle);
                  doodles.updateStorage();
                  $scope.updateView();
                } else {
                  $scope.alert("Error attempting to download Gist");
                }
                $scope.updatePreview(WAIT_NO_MORE);
              });
            } else {
              $scope.updateView();
              $scope.updatePreview(WAIT_NO_MORE);
            }
          } else {
            if (doodles.current().gistId) {
              $state.go(STATE_GISTS, {gistId: doodles.current().gistId});
            } else {
              $scope.updateView();
              $scope.updatePreview(WAIT_NO_MORE);
            }
          }
          $scope.$watch('isViewVisible', function(newVal, oldVal, unused) {
            doodles.current().isViewVisible = $scope.isViewVisible;
            doodles.updateStorage();
          });
          $scope.$watch('isEditMode', function(newVal, oldVal, unused) {
            doodles.current().isCodeVisible = $scope.isEditMode;
            doodles.updateStorage();
          });
        }
        WorkspaceController.prototype.$onInit = function() {
          var _this = this;
          this.resizeListener = function(unused) {
            _this.resize();
          };
          this.$window.addEventListener('resize', this.resizeListener);
          this.$scope.$on('angular-resizable.resizeStart', function(event, data) {});
          this.$scope.$on('angular-resizable.resizing', function(event, data) {});
          this.$scope.$on('angular-resizable.resizeEnd', function(event, data) {
            _this.resize();
          });
          this.resize();
        };
        WorkspaceController.prototype.$onDestroy = function() {
          this.$window.removeEventListener('resize', this.resizeListener);
        };
        WorkspaceController.prototype.resize = function() {
          var fileNames = Object.keys(this.editors);
          var iLen = fileNames.length;
          for (var i = 0; i < iLen; i++) {
            var fileName = fileNames[i];
            var editor = this.editors[fileName];
            editor.resize(true);
          }
        };
        WorkspaceController.prototype.attachEditor = function(filename, mode, editor) {
          switch (mode) {
            case 'TypeScript':
              {
                this.workspace.attachEditor(filename, editor);
                editor.getSession().on('outputFiles', this.createOutputFilesEventHandler(filename));
                break;
              }
            case 'JavaScript':
              {
                this.workspace.attachEditor(filename, editor);
                editor.getSession().on('outputFiles', this.createOutputFilesEventHandler(filename));
                break;
              }
            case 'HTML':
            case 'LESS':
              {
                editor.getSession().on('change', this.createChangeHandler(filename));
                break;
              }
            default:
              {
                console.warn("attachEditor(mode => " + mode + ") is being ignored.");
              }
          }
          this.editors[filename] = editor;
          editor.resize(true);
        };
        WorkspaceController.prototype.createOutputFilesEventHandler = function(filename) {
          var _this = this;
          var handler = function(event, session) {
            var doodle = _this.doodles.current();
            var outputFiles = event.data;
            outputFiles.forEach(function(outputFile) {
              if (typeof doodle.lastKnownJs !== 'object') {
                doodle.lastKnownJs = {};
              }
              if (doodle.lastKnownJs[filename] !== outputFile.text) {
                doodle.lastKnownJs[filename] = outputFile.text;
                _this.doodles.updateStorage();
                _this.$scope.updatePreview(WAIT_FOR_MORE_CODE_KEYSTROKES);
              }
            });
          };
          this.outputFilesEventHandlers[filename] = handler;
          return handler;
        };
        WorkspaceController.prototype.deleteOutputFileHandler = function(filename) {
          delete this.outputFilesEventHandlers[filename];
        };
        WorkspaceController.prototype.createChangeHandler = function(filename) {
          var _this = this;
          var handler = function(delta, session) {
            if (_this.doodles.current()) {
              _this.doodles.updateStorage();
              _this.$scope.updatePreview(WAIT_FOR_MORE_OTHER_KEYSTROKES);
            }
          };
          this.changeHandlers[filename] = handler;
          return handler;
        };
        WorkspaceController.prototype.deleteChangeHandler = function(filename) {
          delete this.outputFilesEventHandlers[filename];
        };
        WorkspaceController.prototype.detachEditor = function(filename, mode, editor) {
          switch (mode) {
            case 'TypeScript':
              {
                var handler = this.outputFilesEventHandlers[filename];
                editor.getSession().off('outputFiles', handler);
                this.deleteOutputFileHandler(filename);
                this.workspace.detachEditor(filename, editor);
                break;
              }
            case 'JavaScript':
              {
                var handler = this.outputFilesEventHandlers[filename];
                editor.getSession().off('outputFiles', handler);
                this.deleteOutputFileHandler(filename);
                this.workspace.detachEditor(filename, editor);
                break;
              }
            case 'HTML':
            case 'LESS':
              {
                var handler = this.changeHandlers[filename];
                editor.getSession().off('change', handler);
                this.deleteChangeHandler(filename);
                break;
              }
            default:
              {
                console.warn("detachEditor(mode => " + mode + ") is being ignored.");
              }
          }
          delete this.editors[filename];
        };
        WorkspaceController.prototype.updateWorkspace = function() {
          var _this = this;
          var news = optionsToNames(closure(namesToOptions(this.doodles.current().dependencies, this.options), this.options));
          var adds = news.filter(function(dep) {
            return _this.olds.indexOf(dep) < 0;
          });
          var rmvs = this.olds.filter(function(dep) {
            return news.indexOf(dep) < 0;
          });
          if (rmvs.indexOf('lib') >= 0) {
            rmvs.splice(rmvs.indexOf('lib'), 1);
          }
          var rmvOpts = namesToOptions(rmvs, this.options);
          var rmvUnits = rmvOpts.map(function(option) {
            return {
              name: option.name,
              fileName: option.dts
            };
          });
          var addOpts = namesToOptions(adds, this.options);
          var addUnits = addOpts.map(function(option) {
            return {
              name: option.name,
              fileName: option.dts
            };
          });
          if (this.olds.indexOf('lib') < 0) {
            addUnits = addUnits.concat({
              name: 'lib',
              fileName: this.FILENAME_TYPESCRIPT_CURRENT_LIB_DTS
            });
          }
          var FWD_SLASH = '/';
          var DOMAIN = this.$location.protocol() + ':' + FWD_SLASH + FWD_SLASH + this.$location.host() + ":" + this.$location.port();
          var readFile = function(fileName, callback) {
            var url = scriptURL(DOMAIN, fileName, _this.VENDOR_FOLDER_MARKER);
            _this.$http.get(url).success(function(data, status, headers, config) {
              callback(null, data);
            }).error(function(data, status, headers, config) {
              callback(new Error("Unable to wrangle #{fileName}."));
            });
          };
          rmvUnits.forEach(function(rmvUnit) {
            _this.workspace.removeScript(rmvUnit.fileName);
            _this.olds.splice(_this.olds.indexOf(rmvUnit.name), 1);
          });
          addUnits.forEach(function(addUnit) {
            readFile(addUnit.fileName, function(err, content) {
              if (!err) {
                _this.workspace.ensureScript(addUnit.fileName, content.replace(/\r\n?/g, '\n'));
                _this.olds.unshift(addUnit.name);
              }
            });
          });
        };
        WorkspaceController.prototype.rebuildPreview = function() {
          var _this = this;
          var FWD_SLASH = '/';
          var DOMAIN = this.$location.protocol() + ':' + FWD_SLASH + FWD_SLASH + this.$location.host() + ":" + this.$location.port();
          try {
            this.$scope.previewIFrame = undefined;
            var preview = this.$window.document.getElementById('preview');
            if (preview) {
              while (preview.children.length > 0) {
                preview.removeChild(preview.firstChild);
              }
              var doodle_1 = this.doodles.current();
              if (this.$scope.isViewVisible && doodle_1) {
                this.$scope.previewIFrame = document.createElement('iframe');
                this.$scope.previewIFrame.style.width = '100%';
                this.$scope.previewIFrame.style.height = '100%';
                this.$scope.previewIFrame.style.border = '0';
                this.$scope.previewIFrame.style.backgroundColor = '#ffffff';
                preview.appendChild(this.$scope.previewIFrame);
                var content = this.$scope.previewIFrame.contentDocument || this.$scope.previewIFrame.contentWindow.document;
                var html = fileContent(this.FILENAME_HTML, doodle_1);
                if (typeof html === 'string') {
                  var selOpts = this.options.filter(function(option, index, array) {
                    return doodle_1.dependencies.indexOf(option.name) > -1;
                  });
                  var closureOpts = closure(selOpts, this.options);
                  var chosenFileNames = closureOpts.map(function(option) {
                    return option.minJs;
                  });
                  var scriptFileNames = this.doodles.current().operatorOverloading ? chosenFileNames.concat(this.FILENAME_MATHSCRIPT_CURRENT_LIB_MIN_JS) : chosenFileNames;
                  var scriptTags = scriptFileNames.map(function(fileName) {
                    return "<script src='" + scriptURL(DOMAIN, fileName, _this.VENDOR_FOLDER_MARKER) + "'></script>\n";
                  });
                  html = html.replace(this.SCRIPTS_MARKER, scriptTags.join(""));
                  html = html.replace(this.STYLE_MARKER, [fileContent(this.FILENAME_LESS, doodle_1)].join(""));
                  if (detect1x_1.default(doodle_1)) {
                    html = html.replace(this.LIBS_MARKER, currentJavaScript(this.FILENAME_LIBS, doodle_1));
                    html = html.replace(this.CODE_MARKER, currentJavaScript(this.FILENAME_CODE, doodle_1));
                    html = html.replace('<!-- STYLE-MARKER -->', ['<style>', fileContent(this.FILENAME_LESS, doodle_1), '</style>'].join(""));
                    html = html.replace('<!-- CODE-MARKER -->', currentJavaScript(this.FILENAME_CODE, this.doodles.current()));
                  } else {
                    var modulesJs = [];
                    var names = Object.keys(doodle_1.lastKnownJs);
                    var iLen = names.length;
                    for (var i = 0; i < iLen; i++) {
                      var name_2 = names[i];
                      var moduleJs = doodle_1.lastKnownJs[name_2];
                      var moduleMs = doodle_1.operatorOverloading ? davinci_mathscript_1.default.transpile(moduleJs) : moduleJs;
                      modulesJs.push(moduleMs);
                    }
                    html = html.replace(this.CODE_MARKER, modulesJs.join('\n'));
                  }
                  content.open();
                  content.write(html);
                  content.close();
                  bubbleIframeMouseMove(this.$scope.previewIFrame);
                }
              }
            } else {
              console.warn("There is no #preview element on the doodle page.");
            }
          } catch (e) {
            console.warn(e);
          }
        };
        ;
        WorkspaceController.$inject = ['$scope', '$state', '$stateParams', '$http', '$location', '$timeout', '$window', 'GitHub', 'GitHubAuthManager', 'cloud', 'cookie', 'templates', 'uuid4', 'ga', 'doodlesKey', 'doodles', 'options', 'FILENAME_META', 'FILENAME_HTML', 'FILENAME_CODE', 'FILENAME_LIBS', 'FILENAME_LESS', 'FILENAME_MATHSCRIPT_CURRENT_LIB_MIN_JS', 'FILENAME_TYPESCRIPT_CURRENT_LIB_DTS', 'STATE_GISTS', 'STYLE_MARKER', 'SCRIPTS_MARKER', 'CODE_MARKER', 'LIBS_MARKER', 'VENDOR_FOLDER_MARKER', 'settings'];
        return WorkspaceController;
      }());
      exports_1("default", WorkspaceController);
    }
  };
});

System.register("js/directives/workspace/workspace.component.js", ["./WorkspaceController"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var WorkspaceController_1;
  function factory() {
    function link($scope, element, attrs, controllers, transclude) {}
    var directive = {
      require: [],
      restrict: 'E',
      controller: WorkspaceController_1.default,
      link: link
    };
    return directive;
  }
  return {
    setters: [function(WorkspaceController_1_1) {
      WorkspaceController_1 = WorkspaceController_1_1;
    }],
    execute: function() {
      factory.$inject = [];
      exports_1("default", factory);
    }
  };
});

System.register("js/controllers/AboutController.js", ["../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.controller('about-controller', ['$scope', '$state', '$window', function($scope, $state, $window) {
        $scope.doCheckForUpdates = function() {
          var appCache = $window.applicationCache;
          appCache.update();
          if (appCache.status === $window.applicationCache.UPDATEREADY) {
            appCache.swapCache();
          }
        };
        $scope.doClose = function() {
          $state.transitionTo('doodle');
        };
      }]);
    }
  };
});

System.register("js/controllers/BodyController.js", ["../app", "bootstrap-dialog", "../utils/linkToMap"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1,
      bootstrap_dialog_1,
      linkToMap_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }, function(bootstrap_dialog_1_1) {
      bootstrap_dialog_1 = bootstrap_dialog_1_1;
    }, function(linkToMap_1_1) {
      linkToMap_1 = linkToMap_1_1;
    }],
    execute: function() {
      app_1.default.controller('body-controller', ['$scope', '$state', 'doodles', 'ga', 'GitHub', 'cookie', 'GITHUB_TOKEN_COOKIE_NAME', function($scope, $state, doodles, ga, github, cookie, GITHUB_TOKEN_COOKIE_NAME) {
        $scope.currentDoodle = function() {
          return doodles.current();
        };
        $scope.doodles = function() {
          return doodles.filter(function() {
            return true;
          });
        };
        $scope.clickDownload = function(label, value) {
          ga('send', 'event', 'doodle', 'download', label, value);
          var token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
          github.getGists(token, function(err, gists, status, headers, config) {
            if (!err) {
              $scope.gists = gists;
              $scope.links = linkToMap_1.default(headers('link'));
              $state.go('download');
            } else {
              bootstrap_dialog_1.default.show({
                type: bootstrap_dialog_1.default.TYPE_DANGER,
                title: $("<h3>Download failed</h3>"),
                message: "Unable to download Gists. Cause: " + err + " " + status,
                buttons: [{
                  label: "Close",
                  cssClass: 'btn btn-primary',
                  action: function(dialog) {
                    dialog.close();
                  }
                }]
              });
            }
          });
        };
      }]);
    }
  };
});

System.register("js/controllers/CopyController.js", ["../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.controller('copy-controller', ['$scope', '$state', 'doodles', 'STATE_DOODLE', function($scope, $state, doodles, STATE_DOODLE) {
        $scope.description = doodles.suggestName();
        $scope.template = doodles.current();
        $scope.doOK = function() {
          doodles.createDoodle($scope.template, $scope.description);
          doodles.updateStorage();
          $state.go(STATE_DOODLE);
        };
        $scope.doCancel = function() {
          $state.go(STATE_DOODLE);
        };
      }]);
    }
  };
});

System.register("js/utils/linkToMap.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function linkToMap(links) {
    var map = {};
    var parts = links.split(',');
    for (var i = 0,
        iLength = parts.length; i < iLength; i++) {
      var link = parts[i];
      var lt = link.indexOf('<');
      var gt = link.indexOf('>');
      var rs = link.indexOf('rel=');
      var href = link.substring(lt + 1, gt);
      var rem = link.substring(rs + 5);
      var rel = rem.substring(0, rem.length - 1);
      map[rel] = href;
    }
    return map;
  }
  exports_1("default", linkToMap);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/controllers/DownloadController.js", ["../app", "../utils/linkToMap"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1,
      linkToMap_1;
  var PAGE_F,
      PAGE_P,
      PAGE_N,
      PAGE_L;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }, function(linkToMap_1_1) {
      linkToMap_1 = linkToMap_1_1;
    }],
    execute: function() {
      PAGE_F = 'first';
      PAGE_P = 'prev';
      PAGE_N = 'next';
      PAGE_L = 'last';
      app_1.default.controller('download-controller', ['$scope', '$state', 'cloud', 'doodles', 'cookie', 'ga', 'GitHub', 'GITHUB_TOKEN_COOKIE_NAME', 'STATE_DOODLE', function($scope, $state, cloud, doodles, cookie, ga, github, GITHUB_TOKEN_COOKIE_NAME, STATE_DOODLE) {
        function isPage(rel) {
          return typeof $scope.links[rel] === 'string';
        }
        $scope.isPageF = function() {
          return isPage(PAGE_F);
        };
        $scope.isPageP = function() {
          return isPage(PAGE_P);
        };
        $scope.isPageN = function() {
          return isPage(PAGE_N);
        };
        $scope.isPageL = function() {
          return isPage(PAGE_L);
        };
        function doPage(rel) {
          if (!isPage(rel)) {
            return;
          }
          var href = $scope.links[rel];
          var token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
          github.getGistsPage(token, href, function(err, gists, status, headers, config) {
            if (!err) {
              $scope.gists = gists;
              $scope.links = linkToMap_1.default(headers('link'));
              $state.go('download');
            } else {
              BootstrapDialog.show({
                type: BootstrapDialog.TYPE_DANGER,
                title: $("<h3>Download failed</h3>"),
                message: "Unable to download Gists. Cause: " + err + " " + status,
                buttons: [{
                  label: "Close",
                  cssClass: 'btn btn-primary',
                  action: function(dialog) {
                    dialog.close();
                  }
                }]
              });
            }
          });
        }
        $scope.doPageF = function() {
          doPage(PAGE_F);
        };
        $scope.doPageP = function() {
          doPage(PAGE_P);
        };
        $scope.doPageL = function() {
          doPage(PAGE_L);
        };
        $scope.doPageN = function() {
          doPage(PAGE_N);
        };
        $scope.doCancel = function() {
          $state.go(STATE_DOODLE);
        };
      }]);
    }
  };
});

System.register("js/controllers/ExamplesController.js", ["../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.controller('examples-controller', ['$scope', '$state', '$stateParams', '$http', '$location', '$timeout', '$window', 'GitHubAuthManager', 'ga', 'STATE_GISTS', function(scope, $state, $stateParams, http, $location, $timeout, $window, authManager, ga, STATE_GISTS) {
        authManager.handleGitHubLoginCallback(function(err, token) {
          if (err) {
            scope.alert(err.message);
          }
        });
        $window.document.body.style.overflow = "auto";
        ga('create', 'UA-41504069-3', 'auto');
        ga('send', 'pageview');
        scope.goHome = function(label, value) {
          ga('send', 'event', 'examples', 'goHome', label, value);
          $state.go('home');
        };
      }]);
    }
  };
});

System.register("js/controllers/HomeController.js", ["../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.controller('home-controller', ['$scope', '$state', '$twitter', '$window', 'GitHubAuthManager', 'NAMESPACE_TWITTER_WIDGETS', 'STATE_DOODLE', 'STATE_EXAMPLES', function($scope, $state, $twitter, $window, authManager, NAMESPACE_TWITTER_WIDGETS, STATE_DOODLE, STATE_EXAMPLES) {
        $window.document.body.style.overflow = 'auto';
        authManager.handleGitHubLoginCallback(function(err, token) {
          if (err) {
            $scope.alert(err.message);
          }
        });
        if ($window[NAMESPACE_TWITTER_WIDGETS] && $window[NAMESPACE_TWITTER_WIDGETS].widgets) {
          $window[NAMESPACE_TWITTER_WIDGETS].widgets.load();
        } else {}
        $scope.twitterShareText = "MathDoodle · Learning Mathematics and Geometric Physics through Computational Modeling.";
        $scope.goDoodle = function() {
          $state.go(STATE_DOODLE);
        };
        $scope.goExamples = function() {
          $state.go(STATE_EXAMPLES);
        };
      }]);
    }
  };
});

System.register("js/controllers/LoginController.js", ["../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.controller('LoginController', ['$scope', '$state', '$window', 'cookie', 'uuid4', 'ga', 'githubKey', function($scope, $state, $window, cookie, uuid4, ga, githubKey) {
        var GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME = 'mathdoodle-github-application-client-id';
        var GITHUB_GET_LOGIN_OAUTH_AUTHORIZE = "https://github.com/login/oauth/authorize";
        $scope.githubLogin = function(label, value) {
          ga('send', 'event', 'GitHub', 'login', label, value);
          var clientId = cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
          var state = uuid4.generate();
          var githubURL = GITHUB_GET_LOGIN_OAUTH_AUTHORIZE + "?client_id=" + clientId + "&amp;scope=user,gist" + "&amp;state=" + state;
          var github = {oauth: {pending: state}};
          $window.localStorage.setItem(githubKey, JSON.stringify(github));
          $window.location.href = githubURL;
        };
      }]);
    }
  };
});

System.register("js/controllers/NewController.js", ["../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.controller('new-controller', ['$scope', '$state', 'doodles', 'templates', 'STATE_DOODLE', function($scope, $state, doodles, templates, STATE_DOODLE) {
        $scope.description = doodles.suggestName();
        $scope.template = templates[0];
        $scope.templates = templates;
        $scope.doOK = function() {
          doodles.createDoodle($scope.template, $scope.description);
          doodles.updateStorage();
          $state.go(STATE_DOODLE);
        };
        $scope.doCancel = function() {
          $state.go(STATE_DOODLE);
        };
      }]);
    }
  };
});

System.register("js/controllers/OpenController.js", ["../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.controller('open-controller', ['$scope', '$state', 'doodles', 'STATE_DOODLE', function($scope, $state, doodles, STATE_DOODLE) {
        $scope.doOpen = function(uuid) {
          doodles.makeCurrent(uuid);
          $state.go(STATE_DOODLE);
        };
        $scope.doDelete = function(uuid) {
          doodles.deleteDoodle(uuid);
        };
        $scope.doClose = function() {
          $state.go(STATE_DOODLE);
        };
      }]);
    }
  };
});

System.register("js/controllers/PropertiesController.js", ["../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.controller('properties-controller', ['$scope', '$state', '$stateParams', 'doodles', 'options', 'STATE_DOODLE', function(scope, $state, $stateParams, doodles, options, STATE_DOODLE) {
        scope.zombie = JSON.parse(JSON.stringify(doodles.current()));
        scope.options = options.filter(function(option) {
          return option.visible;
        });
        scope.toggleDependency = function(name) {
          var idx = scope.zombie.dependencies.indexOf(name);
          if (idx > -1) {
            scope.zombie.dependencies.splice(idx, 1);
          } else {
            scope.zombie.dependencies.push(name);
          }
        };
        scope.doOK = function() {
          doodles.current().description = scope.zombie.description;
          doodles.current().dependencies = scope.zombie.dependencies.filter(function(name) {
            return options.filter(function(option) {
              return option.visible && option.name === name;
            }).length > 0;
          });
          doodles.current().operatorOverloading = scope.zombie.operatorOverloading;
          $state.go(STATE_DOODLE);
        };
        scope.doCancel = function() {
          $state.go(STATE_DOODLE);
        };
      }]);
    }
  };
});

System.register("js/fugly/ga/ga.js", ["../../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.factory('ga', ['$window', 'NAMESPACE_GOOGLE_ANALYTICS', function($window, NAMESPACE_GOOGLE_ANALYTICS) {
        (function(i, $document, tagName, url, r, a, m) {
          i['GoogleAnalyticsObject'] = r;
          i[r] = i[r] || function() {
            (i[r].q = i[r].q || []).push(arguments);
          }, i[r].l = new Date().valueOf();
          a = $document.createElement(tagName);
          m = $document.getElementsByTagName(tagName)[0];
          a.async = 1;
          a.src = url;
          m.parentNode.insertBefore(a, m);
        })($window, document, 'script', '//www.google-analytics.com/analytics.js', NAMESPACE_GOOGLE_ANALYTICS);
        var service = function() {
          if (angular.isArray(arguments[0])) {
            for (var i = 0; i < arguments.length; ++i) {
              service.apply(this, arguments[i]);
            }
            return;
          }
          if ($window[NAMESPACE_GOOGLE_ANALYTICS]) {
            $window[NAMESPACE_GOOGLE_ANALYTICS]['apply'](this, arguments);
          }
        };
        return service;
      }]);
    }
  };
});

System.register("js/services/cloud/cloud.js", ["../../app", "../doodles/Doodle", "../doodles/DoodleFile", "../../utils/modeFromName"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1,
      Doodle_1,
      DoodleFile_1,
      modeFromName_1;
  function mapFiles(gFiles, excludes) {
    var dFiles = {};
    var names = Object.keys(gFiles);
    var iLen = names.length;
    for (var i = 0; i < iLen; i++) {
      var name_1 = names[i];
      if (excludes.indexOf(name_1) < 0) {
        var gFile = gFiles[name_1];
        var dFile = new DoodleFile_1.default();
        dFile.content = gFile.content;
        dFile.language = modeFromName_1.default(name_1);
        dFiles[name_1] = dFile;
      }
    }
    return dFiles;
  }
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }, function(Doodle_1_1) {
      Doodle_1 = Doodle_1_1;
    }, function(DoodleFile_1_1) {
      DoodleFile_1 = DoodleFile_1_1;
    }, function(modeFromName_1_1) {
      modeFromName_1 = modeFromName_1_1;
    }],
    execute: function() {
      app_1.default.factory('cloud', ['GitHub', 'FILENAME_META', 'FILENAME_HTML', 'FILENAME_CODE', 'FILENAME_LIBS', 'FILENAME_LESS', function(github, FILENAME_META, FILENAME_HTML, FILENAME_CODE, FILENAME_LIBS, FILENAME_LESS) {
        function depArray(deps) {
          var ds = [];
          for (var prop in deps) {
            if (deps.hasOwnProperty(prop)) {
              ds.push(prop);
            }
          }
          return ds;
        }
        var cloud = {downloadGist: function(token, gistId, callback) {
            github.getGist(token, gistId, function(err, gist) {
              if (!err) {
                var metaInfo = JSON.parse(gist.files[FILENAME_META].content);
                var doodle = new Doodle_1.default();
                doodle.gistId = gistId;
                doodle.uuid = metaInfo.uuid;
                doodle.description = gist.description;
                doodle.operatorOverloading = metaInfo.operatorOverloading;
                doodle.files = mapFiles(gist.files, [FILENAME_META]);
                doodle.dependencies = depArray(metaInfo.dependencies);
                callback(undefined, doodle);
              } else {
                callback(err);
              }
            });
          }};
        return cloud;
      }]);
    }
  };
});

System.register("js/services/cookie/cookie.js", ["../../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.factory('cookie', [function() {
        return {
          getItem: function(name) {
            var escapedName = encodeURI(name).replace(/[\-\.\+\*]/g, "\\$&");
            return decodeURI(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + escapedName + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
          },
          setItem: function(name, value, end, path, domain, secure) {
            var cookie,
                expires;
            if (!name || /^(?:expires|max\-age|path|domain|secure)$/i.test(name)) {
              throw new Error("Illegal name");
            }
            if (end) {
              switch (end.constructor) {
                case Number:
                  expires = end === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + end;
                  break;
                case String:
                  expires = "; expires=" + end;
                  break;
                case Date:
                  expires = "; expires=" + end.toGMTString();
                  break;
                default:
                  expires = "";
              }
            } else {
              expires = "";
            }
            domain = domain ? "; domain=" + domain : "";
            path = path ? "; path=" + path : "";
            secure = secure ? "; secure" : "";
            cookie = "" + (encodeURI(name)) + "=" + (encodeURI(value)) + expires + domain + path + secure;
            document.cookie = cookie;
          },
          removeItem: function(name, path) {
            if (!name || !this.hasItem(name)) {
              return false;
            }
            return this.setItem(name, "", new Date(0), path);
          },
          hasItem: function(name) {
            return (new RegExp("(?:^|;\\s*)" + encodeURI(name).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
          }
        };
      }]);
    }
  };
});

System.register("js/services/doodles/doodles.js", ["../../app", "./Doodle", "./DoodleFile"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1,
      Doodle_1,
      DoodleFile_1;
  function deserialize(doodles) {
    var ds = [];
    var iLen = doodles.length;
    for (var i = 0; i < iLen; i++) {
      var inDoodle = doodles[i];
      var d = new Doodle_1.default();
      d.dependencies = inDoodle.dependencies.slice();
      d.description = inDoodle.description;
      d.files = copyFiles(inDoodle.files);
      d.focusEditor = inDoodle.focusEditor;
      d.isCodeVisible = inDoodle.isCodeVisible;
      d.isViewVisible = inDoodle.isViewVisible;
      d.lastKnownJs = inDoodle.lastKnownJs;
      d.operatorOverloading = inDoodle.operatorOverloading;
      d.uuid = inDoodle.uuid;
      ds.push(d);
    }
    return ds;
  }
  function copyFiles(inFiles) {
    var outFiles = {};
    var names = Object.keys(inFiles);
    var iLen = names.length;
    for (var i = 0; i < iLen; i++) {
      var name_1 = names[i];
      var inFile = inFiles[name_1];
      var outFile = new DoodleFile_1.default();
      outFile.content = inFile.content;
      outFile.language = inFile.language;
      outFiles[name_1] = outFile;
    }
    return outFiles;
  }
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }, function(Doodle_1_1) {
      Doodle_1 = Doodle_1_1;
    }, function(DoodleFile_1_1) {
      DoodleFile_1 = DoodleFile_1_1;
    }],
    execute: function() {
      app_1.default.factory('doodles', ['$window', 'uuid4', 'doodlesKey', function($window, uuid4, doodlesKey) {
        var _doodles = deserialize($window.localStorage[doodlesKey] !== undefined ? JSON.parse($window.localStorage[doodlesKey]) : []);
        var suggestName = function() {
          var UNTITLED = "Doodle";
          function compareNumbers(a, b) {
            return b - a;
          }
          var nums = _doodles.filter(function(doodle) {
            return typeof doodle.description.match(new RegExp(UNTITLED)) !== 'null';
          }).map(function(doodle) {
            return parseInt(doodle.description.replace(UNTITLED + ' ', '').trim(), 10);
          }).filter(function(num) {
            return !isNaN(num);
          });
          nums.sort(compareNumbers);
          return UNTITLED + ' ' + (nums.length === 0 ? 1 : nums[0] + 1);
        };
        var that = {
          unshift: function(doodle) {
            return _doodles.unshift(doodle);
          },
          get length() {
            return _doodles.length;
          },
          filter: function(callback) {
            return _doodles.filter(callback);
          },
          current: function() {
            if (_doodles.length > 0) {
              return _doodles[0];
            } else {
              return undefined;
            }
          },
          createDoodle: function(template, description) {
            if (!description) {
              description = suggestName();
            }
            var doodle = new Doodle_1.default();
            doodle.uuid = uuid4.generate();
            doodle.description = description;
            doodle.operatorOverloading = template.operatorOverloading;
            doodle.files = copyFiles(template.files);
            doodle.dependencies = template.dependencies.slice();
            _doodles.unshift(doodle);
          },
          makeCurrent: function(uuid) {
            var doodles = [];
            var i = 0,
                found;
            while (i < _doodles.length) {
              if (_doodles[i].uuid === uuid) {
                found = _doodles[i];
              } else {
                doodles.push(_doodles[i]);
              }
              i++;
            }
            if (!found)
              return;
            doodles.unshift(found);
            _doodles = doodles;
          },
          deleteDoodle: function(uuid) {
            var doodles = [];
            var i = 0,
                found;
            while (i < _doodles.length) {
              if (_doodles[i].uuid === uuid) {
                found = _doodles[i];
              } else {
                doodles.push(_doodles[i]);
              }
              i++;
            }
            if (!found)
              return;
            _doodles = doodles;
          },
          suggestName: suggestName,
          updateStorage: function() {
            $window.localStorage[doodlesKey] = JSON.stringify(_doodles);
          }
        };
        return that;
      }]);
    }
  };
});

System.register("js/services/gham/GitHubAuthManager.js", ["../../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.service('GitHubAuthManager', ['$http', '$location', '$window', 'cookie', 'GitHub', 'githubKey', function($http, $location, $window, cookie, github, githubKey) {
        var GATEKEEPER_DOMAIN = "" + ($location.protocol()) + "://" + ($location.host()) + ":" + ($location.port());
        var GITHUB_TOKEN_COOKIE_NAME = 'github-token';
        var GITHUB_LOGIN_COOKIE_NAME = 'github-login';
        var handleGitHubLoginCallback = function(done) {
          var ghItem = JSON.parse($window.localStorage.getItem(githubKey));
          if (ghItem) {
            $window.localStorage.removeItem(githubKey);
            var code = ghItem.oauth.code;
            $http.get("" + GATEKEEPER_DOMAIN + "/authenticate/" + code).success(function(data, status, headers, config) {
              var token;
              token = data.token;
              cookie.setItem(GITHUB_TOKEN_COOKIE_NAME, token);
              github.getUser(token, function(error, user) {
                if (!error) {
                  cookie.setItem(GITHUB_LOGIN_COOKIE_NAME, user.login);
                  done(null, token);
                } else {
                  done(new Error("Unable to retrieve your user information."));
                }
              });
            }).error(function(data, status, headers, config) {
              done(new Error("Unable to retrieve your authentication token."));
            });
          } else {}
        };
        var handleLoginCallback = function(done) {
          var match = $window.location.href.match(/\?code=([a-z0-9]*)/);
          if (match) {
            $location.search({});
            var code = match[1];
            $http.get("" + GATEKEEPER_DOMAIN + "/authenticate/" + code).success(function(data, status, headers, config) {
              var token;
              token = data.token;
              cookie.setItem(GITHUB_TOKEN_COOKIE_NAME, token);
              github.getUser(token, function(error, user) {
                if (!error) {
                  cookie.setItem(GITHUB_LOGIN_COOKIE_NAME, user.login);
                  done(null, token);
                } else {
                  done(new Error("Unable to retrieve your user information."));
                }
              });
            }).error(function(data, status, headers, config) {
              done(new Error("Unable to retrieve your authentication token."));
            });
          } else if ($window.location.href.match(/\?error=access_denied/)) {
            $location.search({});
          }
        };
        var api = {
          handleGitHubLoginCallback: handleGitHubLoginCallback,
          handleLoginCallback: handleLoginCallback
        };
        return api;
      }]);
    }
  };
});

System.register("js/services/github/Gist.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var Gist;
  return {
    setters: [],
    execute: function() {
      Gist = (function() {
        function Gist(id, description, isPublic, files, html_url) {
          this.id = id;
          this.description = description;
          this["public"] = isPublic;
          this.files = files;
          this.html_url = html_url;
        }
        return Gist;
      }());
      exports_1("default", Gist);
    }
  };
});

System.register("js/services/github/Repo.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var Repo;
  return {
    setters: [],
    execute: function() {
      Repo = (function() {
        function Repo(name, description, language, html_url) {
          this.name = name;
          this.description = description;
          this.language = language;
          this.html_url = html_url;
        }
        return Repo;
      }());
      exports_1("default", Repo);
    }
  };
});

System.register("js/services/github/User.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var User;
  return {
    setters: [],
    execute: function() {
      User = (function() {
        function User(name, login) {
          this.name = name;
          this.login = login;
        }
        return User;
      }());
      exports_1("default", User);
    }
  };
});

System.registerDynamic("npm:underscore@1.8.3/underscore.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function() {
    var root = this;
    var previousUnderscore = root._;
    var ArrayProto = Array.prototype,
        ObjProto = Object.prototype,
        FuncProto = Function.prototype;
    var push = ArrayProto.push,
        slice = ArrayProto.slice,
        toString = ObjProto.toString,
        hasOwnProperty = ObjProto.hasOwnProperty;
    var nativeIsArray = Array.isArray,
        nativeKeys = Object.keys,
        nativeBind = FuncProto.bind,
        nativeCreate = Object.create;
    var Ctor = function() {};
    var _ = function(obj) {
      if (obj instanceof _)
        return obj;
      if (!(this instanceof _))
        return new _(obj);
      this._wrapped = obj;
    };
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }
    _.VERSION = '1.8.3';
    var optimizeCb = function(func, context, argCount) {
      if (context === void 0)
        return func;
      switch (argCount == null ? 3 : argCount) {
        case 1:
          return function(value) {
            return func.call(context, value);
          };
        case 2:
          return function(value, other) {
            return func.call(context, value, other);
          };
        case 3:
          return function(value, index, collection) {
            return func.call(context, value, index, collection);
          };
        case 4:
          return function(accumulator, value, index, collection) {
            return func.call(context, accumulator, value, index, collection);
          };
      }
      return function() {
        return func.apply(context, arguments);
      };
    };
    var cb = function(value, context, argCount) {
      if (value == null)
        return _.identity;
      if (_.isFunction(value))
        return optimizeCb(value, context, argCount);
      if (_.isObject(value))
        return _.matcher(value);
      return _.property(value);
    };
    _.iteratee = function(value, context) {
      return cb(value, context, Infinity);
    };
    var createAssigner = function(keysFunc, undefinedOnly) {
      return function(obj) {
        var length = arguments.length;
        if (length < 2 || obj == null)
          return obj;
        for (var index = 1; index < length; index++) {
          var source = arguments[index],
              keys = keysFunc(source),
              l = keys.length;
          for (var i = 0; i < l; i++) {
            var key = keys[i];
            if (!undefinedOnly || obj[key] === void 0)
              obj[key] = source[key];
          }
        }
        return obj;
      };
    };
    var baseCreate = function(prototype) {
      if (!_.isObject(prototype))
        return {};
      if (nativeCreate)
        return nativeCreate(prototype);
      Ctor.prototype = prototype;
      var result = new Ctor;
      Ctor.prototype = null;
      return result;
    };
    var property = function(key) {
      return function(obj) {
        return obj == null ? void 0 : obj[key];
      };
    };
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    var getLength = property('length');
    var isArrayLike = function(collection) {
      var length = getLength(collection);
      return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
    };
    _.each = _.forEach = function(obj, iteratee, context) {
      iteratee = optimizeCb(iteratee, context);
      var i,
          length;
      if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
          iteratee(obj[i], i, obj);
        }
      } else {
        var keys = _.keys(obj);
        for (i = 0, length = keys.length; i < length; i++) {
          iteratee(obj[keys[i]], keys[i], obj);
        }
      }
      return obj;
    };
    _.map = _.collect = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          results = Array(length);
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    };
    function createReduce(dir) {
      function iterator(obj, iteratee, memo, keys, index, length) {
        for (; index >= 0 && index < length; index += dir) {
          var currentKey = keys ? keys[index] : index;
          memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
      }
      return function(obj, iteratee, memo, context) {
        iteratee = optimizeCb(iteratee, context, 4);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            index = dir > 0 ? 0 : length - 1;
        if (arguments.length < 3) {
          memo = obj[keys ? keys[index] : index];
          index += dir;
        }
        return iterator(obj, iteratee, memo, keys, index, length);
      };
    }
    _.reduce = _.foldl = _.inject = createReduce(1);
    _.reduceRight = _.foldr = createReduce(-1);
    _.find = _.detect = function(obj, predicate, context) {
      var key;
      if (isArrayLike(obj)) {
        key = _.findIndex(obj, predicate, context);
      } else {
        key = _.findKey(obj, predicate, context);
      }
      if (key !== void 0 && key !== -1)
        return obj[key];
    };
    _.filter = _.select = function(obj, predicate, context) {
      var results = [];
      predicate = cb(predicate, context);
      _.each(obj, function(value, index, list) {
        if (predicate(value, index, list))
          results.push(value);
      });
      return results;
    };
    _.reject = function(obj, predicate, context) {
      return _.filter(obj, _.negate(cb(predicate)), context);
    };
    _.every = _.all = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj))
          return false;
      }
      return true;
    };
    _.some = _.any = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj))
          return true;
      }
      return false;
    };
    _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
      if (!isArrayLike(obj))
        obj = _.values(obj);
      if (typeof fromIndex != 'number' || guard)
        fromIndex = 0;
      return _.indexOf(obj, item, fromIndex) >= 0;
    };
    _.invoke = function(obj, method) {
      var args = slice.call(arguments, 2);
      var isFunc = _.isFunction(method);
      return _.map(obj, function(value) {
        var func = isFunc ? method : value[method];
        return func == null ? func : func.apply(value, args);
      });
    };
    _.pluck = function(obj, key) {
      return _.map(obj, _.property(key));
    };
    _.where = function(obj, attrs) {
      return _.filter(obj, _.matcher(attrs));
    };
    _.findWhere = function(obj, attrs) {
      return _.find(obj, _.matcher(attrs));
    };
    _.max = function(obj, iteratee, context) {
      var result = -Infinity,
          lastComputed = -Infinity,
          value,
          computed;
      if (iteratee == null && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);
        for (var i = 0,
            length = obj.length; i < length; i++) {
          value = obj[i];
          if (value > result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index, list) {
          computed = iteratee(value, index, list);
          if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
            result = value;
            lastComputed = computed;
          }
        });
      }
      return result;
    };
    _.min = function(obj, iteratee, context) {
      var result = Infinity,
          lastComputed = Infinity,
          value,
          computed;
      if (iteratee == null && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);
        for (var i = 0,
            length = obj.length; i < length; i++) {
          value = obj[i];
          if (value < result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index, list) {
          computed = iteratee(value, index, list);
          if (computed < lastComputed || computed === Infinity && result === Infinity) {
            result = value;
            lastComputed = computed;
          }
        });
      }
      return result;
    };
    _.shuffle = function(obj) {
      var set = isArrayLike(obj) ? obj : _.values(obj);
      var length = set.length;
      var shuffled = Array(length);
      for (var index = 0,
          rand; index < length; index++) {
        rand = _.random(0, index);
        if (rand !== index)
          shuffled[index] = shuffled[rand];
        shuffled[rand] = set[index];
      }
      return shuffled;
    };
    _.sample = function(obj, n, guard) {
      if (n == null || guard) {
        if (!isArrayLike(obj))
          obj = _.values(obj);
        return obj[_.random(obj.length - 1)];
      }
      return _.shuffle(obj).slice(0, Math.max(0, n));
    };
    _.sortBy = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      return _.pluck(_.map(obj, function(value, index, list) {
        return {
          value: value,
          index: index,
          criteria: iteratee(value, index, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0)
            return 1;
          if (a < b || b === void 0)
            return -1;
        }
        return left.index - right.index;
      }), 'value');
    };
    var group = function(behavior) {
      return function(obj, iteratee, context) {
        var result = {};
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index) {
          var key = iteratee(value, index, obj);
          behavior(result, value, key);
        });
        return result;
      };
    };
    _.groupBy = group(function(result, value, key) {
      if (_.has(result, key))
        result[key].push(value);
      else
        result[key] = [value];
    });
    _.indexBy = group(function(result, value, key) {
      result[key] = value;
    });
    _.countBy = group(function(result, value, key) {
      if (_.has(result, key))
        result[key]++;
      else
        result[key] = 1;
    });
    _.toArray = function(obj) {
      if (!obj)
        return [];
      if (_.isArray(obj))
        return slice.call(obj);
      if (isArrayLike(obj))
        return _.map(obj, _.identity);
      return _.values(obj);
    };
    _.size = function(obj) {
      if (obj == null)
        return 0;
      return isArrayLike(obj) ? obj.length : _.keys(obj).length;
    };
    _.partition = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var pass = [],
          fail = [];
      _.each(obj, function(value, key, obj) {
        (predicate(value, key, obj) ? pass : fail).push(value);
      });
      return [pass, fail];
    };
    _.first = _.head = _.take = function(array, n, guard) {
      if (array == null)
        return void 0;
      if (n == null || guard)
        return array[0];
      return _.initial(array, array.length - n);
    };
    _.initial = function(array, n, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    };
    _.last = function(array, n, guard) {
      if (array == null)
        return void 0;
      if (n == null || guard)
        return array[array.length - 1];
      return _.rest(array, Math.max(0, array.length - n));
    };
    _.rest = _.tail = _.drop = function(array, n, guard) {
      return slice.call(array, n == null || guard ? 1 : n);
    };
    _.compact = function(array) {
      return _.filter(array, _.identity);
    };
    var flatten = function(input, shallow, strict, startIndex) {
      var output = [],
          idx = 0;
      for (var i = startIndex || 0,
          length = getLength(input); i < length; i++) {
        var value = input[i];
        if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
          if (!shallow)
            value = flatten(value, shallow, strict);
          var j = 0,
              len = value.length;
          output.length += len;
          while (j < len) {
            output[idx++] = value[j++];
          }
        } else if (!strict) {
          output[idx++] = value;
        }
      }
      return output;
    };
    _.flatten = function(array, shallow) {
      return flatten(array, shallow, false);
    };
    _.without = function(array) {
      return _.difference(array, slice.call(arguments, 1));
    };
    _.uniq = _.unique = function(array, isSorted, iteratee, context) {
      if (!_.isBoolean(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
      }
      if (iteratee != null)
        iteratee = cb(iteratee, context);
      var result = [];
      var seen = [];
      for (var i = 0,
          length = getLength(array); i < length; i++) {
        var value = array[i],
            computed = iteratee ? iteratee(value, i, array) : value;
        if (isSorted) {
          if (!i || seen !== computed)
            result.push(value);
          seen = computed;
        } else if (iteratee) {
          if (!_.contains(seen, computed)) {
            seen.push(computed);
            result.push(value);
          }
        } else if (!_.contains(result, value)) {
          result.push(value);
        }
      }
      return result;
    };
    _.union = function() {
      return _.uniq(flatten(arguments, true, true));
    };
    _.intersection = function(array) {
      var result = [];
      var argsLength = arguments.length;
      for (var i = 0,
          length = getLength(array); i < length; i++) {
        var item = array[i];
        if (_.contains(result, item))
          continue;
        for (var j = 1; j < argsLength; j++) {
          if (!_.contains(arguments[j], item))
            break;
        }
        if (j === argsLength)
          result.push(item);
      }
      return result;
    };
    _.difference = function(array) {
      var rest = flatten(arguments, true, true, 1);
      return _.filter(array, function(value) {
        return !_.contains(rest, value);
      });
    };
    _.zip = function() {
      return _.unzip(arguments);
    };
    _.unzip = function(array) {
      var length = array && _.max(array, getLength).length || 0;
      var result = Array(length);
      for (var index = 0; index < length; index++) {
        result[index] = _.pluck(array, index);
      }
      return result;
    };
    _.object = function(list, values) {
      var result = {};
      for (var i = 0,
          length = getLength(list); i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };
    function createPredicateIndexFinder(dir) {
      return function(array, predicate, context) {
        predicate = cb(predicate, context);
        var length = getLength(array);
        var index = dir > 0 ? 0 : length - 1;
        for (; index >= 0 && index < length; index += dir) {
          if (predicate(array[index], index, array))
            return index;
        }
        return -1;
      };
    }
    _.findIndex = createPredicateIndexFinder(1);
    _.findLastIndex = createPredicateIndexFinder(-1);
    _.sortedIndex = function(array, obj, iteratee, context) {
      iteratee = cb(iteratee, context, 1);
      var value = iteratee(obj);
      var low = 0,
          high = getLength(array);
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value)
          low = mid + 1;
        else
          high = mid;
      }
      return low;
    };
    function createIndexFinder(dir, predicateFind, sortedIndex) {
      return function(array, item, idx) {
        var i = 0,
            length = getLength(array);
        if (typeof idx == 'number') {
          if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
          } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
          }
        } else if (sortedIndex && idx && length) {
          idx = sortedIndex(array, item);
          return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
          idx = predicateFind(slice.call(array, i, length), _.isNaN);
          return idx >= 0 ? idx + i : -1;
        }
        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
          if (array[idx] === item)
            return idx;
        }
        return -1;
      };
    }
    _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
    _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
    _.range = function(start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }
      step = step || 1;
      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range = Array(length);
      for (var idx = 0; idx < length; idx++, start += step) {
        range[idx] = start;
      }
      return range;
    };
    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
      if (!(callingContext instanceof boundFunc))
        return sourceFunc.apply(context, args);
      var self = baseCreate(sourceFunc.prototype);
      var result = sourceFunc.apply(self, args);
      if (_.isObject(result))
        return result;
      return self;
    };
    _.bind = function(func, context) {
      if (nativeBind && func.bind === nativeBind)
        return nativeBind.apply(func, slice.call(arguments, 1));
      if (!_.isFunction(func))
        throw new TypeError('Bind must be called on a function');
      var args = slice.call(arguments, 2);
      var bound = function() {
        return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
      };
      return bound;
    };
    _.partial = function(func) {
      var boundArgs = slice.call(arguments, 1);
      var bound = function() {
        var position = 0,
            length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length)
          args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    };
    _.bindAll = function(obj) {
      var i,
          length = arguments.length,
          key;
      if (length <= 1)
        throw new Error('bindAll must be passed function names');
      for (i = 1; i < length; i++) {
        key = arguments[i];
        obj[key] = _.bind(obj[key], obj);
      }
      return obj;
    };
    _.memoize = function(func, hasher) {
      var memoize = function(key) {
        var cache = memoize.cache;
        var address = '' + (hasher ? hasher.apply(this, arguments) : key);
        if (!_.has(cache, address))
          cache[address] = func.apply(this, arguments);
        return cache[address];
      };
      memoize.cache = {};
      return memoize;
    };
    _.delay = function(func, wait) {
      var args = slice.call(arguments, 2);
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    };
    _.defer = _.partial(_.delay, _, 1);
    _.throttle = function(func, wait, options) {
      var context,
          args,
          result;
      var timeout = null;
      var previous = 0;
      if (!options)
        options = {};
      var later = function() {
        previous = options.leading === false ? 0 : _.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
          context = args = null;
      };
      return function() {
        var now = _.now();
        if (!previous && options.leading === false)
          previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          result = func.apply(context, args);
          if (!timeout)
            context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    };
    _.debounce = function(func, wait, immediate) {
      var timeout,
          args,
          context,
          timestamp,
          result;
      var later = function() {
        var last = _.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            if (!timeout)
              context = args = null;
          }
        }
      };
      return function() {
        context = this;
        args = arguments;
        timestamp = _.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
    };
    _.wrap = function(func, wrapper) {
      return _.partial(wrapper, func);
    };
    _.negate = function(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    };
    _.compose = function() {
      var args = arguments;
      var start = args.length - 1;
      return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while (i--)
          result = args[i].call(this, result);
        return result;
      };
    };
    _.after = function(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };
    _.before = function(times, func) {
      var memo;
      return function() {
        if (--times > 0) {
          memo = func.apply(this, arguments);
        }
        if (times <= 1)
          func = null;
        return memo;
      };
    };
    _.once = _.partial(_.before, 2);
    var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
    function collectNonEnumProps(obj, keys) {
      var nonEnumIdx = nonEnumerableProps.length;
      var constructor = obj.constructor;
      var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;
      var prop = 'constructor';
      if (_.has(obj, prop) && !_.contains(keys, prop))
        keys.push(prop);
      while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
          keys.push(prop);
        }
      }
    }
    _.keys = function(obj) {
      if (!_.isObject(obj))
        return [];
      if (nativeKeys)
        return nativeKeys(obj);
      var keys = [];
      for (var key in obj)
        if (_.has(obj, key))
          keys.push(key);
      if (hasEnumBug)
        collectNonEnumProps(obj, keys);
      return keys;
    };
    _.allKeys = function(obj) {
      if (!_.isObject(obj))
        return [];
      var keys = [];
      for (var key in obj)
        keys.push(key);
      if (hasEnumBug)
        collectNonEnumProps(obj, keys);
      return keys;
    };
    _.values = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var values = Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }
      return values;
    };
    _.mapObject = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var keys = _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    };
    _.pairs = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var pairs = Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }
      return pairs;
    };
    _.invert = function(obj) {
      var result = {};
      var keys = _.keys(obj);
      for (var i = 0,
          length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }
      return result;
    };
    _.functions = _.methods = function(obj) {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key]))
          names.push(key);
      }
      return names.sort();
    };
    _.extend = createAssigner(_.allKeys);
    _.extendOwn = _.assign = createAssigner(_.keys);
    _.findKey = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = _.keys(obj),
          key;
      for (var i = 0,
          length = keys.length; i < length; i++) {
        key = keys[i];
        if (predicate(obj[key], key, obj))
          return key;
      }
    };
    _.pick = function(object, oiteratee, context) {
      var result = {},
          obj = object,
          iteratee,
          keys;
      if (obj == null)
        return result;
      if (_.isFunction(oiteratee)) {
        keys = _.allKeys(obj);
        iteratee = optimizeCb(oiteratee, context);
      } else {
        keys = flatten(arguments, false, false, 1);
        iteratee = function(value, key, obj) {
          return key in obj;
        };
        obj = Object(obj);
      }
      for (var i = 0,
          length = keys.length; i < length; i++) {
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj))
          result[key] = value;
      }
      return result;
    };
    _.omit = function(obj, iteratee, context) {
      if (_.isFunction(iteratee)) {
        iteratee = _.negate(iteratee);
      } else {
        var keys = _.map(flatten(arguments, false, false, 1), String);
        iteratee = function(value, key) {
          return !_.contains(keys, key);
        };
      }
      return _.pick(obj, iteratee, context);
    };
    _.defaults = createAssigner(_.allKeys, true);
    _.create = function(prototype, props) {
      var result = baseCreate(prototype);
      if (props)
        _.extendOwn(result, props);
      return result;
    };
    _.clone = function(obj) {
      if (!_.isObject(obj))
        return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };
    _.tap = function(obj, interceptor) {
      interceptor(obj);
      return obj;
    };
    _.isMatch = function(object, attrs) {
      var keys = _.keys(attrs),
          length = keys.length;
      if (object == null)
        return !length;
      var obj = Object(object);
      for (var i = 0; i < length; i++) {
        var key = keys[i];
        if (attrs[key] !== obj[key] || !(key in obj))
          return false;
      }
      return true;
    };
    var eq = function(a, b, aStack, bStack) {
      if (a === b)
        return a !== 0 || 1 / a === 1 / b;
      if (a == null || b == null)
        return a === b;
      if (a instanceof _)
        a = a._wrapped;
      if (b instanceof _)
        b = b._wrapped;
      var className = toString.call(a);
      if (className !== toString.call(b))
        return false;
      switch (className) {
        case '[object RegExp]':
        case '[object String]':
          return '' + a === '' + b;
        case '[object Number]':
          if (+a !== +a)
            return +b !== +b;
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
          return +a === +b;
      }
      var areArrays = className === '[object Array]';
      if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object')
          return false;
        var aCtor = a.constructor,
            bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
          return false;
        }
      }
      aStack = aStack || [];
      bStack = bStack || [];
      var length = aStack.length;
      while (length--) {
        if (aStack[length] === a)
          return bStack[length] === b;
      }
      aStack.push(a);
      bStack.push(b);
      if (areArrays) {
        length = a.length;
        if (length !== b.length)
          return false;
        while (length--) {
          if (!eq(a[length], b[length], aStack, bStack))
            return false;
        }
      } else {
        var keys = _.keys(a),
            key;
        length = keys.length;
        if (_.keys(b).length !== length)
          return false;
        while (length--) {
          key = keys[length];
          if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack)))
            return false;
        }
      }
      aStack.pop();
      bStack.pop();
      return true;
    };
    _.isEqual = function(a, b) {
      return eq(a, b);
    };
    _.isEmpty = function(obj) {
      if (obj == null)
        return true;
      if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)))
        return obj.length === 0;
      return _.keys(obj).length === 0;
    };
    _.isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
    };
    _.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) === '[object Array]';
    };
    _.isObject = function(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    };
    _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
      _['is' + name] = function(obj) {
        return toString.call(obj) === '[object ' + name + ']';
      };
    });
    if (!_.isArguments(arguments)) {
      _.isArguments = function(obj) {
        return _.has(obj, 'callee');
      };
    }
    if (typeof/./ != 'function' && typeof Int8Array != 'object') {
      _.isFunction = function(obj) {
        return typeof obj == 'function' || false;
      };
    }
    _.isFinite = function(obj) {
      return isFinite(obj) && !isNaN(parseFloat(obj));
    };
    _.isNaN = function(obj) {
      return _.isNumber(obj) && obj !== +obj;
    };
    _.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    };
    _.isNull = function(obj) {
      return obj === null;
    };
    _.isUndefined = function(obj) {
      return obj === void 0;
    };
    _.has = function(obj, key) {
      return obj != null && hasOwnProperty.call(obj, key);
    };
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };
    _.identity = function(value) {
      return value;
    };
    _.constant = function(value) {
      return function() {
        return value;
      };
    };
    _.noop = function() {};
    _.property = property;
    _.propertyOf = function(obj) {
      return obj == null ? function() {} : function(key) {
        return obj[key];
      };
    };
    _.matcher = _.matches = function(attrs) {
      attrs = _.extendOwn({}, attrs);
      return function(obj) {
        return _.isMatch(obj, attrs);
      };
    };
    _.times = function(n, iteratee, context) {
      var accum = Array(Math.max(0, n));
      iteratee = optimizeCb(iteratee, context, 1);
      for (var i = 0; i < n; i++)
        accum[i] = iteratee(i);
      return accum;
    };
    _.random = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };
    _.now = Date.now || function() {
      return new Date().getTime();
    };
    var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };
    var unescapeMap = _.invert(escapeMap);
    var createEscaper = function(map) {
      var escaper = function(match) {
        return map[match];
      };
      var source = '(?:' + _.keys(map).join('|') + ')';
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, 'g');
      return function(string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    };
    _.escape = createEscaper(escapeMap);
    _.unescape = createEscaper(unescapeMap);
    _.result = function(object, property, fallback) {
      var value = object == null ? void 0 : object[property];
      if (value === void 0) {
        value = fallback;
      }
      return _.isFunction(value) ? value.call(object) : value;
    };
    var idCounter = 0;
    _.uniqueId = function(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };
    _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
    var noMatch = /(.)^/;
    var escapes = {
      "'": "'",
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };
    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
    var escapeChar = function(match) {
      return '\\' + escapes[match];
    };
    _.template = function(text, settings, oldSettings) {
      if (!settings && oldSettings)
        settings = oldSettings;
      settings = _.defaults({}, settings, _.templateSettings);
      var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escaper, escapeChar);
        index = offset + match.length;
        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }
        return match;
      });
      source += "';\n";
      if (!settings.variable)
        source = 'with(obj||{}){\n' + source + '}\n';
      source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
      try {
        var render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }
      var template = function(data) {
        return render.call(this, data, _);
      };
      var argument = settings.variable || 'obj';
      template.source = 'function(' + argument + '){\n' + source + '}';
      return template;
    };
    _.chain = function(obj) {
      var instance = _(obj);
      instance._chain = true;
      return instance;
    };
    var result = function(instance, obj) {
      return instance._chain ? _(obj).chain() : obj;
    };
    _.mixin = function(obj) {
      _.each(_.functions(obj), function(name) {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return result(this, func.apply(_, args));
        };
      });
    };
    _.mixin(_);
    _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name === 'shift' || name === 'splice') && obj.length === 0)
          delete obj[0];
        return result(this, obj);
      };
    });
    _.each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        return result(this, method.apply(this._wrapped, arguments));
      };
    });
    _.prototype.value = function() {
      return this._wrapped;
    };
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    _.prototype.toString = function() {
      return '' + this._wrapped;
    };
    if (typeof define === 'function' && define.amd) {
      define('underscore', [], function() {
        return _;
      });
    }
  }.call(this));
  return module.exports;
});

System.registerDynamic("npm:underscore@1.8.3.js", ["npm:underscore@1.8.3/underscore.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:underscore@1.8.3/underscore.js');
  return module.exports;
});

System.register("js/services/github/GitHub.js", ["../../app", "./Gist", "./Repo", "./User", "underscore"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1,
      Gist_1,
      Repo_1,
      User_1,
      _;
  var GITHUB_PROTOCOL,
      GITHUB_DOMAIN,
      HTTP_METHOD_DELETE,
      HTTP_METHOD_GET,
      HTTP_METHOD_PATCH,
      HTTP_METHOD_POST,
      HTTP_METHOD_PUT,
      ACCEPT_HEADER;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }, function(Gist_1_1) {
      Gist_1 = Gist_1_1;
    }, function(Repo_1_1) {
      Repo_1 = Repo_1_1;
    }, function(User_1_1) {
      User_1 = User_1_1;
    }, function(_1) {
      _ = _1;
    }],
    execute: function() {
      GITHUB_PROTOCOL = 'https';
      GITHUB_DOMAIN = 'api.github.com';
      HTTP_METHOD_DELETE = 'DELETE';
      HTTP_METHOD_GET = 'GET';
      HTTP_METHOD_PATCH = 'PATCH';
      HTTP_METHOD_POST = 'POST';
      HTTP_METHOD_PUT = 'PUT';
      ACCEPT_HEADER = "application/vnd.github.v3+json";
      app_1.default.factory('GitHub', ['$http', function($http) {
        function getGistsPage(token, href, done) {
          var headers = token ? {
            Accept: ACCEPT_HEADER,
            Authorization: "token " + token
          } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: href,
            headers: headers
          }).success(function(gists, status, headers, config) {
            gists = _.map(gists, function(gist) {
              return new Gist_1.default(gist.id, gist.description, gist["public"], gist.files, gist.html_url);
            });
            return done(null, gists, status, headers, config);
          }).error(function(response, status, headers, config) {
            if (response && response.message) {
              return done(new Error(response.message), response, status, headers, config);
            } else {
              return done(new Error("Invalid response from GitHub."), response, status, headers, config);
            }
          });
        }
        return {
          getUser: function(token, done) {
            var headers;
            headers = token ? {
              Accept: ACCEPT_HEADER,
              Authorization: "token " + token
            } : {};
            return $http({
              method: HTTP_METHOD_GET,
              url: "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/user",
              headers: headers
            }).success(function(user, status, headers, config) {
              return done(null, new User_1.default(user.name, user.login), status, headers, config);
            }).error(function(response, status, headers, config) {
              if (response && response.message) {
                return done(new Error(response.message), response, status, headers, config);
              } else {
                return done(new Error("Invalid response from GitHub."), response, status, headers, config);
              }
            });
          },
          getUserRepos: function(token, done) {
            var headers;
            headers = token ? {
              Accept: ACCEPT_HEADER,
              Authorization: "token " + token
            } : {};
            return $http({
              method: HTTP_METHOD_GET,
              url: "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/user/repos",
              headers: headers
            }).success(function(response, status, headers, config) {
              var repos = _.map(response, function(repo) {
                return new Repo_1.default(repo.name, repo.description, repo.language, repo.html_url);
              });
              return done(null, repos, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), response, status, headers, config);
            });
          },
          getRepoContents: function(token, user, repo, done) {
            var url;
            url = "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/repos/" + user + "/" + repo + "/contents";
            return $http({
              "method": HTTP_METHOD_GET,
              "url": url,
              "headers": {
                Accept: ACCEPT_HEADER,
                Authorization: "token " + token
              }
            }).success(function(contents, status, headers, config) {
              return done(void 0, contents, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), void 0, status, headers, config);
            });
          },
          getPathContents: function(token, user, repo, path, done) {
            var headers,
                url;
            url = "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/repos/" + user + "/" + repo + "/contents";
            if (path) {
              url = "" + url + "/" + path;
            }
            headers = token ? {
              Accept: ACCEPT_HEADER,
              Authorization: "token " + token
            } : {};
            return $http({
              "method": HTTP_METHOD_GET,
              "url": url,
              "headers": headers
            }).success(function(contents, status, headers, config) {
              return done(null, contents, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), response, status, headers, config);
            });
          },
          putFile: function(token, owner, repo, path, message, content, sha, done) {
            var data,
                headers,
                url;
            url = "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/repos/" + owner + "/" + repo + "/contents/" + path;
            data = {
              message: message,
              content: content
            };
            if (sha) {
              data.sha = sha;
            }
            headers = token ? {
              Accept: ACCEPT_HEADER,
              Authorization: "token " + token
            } : {};
            return $http({
              method: HTTP_METHOD_PUT,
              url: url,
              data: data,
              headers: headers
            }).success(function(file, status, headers, config) {
              return done(null, file, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), response, status, headers, config);
            });
          },
          deleteFile: function(token, owner, repo, path, message, sha, done) {
            var data,
                url;
            url = "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/repos/" + owner + "/" + repo + "/contents/" + path;
            data = {
              message: message,
              sha: sha
            };
            return $http({
              method: HTTP_METHOD_DELETE,
              url: url,
              data: data,
              headers: {
                Accept: ACCEPT_HEADER,
                Authorization: "token " + token
              }
            }).success(function(file, status, headers, config) {
              return done(null, file, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), response, status, headers, config);
            });
          },
          postRepo: function(token, name, description, priv, autoInit, done) {
            var data,
                headers,
                url;
            url = "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/user/repos";
            data = {
              name: name,
              description: description,
              "private": priv,
              auto_init: autoInit
            };
            headers = token ? {
              Accept: ACCEPT_HEADER,
              Authorization: "token " + token
            } : {};
            return $http({
              method: HTTP_METHOD_POST,
              url: url,
              data: data,
              headers: headers
            }).success(function(repo, status, headers, config) {
              return done(null, repo, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), response, status, headers, config);
            });
          },
          deleteRepo: function(token, owner, repo, done) {
            var url;
            url = "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/repos/" + owner + "/" + repo;
            return $http({
              method: HTTP_METHOD_DELETE,
              url: url,
              headers: {
                Accept: ACCEPT_HEADER,
                Authorization: "token " + token
              }
            }).success(function(repo, status, headers, config) {
              return done(null, repo, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), response, status, headers, config);
            });
          },
          getGist: function(token, id, done) {
            var headers,
                url;
            url = "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/gists/" + id;
            headers = token ? {
              Accept: ACCEPT_HEADER,
              Authorization: "token " + token
            } : {};
            return $http({
              "method": HTTP_METHOD_GET,
              "url": url,
              "headers": headers
            }).success(function(contents, status, headers, config) {
              return done(null, contents, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), response, status, headers, config);
            });
          },
          patchGist: function(token, gistId, data, done) {
            var headers,
                url;
            url = "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/gists/" + gistId;
            headers = token ? {
              Accept: ACCEPT_HEADER,
              Authorization: "token " + token
            } : {};
            return $http({
              method: HTTP_METHOD_PATCH,
              url: url,
              data: data,
              headers: headers
            }).success(function(response, status, headers, config) {
              return done(null, response, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), response, status, headers, config);
            });
          },
          postGist: function(token, data, done) {
            var headers,
                url;
            url = "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/gists";
            headers = token ? {
              Accept: ACCEPT_HEADER,
              Authorization: "token " + token
            } : {};
            return $http({
              method: HTTP_METHOD_POST,
              url: url,
              data: data,
              headers: headers
            }).success(function(response, status, headers, config) {
              return done(null, response, status, headers, config);
            }).error(function(response, status, headers, config) {
              if (response && response.message) {
                return done(new Error(response.message), response, status, headers, config);
              } else {
                return done(new Error("Invalid response from GitHub."), response, status, headers, config);
              }
            });
          },
          deleteGist: function(token, owner, id, done) {
            var url;
            url = "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/gists/" + id;
            return $http({
              method: HTTP_METHOD_DELETE,
              url: url,
              headers: {
                Accept: ACCEPT_HEADER,
                Authorization: "token " + token
              }
            }).success(function(response, status, headers, config) {
              return done(null, response, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), response, status, headers, config);
            });
          },
          getUserGists: function(token, user, done) {
            var headers;
            headers = token ? {
              Accept: ACCEPT_HEADER,
              Authorization: "token " + token
            } : {};
            return $http({
              method: HTTP_METHOD_GET,
              url: "" + GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/users/" + user + "/gists",
              headers: headers
            }).success(function(gists, status, headers, config) {
              gists = _.map(gists, function(gist) {
                return gist;
              });
              return done(null, gists, status, headers, config);
            }).error(function(response, status, headers, config) {
              return done(new Error(response.message), response, status, headers, config);
            });
          },
          getGists: function(token, done) {
            var url = GITHUB_PROTOCOL + "://" + GITHUB_DOMAIN + "/gists";
            return getGistsPage(token, url, done);
          },
          getGistsPage: function(token, href, done) {
            return getGistsPage(token, href, done);
          }
        };
      }]);
    }
  };
});

System.register("js/services/options/options.js", ["../../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.factory('options', ['$window', 'doodlesKey', 'VENDOR_FOLDER_MARKER', function($window, doodlesKey, VENDOR_FOLDER_MARKER) {
        var VERSION_ANGULARJS = '1.5.3';
        var VERSION_DAT_GUI = '0.5.0';
        var VERSION_DECKJS = '1.1.0';
        var VERSION_DOMREADY = '1.0.0';
        var VERSION_D3 = '3.5.5';
        var VERSION_EIGHT = '2.102.0';
        var VERSION_JQUERY = '2.1.4';
        var VERSION_JSXGRAPH = '0.99.3';
        var VERSION_PLOTLY = '1.5.2';
        var VERSION_STATSJS = '0.0.14';
        var VERSION_THREEJS = '0.72.0';
        var VERSION_TWO = '0.5.0';
        function vendorFolder(packageFolder, version, subFolder, fileName) {
          var steps = [];
          steps.push(VENDOR_FOLDER_MARKER);
          steps.push('/');
          steps.push(packageFolder);
          steps.push('@');
          steps.push(version);
          steps.push('/');
          if (subFolder) {
            steps.push(subFolder);
            steps.push('/');
          }
          steps.push(fileName);
          return steps.join('');
        }
        function angular(fileName) {
          return vendorFolder('angular', VERSION_ANGULARJS, void 0, fileName);
        }
        function datGUI(fileName) {
          return vendorFolder('dat-gui', VERSION_DAT_GUI, void 0, fileName);
        }
        function deck(fileName) {
          return vendorFolder('deck.js', VERSION_DECKJS, 'core', fileName);
        }
        function domready(fileName) {
          return vendorFolder('domready', VERSION_DOMREADY, void 0, fileName);
        }
        function d3(fileName) {
          return vendorFolder('d3', VERSION_D3, void 0, fileName);
        }
        function eight(subFolder, fileName) {
          return vendorFolder('davinci-eight', VERSION_EIGHT, subFolder, fileName);
        }
        function jquery(fileName) {
          return vendorFolder('jquery', VERSION_JQUERY, 'dist', fileName);
        }
        function jsxgraph(fileName) {
          return vendorFolder('jsxgraph', VERSION_JSXGRAPH, void 0, fileName);
        }
        function plotly(fileName) {
          return vendorFolder('plotly', VERSION_PLOTLY, void 0, fileName);
        }
        function statsjs(fileName) {
          return vendorFolder('stats.js', VERSION_STATSJS, void 0, fileName);
        }
        function threejs(fileName) {
          return vendorFolder('threejs', VERSION_THREEJS, 'build', fileName);
        }
        function two(fileName) {
          return vendorFolder('two', VERSION_TWO, void 0, fileName);
        }
        var _options = [{
          name: 'angular',
          moniker: 'AngularJS',
          description: "HTML enhanced for web apps!",
          homepage: 'https://angularjs.org',
          version: VERSION_ANGULARJS,
          visible: true,
          dts: angular('angular.d.ts'),
          js: angular('angular.js'),
          minJs: angular('angular.min.js'),
          dependencies: {}
        }, {
          name: 'dat-gui',
          moniker: 'dat.GUI',
          description: "dat.gui is a lightweight controller library for JavaScript.",
          homepage: 'https://github.com/dataarts/dat.gui',
          version: VERSION_DAT_GUI,
          visible: true,
          dts: datGUI('dat-gui.d.ts'),
          js: datGUI('dat-gui.js'),
          minJs: datGUI('dat-gui.min.js'),
          dependencies: {}
        }, {
          name: 'davinci-eight',
          moniker: 'Eight.js',
          description: "Mathematical Computer Graphics using WebGL.",
          homepage: 'http://www.mathdoodle.io/docs/davinci-eight/index.html',
          version: VERSION_EIGHT,
          visible: true,
          dts: eight('dist', 'davinci-eight.d.ts'),
          js: eight('dist', 'davinci-eight.js'),
          minJs: eight('dist', 'davinci-eight.js'),
          dependencies: {}
        }, {
          name: 'd3',
          moniker: 'd3',
          description: "Data-Driven Documents.",
          homepage: 'http://d3js.org',
          version: VERSION_D3,
          visible: true,
          dts: d3('d3.d.ts'),
          js: d3('d3.js'),
          minJs: d3('d3.min.js'),
          dependencies: {}
        }, {
          name: 'DomReady',
          moniker: 'DomReady',
          description: "Browser portable and safe way to know when DOM has loaded.",
          homepage: '',
          version: VERSION_DOMREADY,
          visible: true,
          dts: domready('domready.d.ts'),
          js: domready('domready.js'),
          minJs: domready('domready.js'),
          dependencies: {}
        }, {
          name: 'jquery',
          moniker: 'jQuery',
          description: "The Write Less, Do More, JavaScript Library.",
          homepage: 'https://jquery.com',
          version: VERSION_JQUERY,
          visible: true,
          dts: jquery('jquery.d.ts'),
          js: jquery('jquery.js'),
          minJs: jquery('jquery.min.js'),
          dependencies: {}
        }, {
          name: 'deck.js',
          moniker: 'deckJS',
          description: "Modern HTML Presentations.",
          homepage: 'http://imakewebthings.github.com/deck.js',
          version: VERSION_DECKJS,
          visible: true,
          dts: deck('deck.core.d.ts'),
          js: deck('deck.core.js'),
          minJs: deck('deck.core.js'),
          dependencies: {'jquery': '2.1.4'}
        }, {
          name: 'jsxgraph',
          moniker: 'JSXGraph',
          description: "2D Geometry, Plotting, and Visualization.",
          homepage: 'http://jsxgraph.uni-bayreuth.de',
          version: VERSION_JSXGRAPH,
          visible: true,
          dts: jsxgraph('jsxgraph.d.ts'),
          js: jsxgraph('jsxgraph.js'),
          minJs: jsxgraph('jsxgraph.min.js'),
          dependencies: {}
        }, {
          name: 'plot.ly',
          moniker: 'plotly',
          description: "The open source JavaScript graphing library that powers plotly.",
          homepage: 'https://plot.ly/javascript/',
          version: VERSION_PLOTLY,
          visible: true,
          dts: plotly('plotly.d.ts'),
          js: plotly('plotly.js'),
          minJs: plotly('plotly.min.js'),
          dependencies: {}
        }, {
          name: 'stats.js',
          moniker: 'Stats',
          description: "JavaScript Performance Monitoring.",
          homepage: 'https://github.com/mrdoob/stats.js',
          version: VERSION_STATSJS,
          visible: true,
          dts: statsjs('stats.d.ts'),
          js: statsjs('stats.min.js'),
          minJs: statsjs('stats.min.js'),
          dependencies: {}
        }, {
          name: 'three.js',
          moniker: 'Three.js',
          description: "JavaScript 3D library.",
          homepage: 'http://threejs.org/',
          version: VERSION_THREEJS,
          visible: true,
          dts: threejs('three.d.ts'),
          js: threejs('three.js'),
          minJs: threejs('three.min.js'),
          dependencies: {}
        }, {
          name: 'two.js',
          moniker: 'Two.js',
          description: "A two-dimensional drawing api for modern browsers.",
          homepage: 'http://jonobr1.github.io/two.js/',
          version: VERSION_TWO,
          visible: true,
          dts: two('two.d.ts'),
          js: two('two.js'),
          minJs: two('two.min.js'),
          dependencies: {}
        }];
        var that = {
          unshift: function(doodle) {
            return _options.unshift(doodle);
          },
          get length() {
            return _options.length;
          },
          filter: function(callback) {
            return _options.filter(callback);
          },
          deleteOption: function(name) {
            var options = [];
            var i = 0,
                found;
            while (i < _options.length) {
              if (_options[i].name === name) {
                found = _options[i];
              } else {
                options.push(_options[i]);
              }
              i++;
            }
            if (!found)
              return;
            _options = options;
          }
        };
        return that;
      }]);
    }
  };
});

System.register("js/services/settings/settings.js", ["../../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.factory('settings', [function() {
        var settings = {
          theme: 'ace/theme/mathdoodle',
          indent: 2,
          fontSize: '16px',
          showInvisibles: false,
          showPrintMargin: false,
          displayIndentGuides: false
        };
        return settings;
      }]);
    }
  };
});

System.register("js/services/doodles/DoodleFile.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var DoodleFile;
  return {
    setters: [],
    execute: function() {
      DoodleFile = (function() {
        function DoodleFile() {
          this.content = "";
          this.isOpen = true;
          this.selected = false;
        }
        return DoodleFile;
      }());
      exports_1("default", DoodleFile);
    }
  };
});

System.register("js/services/doodles/Doodle.js", ["./DoodleFile", "../../utils/modeFromName"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var DoodleFile_1,
      modeFromName_1;
  var Doodle;
  return {
    setters: [function(DoodleFile_1_1) {
      DoodleFile_1 = DoodleFile_1_1;
    }, function(modeFromName_1_1) {
      modeFromName_1 = modeFromName_1_1;
    }],
    execute: function() {
      Doodle = (function() {
        function Doodle() {
          this.description = "";
          this.isCodeVisible = true;
          this.isViewVisible = false;
          this.lastKnownJs = {};
          this.operatorOverloading = true;
          this.dependencies = [];
        }
        Doodle.prototype.closeFile = function(name) {
          var file = this.findFileByName(name);
          if (file) {
            file.isOpen = false;
            file.selected = false;
          } else {
            console.log(name + " => was not found");
          }
          this.deselectAll();
          var names = Object.keys(this.files);
          var iLen = names.length;
          for (var i = 0; i < iLen; i++) {
            var name_1 = names[i];
            var file_1 = this.files[name_1];
            if (file_1.isOpen) {
              file_1.selected = true;
              return;
            }
          }
        };
        Doodle.prototype.deselectAll = function() {
          var names = Object.keys(this.files);
          var iLen = names.length;
          for (var i = 0; i < iLen; i++) {
            var name_2 = names[i];
            var file = this.files[name_2];
            file.selected = false;
          }
        };
        Doodle.prototype.findFileByName = function(name) {
          return this.files[name];
        };
        Doodle.prototype.newFile = function(name) {
          var mode = modeFromName_1.default(name);
          if (!mode) {
            throw new Error(name + " is not a recognized language.");
          }
          var existing = this.findFileByName(name);
          if (!existing) {
            var file = new DoodleFile_1.default();
            file.language = mode;
            this.files[name] = file;
          } else {
            throw new Error(name + " already exists. The name must be unique.");
          }
        };
        Doodle.prototype.openFile = function(name) {
          var file = this.findFileByName(name);
          if (file) {
            file.isOpen = true;
          } else {
            console.log(name + " => was not found");
          }
        };
        Doodle.prototype.renameFile = function(oldName, newName) {
          var mode = modeFromName_1.default(newName);
          if (!mode) {
            throw new Error(name + " is not a recognized language.");
          }
          var file = this.findFileByName(oldName);
          if (file) {
            var existing = this.findFileByName(newName);
            if (!existing) {
              this.files[newName] = file;
              file.language = mode;
              delete this.files[oldName];
              this.lastKnownJs[newName] = this.lastKnownJs[oldName];
              delete this.lastKnownJs[oldName];
            } else {
              throw new Error(newName + " already exists. The new name must be unique.");
            }
          } else {
            throw new Error(oldName + " does not exist. The old name must be the name of an existing file.");
          }
        };
        Doodle.prototype.selectFile = function(name) {
          var file = this.findFileByName(name);
          if (file && file.isOpen) {
            var names = Object.keys(this.files);
            var iLen = names.length;
            for (var i = 0; i < iLen; i++) {
              var file_2 = this.files[names[i]];
              if (file_2.isOpen) {
                file_2.selected = names[i] === name;
              }
            }
          } else {
            console.log(name + " => was not found or is not open");
          }
        };
        Doodle.prototype.deleteFile = function(name) {
          var file = this.findFileByName(name);
          if (file) {
            delete this.files[name];
            delete this.lastKnownJs[name];
          } else {
            console.warn("deleteFile(" + name + "), " + name + " was not found.");
          }
        };
        return Doodle;
      }());
      exports_1("default", Doodle);
    }
  };
});

System.register("js/utils/modeFromName.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var extensionToMode;
  function default_1(name) {
    var period = name.lastIndexOf('.');
    if (period >= 0) {
      var extension = name.substring(period + 1);
      return extensionToMode[extension];
    }
    return void 0;
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {
      extensionToMode = {};
      extensionToMode['coffee'] = 'CoffeeScript';
      extensionToMode['css'] = 'CSS';
      extensionToMode['html'] = 'HTML';
      extensionToMode['js'] = 'JavaScript';
      extensionToMode['less'] = 'LESS';
      extensionToMode['py'] = 'Python';
      extensionToMode['sass'] = 'SASS';
      extensionToMode['ts'] = 'TypeScript';
    }
  };
});

System.register("js/services/templates/EIGHTJS_HTML.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function default_1(styleMarker, scriptsMarker, libsMarker, codeMarker, width, height, canvasId) {
    var lines = "" + "<!doctype html>\n" + "<html>\n" + "  <head>\n" + styleMarker() + scriptsMarker() + "  </head>\n" + "  <body>\n" + libsMarker() + codeMarker() + ("    <canvas id='" + canvasId + "'></canvas>\n") + "  </body>\n" + "</html>\n";
    return lines;
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/services/templates/EIGHTJS_CODE.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function default_1(width, height, canvasId, refChange, useStats) {
    var lines = ["EIGHT.refChange('quiet')", "EIGHT.refChange('start')", "", "class ModelController {", "  /**", "   * The amplitude.", "   */", "  public A = 3", "  /**", "   * The periodic time.", "   */", "  public T = 5", "  private _trail: EIGHT.Trail", "  private controls: EIGHT.ViewController", "  constructor(controls: EIGHT.ViewController, trail: EIGHT.Trail) {", "    this.controls = controls", "    this._trail = trail", "  }", "  /**", "   * The rotational velocity bivector.", "   */", "  get Ω() {", "    return τ * (1 / this.T) * e2 ^ e3", "  }", "  get trail() {", "    return this._trail.config.enabled", "  }", "  set trail(enabled: boolean) {", "    this._trail.config.enabled = enabled", "    if (!enabled) {", "      this._trail.erase()", "    }", "  }", "  reset(): void {", "    this.controls.reset()", "  }", "}", "", "const engine = new EIGHT.Engine()", "", "const scene = new EIGHT.Scene(engine)", "", "const ambients: EIGHT.Facet[] = []", "", "const camera = new EIGHT.PerspectiveCamera()", "camera.eye.copy(e3 - e2).normalize().scale(10)", "camera.up.copy(e3)", "ambients.push(camera)", "", "const dirLight = new EIGHT.DirectionalLight()", "ambients.push(dirLight)", "", "const controls = new EIGHT.TrackballControls(camera, window)", "", "const arrow = new EIGHT.Arrow({color: white})", "scene.add(arrow)", "", "const cube = new EIGHT.Box({color: green, position: 2 * e1, width: 0.2})", "scene.add(cube)", "", "const helix = new EIGHT.Curve({", "  uSegments: 128,", "  aPosition: (u: number) => {", "  return cos(4 * τ * u) * e1 + sin(4 * τ * u) * e2 + 3 * u * e3", "  }", "})", "scene.add(helix)", "", "const grid = new EIGHT.Grid({uMin: -4, uMax: 4, uSegments: 8, vMin: -4, vMax: 4, vSegments: 8})", "grid.color = gray", "scene.add(grid)", "", "const ball = new EIGHT.Sphere({color: blue, radius: 0.1})", "scene.add(ball)", "", "const trail = new EIGHT.Trail(ball)", "", "const rod = new EIGHT.Cylinder({color: magenta, position: -2 * e1, length: 0.2, radius: 0.5})", "scene.add(rod)", "", "const stats = new Stats()", "stats.setMode(0)", "document.body.appendChild(stats.domElement)", "", "const model = new ModelController(controls, trail)", "", "/**", " * Initializes the WebGL context once the DOM is ready.", " */", "window.onload = function() {", ("  const canvas = <HTMLCanvasElement>document.getElementById('" + canvasId + "')"), ("  canvas.width = " + width), ("  canvas.height = " + height), "", "  const gui = new dat.GUI()", "  gui.add(model, 'A', 0, 4)", "  gui.add(model, 'T', 1, 10)", "  gui.add(model, 'trail')", "  gui.add(model, 'reset')", "", "  engine.start(canvas)", "", "  controls.subscribe(canvas)", "", "  requestAnimationFrame(animate)", "}", "", "/**", " * Animates the scene.", " */", "function animate(timestamp: number) {", "  stats.begin()", "  requestAnimationFrame(animate)", "", "  engine.clear()", "", "  controls.update()", "", "  dirLight.direction.copy(camera.look).sub(camera.eye)", "", "  const t = timestamp * 0.001", "", "  ball.X = model.A * (cos(τ * t / model.T) * e1 + sin(τ * t / model.T) * e3)", "  trail.snapshot()", "", "  cube.R = exp(-model.Ω * t/2)", "  rod.R = exp(-model.Ω * t/2)", "", "  arrow.X = rod.X", "  arrow.h = rod.axis", "", "  scene.draw(ambients)", "", "  trail.draw(ambients)", "", "  stats.end()", "}", "", "/**", " * Free WebGL resources when the window is unloaded.", " */", "window.onunload = function() {", "", "    controls.unsubscribe()", "    controls.release()", "", "    engine.stop()", "    engine.release()", "", "    scene.release()", "    trail.release()", "", "    arrow.release()", "    ball.release()", "    cube.release()", "    grid.release()", "    helix.release()", "    rod.release()", "", "    EIGHT.refChange('stop')", "    EIGHT.refChange('dump')", "}", ""];
    return lines.join('\n');
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/services/templates/EIGHTJS_LIBS.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function default_1() {
    var lines = ["//", "// Using WARNME helps keep things going in the face of errors.", "//", "EIGHT.errorMode = EIGHT.ErrorMode.WARNME", "", "//", "// Basis elements", "//", "const zero = EIGHT.Geometric3.zero()", "const one = EIGHT.Geometric3.one()", "const e1 = EIGHT.Geometric3.e1()", "const e2 = EIGHT.Geometric3.e2()", "const e3 = EIGHT.Geometric3.e3()", "", "/**", " * The pseudoscalar for Euclidean 3D Geometric Space.", " */", "const I  = e1 ^ e2 ^ e3", "", "//", "// Universal functions", "//", "const exp = EIGHT.exp", "const log = EIGHT.log", "const cos = EIGHT.cos", "const sin = EIGHT.sin", "", "//", "// Constants", "//", "/**", " * A complete turn, 2 * π.", " */", "const τ = 2 * Math.PI", "", "//", "// Colors", "//", "const black = EIGHT.Color.black", "const blue = EIGHT.Color.blue", "const cyan = EIGHT.Color.cyan", "const gray = EIGHT.Color.gray", "const green = EIGHT.Color.green", "const magenta = EIGHT.Color.magenta", "const red = EIGHT.Color.red", "const white = EIGHT.Color.white", "const yellow = EIGHT.Color.yellow", ""];
    return lines.join('\n');
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/services/templates/EIGHTJS_LESS.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function default_1(width, height) {
    var lines = "" + "body { margin: 0; }\n" + ("canvas { width: " + width + "px; height: " + height + "px }\n") + "#stats { position: absolute; top: 0; left: 0; }\n";
    return lines;
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/services/templates/SINGLE_VIEW_HTML.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function default_1(styleMarker, scriptsMarker, libsMarker, codeMarker, width, height, canvasId) {
    var lines = "" + "<!doctype html>\n" + "<html>\n" + "  <head>\n" + styleMarker() + scriptsMarker() + "  </head>\n" + "  <body>\n" + libsMarker() + codeMarker() + ("    <canvas id='" + canvasId + "'></canvas>\n") + "  </body>\n" + "</html>\n";
    return lines;
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/services/templates/SINGLE_VIEW_CODE.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function default_1(width, height, canvasId, refChange, useStats) {
    var lines = ["class MyApp extends EIGHT.SingleViewApp {", "  private cube = new EIGHT.Box({color: green, height: 0.2})", "  private ball = new EIGHT.Sphere({color: blue, radius: 0.1})", "  private controls = new EIGHT.TrackballControls(this.view.camera, this.window)", "  private gui = new dat.GUI()", "  private t = 0", "  private dt = 0", "  constructor() {", "    super({memcheck:true})", "  }", "  protected initialize(): void {", "    super.initialize()", "    this.view.camera.eye = 5 * e3 + 2 * e2", "    this.controls.synchronize()", "    const scene = this.view.scene", "    scene.add(this.cube)", "    scene.add(this.ball)", "    scene.release()", "    this.controls.subscribe(this.canvas)", "    this.gui.add(this, 'start')", "    this.gui.add(this, 'stop')", "    this.gui.add(this, 'reset')", "    this.gui.add(this, 'resetView')", "    this.animation.start()", "  }", "  protected animate(t: number): void {", "    this.t += this.dt", "    this.engine.clear()", "    this.controls.update()", "    const view = this.view", "    const camera = view.camera", "    view.dirLight.direction.copy(camera.look).sub(camera.eye)", "    this.ball.X = Math.cos(this.t) * e1 + Math.sin(this.t) * e3", "    view.draw()", "  }", "  protected destructor(): void {", "    this.controls.unsubscribe()", "    this.controls.release()", "    this.cube.release()", "    this.ball.release()", "    super.destructor()", "  }", "  public start() {", "    this.dt = 0.01", "  }", "  public stop() {", "    this.dt = 0", "  }", "  public reset() {", "    this.t = 0", "  }", "  public resetView() {", "    this.controls.reset()", "  }", "}", "new MyApp()", ""];
    return lines.join('\n');
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/services/templates/SINGLE_VIEW_LIBS.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function default_1() {
    var lines = ["//", "// Using WARNME helps keep things going in the face of errors.", "//", "EIGHT.errorMode = EIGHT.ErrorMode.WARNME", "", "//", "// Basis elements", "//", "const zero = EIGHT.Geometric3.zero()", "const one = EIGHT.Geometric3.one()", "const e1 = EIGHT.Geometric3.e1()", "const e2 = EIGHT.Geometric3.e2()", "const e3 = EIGHT.Geometric3.e3()", "", "/**", " * The pseudoscalar for Euclidean 3D Geometric Space.", " */", "const I  = e1 ^ e2 ^ e3", "", "//", "// Universal functions", "//", "const exp = EIGHT.exp", "const log = EIGHT.log", "const cos = EIGHT.cos", "const sin = EIGHT.sin", "", "//", "// Constants", "//", "/**", " * A complete turn, 2 * π.", " */", "const τ = 2 * Math.PI", "", "//", "// Colors", "//", "const black = EIGHT.Color.black", "const blue = EIGHT.Color.blue", "const cyan = EIGHT.Color.cyan", "const gray = EIGHT.Color.gray", "const green = EIGHT.Color.green", "const magenta = EIGHT.Color.magenta", "const red = EIGHT.Color.red", "const white = EIGHT.Color.white", "const yellow = EIGHT.Color.yellow", ""];
    return lines.join('\n');
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/services/templates/SINGLE_VIEW_LESS.js", [], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  function default_1(width, height) {
    var lines = "" + "body { margin: 0; }\n" + ("canvas { width: " + width + "px; height: " + height + "px }\n") + "#stats { position: absolute; top: 0; left: 0; }\n";
    return lines;
  }
  exports_1("default", default_1);
  return {
    setters: [],
    execute: function() {}
  };
});

System.register("js/services/templates/templates.js", ["../../app", "../doodles/Doodle", "../../utils/modeFromName", "./EIGHTJS_HTML", "./EIGHTJS_CODE", "./EIGHTJS_LIBS", "./EIGHTJS_LESS", "./SINGLE_VIEW_HTML", "./SINGLE_VIEW_CODE", "./SINGLE_VIEW_LIBS", "./SINGLE_VIEW_LESS"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1,
      Doodle_1,
      modeFromName_1,
      EIGHTJS_HTML_1,
      EIGHTJS_CODE_1,
      EIGHTJS_LIBS_1,
      EIGHTJS_LESS_1,
      SINGLE_VIEW_HTML_1,
      SINGLE_VIEW_CODE_1,
      SINGLE_VIEW_LIBS_1,
      SINGLE_VIEW_LESS_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }, function(Doodle_1_1) {
      Doodle_1 = Doodle_1_1;
    }, function(modeFromName_1_1) {
      modeFromName_1 = modeFromName_1_1;
    }, function(EIGHTJS_HTML_1_1) {
      EIGHTJS_HTML_1 = EIGHTJS_HTML_1_1;
    }, function(EIGHTJS_CODE_1_1) {
      EIGHTJS_CODE_1 = EIGHTJS_CODE_1_1;
    }, function(EIGHTJS_LIBS_1_1) {
      EIGHTJS_LIBS_1 = EIGHTJS_LIBS_1_1;
    }, function(EIGHTJS_LESS_1_1) {
      EIGHTJS_LESS_1 = EIGHTJS_LESS_1_1;
    }, function(SINGLE_VIEW_HTML_1_1) {
      SINGLE_VIEW_HTML_1 = SINGLE_VIEW_HTML_1_1;
    }, function(SINGLE_VIEW_CODE_1_1) {
      SINGLE_VIEW_CODE_1 = SINGLE_VIEW_CODE_1_1;
    }, function(SINGLE_VIEW_LIBS_1_1) {
      SINGLE_VIEW_LIBS_1 = SINGLE_VIEW_LIBS_1_1;
    }, function(SINGLE_VIEW_LESS_1_1) {
      SINGLE_VIEW_LESS_1 = SINGLE_VIEW_LESS_1_1;
    }],
    execute: function() {
      app_1.default.factory('templates', ['$location', 'uuid4', 'CODE_MARKER', 'LIBS_MARKER', 'STYLE_MARKER', 'SCRIPTS_MARKER', 'FILENAME_HTML', 'FILENAME_CODE', 'FILENAME_LIBS', 'FILENAME_LESS', function($location, uuid, CODE_MARKER, LIBS_MARKER, STYLE_MARKER, SCRIPTS_MARKER, FILENAME_HTML, FILENAME_CODE, FILENAME_LIBS, FILENAME_LESS) {
        function makeFiles(html, code, libs, less) {
          var files = {};
          files[FILENAME_HTML] = {
            content: html,
            language: modeFromName_1.default(FILENAME_HTML)
          };
          files[FILENAME_CODE] = {
            content: code,
            language: modeFromName_1.default(FILENAME_CODE)
          };
          files[FILENAME_LIBS] = {
            content: libs,
            language: modeFromName_1.default(FILENAME_LIBS)
          };
          files[FILENAME_LESS] = {
            content: less,
            language: modeFromName_1.default(FILENAME_LESS)
          };
          return files;
        }
        function newLine(s) {
          return s + "\n";
        }
        function indent(s) {
          return "    " + s;
        }
        function styleMarker() {
          return ['<style>', STYLE_MARKER, '</style>'].map(indent).map(newLine).join("");
        }
        function scriptsMarker() {
          return [SCRIPTS_MARKER].map(indent).map(newLine).join("");
        }
        function codeMarker() {
          return ['<script>', CODE_MARKER, '</script>'].map(indent).map(newLine).join("");
        }
        function libsMarker() {
          return ['<script>', LIBS_MARKER, '</script>'].map(indent).map(newLine).join("");
        }
        var HTML_TEMPLATE_MINIMAL = "" + "<!doctype html>\n" + "<html>\n" + "  <head>\n" + styleMarker() + scriptsMarker() + "  </head>\n" + "  <body>\n" + libsMarker() + codeMarker() + "  </body>\n" + "</html>\n";
        var CODE_TEMPLATE_MINIMAL = "";
        var LESS_TEMPLATE_MINIMAL = "";
        var LIBS_TEMPLATE_MINIMAL = "";
        var HTML_TEMPLATE_CALCULATION = "" + "<!doctype html>\n" + "<html>\n" + "  <head>\n" + styleMarker() + scriptsMarker() + "  </head>\n" + "  <body>\n" + "    <pre id='info'></pre>\n" + libsMarker() + codeMarker() + "  </body>\n" + "</html>\n";
        var CODE_TEMPLATE_CALCULATION = ["/**", " * Executed when the DOM is ready...", " */", "function main() {", "  const g = -9.81 * e3 * newton / kilogram", "  const mass = 70 * kilogram", "  const F = mass * g", "  const d = -2 * e3 * meter", "  const W = F << d", "", "  printvar('g', g)", "  printvar('g.direction()', g.direction())", "  printvar('g.magnitude()', g.magnitude())", "  printvar('mass', mass)", "  printvar('F = mass * g', F.toFixed(2))", "  printvar('d', d)", "  printvar('W = F << d', W.toPrecision(6))", "}", ""].join('\n');
        var LIBS_TEMPLATE_CALCULATION = ["// Create shortcuts for some values.", "const e1 = EIGHT.G3.e1", "const e2 = EIGHT.G3.e2", "const e3 = EIGHT.G3.e3", "const meter    = EIGHT.G3.meter", "const kilogram = EIGHT.G3.kilogram", "const second   = EIGHT.G3.second", "const coulomb  = EIGHT.G3.coulomb", "const ampere   = EIGHT.G3.ampere", "const kelvin   = EIGHT.G3.kelvin", "const mole     = EIGHT.G3.mole", "const candela  = EIGHT.G3.candela", "const newton   = meter * kilogram / (second * second)", "const joule    = newton * meter", "const volt     = joule / coulomb", "", "// Wait for the DOM to be loaded.", "DomReady.ready(function() {", "  try {", "    main();", "  }", "  catch(e) {", "    function colorize(arg: any, color: string) {", "      return \"<span style='color:\"+color+\"'>\" + arg + \"</span>\";", "    }", "    println(colorize(e.message, 'red'));", "  }", "});", "", "/**", " * Print the HTML string without a line ending.", " */", "function print(html: string): void {", "  const element = document.getElementById('info');", "  element.innerHTML = element.innerHTML + html;", "}", "", "/**", " * Print the HTML string and go to the next line.", " */", "function println(html: string): void {", "  print(html + '\\n');", "}", "", "/**", " * Print the value of a variable.", " */", "function printvar(name: string, value): void {", "  println('<b>' + name + '</b> => ' + value);", "}", ""].join('\n');
        var LESS_TEMPLATE_CALCULATION = ["body {", "  background-color: #000000;", "}", "", "#info {", "  position: absolute;", "  left: 20px;", "  top: 20px;", "  font-size: 26px;", "  color: #00FF00;", "}"].join('\n');
        var HTML_TEMPLATE_JSXGRAPH_DEMO = "" + "<!doctype html>\n" + "<html>\n" + "  <head>\n" + styleMarker() + scriptsMarker() + "  </head>\n" + "  <body>\n" + "    <div id='box' class='jxgbox' style='width:500px; height:500px'></div>\n" + "    <ul>\n" + "      <li>\n" + "        <a href='http://jsxgraph.uni-bayreuth.de' target='_blank' class='JXGtext'>JSXGraph Home Page</a>\n" + "      </li>\n" + "    </ul>\n" + libsMarker() + codeMarker() + "  </body>\n" + "</html>\n";
        var CODE_TEMPLATE_JSXGRAPH_DEMO = "" + "var graph = JXG.JSXGraph;\n" + "var brd = JXG.JSXGraph.initBoard('box',{boundingbox:[-5,5,5,-5], keepaspectratio:true, axis:true});\n" + "var i;\n" + "var p: JXG.Point[] = [];\n" + "var angle: number;\n" + "var co: number;\n" + "var si: number;\n" + "/**\n" + " * Parameter affecting the spread of the points around the circle.\n" + " */\n" + "var delta = 0.8;\n" + "\n" + "// Random points are constructed which lie roughly on a circle\n" + "// of radius 4 having the origin as center.\n" + "// delta*0.5 is the maximal distance in x- and y- direction of the random\n" + "// points from the circle line.\n" + "brd.suspendUpdate();\n" + "for (i=0;i<10;i++) {\n" + "  angle = Math.random()*2*Math.PI;\n" + "\n" + "  co = 4*Math.cos(angle)+delta*(Math.random()-0.5);\n" + "  si = 4*Math.sin(angle)+delta*(Math.random()-0.5);\n" + "  p.push(brd.create('point',[co, si], {withLabel:false}));\n" + "}\n" + "brd.unsuspendUpdate();\n" + "\n" + "// Having constructed the points, we can fit a circle\n" + "// through the point set, consisting of n points.\n" + "// The (n times 3) matrix consists of\n" + "//   x_1, y_1, 1\n" + "//   x_2, y_2, 1\n" + "//\n" + "//   x_n, y_n, 1\n" + "// where x_i, y_i is the position of point p_i\n" + "// The vector y of length n consists of\n" + "//    x_i*x_i+y_i*y_i\n" + "// for i=1,...n\n" + "var M: number[][] = [];\n" + "var y: number[] = [];\n" + "var n = p.length;\n" + "\n" + "for (i=0;i<n;i++) {\n" + "  M.push([p[i].X(), p[i].Y(), 1.0]);\n" + "  y.push(p[i].X()*p[i].X() + p[i].Y()*p[i].Y());\n" + "}\n" + "\n" + "// Now, the general linear least-square fitting problem\n" + "//    min_z || M*z - y||_2^2\n" + "// is solved by solving the system of linear equations\n" + "//    (M^T*M) * z = (M^T*y)\n" + "// with Gauss elimination.\n" + "var MT = JXG.Math.transpose(M);\n" + "var B = JXG.Math.matMatMult(MT, M);\n" + "var c = JXG.Math.matVecMult(MT, y);\n" + "var z = JXG.Math.Numerics.Gauss(B, c);\n" + "\n" + "// Finally, we can read from the solution vector z the coordinates [xm, ym] of the center\n" + "// and the radius r and draw the circle.\n" + "var xm = z[0]*0.5;\n" + "var ym = z[1]*0.5;\n" + "var r = Math.sqrt(z[2]+xm*xm+ym*ym);\n" + "\n" + "brd.create('circle',[ [xm,ym], r]);\n";
        var LIBS_TEMPLATE_JSXGRAPH_DEMO = "";
        var LESS_TEMPLATE_JSXGRAPH_DEMO = "" + ".jxgbox {\n" + "  position: relative;\n" + "  overflow: hidden;\n" + "  background-color: #ffffff;\n" + "  border-style: solid;\n" + "  border-width: 1px;\n" + "  border-color: #356AA0;\n" + "  border-radius: 6px;\n" + "  -webkit-border-radius: 6px;\n" + "  -ms-touch-action: none;\n" + "}\n" + "\n" + ".JXGtext {\n" + "  background-color: transparent;\n" + "  font-family: Arial, Helvetica, Geneva, sans-serif;\n" + "  padding: 0;\n" + "  margin: 0;\n" + "}\n" + "\n" + ".JXGinfobox {\n" + "  border-style: none;\n" + "  border-width: 1px;\n" + "  border-color: black;\n" + "}\n" + "\n" + ".JXGimage {\n" + "  opacity: 1.0;\n" + "}\n" + "\n" + ".JXGimageHighlight {\n" + "  opacity: 0.6;\n" + "}\n";
        var width = 600;
        var height = 600;
        var canvasId = 'canvas';
        var T0 = new Doodle_1.default();
        T0.uuid = uuid.generate();
        T0.description = "EightJS — 3D Library for WebGL Graphics and Geometric Algebra";
        T0.files = makeFiles(EIGHTJS_HTML_1.default(styleMarker, scriptsMarker, libsMarker, codeMarker, width, height, canvasId), EIGHTJS_CODE_1.default(width, height, canvasId, true, true), EIGHTJS_LIBS_1.default(), EIGHTJS_LESS_1.default(width, height));
        T0.dependencies = ['stats.js', 'dat-gui', 'davinci-eight'];
        var T1 = new Doodle_1.default();
        T1.uuid = uuid.generate();
        T1.description = "SingleViewApp — Template for WebGL Graphics and Geometric Algebra";
        T1.files = makeFiles(SINGLE_VIEW_HTML_1.default(styleMarker, scriptsMarker, libsMarker, codeMarker, width, height, canvasId), SINGLE_VIEW_CODE_1.default(width, height, 'canvas', true, true), SINGLE_VIEW_LIBS_1.default(), SINGLE_VIEW_LESS_1.default(width, height));
        T1.dependencies = ['stats.js', 'dat-gui', 'davinci-eight'];
        var T2 = new Doodle_1.default();
        T2.uuid = uuid.generate();
        T2.description = "Geometric Algebra and Unit of Measure calculations using EIGHT";
        T2.files = makeFiles(HTML_TEMPLATE_CALCULATION, CODE_TEMPLATE_CALCULATION, LIBS_TEMPLATE_CALCULATION, LESS_TEMPLATE_CALCULATION);
        T2.dependencies = ['DomReady', 'davinci-eight'];
        var T3 = new Doodle_1.default();
        T3.uuid = uuid.generate();
        T3.description = "Minimal";
        T3.files = makeFiles(HTML_TEMPLATE_MINIMAL, CODE_TEMPLATE_MINIMAL, LIBS_TEMPLATE_MINIMAL, LESS_TEMPLATE_MINIMAL);
        T3.dependencies = [];
        var T4 = new Doodle_1.default();
        T4.uuid = uuid.generate();
        T4.description = "JSXGraph — 2D Library for Geometry";
        T4.files = makeFiles(HTML_TEMPLATE_JSXGRAPH_DEMO, CODE_TEMPLATE_JSXGRAPH_DEMO, LIBS_TEMPLATE_JSXGRAPH_DEMO, LESS_TEMPLATE_JSXGRAPH_DEMO);
        T4.dependencies = ['jsxgraph'];
        return [T0, T1, T2, T3, T4];
      }]);
    }
  };
});

System.register("js/services/tw/tw.js", ["../../app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  function twitterFactory($window, NAMESPACE_TWITTER_WIDGETS) {
    $window[NAMESPACE_TWITTER_WIDGETS] = (function(tagName, id) {
      var js;
      var fjs = $window.document.getElementsByTagName(tagName)[0];
      var t = $window[NAMESPACE_TWITTER_WIDGETS] || {};
      if ($window.document.getElementById(id))
        return t;
      js = $window.document.createElement(tagName);
      js.id = id;
      js.src = "https://platform.twitter.com/widgets.js";
      fjs.parentNode.insertBefore(js, fjs);
      t['_e'] = [];
      t.ready = function(callback) {
        t['_e'].push(callback);
      };
      return t;
    }('script', 'twitter-wjs'));
    $window[NAMESPACE_TWITTER_WIDGETS].ready(function(twttr) {});
    return $window[NAMESPACE_TWITTER_WIDGETS];
  }
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.factory('$twitter', ['$window', 'NAMESPACE_TWITTER_WIDGETS', twitterFactory]);
    }
  };
});

System.register("js/services/uuid/UuidService.js", ["../../app"], function(exports_1, context_1) {
  'use strict';
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.factory('uuid4', function() {
        var maxFromBits = function(bits) {
          return Math.pow(2, bits);
        };
        var limitUI06 = maxFromBits(6);
        var limitUI08 = maxFromBits(8);
        var limitUI12 = maxFromBits(12);
        var limitUI16 = maxFromBits(16);
        var limitUI32 = maxFromBits(32);
        var getRandomInt = function(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        };
        var randomUI06 = function() {
          return getRandomInt(0, limitUI06 - 1);
        };
        var randomUI08 = function() {
          return getRandomInt(0, limitUI08 - 1);
        };
        var randomUI12 = function() {
          return getRandomInt(0, limitUI12 - 1);
        };
        var randomUI16 = function() {
          return getRandomInt(0, limitUI16 - 1);
        };
        var randomUI32 = function() {
          return getRandomInt(0, limitUI32 - 1);
        };
        var randomUI48 = function() {
          return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 48 - 30)) * (1 << 30);
        };
        var paddedString = function(s, length, z) {
          s = String(s);
          z = (!z) ? '0' : z;
          var i = length - s.length;
          for (; i > 0; i >>>= 1, z += z) {
            if (i & 1) {
              s = z + s;
            }
          }
          return s;
        };
        var fromParts = function(timeLow, timeMid, timeHiAndVersion, clockSeqHiAndReserved, clockSeqLow, node) {
          var hex = paddedString(timeLow.toString(16), 8) + '-' + paddedString(timeMid.toString(16), 4) + '-' + paddedString(timeHiAndVersion.toString(16), 4) + '-' + paddedString(clockSeqHiAndReserved.toString(16), 2) + paddedString(clockSeqLow.toString(16), 2) + '-' + paddedString(node.toString(16), 12);
          return hex;
        };
        var that = {
          generate: function() {
            return fromParts(randomUI32(), randomUI16(), 0x4000 | randomUI12(), 0x80 | randomUI06(), randomUI08(), randomUI48());
          },
          validate: function(uuid) {
            var testPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
            return testPattern.test(uuid);
          }
        };
        return that;
      });
    }
  };
});

System.registerDynamic("github:angular/bower-angular-animate@1.5.3/angular-animate.js", ["angular"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var noop = angular.noop;
      var copy = angular.copy;
      var extend = angular.extend;
      var jqLite = angular.element;
      var forEach = angular.forEach;
      var isArray = angular.isArray;
      var isString = angular.isString;
      var isObject = angular.isObject;
      var isUndefined = angular.isUndefined;
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isElement = angular.isElement;
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var ADD_CLASS_SUFFIX = '-add';
      var REMOVE_CLASS_SUFFIX = '-remove';
      var EVENT_CLASS_PREFIX = 'ng-';
      var ACTIVE_CLASS_SUFFIX = '-active';
      var PREPARE_CLASS_SUFFIX = '-prepare';
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var isPromiseLike = function(p) {
        return p && p.then ? true : false;
      };
      var ngMinErr = angular.$$minErr('ng');
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return [];
              break;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
              break;
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {};
        var newOptions = newAnimation.options || {};
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
          delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
          target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        oldAnimation.addClass = target.addClass;
        oldAnimation.removeClass = target.removeClass;
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof angular.element) ? element[0] : element;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        var classes = '';
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
          classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.addClass(classes);
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          element.removeClass(options.preparationClasses);
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          element.removeClass(options.activeClasses);
          options.activeClasses = null;
        }
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function concatWithSpace(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        return a + ' ' + b;
      }
      var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
        var queue,
            cancelFn;
        function scheduler(tasks) {
          queue = queue.concat(tasks);
          nextTick();
        }
        queue = scheduler.queue = [];
        scheduler.waitUntilQuiet = function(fn) {
          if (cancelFn)
            cancelFn();
          cancelFn = $$rAF(function() {
            cancelFn = null;
            fn();
            nextTick();
          });
        };
        return scheduler;
        function nextTick() {
          if (!queue.length)
            return;
          var items = queue.shift();
          for (var i = 0; i < items.length; i++) {
            items[i]();
          }
          if (!cancelFn) {
            $$rAF(function() {
              if (!cancelFn)
                nextTick();
            });
          }
        }
      }];
      var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
        return {link: function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (angular.isString(val) && val.length === 0) {
              element.data(NG_ANIMATE_CHILDREN_DATA, true);
            } else {
              setData($interpolate(val)(scope));
              attrs.$observe('ngAnimateChildren', setData);
            }
            function setData(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            }
          }};
      }];
      var ANIMATE_TIMER_KEY = '$$animateCss';
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
          backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue', function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var cancelLastRAFRequest;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function() {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          return function init(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = prepareAnimationOptions(copy(options));
            }
            var restoreStyles = {};
            var node = getDomNode(element);
            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
              return closeAndReturnNoopAnimator();
            }
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            var startTime;
            var events = [];
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
            }
            var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + preparationClasses;
            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.delay != null) {
              var delayStyle;
              if (typeof options.delay !== "boolean") {
                delayStyle = parseFloat(options.delay);
                maxDelay = Math.max(delayStyle, 0);
              }
              if (flags.applyTransitionDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle));
              }
              if (flags.applyAnimationDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
              }
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            if (options.from) {
              if (options.cleanupStyles) {
                registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
              }
              applyAnimationFromStyles(element, options);
            }
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (Object.keys(restoreStyles).length) {
                forEach(restoreStyles, function(value, prop) {
                  value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                });
              }
              if (options.onDone) {
                options.onDone();
              }
              if (events && events.length) {
                element.off(events.join(' '), onAnimationProgress);
              }
              var animationTimerData = element.data(ANIMATE_TIMER_KEY);
              if (animationTimerData) {
                $timeout.cancel(animationTimerData[0].timer);
                element.removeData(ANIMATE_TIMER_KEY);
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              waitUntilQuiet(noop);
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function onAnimationProgress(event) {
              event.stopPropagation();
              var ev = event.originalEvent || event;
              var timeStamp = ev.$manualTimeStamp || Date.now();
              var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
              if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                animationCompleted = true;
                close();
              }
            }
            function start() {
              if (animationClosed)
                return;
              if (!node.parentNode) {
                close();
                return;
              }
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                var endTime = startTime + timerTime;
                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                var setupFallbackTimer = true;
                if (animationsData.length) {
                  var currentTimerData = animationsData[0];
                  setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                  if (setupFallbackTimer) {
                    $timeout.cancel(currentTimerData.timer);
                  } else {
                    animationsData.push(close);
                  }
                }
                if (setupFallbackTimer) {
                  var timer = $timeout(onAnimationExpired, timerTime, false);
                  animationsData[0] = {
                    timer: timer,
                    expectedEndTime: endTime
                  };
                  animationsData.push(close);
                  element.data(ANIMATE_TIMER_KEY, animationsData);
                }
                if (events.length) {
                  element.on(events.join(' '), onAnimationProgress);
                }
                if (options.to) {
                  if (options.cleanupStyles) {
                    registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                  }
                  applyAnimationToStyles(element, options);
                }
              }
              function onAnimationExpired() {
                var animationsData = element.data(ANIMATE_TIMER_KEY);
                if (animationsData) {
                  for (var i = 1; i < animationsData.length; i++) {
                    animationsData[i]();
                  }
                  element.removeData(ANIMATE_TIMER_KEY);
                }
              }
            }
          };
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        function isDocumentFragment(node) {
          return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = $document[0].body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              options.structural = true;
              options.applyClassesEarly = true;
              if (animationDetails.event === 'leave') {
                options.onDone = options.domOperation;
              }
            }
            if (options.preparationClasses) {
              options.event = concatWithSpace(options.event, options.preparationClasses);
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$jqLite', function($injector, $$AnimateRunner, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            var animationClosed = false;
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            function close() {
              animationClosed = true;
              applyOptions();
              applyAnimationStyles(element, options);
            }
            var runner;
            return {
              $$willAnimate: true,
              end: function() {
                if (runner) {
                  runner.end();
                } else {
                  close();
                  runner = new $$AnimateRunner();
                  runner.complete(true);
                }
                return runner;
              },
              start: function() {
                if (runner) {
                  return runner;
                }
                runner = new $$AnimateRunner();
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                runner.setHost({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  close(success);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }
            };
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var ONE_SPACE = ' ';
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function makeTruthyCssClassMap(classString) {
          if (!classString) {
            return null;
          }
          var keys = classString.split(ONE_SPACE);
          var map = Object.create(null);
          forEach(keys, function(key) {
            map[key] = true;
          });
          return map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
          if (newClassString && currentClassString) {
            var currentClassMap = makeTruthyCssClassMap(currentClassString);
            return newClassString.split(ONE_SPACE).some(function(className) {
              return currentClassMap[className];
            });
          }
        }
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(animation, and) {
          var a = (animation.addClass || '').length > 0;
          var b = (animation.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          if (currentAnimation.structural)
            return false;
          var nA = newAnimation.addClass;
          var nR = newAnimation.removeClass;
          var cA = currentAnimation.addClass;
          var cR = currentAnimation.removeClass;
          if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
            return false;
          }
          return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          function postDigestTaskFactory() {
            var postDigestCalled = false;
            return function(fn) {
              if (postDigestCalled) {
                fn();
              } else {
                $rootScope.$$postDigest(function() {
                  postDigestCalled = true;
                  fn();
                });
              }
            };
          }
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var callbackRegistry = {};
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationDetails(element, animation) {
            return mergeAnimationDetails(element, animation, {});
          }
          var contains = Node.prototype.contains || function(arg) {
            return this === arg || !!(this.compareDocumentPosition(arg) & 16);
          };
          function findCallbacks(parent, element, event) {
            var targetNode = getDomNode(element);
            var targetParentNode = getDomNode(parent);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (contains.call(entry.node, targetNode)) {
                  matches.push(entry.callback);
                } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          var $animate = {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
              jqLite(container).on('$destroy', function() {
                $animate.off(event, container, callback);
              });
            },
            off: function(event, container, callback) {
              var entries = callbackRegistry[event];
              if (!entries)
                return;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
              function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                  var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                  return !isMatch;
                });
              }
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  var recordExists = disabledElementsLookup.get(node);
                  if (argCount === 1) {
                    bool = !recordExists;
                  } else {
                    disabledElementsLookup.put(node, !bool);
                  }
                }
              }
              return bool;
            }
          };
          return $animate;
          function queueAnimation(element, event, initialOptions) {
            var options = copy(initialOptions);
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            var runInNextPostDigestOrNow = postDigestTaskFactory();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var skipAnimations = !animationsEnabled || $document[0].hidden || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              close();
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              addClass: options.addClass,
              removeClass: options.removeClass,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationDetails(element, newAnimation);
                  } else {
                    applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationDetails(element, newAnimation);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? 'setClass' : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options);
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              runInNextPostDigestOrNow(function() {
                var callbacks = findCallbacks(parent, element, event);
                if (callbacks.length) {
                  $$rAF(function() {
                    forEach(callbacks, function(callback) {
                      callback(element, phase, data);
                    });
                  });
                }
              });
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              if (animationDetails) {
                switch (state) {
                  case RUNNING_STATE:
                    animationDetails.runner.end();
                  case PRE_DIGEST_STATE:
                    activeAnimationsLookup.remove(child);
                    break;
                }
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElement = jqLite($document[0].body);
            var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var elementDisabled = disabledElementsLookup.get(getDomNode(element));
            var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            parentElement = getDomNode(parentElement);
            while (parentElement) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              if (parentElement.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentElement) || {};
              if (!parentAnimationDetected) {
                var parentElementDisabled = disabledElementsLookup.get(parentElement);
                if (parentElementDisabled === true && elementDisabled !== false) {
                  elementDisabled = true;
                  break;
                } else if (parentElementDisabled === false) {
                  elementDisabled = false;
                }
                parentAnimationDetected = details.structural;
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, bodyElement);
              }
              if (bodyElementDetected && rootElementDetected) {
                break;
              }
              if (!rootElementDetected) {
                parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
                if (parentHost) {
                  parentElement = getDomNode(parentHost);
                  continue;
                }
              }
              parentElement = parentElement.parentNode;
            }
            var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = {children: []};
            var i,
                lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(animation.domNode, animations[i] = {
                domNode: animation.domNode,
                fn: animation.fn,
                children: []
              });
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed)
                return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result.push(row);
                  row = [];
                }
                row.push(entry.fn);
                entry.children.forEach(function(childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result.push(row);
              }
              return result;
            }
          }
          return function(element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            var prepareClassName;
            if (isStructural) {
              prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
              $$jqLite.addClass(element, prepareClassName);
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              var animations = [];
              forEach(animationQueue, function(entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function(animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                        closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function(status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  }
                });
              });
              $$rAFScheduler(sortAnimations(toBeSortedAnimations));
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                if (!$injector.has(driverName))
                  continue;
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
              if (prepareClassName) {
                $$jqLite.removeClass(element, prepareClassName);
                prepareClassName = null;
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                getRunner(element).setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
        return {
          restrict: 'A',
          transclude: 'element',
          terminal: true,
          priority: 600,
          link: function(scope, $element, attrs, ctrl, $transclude) {
            var previousElement,
                previousScope;
            scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
              if (previousElement) {
                $animate.leave(previousElement);
              }
              if (previousScope) {
                previousScope.$destroy();
                previousScope = null;
              }
              if (value || value === 0) {
                previousScope = scope.$new();
                $transclude(previousScope, function(element) {
                  previousElement = element;
                  $animate.enter(element, null, $element);
                });
              }
            });
          }
        };
      }];
      angular.module('ngAnimate', []).directive('ngAnimateSwap', ngAnimateSwapDirective).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFScheduler', $$rAFSchedulerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-animate@1.5.3.js", ["github:angular/bower-angular-animate@1.5.3/angular-animate"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:angular/bower-angular-animate@1.5.3/angular-animate');
  return module.exports;
});

System.registerDynamic("github:angular-ui/bootstrap-bower@1.3.2/ui-bootstrap-tpls.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
    angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/backdrop.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]);
    angular.module('ui.bootstrap.collapse', []).directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {
      var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
      return {link: function(scope, element, attrs) {
          var expandingExpr = $parse(attrs.expanding),
              expandedExpr = $parse(attrs.expanded),
              collapsingExpr = $parse(attrs.collapsing),
              collapsedExpr = $parse(attrs.collapsed);
          if (!scope.$eval(attrs.uibCollapse)) {
            element.addClass('in').addClass('collapse').attr('aria-expanded', true).attr('aria-hidden', false).css({height: 'auto'});
          }
          function expand() {
            if (element.hasClass('collapse') && element.hasClass('in')) {
              return;
            }
            $q.resolve(expandingExpr(scope)).then(function() {
              element.removeClass('collapse').addClass('collapsing').attr('aria-expanded', true).attr('aria-hidden', false);
              if ($animateCss) {
                $animateCss(element, {
                  addClass: 'in',
                  easing: 'ease',
                  to: {height: element[0].scrollHeight + 'px'}
                }).start()['finally'](expandDone);
              } else {
                $animate.addClass(element, 'in', {to: {height: element[0].scrollHeight + 'px'}}).then(expandDone);
              }
            });
          }
          function expandDone() {
            element.removeClass('collapsing').addClass('collapse').css({height: 'auto'});
            expandedExpr(scope);
          }
          function collapse() {
            if (!element.hasClass('collapse') && !element.hasClass('in')) {
              return collapseDone();
            }
            $q.resolve(collapsingExpr(scope)).then(function() {
              element.css({height: element[0].scrollHeight + 'px'}).removeClass('collapse').addClass('collapsing').attr('aria-expanded', false).attr('aria-hidden', true);
              if ($animateCss) {
                $animateCss(element, {
                  removeClass: 'in',
                  to: {height: '0'}
                }).start()['finally'](collapseDone);
              } else {
                $animate.removeClass(element, 'in', {to: {height: '0'}}).then(collapseDone);
              }
            });
          }
          function collapseDone() {
            element.css({height: '0'});
            element.removeClass('collapsing').addClass('collapse');
            collapsedExpr(scope);
          }
          scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
            if (shouldCollapse) {
              collapse();
            } else {
              expand();
            }
          });
        }};
    }]);
    angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse']).constant('uibAccordionConfig', {closeOthers: true}).controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
      this.groups = [];
      this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if (closeOthers) {
          angular.forEach(this.groups, function(group) {
            if (group !== openGroup) {
              group.isOpen = false;
            }
          });
        }
      };
      this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope);
        groupScope.$on('$destroy', function(event) {
          that.removeGroup(groupScope);
        });
      };
      this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
          this.groups.splice(index, 1);
        }
      };
    }]).directive('uibAccordion', function() {
      return {
        controller: 'UibAccordionController',
        controllerAs: 'accordion',
        transclude: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/accordion/accordion.html';
        }
      };
    }).directive('uibAccordionGroup', function() {
      return {
        require: '^uibAccordion',
        transclude: true,
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
        },
        scope: {
          heading: '@',
          panelClass: '@?',
          isOpen: '=?',
          isDisabled: '=?'
        },
        controller: function() {
          this.setHeading = function(element) {
            this.heading = element;
          };
        },
        link: function(scope, element, attrs, accordionCtrl) {
          accordionCtrl.addGroup(scope);
          scope.openClass = attrs.openClass || 'panel-open';
          scope.panelClass = attrs.panelClass || 'panel-default';
          scope.$watch('isOpen', function(value) {
            element.toggleClass(scope.openClass, !!value);
            if (value) {
              accordionCtrl.closeOthers(scope);
            }
          });
          scope.toggleOpen = function($event) {
            if (!scope.isDisabled) {
              if (!$event || $event.which === 32) {
                scope.isOpen = !scope.isOpen;
              }
            }
          };
          var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
          scope.headingId = id + '-tab';
          scope.panelId = id + '-panel';
        }
      };
    }).directive('uibAccordionHeading', function() {
      return {
        transclude: true,
        template: '',
        replace: true,
        require: '^uibAccordionGroup',
        link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
          accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
      };
    }).directive('uibAccordionTransclude', function() {
      return {
        require: '^uibAccordionGroup',
        link: function(scope, element, attrs, controller) {
          scope.$watch(function() {
            return controller[attrs.uibAccordionTransclude];
          }, function(heading) {
            if (heading) {
              var elem = angular.element(element[0].querySelector('[uib-accordion-header]'));
              elem.html('');
              elem.append(heading);
            }
          });
        }
      };
    });
    angular.module('ui.bootstrap.alert', []).controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {
      $scope.closeable = !!$attrs.close;
      var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
      if (dismissOnTimeout) {
        $timeout(function() {
          $scope.close();
        }, parseInt(dismissOnTimeout, 10));
      }
    }]).directive('uibAlert', function() {
      return {
        controller: 'UibAlertController',
        controllerAs: 'alert',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/alert/alert.html';
        },
        transclude: true,
        replace: true,
        scope: {
          type: '@',
          close: '&'
        }
      };
    });
    angular.module('ui.bootstrap.buttons', []).constant('uibButtonConfig', {
      activeClass: 'active',
      toggleEvent: 'click'
    }).controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
      this.activeClass = buttonConfig.activeClass || 'active';
      this.toggleEvent = buttonConfig.toggleEvent || 'click';
    }]).directive('uibBtnRadio', ['$parse', function($parse) {
      return {
        require: ['uibBtnRadio', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'buttons',
        link: function(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          var uncheckableExpr = $parse(attrs.uibUncheckable);
          element.find('input').css({display: 'none'});
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
          };
          element.on(buttonsCtrl.toggleEvent, function() {
            if (attrs.disabled) {
              return;
            }
            var isActive = element.hasClass(buttonsCtrl.activeClass);
            if (!isActive || angular.isDefined(attrs.uncheckable)) {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
                ngModelCtrl.$render();
              });
            }
          });
          if (attrs.uibUncheckable) {
            scope.$watch(uncheckableExpr, function(uncheckable) {
              attrs.$set('uncheckable', uncheckable ? '' : undefined);
            });
          }
        }
      };
    }]).directive('uibBtnCheckbox', function() {
      return {
        require: ['uibBtnCheckbox', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'button',
        link: function(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          element.find('input').css({display: 'none'});
          function getTrueValue() {
            return getCheckboxValue(attrs.btnCheckboxTrue, true);
          }
          function getFalseValue() {
            return getCheckboxValue(attrs.btnCheckboxFalse, false);
          }
          function getCheckboxValue(attribute, defaultValue) {
            return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
          }
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
          };
          element.on(buttonsCtrl.toggleEvent, function() {
            if (attrs.disabled) {
              return;
            }
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
              ngModelCtrl.$render();
            });
          });
        }
      };
    });
    angular.module('ui.bootstrap.carousel', []).controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {
      var self = this,
          slides = self.slides = $scope.slides = [],
          SLIDE_DIRECTION = 'uib-slideDirection',
          currentIndex = $scope.active,
          currentInterval,
          isPlaying,
          bufferedTransitions = [];
      var destroyed = false;
      self.addSlide = function(slide, element) {
        slides.push({
          slide: slide,
          element: element
        });
        slides.sort(function(a, b) {
          return +a.slide.index - +b.slide.index;
        });
        if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
          if ($scope.$currentTransition) {
            $scope.$currentTransition = null;
          }
          currentIndex = slide.index;
          $scope.active = slide.index;
          setActive(currentIndex);
          self.select(slides[findSlideIndex(slide)]);
          if (slides.length === 1) {
            $scope.play();
          }
        }
      };
      self.getCurrentIndex = function() {
        for (var i = 0; i < slides.length; i++) {
          if (slides[i].slide.index === currentIndex) {
            return i;
          }
        }
      };
      self.next = $scope.next = function() {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;
        if (newIndex === 0 && $scope.noWrap()) {
          $scope.pause();
          return;
        }
        return self.select(slides[newIndex], 'next');
      };
      self.prev = $scope.prev = function() {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
        if ($scope.noWrap() && newIndex === slides.length - 1) {
          $scope.pause();
          return;
        }
        return self.select(slides[newIndex], 'prev');
      };
      self.removeSlide = function(slide) {
        var index = findSlideIndex(slide);
        var bufferedIndex = bufferedTransitions.indexOf(slides[index]);
        if (bufferedIndex !== -1) {
          bufferedTransitions.splice(bufferedIndex, 1);
        }
        slides.splice(index, 1);
        if (slides.length > 0 && currentIndex === index) {
          if (index >= slides.length) {
            currentIndex = slides.length - 1;
            $scope.active = currentIndex;
            setActive(currentIndex);
            self.select(slides[slides.length - 1]);
          } else {
            currentIndex = index;
            $scope.active = currentIndex;
            setActive(currentIndex);
            self.select(slides[index]);
          }
        } else if (currentIndex > index) {
          currentIndex--;
          $scope.active = currentIndex;
        }
        if (slides.length === 0) {
          currentIndex = null;
          $scope.active = null;
          clearBufferedTransitions();
        }
      };
      self.select = $scope.select = function(nextSlide, direction) {
        var nextIndex = findSlideIndex(nextSlide.slide);
        if (direction === undefined) {
          direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
        }
        if (nextSlide.slide.index !== currentIndex && !$scope.$currentTransition) {
          goNext(nextSlide.slide, nextIndex, direction);
        } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {
          bufferedTransitions.push(slides[nextIndex]);
        }
      };
      $scope.indexOfSlide = function(slide) {
        return +slide.slide.index;
      };
      $scope.isActive = function(slide) {
        return $scope.active === slide.slide.index;
      };
      $scope.isPrevDisabled = function() {
        return $scope.active === 0 && $scope.noWrap();
      };
      $scope.isNextDisabled = function() {
        return $scope.active === slides.length - 1 && $scope.noWrap();
      };
      $scope.pause = function() {
        if (!$scope.noPause) {
          isPlaying = false;
          resetTimer();
        }
      };
      $scope.play = function() {
        if (!isPlaying) {
          isPlaying = true;
          restartTimer();
        }
      };
      $scope.$on('$destroy', function() {
        destroyed = true;
        resetTimer();
      });
      $scope.$watch('noTransition', function(noTransition) {
        $animate.enabled($element, !noTransition);
      });
      $scope.$watch('interval', restartTimer);
      $scope.$watchCollection('slides', resetTransition);
      $scope.$watch('active', function(index) {
        if (angular.isNumber(index) && currentIndex !== index) {
          for (var i = 0; i < slides.length; i++) {
            if (slides[i].slide.index === index) {
              index = i;
              break;
            }
          }
          var slide = slides[index];
          if (slide) {
            setActive(index);
            self.select(slides[index]);
            currentIndex = index;
          }
        }
      });
      function clearBufferedTransitions() {
        while (bufferedTransitions.length) {
          bufferedTransitions.shift();
        }
      }
      function getSlideByIndex(index) {
        for (var i = 0,
            l = slides.length; i < l; ++i) {
          if (slides[i].index === index) {
            return slides[i];
          }
        }
      }
      function setActive(index) {
        for (var i = 0; i < slides.length; i++) {
          slides[i].slide.active = i === index;
        }
      }
      function goNext(slide, index, direction) {
        if (destroyed) {
          return;
        }
        angular.extend(slide, {direction: direction});
        angular.extend(slides[currentIndex].slide || {}, {direction: direction});
        if ($animate.enabled($element) && !$scope.$currentTransition && slides[index].element && self.slides.length > 1) {
          slides[index].element.data(SLIDE_DIRECTION, slide.direction);
          var currentIdx = self.getCurrentIndex();
          if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
            slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
          }
          $scope.$currentTransition = true;
          $animate.on('addClass', slides[index].element, function(element, phase) {
            if (phase === 'close') {
              $scope.$currentTransition = null;
              $animate.off('addClass', element);
              if (bufferedTransitions.length) {
                var nextSlide = bufferedTransitions.pop().slide;
                var nextIndex = nextSlide.index;
                var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
                clearBufferedTransitions();
                goNext(nextSlide, nextIndex, nextDirection);
              }
            }
          });
        }
        $scope.active = slide.index;
        currentIndex = slide.index;
        setActive(index);
        restartTimer();
      }
      function findSlideIndex(slide) {
        for (var i = 0; i < slides.length; i++) {
          if (slides[i].slide === slide) {
            return i;
          }
        }
      }
      function resetTimer() {
        if (currentInterval) {
          $interval.cancel(currentInterval);
          currentInterval = null;
        }
      }
      function resetTransition(slides) {
        if (!slides.length) {
          $scope.$currentTransition = null;
          clearBufferedTransitions();
        }
      }
      function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        if (!isNaN(interval) && interval > 0) {
          currentInterval = $interval(timerFn, interval);
        }
      }
      function timerFn() {
        var interval = +$scope.interval;
        if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
          $scope.next();
        } else {
          $scope.pause();
        }
      }
    }]).directive('uibCarousel', function() {
      return {
        transclude: true,
        replace: true,
        controller: 'UibCarouselController',
        controllerAs: 'carousel',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/carousel/carousel.html';
        },
        scope: {
          active: '=',
          interval: '=',
          noTransition: '=',
          noPause: '=',
          noWrap: '&'
        }
      };
    }).directive('uibSlide', function() {
      return {
        require: '^uibCarousel',
        transclude: true,
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/carousel/slide.html';
        },
        scope: {
          actual: '=?',
          index: '=?'
        },
        link: function(scope, element, attrs, carouselCtrl) {
          carouselCtrl.addSlide(scope, element);
          scope.$on('$destroy', function() {
            carouselCtrl.removeSlide(scope);
          });
        }
      };
    }).animation('.item', ['$animateCss', function($animateCss) {
      var SLIDE_DIRECTION = 'uib-slideDirection';
      function removeClass(element, className, callback) {
        element.removeClass(className);
        if (callback) {
          callback();
        }
      }
      return {
        beforeAddClass: function(element, className, done) {
          if (className === 'active') {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element, directionClass + ' ' + direction, done);
            element.addClass(direction);
            $animateCss(element, {addClass: directionClass}).start().done(removeClassFn);
            return function() {
              stopped = true;
            };
          }
          done();
        },
        beforeRemoveClass: function(element, className, done) {
          if (className === 'active') {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction === 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element, directionClass, done);
            $animateCss(element, {addClass: directionClass}).start().done(removeClassFn);
            return function() {
              stopped = true;
            };
          }
          done();
        }
      };
    }]);
    angular.module('ui.bootstrap.dateparser', []).service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {
      var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      var localeId;
      var formatCodeToRegex;
      this.init = function() {
        localeId = $locale.id;
        this.parsers = {};
        this.formatters = {};
        formatCodeToRegex = [{
          key: 'yyyy',
          regex: '\\d{4}',
          apply: function(value) {
            this.year = +value;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'yyyy');
          }
        }, {
          key: 'yy',
          regex: '\\d{2}',
          apply: function(value) {
            value = +value;
            this.year = value < 69 ? value + 2000 : value + 1900;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'yy');
          }
        }, {
          key: 'y',
          regex: '\\d{1,4}',
          apply: function(value) {
            this.year = +value;
          },
          formatter: function(date) {
            var _date = new Date();
            _date.setFullYear(Math.abs(date.getFullYear()));
            return dateFilter(_date, 'y');
          }
        }, {
          key: 'M!',
          regex: '0?[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            var value = date.getMonth();
            if (/^[0-9]$/.test(value)) {
              return dateFilter(date, 'MM');
            }
            return dateFilter(date, 'M');
          }
        }, {
          key: 'MMMM',
          regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
          apply: function(value) {
            this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
          },
          formatter: function(date) {
            return dateFilter(date, 'MMMM');
          }
        }, {
          key: 'MMM',
          regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
          apply: function(value) {
            this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
          },
          formatter: function(date) {
            return dateFilter(date, 'MMM');
          }
        }, {
          key: 'MM',
          regex: '0[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            return dateFilter(date, 'MM');
          }
        }, {
          key: 'M',
          regex: '[1-9]|1[0-2]',
          apply: function(value) {
            this.month = value - 1;
          },
          formatter: function(date) {
            return dateFilter(date, 'M');
          }
        }, {
          key: 'd!',
          regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            var value = date.getDate();
            if (/^[1-9]$/.test(value)) {
              return dateFilter(date, 'dd');
            }
            return dateFilter(date, 'd');
          }
        }, {
          key: 'dd',
          regex: '[0-2][0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'dd');
          }
        }, {
          key: 'd',
          regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
          apply: function(value) {
            this.date = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'd');
          }
        }, {
          key: 'EEEE',
          regex: $locale.DATETIME_FORMATS.DAY.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'EEEE');
          }
        }, {
          key: 'EEE',
          regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'EEE');
          }
        }, {
          key: 'HH',
          regex: '(?:0|1)[0-9]|2[0-3]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'HH');
          }
        }, {
          key: 'hh',
          regex: '0[0-9]|1[0-2]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'hh');
          }
        }, {
          key: 'H',
          regex: '1?[0-9]|2[0-3]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'H');
          }
        }, {
          key: 'h',
          regex: '[0-9]|1[0-2]',
          apply: function(value) {
            this.hours = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'h');
          }
        }, {
          key: 'mm',
          regex: '[0-5][0-9]',
          apply: function(value) {
            this.minutes = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'mm');
          }
        }, {
          key: 'm',
          regex: '[0-9]|[1-5][0-9]',
          apply: function(value) {
            this.minutes = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'm');
          }
        }, {
          key: 'sss',
          regex: '[0-9][0-9][0-9]',
          apply: function(value) {
            this.milliseconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'sss');
          }
        }, {
          key: 'ss',
          regex: '[0-5][0-9]',
          apply: function(value) {
            this.seconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 'ss');
          }
        }, {
          key: 's',
          regex: '[0-9]|[1-5][0-9]',
          apply: function(value) {
            this.seconds = +value;
          },
          formatter: function(date) {
            return dateFilter(date, 's');
          }
        }, {
          key: 'a',
          regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
          apply: function(value) {
            if (this.hours === 12) {
              this.hours = 0;
            }
            if (value === 'PM') {
              this.hours += 12;
            }
          },
          formatter: function(date) {
            return dateFilter(date, 'a');
          }
        }, {
          key: 'Z',
          regex: '[+-]\\d{4}',
          apply: function(value) {
            var matches = value.match(/([+-])(\d{2})(\d{2})/),
                sign = matches[1],
                hours = matches[2],
                minutes = matches[3];
            this.hours += toInt(sign + hours);
            this.minutes += toInt(sign + minutes);
          },
          formatter: function(date) {
            return dateFilter(date, 'Z');
          }
        }, {
          key: 'ww',
          regex: '[0-4][0-9]|5[0-3]',
          formatter: function(date) {
            return dateFilter(date, 'ww');
          }
        }, {
          key: 'w',
          regex: '[0-9]|[1-4][0-9]|5[0-3]',
          formatter: function(date) {
            return dateFilter(date, 'w');
          }
        }, {
          key: 'GGGG',
          regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
          formatter: function(date) {
            return dateFilter(date, 'GGGG');
          }
        }, {
          key: 'GGG',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'GGG');
          }
        }, {
          key: 'GG',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'GG');
          }
        }, {
          key: 'G',
          regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
          formatter: function(date) {
            return dateFilter(date, 'G');
          }
        }];
      };
      this.init();
      function createParser(format, func) {
        var map = [],
            regex = format.split('');
        var quoteIndex = format.indexOf('\'');
        if (quoteIndex > -1) {
          var inLiteral = false;
          format = format.split('');
          for (var i = quoteIndex; i < format.length; i++) {
            if (inLiteral) {
              if (format[i] === '\'') {
                if (i + 1 < format.length && format[i + 1] === '\'') {
                  format[i + 1] = '$';
                  regex[i + 1] = '';
                } else {
                  regex[i] = '';
                  inLiteral = false;
                }
              }
              format[i] = '$';
            } else {
              if (format[i] === '\'') {
                format[i] = '$';
                regex[i] = '';
                inLiteral = true;
              }
            }
          }
          format = format.join('');
        }
        angular.forEach(formatCodeToRegex, function(data) {
          var index = format.indexOf(data.key);
          if (index > -1) {
            format = format.split('');
            regex[index] = '(' + data.regex + ')';
            format[index] = '$';
            for (var i = index + 1,
                n = index + data.key.length; i < n; i++) {
              regex[i] = '';
              format[i] = '$';
            }
            format = format.join('');
            map.push({
              index: index,
              key: data.key,
              apply: data[func],
              matcher: data.regex
            });
          }
        });
        return {
          regex: new RegExp('^' + regex.join('') + '$'),
          map: orderByFilter(map, 'index')
        };
      }
      this.filter = function(date, format) {
        if (!angular.isDate(date) || isNaN(date) || !format) {
          return '';
        }
        format = $locale.DATETIME_FORMATS[format] || format;
        if ($locale.id !== localeId) {
          this.init();
        }
        if (!this.formatters[format]) {
          this.formatters[format] = createParser(format, 'formatter');
        }
        var parser = this.formatters[format],
            map = parser.map;
        var _format = format;
        return map.reduce(function(str, mapper, i) {
          var match = _format.match(new RegExp('(.*)' + mapper.key));
          if (match && angular.isString(match[1])) {
            str += match[1];
            _format = _format.replace(match[1] + mapper.key, '');
          }
          var endStr = i === map.length - 1 ? _format : '';
          if (mapper.apply) {
            return str + mapper.apply.call(null, date) + endStr;
          }
          return str + endStr;
        }, '');
      };
      this.parse = function(input, format, baseDate) {
        if (!angular.isString(input) || !format) {
          return input;
        }
        format = $locale.DATETIME_FORMATS[format] || format;
        format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
        if ($locale.id !== localeId) {
          this.init();
        }
        if (!this.parsers[format]) {
          this.parsers[format] = createParser(format, 'apply');
        }
        var parser = this.parsers[format],
            regex = parser.regex,
            map = parser.map,
            results = input.match(regex),
            tzOffset = false;
        if (results && results.length) {
          var fields,
              dt;
          if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
            fields = {
              year: baseDate.getFullYear(),
              month: baseDate.getMonth(),
              date: baseDate.getDate(),
              hours: baseDate.getHours(),
              minutes: baseDate.getMinutes(),
              seconds: baseDate.getSeconds(),
              milliseconds: baseDate.getMilliseconds()
            };
          } else {
            if (baseDate) {
              $log.warn('dateparser:', 'baseDate is not a valid date');
            }
            fields = {
              year: 1900,
              month: 0,
              date: 1,
              hours: 0,
              minutes: 0,
              seconds: 0,
              milliseconds: 0
            };
          }
          for (var i = 1,
              n = results.length; i < n; i++) {
            var mapper = map[i - 1];
            if (mapper.matcher === 'Z') {
              tzOffset = true;
            }
            if (mapper.apply) {
              mapper.apply.call(fields, results[i]);
            }
          }
          var datesetter = tzOffset ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear;
          var timesetter = tzOffset ? Date.prototype.setUTCHours : Date.prototype.setHours;
          if (isValid(fields.year, fields.month, fields.date)) {
            if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
              dt = new Date(baseDate);
              datesetter.call(dt, fields.year, fields.month, fields.date);
              timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds);
            } else {
              dt = new Date(0);
              datesetter.call(dt, fields.year, fields.month, fields.date);
              timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0);
            }
          }
          return dt;
        }
      };
      function isValid(year, month, date) {
        if (date < 1) {
          return false;
        }
        if (month === 1 && date > 28) {
          return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
        }
        if (month === 3 || month === 5 || month === 8 || month === 10) {
          return date < 31;
        }
        return true;
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      this.toTimezone = toTimezone;
      this.fromTimezone = fromTimezone;
      this.timezoneToOffset = timezoneToOffset;
      this.addDateMinutes = addDateMinutes;
      this.convertTimezoneToLocal = convertTimezoneToLocal;
      function toTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
      }
      function fromTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
      }
      function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
      }
    }]);
    angular.module('ui.bootstrap.isClass', []).directive('uibIsClass', ['$animate', function($animate) {
      var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
      var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
      var dataPerTracked = {};
      return {
        restrict: 'A',
        compile: function(tElement, tAttrs) {
          var linkedScopes = [];
          var instances = [];
          var expToData = {};
          var lastActivated = null;
          var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
          var onExp = onExpMatches[2];
          var expsStr = onExpMatches[1];
          var exps = expsStr.split(',');
          return linkFn;
          function linkFn(scope, element, attrs) {
            linkedScopes.push(scope);
            instances.push({
              scope: scope,
              element: element
            });
            exps.forEach(function(exp, k) {
              addForExp(exp, scope);
            });
            scope.$on('$destroy', removeScope);
          }
          function addForExp(exp, scope) {
            var matches = exp.match(IS_REGEXP);
            var clazz = scope.$eval(matches[1]);
            var compareWithExp = matches[2];
            var data = expToData[exp];
            if (!data) {
              var watchFn = function(compareWithVal) {
                var newActivated = null;
                instances.some(function(instance) {
                  var thisVal = instance.scope.$eval(onExp);
                  if (thisVal === compareWithVal) {
                    newActivated = instance;
                    return true;
                  }
                });
                if (data.lastActivated !== newActivated) {
                  if (data.lastActivated) {
                    $animate.removeClass(data.lastActivated.element, clazz);
                  }
                  if (newActivated) {
                    $animate.addClass(newActivated.element, clazz);
                  }
                  data.lastActivated = newActivated;
                }
              };
              expToData[exp] = data = {
                lastActivated: null,
                scope: scope,
                watchFn: watchFn,
                compareWithExp: compareWithExp,
                watcher: scope.$watch(compareWithExp, watchFn)
              };
            }
            data.watchFn(scope.$eval(compareWithExp));
          }
          function removeScope(e) {
            var removedScope = e.targetScope;
            var index = linkedScopes.indexOf(removedScope);
            linkedScopes.splice(index, 1);
            instances.splice(index, 1);
            if (linkedScopes.length) {
              var newWatchScope = linkedScopes[0];
              angular.forEach(expToData, function(data) {
                if (data.scope === removedScope) {
                  data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                  data.scope = newWatchScope;
                }
              });
            } else {
              expToData = {};
            }
          }
        }
      };
    }]);
    angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass']).value('$datepickerSuppressError', false).value('$datepickerLiteralWarning', true).constant('uibDatepickerConfig', {
      datepickerMode: 'day',
      formatDay: 'dd',
      formatMonth: 'MMMM',
      formatYear: 'yyyy',
      formatDayHeader: 'EEE',
      formatDayTitle: 'MMMM yyyy',
      formatMonthTitle: 'yyyy',
      maxDate: null,
      maxMode: 'year',
      minDate: null,
      minMode: 'day',
      ngModelOptions: {},
      shortcutPropagation: false,
      showWeeks: true,
      yearColumns: 5,
      yearRows: 4
    }).controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser', function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
      var self = this,
          ngModelCtrl = {$setViewValue: angular.noop},
          ngModelOptions = {},
          watchListeners = [],
          optionsUsed = !!$attrs.datepickerOptions;
      if (!$scope.datepickerOptions) {
        $scope.datepickerOptions = {};
      }
      this.modes = ['day', 'month', 'year'];
      ['customClass', 'dateDisabled', 'datepickerMode', 'formatDay', 'formatDayHeader', 'formatDayTitle', 'formatMonth', 'formatMonthTitle', 'formatYear', 'maxDate', 'maxMode', 'minDate', 'minMode', 'showWeeks', 'shortcutPropagation', 'startingDay', 'yearColumns', 'yearRows'].forEach(function(key) {
        switch (key) {
          case 'customClass':
          case 'dateDisabled':
            $scope[key] = $scope.datepickerOptions[key] || angular.noop;
            break;
          case 'datepickerMode':
            $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ? $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
            break;
          case 'formatDay':
          case 'formatDayHeader':
          case 'formatDayTitle':
          case 'formatMonth':
          case 'formatMonthTitle':
          case 'formatYear':
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
            break;
          case 'showWeeks':
          case 'shortcutPropagation':
          case 'yearColumns':
          case 'yearRows':
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $scope.datepickerOptions[key] : datepickerConfig[key];
            break;
          case 'startingDay':
            if (angular.isDefined($scope.datepickerOptions.startingDay)) {
              self.startingDay = $scope.datepickerOptions.startingDay;
            } else if (angular.isNumber(datepickerConfig.startingDay)) {
              self.startingDay = datepickerConfig.startingDay;
            } else {
              self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
            }
            break;
          case 'maxDate':
          case 'minDate':
            $scope.$watch('datepickerOptions.' + key, function(value) {
              if (value) {
                if (angular.isDate(value)) {
                  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                } else {
                  if ($datepickerLiteralWarning) {
                    $log.warn('Literal date support has been deprecated, please switch to date object usage');
                  }
                  self[key] = new Date(dateFilter(value, 'medium'));
                }
              } else {
                self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
              }
              self.refreshView();
            });
            break;
          case 'maxMode':
          case 'minMode':
            if ($scope.datepickerOptions[key]) {
              $scope.$watch(function() {
                return $scope.datepickerOptions[key];
              }, function(value) {
                self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];
                if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) || key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
                  $scope.datepickerMode = self[key];
                  $scope.datepickerOptions.datepickerMode = self[key];
                }
              });
            } else {
              self[key] = $scope[key] = datepickerConfig[key] || null;
            }
            break;
        }
      });
      $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if (angular.isDefined($attrs.ngDisabled)) {
        watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
          $scope.disabled = disabled;
          self.refreshView();
        }));
      }
      $scope.isActive = function(dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
          $scope.activeDateId = dateObject.uid;
          return true;
        }
        return false;
      };
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;
        if ($scope.datepickerOptions.initDate) {
          self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
          $scope.$watch('datepickerOptions.initDate', function(initDate) {
            if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
              self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
              self.refreshView();
            }
          });
        } else {
          self.activeDate = new Date();
        }
        this.activeDate = ngModelCtrl.$modelValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$modelValue), ngModelOptions.timezone) : dateParser.fromTimezone(new Date(), ngModelOptions.timezone);
        ngModelCtrl.$render = function() {
          self.render();
        };
      };
      this.render = function() {
        if (ngModelCtrl.$viewValue) {
          var date = new Date(ngModelCtrl.$viewValue),
              isValid = !isNaN(date);
          if (isValid) {
            this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
          } else if (!$datepickerSuppressError) {
            $log.error('Datepicker directive: "ng-model" value must be a Date object');
          }
        }
        this.refreshView();
      };
      this.refreshView = function() {
        if (this.element) {
          $scope.selectedDt = null;
          this._refreshView();
          if ($scope.activeDt) {
            $scope.activeDateId = $scope.activeDt.uid;
          }
          var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
          date = dateParser.fromTimezone(date, ngModelOptions.timezone);
          ngModelCtrl.$setValidity('dateDisabled', !date || this.element && !this.isDisabled(date));
        }
      };
      this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        model = dateParser.fromTimezone(model, ngModelOptions.timezone);
        var today = new Date();
        today = dateParser.fromTimezone(today, ngModelOptions.timezone);
        var time = this.compare(date, today);
        var dt = {
          date: date,
          label: dateParser.filter(date, format),
          selected: model && this.compare(date, model) === 0,
          disabled: this.isDisabled(date),
          past: time < 0,
          current: time === 0,
          future: time > 0,
          customClass: this.customClass(date) || null
        };
        if (model && this.compare(date, model) === 0) {
          $scope.selectedDt = dt;
        }
        if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
          $scope.activeDt = dt;
        }
        return dt;
      };
      this.isDisabled = function(date) {
        return $scope.disabled || this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({
          date: date,
          mode: $scope.datepickerMode
        });
      };
      this.customClass = function(date) {
        return $scope.customClass({
          date: date,
          mode: $scope.datepickerMode
        });
      };
      this.split = function(arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      };
      $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
          var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
          dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
          ngModelCtrl.$setViewValue(dt);
          ngModelCtrl.$render();
        } else {
          self.activeDate = date;
          setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);
          $scope.$emit('uib:datepicker.mode');
        }
        $scope.$broadcast('uib:datepicker.focus');
      };
      $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
            month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1);
        self.refreshView();
      };
      $scope.toggleMode = function(direction) {
        direction = direction || 1;
        if ($scope.datepickerMode === self.maxMode && direction === 1 || $scope.datepickerMode === self.minMode && direction === -1) {
          return;
        }
        setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);
        $scope.$emit('uib:datepicker.mode');
      };
      $scope.keys = {
        13: 'enter',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
      };
      var focusElement = function() {
        self.element[0].focus();
      };
      $scope.$on('uib:datepicker.focus', focusElement);
      $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
          return;
        }
        evt.preventDefault();
        if (!self.shortcutPropagation) {
          evt.stopPropagation();
        }
        if (key === 'enter' || key === 'space') {
          if (self.isDisabled(self.activeDate)) {
            return;
          }
          $scope.select(self.activeDate);
        } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
          $scope.toggleMode(key === 'up' ? 1 : -1);
        } else {
          self.handleKeyDown(key, evt);
          self.refreshView();
        }
      };
      $scope.$on('$destroy', function() {
        while (watchListeners.length) {
          watchListeners.shift()();
        }
      });
      function setMode(mode) {
        $scope.datepickerMode = mode;
        $scope.datepickerOptions.datepickerMode = mode;
      }
    }]).controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      this.step = {months: 1};
      this.element = $element;
      function getDaysInMonth(year, month) {
        return month === 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
      }
      this.init = function(ctrl) {
        angular.extend(ctrl, this);
        scope.showWeeks = ctrl.showWeeks;
        ctrl.refreshView();
      };
      this.getDates = function(startDate, n) {
        var dates = new Array(n),
            current = new Date(startDate),
            i = 0,
            date;
        while (i < n) {
          date = new Date(current);
          dates[i++] = date;
          current.setDate(current.getDate() + 1);
        }
        return dates;
      };
      this._refreshView = function() {
        var year = this.activeDate.getFullYear(),
            month = this.activeDate.getMonth(),
            firstDayOfMonth = new Date(this.activeDate);
        firstDayOfMonth.setFullYear(year, month, 1);
        var difference = this.startingDay - firstDayOfMonth.getDay(),
            numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference,
            firstDate = new Date(firstDayOfMonth);
        if (numDisplayedFromPreviousMonth > 0) {
          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        }
        var days = this.getDates(firstDate, 42);
        for (var i = 0; i < 42; i++) {
          days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + '-' + i
          });
        }
        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, this.formatDayHeader),
            full: dateFilter(days[j].date, 'EEEE')
          };
        }
        scope.title = dateFilter(this.activeDate, this.formatDayTitle);
        scope.rows = this.split(days, 7);
        if (scope.showWeeks) {
          scope.weekNumbers = [];
          var thursdayIndex = (4 + 7 - this.startingDay) % 7,
              numWeeks = scope.rows.length;
          for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
            scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
          }
        }
      };
      this.compare = function(date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
        var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        _date1.setFullYear(date1.getFullYear());
        _date2.setFullYear(date2.getFullYear());
        return _date1 - _date2;
      };
      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        var time = checkDate.getTime();
        checkDate.setMonth(0);
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }
      this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getDate();
        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - 7;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + 7;
        } else if (key === 'pageup' || key === 'pagedown') {
          var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
          this.activeDate.setMonth(month, 1);
          date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
        } else if (key === 'home') {
          date = 1;
        } else if (key === 'end') {
          date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
        }
        this.activeDate.setDate(date);
      };
    }]).controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
      this.step = {years: 1};
      this.element = $element;
      this.init = function(ctrl) {
        angular.extend(ctrl, this);
        ctrl.refreshView();
      };
      this._refreshView = function() {
        var months = new Array(12),
            year = this.activeDate.getFullYear(),
            date;
        for (var i = 0; i < 12; i++) {
          date = new Date(this.activeDate);
          date.setFullYear(year, i, 1);
          months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {uid: scope.uniqueId + '-' + i});
        }
        scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
        scope.rows = this.split(months, 3);
      };
      this.compare = function(date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth());
        var _date2 = new Date(date2.getFullYear(), date2.getMonth());
        _date1.setFullYear(date1.getFullYear());
        _date2.setFullYear(date2.getFullYear());
        return _date1 - _date2;
      };
      this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getMonth();
        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - 3;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + 3;
        } else if (key === 'pageup' || key === 'pagedown') {
          var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
          this.activeDate.setFullYear(year);
        } else if (key === 'home') {
          date = 0;
        } else if (key === 'end') {
          date = 11;
        }
        this.activeDate.setMonth(date);
      };
    }]).controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
      var columns,
          range;
      this.element = $element;
      function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }
      this.yearpickerInit = function() {
        columns = this.yearColumns;
        range = this.yearRows * columns;
        this.step = {years: range};
      };
      this._refreshView = function() {
        var years = new Array(range),
            date;
        for (var i = 0,
            start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
          date = new Date(this.activeDate);
          date.setFullYear(start + i, 0, 1);
          years[i] = angular.extend(this.createDateObject(date, this.formatYear), {uid: scope.uniqueId + '-' + i});
        }
        scope.title = [years[0].label, years[range - 1].label].join(' - ');
        scope.rows = this.split(years, columns);
        scope.columns = columns;
      };
      this.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };
      this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getFullYear();
        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - columns;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + columns;
        } else if (key === 'pageup' || key === 'pagedown') {
          date += (key === 'pageup' ? -1 : 1) * range;
        } else if (key === 'home') {
          date = getStartingYear(this.activeDate.getFullYear());
        } else if (key === 'end') {
          date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
        }
        this.activeDate.setFullYear(date);
      };
    }]).directive('uibDatepicker', function() {
      return {
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
        },
        scope: {datepickerOptions: '=?'},
        require: ['uibDatepicker', '^ngModel'],
        controller: 'UibDatepickerController',
        controllerAs: 'datepicker',
        link: function(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          datepickerCtrl.init(ngModelCtrl);
        }
      };
    }).directive('uibDaypicker', function() {
      return {
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/day.html';
        },
        require: ['^uibDatepicker', 'uibDaypicker'],
        controller: 'UibDaypickerController',
        link: function(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              daypickerCtrl = ctrls[1];
          daypickerCtrl.init(datepickerCtrl);
        }
      };
    }).directive('uibMonthpicker', function() {
      return {
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/month.html';
        },
        require: ['^uibDatepicker', 'uibMonthpicker'],
        controller: 'UibMonthpickerController',
        link: function(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              monthpickerCtrl = ctrls[1];
          monthpickerCtrl.init(datepickerCtrl);
        }
      };
    }).directive('uibYearpicker', function() {
      return {
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepicker/year.html';
        },
        require: ['^uibDatepicker', 'uibYearpicker'],
        controller: 'UibYearpickerController',
        link: function(scope, element, attrs, ctrls) {
          var ctrl = ctrls[0];
          angular.extend(ctrl, ctrls[1]);
          ctrl.yearpickerInit();
          ctrl.refreshView();
        }
      };
    });
    angular.module('ui.bootstrap.position', []).factory('$uibPosition', ['$document', '$window', function($document, $window) {
      var SCROLLBAR_WIDTH;
      var BODY_SCROLLBAR_WIDTH;
      var OVERFLOW_REGEX = {
        normal: /(auto|scroll)/,
        hidden: /(auto|scroll|hidden)/
      };
      var PLACEMENT_REGEX = {
        auto: /\s?auto?\s?/i,
        primary: /^(top|bottom|left|right)$/,
        secondary: /^(top|bottom|left|right|center)$/,
        vertical: /^(top|bottom)$/
      };
      var BODY_REGEX = /(HTML|BODY)/;
      return {
        getRawNode: function(elem) {
          return elem.nodeName ? elem : elem[0] || elem;
        },
        parseStyle: function(value) {
          value = parseFloat(value);
          return isFinite(value) ? value : 0;
        },
        offsetParent: function(elem) {
          elem = this.getRawNode(elem);
          var offsetParent = elem.offsetParent || $document[0].documentElement;
          function isStaticPositioned(el) {
            return ($window.getComputedStyle(el).position || 'static') === 'static';
          }
          while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || $document[0].documentElement;
        },
        scrollbarWidth: function(isBody) {
          if (isBody) {
            if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
              var bodyElem = $document.find('body');
              bodyElem.addClass('uib-position-body-scrollbar-measure');
              BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
              BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
              bodyElem.removeClass('uib-position-body-scrollbar-measure');
            }
            return BODY_SCROLLBAR_WIDTH;
          }
          if (angular.isUndefined(SCROLLBAR_WIDTH)) {
            var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
            $document.find('body').append(scrollElem);
            SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
            SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
            scrollElem.remove();
          }
          return SCROLLBAR_WIDTH;
        },
        scrollbarPadding: function(elem) {
          elem = this.getRawNode(elem);
          var elemStyle = $window.getComputedStyle(elem);
          var paddingRight = this.parseStyle(elemStyle.paddingRight);
          var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
          var scrollParent = this.scrollParent(elem, false, true);
          var scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));
          return {
            scrollbarWidth: scrollbarWidth,
            widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
            right: paddingRight + scrollbarWidth,
            originalRight: paddingRight,
            heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
            bottom: paddingBottom + scrollbarWidth,
            originalBottom: paddingBottom
          };
        },
        isScrollable: function(elem, includeHidden) {
          elem = this.getRawNode(elem);
          var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
          var elemStyle = $window.getComputedStyle(elem);
          return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
        },
        scrollParent: function(elem, includeHidden, includeSelf) {
          elem = this.getRawNode(elem);
          var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
          var documentEl = $document[0].documentElement;
          var elemStyle = $window.getComputedStyle(elem);
          if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
            return elem;
          }
          var excludeStatic = elemStyle.position === 'absolute';
          var scrollParent = elem.parentElement || documentEl;
          if (scrollParent === documentEl || elemStyle.position === 'fixed') {
            return documentEl;
          }
          while (scrollParent.parentElement && scrollParent !== documentEl) {
            var spStyle = $window.getComputedStyle(scrollParent);
            if (excludeStatic && spStyle.position !== 'static') {
              excludeStatic = false;
            }
            if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
              break;
            }
            scrollParent = scrollParent.parentElement;
          }
          return scrollParent;
        },
        position: function(elem, includeMagins) {
          elem = this.getRawNode(elem);
          var elemOffset = this.offset(elem);
          if (includeMagins) {
            var elemStyle = $window.getComputedStyle(elem);
            elemOffset.top -= this.parseStyle(elemStyle.marginTop);
            elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
          }
          var parent = this.offsetParent(elem);
          var parentOffset = {
            top: 0,
            left: 0
          };
          if (parent !== $document[0].documentElement) {
            parentOffset = this.offset(parent);
            parentOffset.top += parent.clientTop - parent.scrollTop;
            parentOffset.left += parent.clientLeft - parent.scrollLeft;
          }
          return {
            width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
            height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
            top: Math.round(elemOffset.top - parentOffset.top),
            left: Math.round(elemOffset.left - parentOffset.left)
          };
        },
        offset: function(elem) {
          elem = this.getRawNode(elem);
          var elemBCR = elem.getBoundingClientRect();
          return {
            width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
            height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
            top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
            left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
          };
        },
        viewportOffset: function(elem, useDocument, includePadding) {
          elem = this.getRawNode(elem);
          includePadding = includePadding !== false ? true : false;
          var elemBCR = elem.getBoundingClientRect();
          var offsetBCR = {
            top: 0,
            left: 0,
            bottom: 0,
            right: 0
          };
          var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
          var offsetParentBCR = offsetParent.getBoundingClientRect();
          offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
          offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
          if (offsetParent === $document[0].documentElement) {
            offsetBCR.top += $window.pageYOffset;
            offsetBCR.left += $window.pageXOffset;
          }
          offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
          offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;
          if (includePadding) {
            var offsetParentStyle = $window.getComputedStyle(offsetParent);
            offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
            offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
            offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
            offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
          }
          return {
            top: Math.round(elemBCR.top - offsetBCR.top),
            bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
            left: Math.round(elemBCR.left - offsetBCR.left),
            right: Math.round(offsetBCR.right - elemBCR.right)
          };
        },
        parsePlacement: function(placement) {
          var autoPlace = PLACEMENT_REGEX.auto.test(placement);
          if (autoPlace) {
            placement = placement.replace(PLACEMENT_REGEX.auto, '');
          }
          placement = placement.split('-');
          placement[0] = placement[0] || 'top';
          if (!PLACEMENT_REGEX.primary.test(placement[0])) {
            placement[0] = 'top';
          }
          placement[1] = placement[1] || 'center';
          if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
            placement[1] = 'center';
          }
          if (autoPlace) {
            placement[2] = true;
          } else {
            placement[2] = false;
          }
          return placement;
        },
        positionElements: function(hostElem, targetElem, placement, appendToBody) {
          hostElem = this.getRawNode(hostElem);
          targetElem = this.getRawNode(targetElem);
          var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
          var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');
          placement = this.parsePlacement(placement);
          var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
          var targetElemPos = {
            top: 0,
            left: 0,
            placement: ''
          };
          if (placement[2]) {
            var viewportOffset = this.viewportOffset(hostElem, appendToBody);
            var targetElemStyle = $window.getComputedStyle(targetElem);
            var adjustedSize = {
              width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
              height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
            };
            placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' : placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' : placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' : placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' : placement[0];
            placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' : placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' : placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' : placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' : placement[1];
            if (placement[1] === 'center') {
              if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                  placement[1] = 'left';
                } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                  placement[1] = 'right';
                }
              } else {
                var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                  placement[1] = 'top';
                } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                  placement[1] = 'bottom';
                }
              }
            }
          }
          switch (placement[0]) {
            case 'top':
              targetElemPos.top = hostElemPos.top - targetHeight;
              break;
            case 'bottom':
              targetElemPos.top = hostElemPos.top + hostElemPos.height;
              break;
            case 'left':
              targetElemPos.left = hostElemPos.left - targetWidth;
              break;
            case 'right':
              targetElemPos.left = hostElemPos.left + hostElemPos.width;
              break;
          }
          switch (placement[1]) {
            case 'top':
              targetElemPos.top = hostElemPos.top;
              break;
            case 'bottom':
              targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
              break;
            case 'left':
              targetElemPos.left = hostElemPos.left;
              break;
            case 'right':
              targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
              break;
            case 'center':
              if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
              } else {
                targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
              }
              break;
          }
          targetElemPos.top = Math.round(targetElemPos.top);
          targetElemPos.left = Math.round(targetElemPos.left);
          targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];
          return targetElemPos;
        },
        positionArrow: function(elem, placement) {
          elem = this.getRawNode(elem);
          var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
          if (!innerElem) {
            return;
          }
          var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');
          var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
          if (!arrowElem) {
            return;
          }
          var arrowCss = {
            top: '',
            bottom: '',
            left: '',
            right: ''
          };
          placement = this.parsePlacement(placement);
          if (placement[1] === 'center') {
            angular.element(arrowElem).css(arrowCss);
            return;
          }
          var borderProp = 'border-' + placement[0] + '-width';
          var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];
          var borderRadiusProp = 'border-';
          if (PLACEMENT_REGEX.vertical.test(placement[0])) {
            borderRadiusProp += placement[0] + '-' + placement[1];
          } else {
            borderRadiusProp += placement[1] + '-' + placement[0];
          }
          borderRadiusProp += '-radius';
          var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
          switch (placement[0]) {
            case 'top':
              arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
              break;
            case 'bottom':
              arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
              break;
            case 'left':
              arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
              break;
            case 'right':
              arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
              break;
          }
          arrowCss[placement[1]] = borderRadius;
          angular.element(arrowElem).css(arrowCss);
        }
      };
    }]);
    angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position']).value('$datepickerPopupLiteralWarning', true).constant('uibDatepickerPopupConfig', {
      altInputFormats: [],
      appendToBody: false,
      clearText: 'Clear',
      closeOnDateSelection: true,
      closeText: 'Done',
      currentText: 'Today',
      datepickerPopup: 'yyyy-MM-dd',
      datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
      datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
      html5Types: {
        date: 'yyyy-MM-dd',
        'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
        'month': 'yyyy-MM'
      },
      onOpenFocus: true,
      showButtonBar: true,
      placement: 'auto bottom-left'
    }).controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning', function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
      var cache = {},
          isHtml5DateInput = false;
      var dateFormat,
          closeOnDateSelection,
          appendToBody,
          onOpenFocus,
          datepickerPopupTemplateUrl,
          datepickerTemplateUrl,
          popupEl,
          datepickerEl,
          scrollParentEl,
          ngModel,
          ngModelOptions,
          $popup,
          altInputFormats,
          watchListeners = [],
          timezone;
      this.init = function(_ngModel_) {
        ngModel = _ngModel_;
        ngModelOptions = _ngModel_.$options;
        closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ? $scope.$parent.$eval($attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
        appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ? $scope.$parent.$eval($attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
        onOpenFocus = angular.isDefined($attrs.onOpenFocus) ? $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
        datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ? $attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
        datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ? $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
        altInputFormats = angular.isDefined($attrs.altInputFormats) ? $scope.$parent.$eval($attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;
        $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ? $scope.$parent.$eval($attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
        if (datepickerPopupConfig.html5Types[$attrs.type]) {
          dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
          isHtml5DateInput = true;
        } else {
          dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
          $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;
              if (!dateFormat) {
                throw new Error('uibDatepickerPopup must have a date format specified.');
              }
            }
          });
        }
        if (!dateFormat) {
          throw new Error('uibDatepickerPopup must have a date format specified.');
        }
        if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
          throw new Error('HTML5 date input types do not support custom formats.');
        }
        popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
        if (ngModelOptions) {
          timezone = ngModelOptions.timezone;
          $scope.ngModelOptions = angular.copy(ngModelOptions);
          $scope.ngModelOptions.timezone = null;
          if ($scope.ngModelOptions.updateOnDefault === true) {
            $scope.ngModelOptions.updateOn = $scope.ngModelOptions.updateOn ? $scope.ngModelOptions.updateOn + ' default' : 'default';
          }
          popupEl.attr('ng-model-options', 'ngModelOptions');
        } else {
          timezone = null;
        }
        popupEl.attr({
          'ng-model': 'date',
          'ng-change': 'dateSelection(date)',
          'template-url': datepickerPopupTemplateUrl
        });
        datepickerEl = angular.element(popupEl.children()[0]);
        datepickerEl.attr('template-url', datepickerTemplateUrl);
        if (!$scope.datepickerOptions) {
          $scope.datepickerOptions = {};
        }
        if (isHtml5DateInput) {
          if ($attrs.type === 'month') {
            $scope.datepickerOptions.datepickerMode = 'month';
            $scope.datepickerOptions.minMode = 'month';
          }
        }
        datepickerEl.attr('datepicker-options', 'datepickerOptions');
        if (!isHtml5DateInput) {
          ngModel.$$parserName = 'date';
          ngModel.$validators.date = validator;
          ngModel.$parsers.unshift(parseDate);
          ngModel.$formatters.push(function(value) {
            if (ngModel.$isEmpty(value)) {
              $scope.date = value;
              return value;
            }
            $scope.date = dateParser.fromTimezone(value, timezone);
            if (angular.isNumber($scope.date)) {
              $scope.date = new Date($scope.date);
            }
            return dateParser.filter($scope.date, dateFormat);
          });
        } else {
          ngModel.$formatters.push(function(value) {
            $scope.date = dateParser.fromTimezone(value, timezone);
            return value;
          });
        }
        ngModel.$viewChangeListeners.push(function() {
          $scope.date = parseDateString(ngModel.$viewValue);
        });
        $element.on('keydown', inputKeydownBind);
        $popup = $compile(popupEl)($scope);
        popupEl.remove();
        if (appendToBody) {
          $document.find('body').append($popup);
        } else {
          $element.after($popup);
        }
        $scope.$on('$destroy', function() {
          if ($scope.isOpen === true) {
            if (!$rootScope.$$phase) {
              $scope.$apply(function() {
                $scope.isOpen = false;
              });
            }
          }
          $popup.remove();
          $element.off('keydown', inputKeydownBind);
          $document.off('click', documentClickBind);
          if (scrollParentEl) {
            scrollParentEl.off('scroll', positionPopup);
          }
          angular.element($window).off('resize', positionPopup);
          while (watchListeners.length) {
            watchListeners.shift()();
          }
        });
      };
      $scope.getText = function(key) {
        return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
      };
      $scope.isDisabled = function(date) {
        if (date === 'today') {
          date = dateParser.fromTimezone(new Date(), timezone);
        }
        var dates = {};
        angular.forEach(['minDate', 'maxDate'], function(key) {
          if (!$scope.datepickerOptions[key]) {
            dates[key] = null;
          } else if (angular.isDate($scope.datepickerOptions[key])) {
            dates[key] = dateParser.fromTimezone(new Date($scope.datepickerOptions[key]), timezone);
          } else {
            if ($datepickerPopupLiteralWarning) {
              $log.warn('Literal date support has been deprecated, please switch to date object usage');
            }
            dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
          }
        });
        return $scope.datepickerOptions && dates.minDate && $scope.compare(date, dates.minDate) < 0 || dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
      };
      $scope.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
      };
      $scope.dateSelection = function(dt) {
        if (angular.isDefined(dt)) {
          $scope.date = dt;
        }
        var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null;
        $element.val(date);
        ngModel.$setViewValue(date);
        if (closeOnDateSelection) {
          $scope.isOpen = false;
          $element[0].focus();
        }
      };
      $scope.keydown = function(evt) {
        if (evt.which === 27) {
          evt.stopPropagation();
          $scope.isOpen = false;
          $element[0].focus();
        }
      };
      $scope.select = function(date, evt) {
        evt.stopPropagation();
        if (date === 'today') {
          var today = new Date();
          if (angular.isDate($scope.date)) {
            date = new Date($scope.date);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        $scope.dateSelection(date);
      };
      $scope.close = function(evt) {
        evt.stopPropagation();
        $scope.isOpen = false;
        $element[0].focus();
      };
      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if ($attrs.ngDisabled) {
        watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
          $scope.disabled = disabled;
        }));
      }
      $scope.$watch('isOpen', function(value) {
        if (value) {
          if (!$scope.disabled) {
            $timeout(function() {
              positionPopup();
              if (onOpenFocus) {
                $scope.$broadcast('uib:datepicker.focus');
              }
              $document.on('click', documentClickBind);
              var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
              if (appendToBody || $position.parsePlacement(placement)[2]) {
                scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
                if (scrollParentEl) {
                  scrollParentEl.on('scroll', positionPopup);
                }
              } else {
                scrollParentEl = null;
              }
              angular.element($window).on('resize', positionPopup);
            }, 0, false);
          } else {
            $scope.isOpen = false;
          }
        } else {
          $document.off('click', documentClickBind);
          if (scrollParentEl) {
            scrollParentEl.off('scroll', positionPopup);
          }
          angular.element($window).off('resize', positionPopup);
        }
      });
      function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function($1) {
          return '-' + $1.toLowerCase();
        });
      }
      function parseDateString(viewValue) {
        var date = dateParser.parse(viewValue, dateFormat, $scope.date);
        if (isNaN(date)) {
          for (var i = 0; i < altInputFormats.length; i++) {
            date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
            if (!isNaN(date)) {
              return date;
            }
          }
        }
        return date;
      }
      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          viewValue = new Date(viewValue);
        }
        if (!viewValue) {
          return null;
        }
        if (angular.isDate(viewValue) && !isNaN(viewValue)) {
          return viewValue;
        }
        if (angular.isString(viewValue)) {
          var date = parseDateString(viewValue);
          if (!isNaN(date)) {
            return dateParser.toTimezone(date, timezone);
          }
        }
        return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;
      }
      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        if (!$attrs.ngRequired && !value) {
          return true;
        }
        if (angular.isNumber(value)) {
          value = new Date(value);
        }
        if (!value) {
          return true;
        }
        if (angular.isDate(value) && !isNaN(value)) {
          return true;
        }
        if (angular.isString(value)) {
          return !isNaN(parseDateString(viewValue));
        }
        return false;
      }
      function documentClickBind(event) {
        if (!$scope.isOpen && $scope.disabled) {
          return;
        }
        var popup = $popup[0];
        var dpContainsTarget = $element[0].contains(event.target);
        var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
        if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
          $scope.$apply(function() {
            $scope.isOpen = false;
          });
        }
      }
      function inputKeydownBind(evt) {
        if (evt.which === 27 && $scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.$apply(function() {
            $scope.isOpen = false;
          });
          $element[0].focus();
        } else if (evt.which === 40 && !$scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.$apply(function() {
            $scope.isOpen = true;
          });
        }
      }
      function positionPopup() {
        if ($scope.isOpen) {
          var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
          var position = $position.positionElements($element, dpElement, placement, appendToBody);
          dpElement.css({
            top: position.top + 'px',
            left: position.left + 'px'
          });
          if (dpElement.hasClass('uib-position-measure')) {
            dpElement.removeClass('uib-position-measure');
          }
        }
      }
      $scope.$on('uib:datepicker.mode', function() {
        $timeout(positionPopup, 0, false);
      });
    }]).directive('uibDatepickerPopup', function() {
      return {
        require: ['ngModel', 'uibDatepickerPopup'],
        controller: 'UibDatepickerPopupController',
        scope: {
          datepickerOptions: '=?',
          isOpen: '=?',
          currentText: '@',
          clearText: '@',
          closeText: '@'
        },
        link: function(scope, element, attrs, ctrls) {
          var ngModel = ctrls[0],
              ctrl = ctrls[1];
          ctrl.init(ngModel);
        }
      };
    }).directive('uibDatepickerPopupWrap', function() {
      return {
        replace: true,
        transclude: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
        }
      };
    });
    angular.module('ui.bootstrap.debounce', []).factory('$$debounce', ['$timeout', function($timeout) {
      return function(callback, debounceTime) {
        var timeoutPromise;
        return function() {
          var self = this;
          var args = Array.prototype.slice.call(arguments);
          if (timeoutPromise) {
            $timeout.cancel(timeoutPromise);
          }
          timeoutPromise = $timeout(function() {
            callback.apply(self, args);
          }, debounceTime);
        };
      };
    }]);
    angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position']).constant('uibDropdownConfig', {
      appendToOpenClass: 'uib-dropdown-open',
      openClass: 'open'
    }).service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
      var openScope = null;
      this.open = function(dropdownScope, element) {
        if (!openScope) {
          $document.on('click', closeDropdown);
          element.on('keydown', keybindFilter);
        }
        if (openScope && openScope !== dropdownScope) {
          openScope.isOpen = false;
        }
        openScope = dropdownScope;
      };
      this.close = function(dropdownScope, element) {
        if (openScope === dropdownScope) {
          openScope = null;
          $document.off('click', closeDropdown);
          element.off('keydown', keybindFilter);
        }
      };
      var closeDropdown = function(evt) {
        if (!openScope) {
          return;
        }
        if (evt && openScope.getAutoClose() === 'disabled') {
          return;
        }
        if (evt && evt.which === 3) {
          return;
        }
        var toggleElement = openScope.getToggleElement();
        if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
          return;
        }
        var dropdownElement = openScope.getDropdownElement();
        if (evt && openScope.getAutoClose() === 'outsideClick' && dropdownElement && dropdownElement[0].contains(evt.target)) {
          return;
        }
        openScope.isOpen = false;
        if (!$rootScope.$$phase) {
          openScope.$apply();
        }
      };
      var keybindFilter = function(evt) {
        if (evt.which === 27) {
          evt.stopPropagation();
          openScope.focusToggleElement();
          closeDropdown();
        } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          openScope.focusDropdownEntry(evt.which);
        }
      };
    }]).controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
      var self = this,
          scope = $scope.$new(),
          templateScope,
          appendToOpenClass = dropdownConfig.appendToOpenClass,
          openClass = dropdownConfig.openClass,
          getIsOpen,
          setIsOpen = angular.noop,
          toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
          appendToBody = false,
          appendTo = null,
          keynavEnabled = false,
          selectedOption = null,
          body = $document.find('body');
      $element.addClass('dropdown');
      this.init = function() {
        if ($attrs.isOpen) {
          getIsOpen = $parse($attrs.isOpen);
          setIsOpen = getIsOpen.assign;
          $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
          });
        }
        if (angular.isDefined($attrs.dropdownAppendTo)) {
          var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
          if (appendToEl) {
            appendTo = angular.element(appendToEl);
          }
        }
        appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
        keynavEnabled = angular.isDefined($attrs.keyboardNav);
        if (appendToBody && !appendTo) {
          appendTo = body;
        }
        if (appendTo && self.dropdownMenu) {
          appendTo.append(self.dropdownMenu);
          $element.on('$destroy', function handleDestroyEvent() {
            self.dropdownMenu.remove();
          });
        }
      };
      this.toggle = function(open) {
        scope.isOpen = arguments.length ? !!open : !scope.isOpen;
        if (angular.isFunction(setIsOpen)) {
          setIsOpen(scope, scope.isOpen);
        }
        return scope.isOpen;
      };
      this.isOpen = function() {
        return scope.isOpen;
      };
      scope.getToggleElement = function() {
        return self.toggleElement;
      };
      scope.getAutoClose = function() {
        return $attrs.autoClose || 'always';
      };
      scope.getElement = function() {
        return $element;
      };
      scope.isKeynavEnabled = function() {
        return keynavEnabled;
      };
      scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find('a') : $element.find('ul').eq(0).find('a');
        switch (keyCode) {
          case 40:
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = 0;
              } else {
                self.selectedOption = self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1;
              }
              break;
            }
          case 38:
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = elems.length - 1;
              } else {
                self.selectedOption = self.selectedOption === 0 ? 0 : self.selectedOption - 1;
              }
              break;
            }
        }
        elems[self.selectedOption].focus();
      };
      scope.getDropdownElement = function() {
        return self.dropdownMenu;
      };
      scope.focusToggleElement = function() {
        if (self.toggleElement) {
          self.toggleElement[0].focus();
        }
      };
      scope.$watch('isOpen', function(isOpen, wasOpen) {
        if (appendTo && self.dropdownMenu) {
          var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
              css,
              rightalign;
          css = {
            top: pos.top + 'px',
            display: isOpen ? 'block' : 'none'
          };
          rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
          if (!rightalign) {
            css.left = pos.left + 'px';
            css.right = 'auto';
          } else {
            css.left = 'auto';
            css.right = window.innerWidth - (pos.left + $element.prop('offsetWidth')) + 'px';
          }
          if (!appendToBody) {
            var appendOffset = $position.offset(appendTo);
            css.top = pos.top - appendOffset.top + 'px';
            if (!rightalign) {
              css.left = pos.left - appendOffset.left + 'px';
            } else {
              css.right = window.innerWidth - (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
            }
          }
          self.dropdownMenu.css(css);
        }
        var openContainer = appendTo ? appendTo : $element;
        var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);
        if (hasOpenClass === !isOpen) {
          $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
            if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
              toggleInvoker($scope, {open: !!isOpen});
            }
          });
        }
        if (isOpen) {
          if (self.dropdownMenuTemplateUrl) {
            $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
              templateScope = scope.$new();
              $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl);
                self.dropdownMenu = newEl;
              });
            });
          }
          scope.focusToggleElement();
          uibDropdownService.open(scope, $element);
        } else {
          if (self.dropdownMenuTemplateUrl) {
            if (templateScope) {
              templateScope.$destroy();
            }
            var newEl = angular.element('<ul class="dropdown-menu"></ul>');
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          }
          uibDropdownService.close(scope, $element);
          self.selectedOption = null;
        }
        if (angular.isFunction(setIsOpen)) {
          setIsOpen($scope, isOpen);
        }
      });
    }]).directive('uibDropdown', function() {
      return {
        controller: 'UibDropdownController',
        link: function(scope, element, attrs, dropdownCtrl) {
          dropdownCtrl.init();
        }
      };
    }).directive('uibDropdownMenu', function() {
      return {
        restrict: 'A',
        require: '?^uibDropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
            return;
          }
          element.addClass('dropdown-menu');
          var tplUrl = attrs.templateUrl;
          if (tplUrl) {
            dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
          }
          if (!dropdownCtrl.dropdownMenu) {
            dropdownCtrl.dropdownMenu = element;
          }
        }
      };
    }).directive('uibDropdownToggle', function() {
      return {
        require: '?^uibDropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl) {
            return;
          }
          element.addClass('dropdown-toggle');
          dropdownCtrl.toggleElement = element;
          var toggleDropdown = function(event) {
            event.preventDefault();
            if (!element.hasClass('disabled') && !attrs.disabled) {
              scope.$apply(function() {
                dropdownCtrl.toggle();
              });
            }
          };
          element.bind('click', toggleDropdown);
          element.attr({
            'aria-haspopup': true,
            'aria-expanded': false
          });
          scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
            element.attr('aria-expanded', !!isOpen);
          });
          scope.$on('$destroy', function() {
            element.unbind('click', toggleDropdown);
          });
        }
      };
    });
    angular.module('ui.bootstrap.stackedMap', []).factory('$$stackedMap', function() {
      return {createNew: function() {
          var stack = [];
          return {
            add: function(key, value) {
              stack.push({
                key: key,
                value: value
              });
            },
            get: function(key) {
              for (var i = 0; i < stack.length; i++) {
                if (key === stack[i].key) {
                  return stack[i];
                }
              }
            },
            keys: function() {
              var keys = [];
              for (var i = 0; i < stack.length; i++) {
                keys.push(stack[i].key);
              }
              return keys;
            },
            top: function() {
              return stack[stack.length - 1];
            },
            remove: function(key) {
              var idx = -1;
              for (var i = 0; i < stack.length; i++) {
                if (key === stack[i].key) {
                  idx = i;
                  break;
                }
              }
              return stack.splice(idx, 1)[0];
            },
            removeTop: function() {
              return stack.splice(stack.length - 1, 1)[0];
            },
            length: function() {
              return stack.length;
            }
          };
        }};
    });
    angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap', 'ui.bootstrap.position']).factory('$$multiMap', function() {
      return {createNew: function() {
          var map = {};
          return {
            entries: function() {
              return Object.keys(map).map(function(key) {
                return {
                  key: key,
                  value: map[key]
                };
              });
            },
            get: function(key) {
              return map[key];
            },
            hasKey: function(key) {
              return !!map[key];
            },
            keys: function() {
              return Object.keys(map);
            },
            put: function(key, value) {
              if (!map[key]) {
                map[key] = [];
              }
              map[key].push(value);
            },
            remove: function(key, value) {
              var values = map[key];
              if (!values) {
                return;
              }
              var idx = values.indexOf(value);
              if (idx !== -1) {
                values.splice(idx, 1);
              }
              if (!values.length) {
                delete map[key];
              }
            }
          };
        }};
    }).provider('$uibResolve', function() {
      var resolve = this;
      this.resolver = null;
      this.setResolver = function(resolver) {
        this.resolver = resolver;
      };
      this.$get = ['$injector', '$q', function($injector, $q) {
        var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
        return {resolve: function(invocables, locals, parent, self) {
            if (resolver) {
              return resolver.resolve(invocables, locals, parent, self);
            }
            var promises = [];
            angular.forEach(invocables, function(value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promises.push($q.resolve($injector.invoke(value)));
              } else if (angular.isString(value)) {
                promises.push($q.resolve($injector.get(value)));
              } else {
                promises.push($q.resolve(value));
              }
            });
            return $q.all(promises).then(function(resolves) {
              var resolveObj = {};
              var resolveIter = 0;
              angular.forEach(invocables, function(value, key) {
                resolveObj[key] = resolves[resolveIter++];
              });
              return resolveObj;
            });
          }};
      }];
    }).directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack', function($animate, $injector, $modalStack) {
      return {
        replace: true,
        templateUrl: 'uib/template/modal/backdrop.html',
        compile: function(tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        }
      };
      function linkFn(scope, element, attrs) {
        if (attrs.modalInClass) {
          $animate.addClass(element, attrs.modalInClass);
          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            if (scope.modalOptions.animation) {
              $animate.removeClass(element, attrs.modalInClass).then(done);
            } else {
              done();
            }
          });
        }
      }
    }]).directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document', function($modalStack, $q, $animateCss, $document) {
      return {
        scope: {index: '@'},
        replace: true,
        transclude: true,
        templateUrl: function(tElement, tAttrs) {
          return tAttrs.templateUrl || 'uib/template/modal/window.html';
        },
        link: function(scope, element, attrs) {
          element.addClass(attrs.windowClass || '');
          element.addClass(attrs.windowTopClass || '');
          scope.size = attrs.size;
          scope.close = function(evt) {
            var modal = $modalStack.getTop();
            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && evt.target === evt.currentTarget) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };
          element.on('click', scope.close);
          scope.$isRendered = true;
          var modalRenderDeferObj = $q.defer();
          attrs.$observe('modalRender', function(value) {
            if (value === 'true') {
              modalRenderDeferObj.resolve();
            }
          });
          modalRenderDeferObj.promise.then(function() {
            var animationPromise = null;
            if (attrs.modalInClass) {
              animationPromise = $animateCss(element, {addClass: attrs.modalInClass}).start();
              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                var done = setIsAsync();
                $animateCss(element, {removeClass: attrs.modalInClass}).start().then(done);
              });
            }
            $q.when(animationPromise).then(function() {
              var modal = $modalStack.getTop();
              if (modal) {
                $modalStack.modalRendered(modal.key);
              }
              if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
                var inputWithAutofocus = element[0].querySelector('[autofocus]');
                if (inputWithAutofocus) {
                  inputWithAutofocus.focus();
                } else {
                  element[0].focus();
                }
              }
            });
          });
        }
      };
    }]).directive('uibModalAnimationClass', function() {
      return {compile: function(tElement, tAttrs) {
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.uibModalAnimationClass);
          }
        }};
    }).directive('uibModalTransclude', function() {
      return {link: function(scope, element, attrs, controller, transclude) {
          transclude(scope.$parent, function(clone) {
            element.empty();
            element.append(clone);
          });
        }};
    }).factory('$uibModalStack', ['$animate', '$animateCss', '$document', '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition', function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
      var OPENED_MODAL_CLASS = 'modal-open';
      var backdropDomEl,
          backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {NOW_CLOSING_EVENT: 'modal.stack.now-closing'};
      var topModalIndex = 0;
      var previousTopOpenedModal = null;
      var tabableSelector = 'a[href], area[href], input:not([disabled]), ' + 'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' + 'iframe, object, embed, *[tabindex], *[contenteditable=true]';
      var scrollbarPadding;
      function isVisible(element) {
        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
      }
      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
          topBackdropIndex = topModalIndex;
        }
        return topBackdropIndex;
      }
      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });
      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value;
        var appendToElement = modalWindow.appendTo;
        openedWindows.remove(modalInstance);
        previousTopOpenedModal = openedWindows.top();
        if (previousTopOpenedModal) {
          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
        }
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          var areAnyOpen = openedClasses.hasKey(modalBodyClass);
          appendToElement.toggleClass(modalBodyClass, areAnyOpen);
          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
            if (scrollbarPadding.originalRight) {
              appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});
            } else {
              appendToElement.css({paddingRight: ''});
            }
            scrollbarPadding = null;
          }
          toggleTopWindowClass(true);
        }, modalWindow.closedDeferred);
        checkRemoveBackdrop();
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else if (appendToElement.focus) {
          appendToElement.focus();
        }
      }
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }
      function checkRemoveBackdrop() {
        if (backdropDomEl && backdropIndex() === -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }
      function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }
          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
        return $q.when(asyncPromise).then(afterAnimating);
        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;
          $animate.leave(domEl).then(function() {
            domEl.remove();
            if (closedDeferred) {
              closedDeferred.resolve();
            }
          });
          scope.$destroy();
          if (done) {
            done();
          }
        }
      }
      $document.on('keydown', keydownListener);
      $rootScope.$on('$destroy', function() {
        $document.off('keydown', keydownListener);
      });
      function keydownListener(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }
        var modal = openedWindows.top();
        if (modal) {
          switch (evt.which) {
            case 27:
              {
                if (modal.value.keyboard) {
                  evt.preventDefault();
                  $rootScope.$apply(function() {
                    $modalStack.dismiss(modal.key, 'escape key press');
                  });
                }
                break;
              }
            case 9:
              {
                var list = $modalStack.loadFocusElementList(modal);
                var focusChanged = false;
                if (evt.shiftKey) {
                  if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                    focusChanged = $modalStack.focusLastFocusableElement(list);
                  }
                } else {
                  if ($modalStack.isFocusInLastItem(evt, list)) {
                    focusChanged = $modalStack.focusFirstFocusableElement(list);
                  }
                }
                if (focusChanged) {
                  evt.preventDefault();
                  evt.stopPropagation();
                }
                break;
              }
          }
        }
      }
      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
            modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(false);
        previousTopOpenedModal = openedWindows.top();
        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          closedDeferred: modal.closedDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass,
          animation: modal.animation,
          appendTo: modal.appendTo
        });
        openedClasses.put(modalBodyClass, modalInstance);
        var appendToElement = modal.appendTo,
            currBackdropIndex = backdropIndex();
        if (!appendToElement.length) {
          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
        }
        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.modalOptions = modal;
          backdropScope.index = currBackdropIndex;
          backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
          backdropDomEl.attr('backdrop-class', modal.backdropClass);
          if (modal.animation) {
            backdropDomEl.attr('modal-animation', 'true');
          }
          $compile(backdropDomEl)(backdropScope);
          $animate.enter(backdropDomEl, appendToElement);
          scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
          if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
            appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});
          }
        }
        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
          'template-url': modal.windowTemplateUrl,
          'window-class': modal.windowClass,
          'window-top-class': modal.windowTopClass,
          'size': modal.size,
          'index': topModalIndex,
          'animate': 'animate'
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }
        appendToElement.addClass(modalBodyClass);
        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);
        openedWindows.top().value.modalDomEl = angularDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
      };
      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }
      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };
      $modalStack.getTop = function() {
        return openedWindows.top();
      };
      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };
      $modalStack.focusFirstFocusableElement = function(list) {
        if (list.length > 0) {
          list[0].focus();
          return true;
        }
        return false;
      };
      $modalStack.focusLastFocusableElement = function(list) {
        if (list.length > 0) {
          list[list.length - 1].focus();
          return true;
        }
        return false;
      };
      $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt && modalWindow) {
          var modalDomEl = modalWindow.value.modalDomEl;
          if (modalDomEl && modalDomEl.length) {
            return (evt.target || evt.srcElement) === modalDomEl[0];
          }
        }
        return false;
      };
      $modalStack.isFocusInFirstItem = function(evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[0];
        }
        return false;
      };
      $modalStack.isFocusInLastItem = function(evt, list) {
        if (list.length > 0) {
          return (evt.target || evt.srcElement) === list[list.length - 1];
        }
        return false;
      };
      $modalStack.loadFocusElementList = function(modalWindow) {
        if (modalWindow) {
          var modalDomE1 = modalWindow.value.modalDomEl;
          if (modalDomE1 && modalDomE1.length) {
            var elements = modalDomE1[0].querySelectorAll(tabableSelector);
            return elements ? Array.prototype.filter.call(elements, function(element) {
              return isVisible(element);
            }) : elements;
          }
        }
      };
      return $modalStack;
    }]).provider('$uibModal', function() {
      var $modalProvider = {
        options: {
          animation: true,
          backdrop: true,
          keyboard: true
        },
        $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack', function($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
          var $modal = {};
          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
          }
          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };
          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalClosedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              closed: modalClosedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function(result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function(reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }
            var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);
            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain]).then(resolveWithTemplate, resolveWithTemplate).then(function resolveSuccess(tplAndVars) {
              var providedScope = modalOptions.scope || $rootScope;
              var modalScope = providedScope.$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;
              modalScope.$on('$destroy', function() {
                if (!modalScope.$$uibDestructionScheduled) {
                  modalScope.$dismiss('$uibUnscheduledDestruction');
                }
              });
              var ctrlInstance,
                  ctrlInstantiate,
                  ctrlLocals = {};
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$uibModalInstance = modalInstance;
                angular.forEach(tplAndVars[1], function(value, key) {
                  ctrlLocals[key] = value;
                });
                ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true);
                if (modalOptions.controllerAs) {
                  ctrlInstance = ctrlInstantiate.instance;
                  if (modalOptions.bindToController) {
                    ctrlInstance.$close = modalScope.$close;
                    ctrlInstance.$dismiss = modalScope.$dismiss;
                    angular.extend(ctrlInstance, providedScope);
                  }
                  ctrlInstance = ctrlInstantiate();
                  modalScope[modalOptions.controllerAs] = ctrlInstance;
                } else {
                  ctrlInstance = ctrlInstantiate();
                }
                if (angular.isFunction(ctrlInstance.$onInit)) {
                  ctrlInstance.$onInit();
                }
              }
              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                renderDeferred: modalRenderDeferred,
                closedDeferred: modalClosedDeferred,
                content: tplAndVars[0],
                animation: modalOptions.animation,
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                backdropClass: modalOptions.backdropClass,
                windowTopClass: modalOptions.windowTopClass,
                windowClass: modalOptions.windowClass,
                windowTemplateUrl: modalOptions.windowTemplateUrl,
                size: modalOptions.size,
                openedClass: modalOptions.openedClass,
                appendTo: modalOptions.appendTo
              });
              modalOpenedDeferred.resolve(true);
            }, function resolveError(reason) {
              modalOpenedDeferred.reject(reason);
              modalResultDeferred.reject(reason);
            })['finally'](function() {
              if (promiseChain === samePromise) {
                promiseChain = null;
              }
            });
            return modalInstance;
          };
          return $modal;
        }]
      };
      return $modalProvider;
    });
    angular.module('ui.bootstrap.paging', []).factory('uibPaging', ['$parse', function($parse) {
      return {create: function(ctrl, $scope, $attrs) {
          ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
          ctrl.ngModelCtrl = {$setViewValue: angular.noop};
          ctrl._watchers = [];
          ctrl.init = function(ngModelCtrl, config) {
            ctrl.ngModelCtrl = ngModelCtrl;
            ctrl.config = config;
            ngModelCtrl.$render = function() {
              ctrl.render();
            };
            if ($attrs.itemsPerPage) {
              ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
                ctrl.itemsPerPage = parseInt(value, 10);
                $scope.totalPages = ctrl.calculateTotalPages();
                ctrl.updatePage();
              }));
            } else {
              ctrl.itemsPerPage = config.itemsPerPage;
            }
            $scope.$watch('totalItems', function(newTotal, oldTotal) {
              if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
                $scope.totalPages = ctrl.calculateTotalPages();
                ctrl.updatePage();
              }
            });
          };
          ctrl.calculateTotalPages = function() {
            var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
            return Math.max(totalPages || 0, 1);
          };
          ctrl.render = function() {
            $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
          };
          $scope.selectPage = function(page, evt) {
            if (evt) {
              evt.preventDefault();
            }
            var clickAllowed = !$scope.ngDisabled || !evt;
            if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
              if (evt && evt.target) {
                evt.target.blur();
              }
              ctrl.ngModelCtrl.$setViewValue(page);
              ctrl.ngModelCtrl.$render();
            }
          };
          $scope.getText = function(key) {
            return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
          };
          $scope.noPrevious = function() {
            return $scope.page === 1;
          };
          $scope.noNext = function() {
            return $scope.page === $scope.totalPages;
          };
          ctrl.updatePage = function() {
            ctrl.setNumPages($scope.$parent, $scope.totalPages);
            if ($scope.page > $scope.totalPages) {
              $scope.selectPage($scope.totalPages);
            } else {
              ctrl.ngModelCtrl.$render();
            }
          };
          $scope.$on('$destroy', function() {
            while (ctrl._watchers.length) {
              ctrl._watchers.shift()();
            }
          });
        }};
    }]);
    angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging']).controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {
      $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;
      uibPaging.create(this, $scope, $attrs);
    }]).constant('uibPagerConfig', {
      itemsPerPage: 10,
      previousText: '« Previous',
      nextText: 'Next »',
      align: true
    }).directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {
      return {
        scope: {
          totalItems: '=',
          previousText: '@',
          nextText: '@',
          ngDisabled: '='
        },
        require: ['uibPager', '?ngModel'],
        controller: 'UibPagerController',
        controllerAs: 'pager',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/pager/pager.html';
        },
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return;
          }
          paginationCtrl.init(ngModelCtrl, uibPagerConfig);
        }
      };
    }]);
    angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging']).controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
      var ctrl = this;
      var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
          rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
          forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
          boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,
          pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) {
            return $scope.$parent.$eval($attrs.pageLabel, {$page: idx});
          } : angular.identity;
      $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
      $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
      uibPaging.create(this, $scope, $attrs);
      if ($attrs.maxSize) {
        ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          ctrl.render();
        }));
      }
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }
      function getPages(currentPage, totalPages) {
        var pages = [];
        var startPage = 1,
            endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
        if (isMaxSized) {
          if (rotate) {
            startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
            endPage = startPage + maxSize - 1;
            if (endPage > totalPages) {
              endPage = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, pageLabel(number), number === currentPage);
          pages.push(page);
        }
        if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
          if (startPage > 1) {
            if (!boundaryLinkNumbers || startPage > 3) {
              var previousPageSet = makePage(startPage - 1, '...', false);
              pages.unshift(previousPageSet);
            }
            if (boundaryLinkNumbers) {
              if (startPage === 3) {
                var secondPageLink = makePage(2, '2', false);
                pages.unshift(secondPageLink);
              }
              var firstPageLink = makePage(1, '1', false);
              pages.unshift(firstPageLink);
            }
          }
          if (endPage < totalPages) {
            if (!boundaryLinkNumbers || endPage < totalPages - 2) {
              var nextPageSet = makePage(endPage + 1, '...', false);
              pages.push(nextPageSet);
            }
            if (boundaryLinkNumbers) {
              if (endPage === totalPages - 2) {
                var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
                pages.push(secondToLastPageLink);
              }
              var lastPageLink = makePage(totalPages, totalPages, false);
              pages.push(lastPageLink);
            }
          }
        }
        return pages;
      }
      var originalRender = this.render;
      this.render = function() {
        originalRender();
        if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
          $scope.pages = getPages($scope.page, $scope.totalPages);
        }
      };
    }]).constant('uibPaginationConfig', {
      itemsPerPage: 10,
      boundaryLinks: false,
      boundaryLinkNumbers: false,
      directionLinks: true,
      firstText: 'First',
      previousText: 'Previous',
      nextText: 'Next',
      lastText: 'Last',
      rotate: true,
      forceEllipses: false
    }).directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {
      return {
        scope: {
          totalItems: '=',
          firstText: '@',
          previousText: '@',
          nextText: '@',
          lastText: '@',
          ngDisabled: '='
        },
        require: ['uibPagination', '?ngModel'],
        controller: 'UibPaginationController',
        controllerAs: 'pagination',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/pagination/pagination.html';
        },
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return;
          }
          paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
        }
      };
    }]);
    angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap']).provider('$uibTooltip', function() {
      var defaultOptions = {
        placement: 'top',
        placementClassPrefix: '',
        animation: true,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: false
      };
      var triggerMap = {
        'mouseenter': 'mouseleave',
        'click': 'click',
        'outsideClick': 'outsideClick',
        'focus': 'blur',
        'none': ''
      };
      var globalOptions = {};
      this.options = function(value) {
        angular.extend(globalOptions, value);
      };
      this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
      };
      function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = '-';
        return name.replace(regexp, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
        var openedTooltips = $$stackedMap.createNew();
        $document.on('keypress', keypressListener);
        $rootScope.$on('$destroy', function() {
          $document.off('keypress', keypressListener);
        });
        function keypressListener(e) {
          if (e.which === 27) {
            var last = openedTooltips.top();
            if (last) {
              last.value.close();
              openedTooltips.removeTop();
              last = null;
            }
          }
        }
        return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
          options = angular.extend({}, defaultOptions, globalOptions, options);
          function getTriggers(trigger) {
            var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
            var hide = show.map(function(trigger) {
              return triggerMap[trigger] || trigger;
            });
            return {
              show: show,
              hide: hide
            };
          }
          var directiveName = snake_case(ttType);
          var startSym = $interpolate.startSymbol();
          var endSym = $interpolate.endSymbol();
          var template = '<div ' + directiveName + '-popup ' + 'uib-title="' + startSym + 'title' + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + 'content' + endSym + '" ') + 'placement="' + startSym + 'placement' + endSym + '" ' + 'popup-class="' + startSym + 'popupClass' + endSym + '" ' + 'animation="animation" ' + 'is-open="isOpen" ' + 'origin-scope="origScope" ' + 'class="uib-position-measure"' + '>' + '</div>';
          return {compile: function(tElem, tAttrs) {
              var tooltipLinker = $compile(template);
              return function link(scope, element, attrs, tooltipCtrl) {
                var tooltip;
                var tooltipLinkedScope;
                var transitionTimeout;
                var showTimeout;
                var hideTimeout;
                var positionTimeout;
                var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                var triggers = getTriggers(undefined);
                var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                var ttScope = scope.$new(true);
                var repositionScheduled = false;
                var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
                var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
                var observers = [];
                var lastPlacement;
                var positionTooltip = function() {
                  if (!tooltip || !tooltip.html()) {
                    return;
                  }
                  if (!positionTimeout) {
                    positionTimeout = $timeout(function() {
                      var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                      tooltip.css({
                        top: ttPosition.top + 'px',
                        left: ttPosition.left + 'px'
                      });
                      if (!tooltip.hasClass(ttPosition.placement.split('-')[0])) {
                        tooltip.removeClass(lastPlacement.split('-')[0]);
                        tooltip.addClass(ttPosition.placement.split('-')[0]);
                      }
                      if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                        tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                        tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                      }
                      if (tooltip.hasClass('uib-position-measure')) {
                        $position.positionArrow(tooltip, ttPosition.placement);
                        tooltip.removeClass('uib-position-measure');
                      } else if (lastPlacement !== ttPosition.placement) {
                        $position.positionArrow(tooltip, ttPosition.placement);
                      }
                      lastPlacement = ttPosition.placement;
                      positionTimeout = null;
                    }, 0, false);
                  }
                };
                ttScope.origScope = scope;
                ttScope.isOpen = false;
                openedTooltips.add(ttScope, {close: hide});
                function toggleTooltipBind() {
                  if (!ttScope.isOpen) {
                    showTooltipBind();
                  } else {
                    hideTooltipBind();
                  }
                }
                function showTooltipBind() {
                  if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                    return;
                  }
                  cancelHide();
                  prepareTooltip();
                  if (ttScope.popupDelay) {
                    if (!showTimeout) {
                      showTimeout = $timeout(show, ttScope.popupDelay, false);
                    }
                  } else {
                    show();
                  }
                }
                function hideTooltipBind() {
                  cancelShow();
                  if (ttScope.popupCloseDelay) {
                    if (!hideTimeout) {
                      hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                    }
                  } else {
                    hide();
                  }
                }
                function show() {
                  cancelShow();
                  cancelHide();
                  if (!ttScope.content) {
                    return angular.noop;
                  }
                  createTooltip();
                  ttScope.$evalAsync(function() {
                    ttScope.isOpen = true;
                    assignIsOpen(true);
                    positionTooltip();
                  });
                }
                function cancelShow() {
                  if (showTimeout) {
                    $timeout.cancel(showTimeout);
                    showTimeout = null;
                  }
                  if (positionTimeout) {
                    $timeout.cancel(positionTimeout);
                    positionTimeout = null;
                  }
                }
                function hide() {
                  if (!ttScope) {
                    return;
                  }
                  ttScope.$evalAsync(function() {
                    if (ttScope) {
                      ttScope.isOpen = false;
                      assignIsOpen(false);
                      if (ttScope.animation) {
                        if (!transitionTimeout) {
                          transitionTimeout = $timeout(removeTooltip, 150, false);
                        }
                      } else {
                        removeTooltip();
                      }
                    }
                  });
                }
                function cancelHide() {
                  if (hideTimeout) {
                    $timeout.cancel(hideTimeout);
                    hideTimeout = null;
                  }
                  if (transitionTimeout) {
                    $timeout.cancel(transitionTimeout);
                    transitionTimeout = null;
                  }
                }
                function createTooltip() {
                  if (tooltip) {
                    return;
                  }
                  tooltipLinkedScope = ttScope.$new();
                  tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                    if (appendToBody) {
                      $document.find('body').append(tooltip);
                    } else {
                      element.after(tooltip);
                    }
                  });
                  prepObservers();
                }
                function removeTooltip() {
                  cancelShow();
                  cancelHide();
                  unregisterObservers();
                  if (tooltip) {
                    tooltip.remove();
                    tooltip = null;
                  }
                  if (tooltipLinkedScope) {
                    tooltipLinkedScope.$destroy();
                    tooltipLinkedScope = null;
                  }
                }
                function prepareTooltip() {
                  ttScope.title = attrs[prefix + 'Title'];
                  if (contentParse) {
                    ttScope.content = contentParse(scope);
                  } else {
                    ttScope.content = attrs[ttType];
                  }
                  ttScope.popupClass = attrs[prefix + 'Class'];
                  ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                  var placement = $position.parsePlacement(ttScope.placement);
                  lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];
                  var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                  var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                  ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                  ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
                }
                function assignIsOpen(isOpen) {
                  if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                    isOpenParse.assign(scope, isOpen);
                  }
                }
                ttScope.contentExp = function() {
                  return ttScope.content;
                };
                attrs.$observe('disabled', function(val) {
                  if (val) {
                    cancelShow();
                  }
                  if (val && ttScope.isOpen) {
                    hide();
                  }
                });
                if (isOpenParse) {
                  scope.$watch(isOpenParse, function(val) {
                    if (ttScope && !val === ttScope.isOpen) {
                      toggleTooltipBind();
                    }
                  });
                }
                function prepObservers() {
                  observers.length = 0;
                  if (contentParse) {
                    observers.push(scope.$watch(contentParse, function(val) {
                      ttScope.content = val;
                      if (!val && ttScope.isOpen) {
                        hide();
                      }
                    }));
                    observers.push(tooltipLinkedScope.$watch(function() {
                      if (!repositionScheduled) {
                        repositionScheduled = true;
                        tooltipLinkedScope.$$postDigest(function() {
                          repositionScheduled = false;
                          if (ttScope && ttScope.isOpen) {
                            positionTooltip();
                          }
                        });
                      }
                    }));
                  } else {
                    observers.push(attrs.$observe(ttType, function(val) {
                      ttScope.content = val;
                      if (!val && ttScope.isOpen) {
                        hide();
                      } else {
                        positionTooltip();
                      }
                    }));
                  }
                  observers.push(attrs.$observe(prefix + 'Title', function(val) {
                    ttScope.title = val;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  }));
                  observers.push(attrs.$observe(prefix + 'Placement', function(val) {
                    ttScope.placement = val ? val : options.placement;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  }));
                }
                function unregisterObservers() {
                  if (observers.length) {
                    angular.forEach(observers, function(observer) {
                      observer();
                    });
                    observers.length = 0;
                  }
                }
                function bodyHideTooltipBind(e) {
                  if (!ttScope || !ttScope.isOpen || !tooltip) {
                    return;
                  }
                  if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                    hideTooltipBind();
                  }
                }
                var unregisterTriggers = function() {
                  triggers.show.forEach(function(trigger) {
                    if (trigger === 'outsideClick') {
                      element.off('click', toggleTooltipBind);
                    } else {
                      element.off(trigger, showTooltipBind);
                      element.off(trigger, toggleTooltipBind);
                    }
                  });
                  triggers.hide.forEach(function(trigger) {
                    if (trigger === 'outsideClick') {
                      $document.off('click', bodyHideTooltipBind);
                    } else {
                      element.off(trigger, hideTooltipBind);
                    }
                  });
                };
                function prepTriggers() {
                  var val = attrs[prefix + 'Trigger'];
                  unregisterTriggers();
                  triggers = getTriggers(val);
                  if (triggers.show !== 'none') {
                    triggers.show.forEach(function(trigger, idx) {
                      if (trigger === 'outsideClick') {
                        element.on('click', toggleTooltipBind);
                        $document.on('click', bodyHideTooltipBind);
                      } else if (trigger === triggers.hide[idx]) {
                        element.on(trigger, toggleTooltipBind);
                      } else if (trigger) {
                        element.on(trigger, showTooltipBind);
                        element.on(triggers.hide[idx], hideTooltipBind);
                      }
                      element.on('keypress', function(e) {
                        if (e.which === 27) {
                          hideTooltipBind();
                        }
                      });
                    });
                  }
                }
                prepTriggers();
                var animation = scope.$eval(attrs[prefix + 'Animation']);
                ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                var appendToBodyVal;
                var appendKey = prefix + 'AppendToBody';
                if (appendKey in attrs && attrs[appendKey] === undefined) {
                  appendToBodyVal = true;
                } else {
                  appendToBodyVal = scope.$eval(attrs[appendKey]);
                }
                appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
                scope.$on('$destroy', function onDestroyTooltip() {
                  unregisterTriggers();
                  removeTooltip();
                  openedTooltips.remove(ttScope);
                  ttScope = null;
                });
              };
            }};
        };
      }];
    }).directive('uibTooltipTemplateTransclude', ['$animate', '$sce', '$compile', '$templateRequest', function($animate, $sce, $compile, $templateRequest) {
      return {link: function(scope, elem, attrs) {
          var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
          var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;
          var cleanupLastIncludeContent = function() {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              $animate.leave(currentElement).then(function() {
                previousElement = null;
              });
              previousElement = currentElement;
              currentElement = null;
            }
          };
          scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
            var thisChangeId = ++changeCounter;
            if (src) {
              $templateRequest(src, true).then(function(response) {
                if (thisChangeId !== changeCounter) {
                  return;
                }
                var newScope = origScope.$new();
                var template = response;
                var clone = $compile(template)(newScope, function(clone) {
                  cleanupLastIncludeContent();
                  $animate.enter(clone, elem);
                });
                currentScope = newScope;
                currentElement = clone;
                currentScope.$emit('$includeContentLoaded', src);
              }, function() {
                if (thisChangeId === changeCounter) {
                  cleanupLastIncludeContent();
                  scope.$emit('$includeContentError', src);
                }
              });
              scope.$emit('$includeContentRequested', src);
            } else {
              cleanupLastIncludeContent();
            }
          });
          scope.$on('$destroy', cleanupLastIncludeContent);
        }};
    }]).directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {
      return {
        restrict: 'A',
        link: function(scope, element, attrs) {
          if (scope.placement) {
            var position = $uibPosition.parsePlacement(scope.placement);
            element.addClass(position[0]);
          }
          if (scope.popupClass) {
            element.addClass(scope.popupClass);
          }
          if (scope.animation()) {
            element.addClass(attrs.tooltipAnimationClass);
          }
        }
      };
    }]).directive('uibTooltipPopup', function() {
      return {
        replace: true,
        scope: {
          content: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'uib/template/tooltip/tooltip-popup.html'
      };
    }).directive('uibTooltip', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
    }]).directive('uibTooltipTemplatePopup', function() {
      return {
        replace: true,
        scope: {
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&',
          originScope: '&'
        },
        templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
      };
    }).directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {useContentExp: true});
    }]).directive('uibTooltipHtmlPopup', function() {
      return {
        replace: true,
        scope: {
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
      };
    }).directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {useContentExp: true});
    }]);
    angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('uibPopoverTemplatePopup', function() {
      return {
        replace: true,
        scope: {
          uibTitle: '@',
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&',
          originScope: '&'
        },
        templateUrl: 'uib/template/popover/popover-template.html'
      };
    }).directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {useContentExp: true});
    }]).directive('uibPopoverHtmlPopup', function() {
      return {
        replace: true,
        scope: {
          contentExp: '&',
          uibTitle: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'uib/template/popover/popover-html.html'
      };
    }).directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibPopoverHtml', 'popover', 'click', {useContentExp: true});
    }]).directive('uibPopoverPopup', function() {
      return {
        replace: true,
        scope: {
          uibTitle: '@',
          content: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'uib/template/popover/popover.html'
      };
    }).directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibPopover', 'popover', 'click');
    }]);
    angular.module('ui.bootstrap.progressbar', []).constant('uibProgressConfig', {
      animate: true,
      max: 100
    }).controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
      var self = this,
          animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
      this.bars = [];
      $scope.max = getMaxOrDefault();
      this.addBar = function(bar, element, attrs) {
        if (!animate) {
          element.css({'transition': 'none'});
        }
        this.bars.push(bar);
        bar.max = getMaxOrDefault();
        bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
        bar.$watch('value', function(value) {
          bar.recalculatePercentage();
        });
        bar.recalculatePercentage = function() {
          var totalPercentage = self.bars.reduce(function(total, bar) {
            bar.percent = +(100 * bar.value / bar.max).toFixed(2);
            return total + bar.percent;
          }, 0);
          if (totalPercentage > 100) {
            bar.percent -= totalPercentage - 100;
          }
        };
        bar.$on('$destroy', function() {
          element = null;
          self.removeBar(bar);
        });
      };
      this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
        this.bars.forEach(function(bar) {
          bar.recalculatePercentage();
        });
      };
      $scope.$watch('maxParam', function(maxParam) {
        self.bars.forEach(function(bar) {
          bar.max = getMaxOrDefault();
          bar.recalculatePercentage();
        });
      });
      function getMaxOrDefault() {
        return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
      }
    }]).directive('uibProgress', function() {
      return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        require: 'uibProgress',
        scope: {maxParam: '=?max'},
        templateUrl: 'uib/template/progressbar/progress.html'
      };
    }).directive('uibBar', function() {
      return {
        replace: true,
        transclude: true,
        require: '^uibProgress',
        scope: {
          value: '=',
          type: '@'
        },
        templateUrl: 'uib/template/progressbar/bar.html',
        link: function(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, element, attrs);
        }
      };
    }).directive('uibProgressbar', function() {
      return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        scope: {
          value: '=',
          maxParam: '=?max',
          type: '@'
        },
        templateUrl: 'uib/template/progressbar/progressbar.html',
        link: function(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
        }
      };
    });
    angular.module('ui.bootstrap.rating', []).constant('uibRatingConfig', {
      max: 5,
      stateOn: null,
      stateOff: null,
      enableReset: true,
      titles: ['one', 'two', 'three', 'four', 'five']
    }).controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
      var ngModelCtrl = {$setViewValue: angular.noop},
          self = this;
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.push(function(value) {
          if (angular.isNumber(value) && value << 0 !== value) {
            value = Math.round(value);
          }
          return value;
        });
        this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        this.enableReset = angular.isDefined($attrs.enableReset) ? $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
        var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
        this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
      };
      this.buildTemplateObjects = function(states) {
        for (var i = 0,
            n = states.length; i < n; i++) {
          states[i] = angular.extend({index: i}, {
            stateOn: this.stateOn,
            stateOff: this.stateOff,
            title: this.getTitle(i)
          }, states[i]);
        }
        return states;
      };
      this.getTitle = function(index) {
        if (index >= this.titles.length) {
          return index + 1;
        }
        return this.titles[index];
      };
      $scope.rate = function(value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
          var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
          ngModelCtrl.$setViewValue(newViewValue);
          ngModelCtrl.$render();
        }
      };
      $scope.enter = function(value) {
        if (!$scope.readonly) {
          $scope.value = value;
        }
        $scope.onHover({value: value});
      };
      $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.onLeave();
      };
      $scope.onKeydown = function(evt) {
        if (/(37|38|39|40)/.test(evt.which)) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
        }
      };
      this.render = function() {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.title = self.getTitle($scope.value - 1);
      };
    }]).directive('uibRating', function() {
      return {
        require: ['uibRating', 'ngModel'],
        scope: {
          readonly: '=?readOnly',
          onHover: '&',
          onLeave: '&'
        },
        controller: 'UibRatingController',
        templateUrl: 'uib/template/rating/rating.html',
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          var ratingCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          ratingCtrl.init(ngModelCtrl);
        }
      };
    });
    angular.module('ui.bootstrap.tabs', []).controller('UibTabsetController', ['$scope', function($scope) {
      var ctrl = this,
          oldIndex;
      ctrl.tabs = [];
      ctrl.select = function(index, evt) {
        if (!destroyed) {
          var previousIndex = findTabIndex(oldIndex);
          var previousSelected = ctrl.tabs[previousIndex];
          if (previousSelected) {
            previousSelected.tab.onDeselect({$event: evt});
            if (evt && evt.isDefaultPrevented()) {
              return;
            }
            previousSelected.tab.active = false;
          }
          var selected = ctrl.tabs[index];
          if (selected) {
            selected.tab.onSelect({$event: evt});
            selected.tab.active = true;
            ctrl.active = selected.index;
            oldIndex = selected.index;
          } else if (!selected && angular.isNumber(oldIndex)) {
            ctrl.active = null;
            oldIndex = null;
          }
        }
      };
      ctrl.addTab = function addTab(tab) {
        ctrl.tabs.push({
          tab: tab,
          index: tab.index
        });
        ctrl.tabs.sort(function(t1, t2) {
          if (t1.index > t2.index) {
            return 1;
          }
          if (t1.index < t2.index) {
            return -1;
          }
          return 0;
        });
        if (tab.index === ctrl.active || !angular.isNumber(ctrl.active) && ctrl.tabs.length === 1) {
          var newActiveIndex = findTabIndex(tab.index);
          ctrl.select(newActiveIndex);
        }
      };
      ctrl.removeTab = function removeTab(tab) {
        var index;
        for (var i = 0; i < ctrl.tabs.length; i++) {
          if (ctrl.tabs[i].tab === tab) {
            index = i;
            break;
          }
        }
        if (ctrl.tabs[index].index === ctrl.active) {
          var newActiveTabIndex = index === ctrl.tabs.length - 1 ? index - 1 : index + 1 % ctrl.tabs.length;
          ctrl.select(newActiveTabIndex);
        }
        ctrl.tabs.splice(index, 1);
      };
      $scope.$watch('tabset.active', function(val) {
        if (angular.isNumber(val) && val !== oldIndex) {
          ctrl.select(findTabIndex(val));
        }
      });
      var destroyed;
      $scope.$on('$destroy', function() {
        destroyed = true;
      });
      function findTabIndex(index) {
        for (var i = 0; i < ctrl.tabs.length; i++) {
          if (ctrl.tabs[i].index === index) {
            return i;
          }
        }
      }
    }]).directive('uibTabset', function() {
      return {
        transclude: true,
        replace: true,
        scope: {},
        bindToController: {
          active: '=?',
          type: '@'
        },
        controller: 'UibTabsetController',
        controllerAs: 'tabset',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/tabs/tabset.html';
        },
        link: function(scope, element, attrs) {
          scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
          scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
          if (angular.isUndefined(attrs.active)) {
            scope.active = 0;
          }
        }
      };
    }).directive('uibTab', ['$parse', function($parse) {
      return {
        require: '^uibTabset',
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'uib/template/tabs/tab.html';
        },
        transclude: true,
        scope: {
          heading: '@',
          index: '=?',
          classes: '@?',
          onSelect: '&select',
          onDeselect: '&deselect'
        },
        controller: function() {},
        controllerAs: 'tab',
        link: function(scope, elm, attrs, tabsetCtrl, transclude) {
          scope.disabled = false;
          if (attrs.disable) {
            scope.$parent.$watch($parse(attrs.disable), function(value) {
              scope.disabled = !!value;
            });
          }
          if (angular.isUndefined(attrs.index)) {
            if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
              scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) {
                return t.index;
              })) + 1;
            } else {
              scope.index = 0;
            }
          }
          if (angular.isUndefined(attrs.classes)) {
            scope.classes = '';
          }
          scope.select = function(evt) {
            if (!scope.disabled) {
              var index;
              for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
                if (tabsetCtrl.tabs[i].tab === scope) {
                  index = i;
                  break;
                }
              }
              tabsetCtrl.select(index, evt);
            }
          };
          tabsetCtrl.addTab(scope);
          scope.$on('$destroy', function() {
            tabsetCtrl.removeTab(scope);
          });
          scope.$transcludeFn = transclude;
        }
      };
    }]).directive('uibTabHeadingTransclude', function() {
      return {
        restrict: 'A',
        require: '^uibTab',
        link: function(scope, elm) {
          scope.$watch('headingElement', function updateHeadingElement(heading) {
            if (heading) {
              elm.html('');
              elm.append(heading);
            }
          });
        }
      };
    }).directive('uibTabContentTransclude', function() {
      return {
        restrict: 'A',
        require: '^uibTabset',
        link: function(scope, elm, attrs) {
          var tab = scope.$eval(attrs.uibTabContentTransclude).tab;
          tab.$transcludeFn(tab.$parent, function(contents) {
            angular.forEach(contents, function(node) {
              if (isTabHeading(node)) {
                tab.headingElement = node;
              } else {
                elm.append(node);
              }
            });
          });
        }
      };
      function isTabHeading(node) {
        return node.tagName && (node.hasAttribute('uib-tab-heading') || node.hasAttribute('data-uib-tab-heading') || node.hasAttribute('x-uib-tab-heading') || node.tagName.toLowerCase() === 'uib-tab-heading' || node.tagName.toLowerCase() === 'data-uib-tab-heading' || node.tagName.toLowerCase() === 'x-uib-tab-heading' || node.tagName.toLowerCase() === 'uib:tab-heading');
      }
    });
    angular.module('ui.bootstrap.timepicker', []).constant('uibTimepickerConfig', {
      hourStep: 1,
      minuteStep: 1,
      secondStep: 1,
      showMeridian: true,
      showSeconds: false,
      meridians: null,
      readonlyInput: false,
      mousewheel: true,
      arrowkeys: true,
      showSpinners: true,
      templateUrl: 'uib/template/timepicker/timepicker.html'
    }).controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
      var selected = new Date(),
          watchers = [],
          ngModelCtrl = {$setViewValue: angular.noop},
          meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,
          padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;
      $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
      $element.removeAttr('tabindex');
      this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.unshift(function(modelValue) {
          return modelValue ? new Date(modelValue) : null;
        });
        var hoursInputEl = inputs.eq(0),
            minutesInputEl = inputs.eq(1),
            secondsInputEl = inputs.eq(2);
        var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
        if (mousewheel) {
          this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        }
        var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
        if (arrowkeys) {
          this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        }
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
        this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
      };
      var hourStep = timepickerConfig.hourStep;
      if ($attrs.hourStep) {
        watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
          hourStep = +value;
        }));
      }
      var minuteStep = timepickerConfig.minuteStep;
      if ($attrs.minuteStep) {
        watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
          minuteStep = +value;
        }));
      }
      var min;
      watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
        var dt = new Date(value);
        min = isNaN(dt) ? undefined : dt;
      }));
      var max;
      watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
        var dt = new Date(value);
        max = isNaN(dt) ? undefined : dt;
      }));
      var disabled = false;
      if ($attrs.ngDisabled) {
        watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
          disabled = value;
        }));
      }
      $scope.noIncrementHours = function() {
        var incrementedSelected = addMinutes(selected, hourStep * 60);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
      };
      $scope.noDecrementHours = function() {
        var decrementedSelected = addMinutes(selected, -hourStep * 60);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
      };
      $scope.noIncrementMinutes = function() {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
      };
      $scope.noDecrementMinutes = function() {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
      };
      $scope.noIncrementSeconds = function() {
        var incrementedSelected = addSeconds(selected, secondStep);
        return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
      };
      $scope.noDecrementSeconds = function() {
        var decrementedSelected = addSeconds(selected, -secondStep);
        return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
      };
      $scope.noToggleMeridian = function() {
        if (selected.getHours() < 12) {
          return disabled || addMinutes(selected, 12 * 60) > max;
        }
        return disabled || addMinutes(selected, -12 * 60) < min;
      };
      var secondStep = timepickerConfig.secondStep;
      if ($attrs.secondStep) {
        watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
          secondStep = +value;
        }));
      }
      $scope.showSeconds = timepickerConfig.showSeconds;
      if ($attrs.showSeconds) {
        watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
          $scope.showSeconds = !!value;
        }));
      }
      $scope.showMeridian = timepickerConfig.showMeridian;
      if ($attrs.showMeridian) {
        watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
          $scope.showMeridian = !!value;
          if (ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate(),
                minutes = getMinutesFromTemplate();
            if (angular.isDefined(hours) && angular.isDefined(minutes)) {
              selected.setHours(hours);
              refresh();
            }
          } else {
            updateTemplate();
          }
        }));
      }
      function getHoursFromTemplate() {
        var hours = +$scope.hours;
        var valid = $scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
        if (!valid || $scope.hours === '') {
          return undefined;
        }
        if ($scope.showMeridian) {
          if (hours === 12) {
            hours = 0;
          }
          if ($scope.meridian === meridians[1]) {
            hours = hours + 12;
          }
        }
        return hours;
      }
      function getMinutesFromTemplate() {
        var minutes = +$scope.minutes;
        var valid = minutes >= 0 && minutes < 60;
        if (!valid || $scope.minutes === '') {
          return undefined;
        }
        return minutes;
      }
      function getSecondsFromTemplate() {
        var seconds = +$scope.seconds;
        return seconds >= 0 && seconds < 60 ? seconds : undefined;
      }
      function pad(value, noPad) {
        if (value === null) {
          return '';
        }
        return angular.isDefined(value) && value.toString().length < 2 && !noPad ? '0' + value : value.toString();
      }
      this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        var isScrollingUp = function(e) {
          if (e.originalEvent) {
            e = e.originalEvent;
          }
          var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
          return e.detail || delta > 0;
        };
        hoursInputEl.bind('mousewheel wheel', function(e) {
          if (!disabled) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
          }
          e.preventDefault();
        });
        minutesInputEl.bind('mousewheel wheel', function(e) {
          if (!disabled) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
          }
          e.preventDefault();
        });
        secondsInputEl.bind('mousewheel wheel', function(e) {
          if (!disabled) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
          }
          e.preventDefault();
        });
      };
      this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        hoursInputEl.bind('keydown', function(e) {
          if (!disabled) {
            if (e.which === 38) {
              e.preventDefault();
              $scope.incrementHours();
              $scope.$apply();
            } else if (e.which === 40) {
              e.preventDefault();
              $scope.decrementHours();
              $scope.$apply();
            }
          }
        });
        minutesInputEl.bind('keydown', function(e) {
          if (!disabled) {
            if (e.which === 38) {
              e.preventDefault();
              $scope.incrementMinutes();
              $scope.$apply();
            } else if (e.which === 40) {
              e.preventDefault();
              $scope.decrementMinutes();
              $scope.$apply();
            }
          }
        });
        secondsInputEl.bind('keydown', function(e) {
          if (!disabled) {
            if (e.which === 38) {
              e.preventDefault();
              $scope.incrementSeconds();
              $scope.$apply();
            } else if (e.which === 40) {
              e.preventDefault();
              $scope.decrementSeconds();
              $scope.$apply();
            }
          }
        });
      };
      this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        if ($scope.readonlyInput) {
          $scope.updateHours = angular.noop;
          $scope.updateMinutes = angular.noop;
          $scope.updateSeconds = angular.noop;
          return;
        }
        var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
          ngModelCtrl.$setViewValue(null);
          ngModelCtrl.$setValidity('time', false);
          if (angular.isDefined(invalidHours)) {
            $scope.invalidHours = invalidHours;
          }
          if (angular.isDefined(invalidMinutes)) {
            $scope.invalidMinutes = invalidMinutes;
          }
          if (angular.isDefined(invalidSeconds)) {
            $scope.invalidSeconds = invalidSeconds;
          }
        };
        $scope.updateHours = function() {
          var hours = getHoursFromTemplate(),
              minutes = getMinutesFromTemplate();
          ngModelCtrl.$setDirty();
          if (angular.isDefined(hours) && angular.isDefined(minutes)) {
            selected.setHours(hours);
            selected.setMinutes(minutes);
            if (selected < min || selected > max) {
              invalidate(true);
            } else {
              refresh('h');
            }
          } else {
            invalidate(true);
          }
        };
        hoursInputEl.bind('blur', function(e) {
          ngModelCtrl.$setTouched();
          if (modelIsEmpty()) {
            makeValid();
          } else if ($scope.hours === null || $scope.hours === '') {
            invalidate(true);
          } else if (!$scope.invalidHours && $scope.hours < 10) {
            $scope.$apply(function() {
              $scope.hours = pad($scope.hours, !padHours);
            });
          }
        });
        $scope.updateMinutes = function() {
          var minutes = getMinutesFromTemplate(),
              hours = getHoursFromTemplate();
          ngModelCtrl.$setDirty();
          if (angular.isDefined(minutes) && angular.isDefined(hours)) {
            selected.setHours(hours);
            selected.setMinutes(minutes);
            if (selected < min || selected > max) {
              invalidate(undefined, true);
            } else {
              refresh('m');
            }
          } else {
            invalidate(undefined, true);
          }
        };
        minutesInputEl.bind('blur', function(e) {
          ngModelCtrl.$setTouched();
          if (modelIsEmpty()) {
            makeValid();
          } else if ($scope.minutes === null) {
            invalidate(undefined, true);
          } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
            $scope.$apply(function() {
              $scope.minutes = pad($scope.minutes);
            });
          }
        });
        $scope.updateSeconds = function() {
          var seconds = getSecondsFromTemplate();
          ngModelCtrl.$setDirty();
          if (angular.isDefined(seconds)) {
            selected.setSeconds(seconds);
            refresh('s');
          } else {
            invalidate(undefined, undefined, true);
          }
        };
        secondsInputEl.bind('blur', function(e) {
          if (modelIsEmpty()) {
            makeValid();
          } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
            $scope.$apply(function() {
              $scope.seconds = pad($scope.seconds);
            });
          }
        });
      };
      this.render = function() {
        var date = ngModelCtrl.$viewValue;
        if (isNaN(date)) {
          ngModelCtrl.$setValidity('time', false);
          $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        } else {
          if (date) {
            selected = date;
          }
          if (selected < min || selected > max) {
            ngModelCtrl.$setValidity('time', false);
            $scope.invalidHours = true;
            $scope.invalidMinutes = true;
          } else {
            makeValid();
          }
          updateTemplate();
        }
      };
      function refresh(keyboardChange) {
        makeValid();
        ngModelCtrl.$setViewValue(new Date(selected));
        updateTemplate(keyboardChange);
      }
      function makeValid() {
        ngModelCtrl.$setValidity('time', true);
        $scope.invalidHours = false;
        $scope.invalidMinutes = false;
        $scope.invalidSeconds = false;
      }
      function updateTemplate(keyboardChange) {
        if (!ngModelCtrl.$modelValue) {
          $scope.hours = null;
          $scope.minutes = null;
          $scope.seconds = null;
          $scope.meridian = meridians[0];
        } else {
          var hours = selected.getHours(),
              minutes = selected.getMinutes(),
              seconds = selected.getSeconds();
          if ($scope.showMeridian) {
            hours = hours === 0 || hours === 12 ? 12 : hours % 12;
          }
          $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
          if (keyboardChange !== 'm') {
            $scope.minutes = pad(minutes);
          }
          $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
          if (keyboardChange !== 's') {
            $scope.seconds = pad(seconds);
          }
          $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
        }
      }
      function addSecondsToSelected(seconds) {
        selected = addSeconds(selected, seconds);
        refresh();
      }
      function addMinutes(selected, minutes) {
        return addSeconds(selected, minutes * 60);
      }
      function addSeconds(date, seconds) {
        var dt = new Date(date.getTime() + seconds * 1000);
        var newDate = new Date(date);
        newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
        return newDate;
      }
      function modelIsEmpty() {
        return ($scope.hours === null || $scope.hours === '') && ($scope.minutes === null || $scope.minutes === '') && (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
      }
      $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
      $scope.incrementHours = function() {
        if (!$scope.noIncrementHours()) {
          addSecondsToSelected(hourStep * 60 * 60);
        }
      };
      $scope.decrementHours = function() {
        if (!$scope.noDecrementHours()) {
          addSecondsToSelected(-hourStep * 60 * 60);
        }
      };
      $scope.incrementMinutes = function() {
        if (!$scope.noIncrementMinutes()) {
          addSecondsToSelected(minuteStep * 60);
        }
      };
      $scope.decrementMinutes = function() {
        if (!$scope.noDecrementMinutes()) {
          addSecondsToSelected(-minuteStep * 60);
        }
      };
      $scope.incrementSeconds = function() {
        if (!$scope.noIncrementSeconds()) {
          addSecondsToSelected(secondStep);
        }
      };
      $scope.decrementSeconds = function() {
        if (!$scope.noDecrementSeconds()) {
          addSecondsToSelected(-secondStep);
        }
      };
      $scope.toggleMeridian = function() {
        var minutes = getMinutesFromTemplate(),
            hours = getHoursFromTemplate();
        if (!$scope.noToggleMeridian()) {
          if (angular.isDefined(minutes) && angular.isDefined(hours)) {
            addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
          } else {
            $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
          }
        }
      };
      $scope.blur = function() {
        ngModelCtrl.$setTouched();
      };
      $scope.$on('$destroy', function() {
        while (watchers.length) {
          watchers.shift()();
        }
      });
    }]).directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {
      return {
        require: ['uibTimepicker', '?^ngModel'],
        controller: 'UibTimepickerController',
        controllerAs: 'timepicker',
        replace: true,
        scope: {},
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || uibTimepickerConfig.templateUrl;
        },
        link: function(scope, element, attrs, ctrls) {
          var timepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (ngModelCtrl) {
            timepickerCtrl.init(ngModelCtrl, element.find('input'));
          }
        }
      };
    }]);
    angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position']).factory('uibTypeaheadParser', ['$parse', function($parse) {
      var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
      return {parse: function(input) {
          var match = input.match(TYPEAHEAD_REGEXP);
          if (!match) {
            throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
          }
          return {
            itemName: match[3],
            source: $parse(match[4]),
            viewMapper: $parse(match[2] || match[1]),
            modelMapper: $parse(match[1])
          };
        }};
    }]).controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser', function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
      var HOT_KEYS = [9, 13, 27, 38, 40];
      var eventDebounceTime = 200;
      var modelCtrl,
          ngModelOptions;
      var minLength = originalScope.$eval(attrs.typeaheadMinLength);
      if (!minLength && minLength !== 0) {
        minLength = 1;
      }
      originalScope.$watch(attrs.typeaheadMinLength, function(newVal) {
        minLength = !newVal && newVal !== 0 ? 1 : newVal;
      });
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
      originalScope.$watch(attrs.typeaheadEditable, function(newVal) {
        isEditable = newVal !== false;
      });
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);
      var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
      var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
      var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
      var appendTo = attrs.typeaheadAppendTo ? originalScope.$eval(attrs.typeaheadAppendTo) : null;
      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
      var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
      var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;
      var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;
      var parsedModel = $parse(attrs.ngModel);
      var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
      var $setModelValue = function(scope, newValue) {
        if (angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
          return invokeModelSetter(scope, {$$$p: newValue});
        }
        return parsedModel.assign(scope, newValue);
      };
      var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
      var hasFocus;
      var selected;
      var scope = originalScope.$new();
      var offDestroy = originalScope.$on('$destroy', function() {
        scope.$destroy();
      });
      scope.$on('$destroy', offDestroy);
      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      element.attr({
        'aria-autocomplete': 'list',
        'aria-expanded': false,
        'aria-owns': popupId
      });
      var inputsContainer,
          hintInputElem;
      if (showHint) {
        inputsContainer = angular.element('<div></div>');
        inputsContainer.css('position', 'relative');
        element.after(inputsContainer);
        hintInputElem = element.clone();
        hintInputElem.attr('placeholder', '');
        hintInputElem.attr('tabindex', '-1');
        hintInputElem.val('');
        hintInputElem.css({
          'position': 'absolute',
          'top': '0px',
          'left': '0px',
          'border-color': 'transparent',
          'box-shadow': 'none',
          'opacity': 1,
          'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
          'color': '#999'
        });
        element.css({
          'position': 'relative',
          'vertical-align': 'top',
          'background-color': 'transparent'
        });
        inputsContainer.append(hintInputElem);
        hintInputElem.after(element);
      }
      var popUpEl = angular.element('<div uib-typeahead-popup></div>');
      popUpEl.attr({
        id: popupId,
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx, evt)',
        'move-in-progress': 'moveInProgress',
        query: 'query',
        position: 'position',
        'assign-is-open': 'assignIsOpen(isOpen)',
        debounce: 'debounceUpdate'
      });
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }
      if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
        popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
      }
      var resetHint = function() {
        if (showHint) {
          hintInputElem.val('');
        }
      };
      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr('aria-expanded', false);
        resetHint();
      };
      var getMatchId = function(index) {
        return popupId + '-option-' + index;
      };
      scope.$watch('activeIdx', function(index) {
        if (index < 0) {
          element.removeAttr('aria-activedescendant');
        } else {
          element.attr('aria-activedescendant', getMatchId(index));
        }
      });
      var inputIsExactMatch = function(inputValue, index) {
        if (scope.matches.length > index && inputValue) {
          return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
        }
        return false;
      };
      var getMatchesAsync = function(inputValue, evt) {
        var locals = {$viewValue: inputValue};
        isLoadingSetter(originalScope, true);
        isNoResultsSetter(originalScope, false);
        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
          var onCurrentRequest = inputValue === modelCtrl.$viewValue;
          if (onCurrentRequest && hasFocus) {
            if (matches && matches.length > 0) {
              scope.activeIdx = focusFirst ? 0 : -1;
              isNoResultsSetter(originalScope, false);
              scope.matches.length = 0;
              for (var i = 0; i < matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  id: getMatchId(i),
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }
              scope.query = inputValue;
              recalculatePosition();
              element.attr('aria-expanded', true);
              if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                  $$debounce(function() {
                    scope.select(0, evt);
                  }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                } else {
                  scope.select(0, evt);
                }
              }
              if (showHint) {
                var firstLabel = scope.matches[0].label;
                if (angular.isString(inputValue) && inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                  hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
                } else {
                  hintInputElem.val('');
                }
              }
            } else {
              resetMatches();
              isNoResultsSetter(originalScope, true);
            }
          }
          if (onCurrentRequest) {
            isLoadingSetter(originalScope, false);
          }
        }, function() {
          resetMatches();
          isLoadingSetter(originalScope, false);
          isNoResultsSetter(originalScope, true);
        });
      };
      if (appendToBody) {
        angular.element($window).on('resize', fireRecalculating);
        $document.find('body').on('scroll', fireRecalculating);
      }
      var debouncedRecalculate = $$debounce(function() {
        if (scope.matches.length) {
          recalculatePosition();
        }
        scope.moveInProgress = false;
      }, eventDebounceTime);
      scope.moveInProgress = false;
      function fireRecalculating() {
        if (!scope.moveInProgress) {
          scope.moveInProgress = true;
          scope.$digest();
        }
        debouncedRecalculate();
      }
      function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element);
        scope.position.top += element.prop('offsetHeight');
      }
      scope.query = undefined;
      var timeoutPromise;
      var scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function() {
          getMatchesAsync(inputValue);
        }, waitTime);
      };
      var cancelPreviousTimeout = function() {
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
      };
      resetMatches();
      scope.assignIsOpen = function(isOpen) {
        isOpenSetter(originalScope, isOpen);
      };
      scope.select = function(activeIdx, evt) {
        var locals = {};
        var model,
            item;
        selected = true;
        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);
        modelCtrl.$setValidity('parse', true);
        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals),
          $event: evt
        });
        resetMatches();
        if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
          $timeout(function() {
            element[0].focus();
          }, 0, false);
        }
      };
      element.on('keydown', function(evt) {
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }
        if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13) || evt.which === 9 && !!evt.shiftKey) {
          resetMatches();
          scope.$digest();
          return;
        }
        evt.preventDefault();
        var target;
        switch (evt.which) {
          case 9:
          case 13:
            scope.$apply(function() {
              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                $$debounce(function() {
                  scope.select(scope.activeIdx, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
              } else {
                scope.select(scope.activeIdx, evt);
              }
            });
            break;
          case 27:
            evt.stopPropagation();
            resetMatches();
            originalScope.$digest();
            break;
          case 38:
            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
            scope.$digest();
            target = popUpEl.find('li')[scope.activeIdx];
            target.parentNode.scrollTop = target.offsetTop;
            break;
          case 40:
            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
            scope.$digest();
            target = popUpEl.find('li')[scope.activeIdx];
            target.parentNode.scrollTop = target.offsetTop;
            break;
        }
      });
      element.bind('focus', function(evt) {
        hasFocus = true;
        if (minLength === 0 && !modelCtrl.$viewValue) {
          $timeout(function() {
            getMatchesAsync(modelCtrl.$viewValue, evt);
          }, 0);
        }
      });
      element.bind('blur', function(evt) {
        if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
          selected = true;
          scope.$apply(function() {
            if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
              $$debounce(function() {
                scope.select(scope.activeIdx, evt);
              }, scope.debounceUpdate.blur);
            } else {
              scope.select(scope.activeIdx, evt);
            }
          });
        }
        if (!isEditable && modelCtrl.$error.editable) {
          modelCtrl.$setViewValue();
          modelCtrl.$setValidity('editable', true);
          modelCtrl.$setValidity('parse', true);
          element.val('');
        }
        hasFocus = false;
        selected = false;
      });
      var dismissClickHandler = function(evt) {
        if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
          resetMatches();
          if (!$rootScope.$$phase) {
            originalScope.$digest();
          }
        }
      };
      $document.on('click', dismissClickHandler);
      originalScope.$on('$destroy', function() {
        $document.off('click', dismissClickHandler);
        if (appendToBody || appendTo) {
          $popup.remove();
        }
        if (appendToBody) {
          angular.element($window).off('resize', fireRecalculating);
          $document.find('body').off('scroll', fireRecalculating);
        }
        popUpEl.remove();
        if (showHint) {
          inputsContainer.remove();
        }
      });
      var $popup = $compile(popUpEl)(scope);
      if (appendToBody) {
        $document.find('body').append($popup);
      } else if (appendTo) {
        angular.element(appendTo).eq(0).append($popup);
      } else {
        element.after($popup);
      }
      this.init = function(_modelCtrl, _ngModelOptions) {
        modelCtrl = _modelCtrl;
        ngModelOptions = _ngModelOptions;
        scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);
        modelCtrl.$parsers.unshift(function(inputValue) {
          hasFocus = true;
          if (minLength === 0 || inputValue && inputValue.length >= minLength) {
            if (waitTime > 0) {
              cancelPreviousTimeout();
              scheduleSearchWithTimeout(inputValue);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            cancelPreviousTimeout();
            resetMatches();
          }
          if (isEditable) {
            return inputValue;
          }
          if (!inputValue) {
            modelCtrl.$setValidity('editable', true);
            return null;
          }
          modelCtrl.$setValidity('editable', false);
          return undefined;
        });
        modelCtrl.$formatters.push(function(modelValue) {
          var candidateViewValue,
              emptyViewValue;
          var locals = {};
          if (!isEditable) {
            modelCtrl.$setValidity('editable', true);
          }
          if (inputFormatter) {
            locals.$model = modelValue;
            return inputFormatter(originalScope, locals);
          }
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);
          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
        });
      };
    }]).directive('uibTypeahead', function() {
      return {
        controller: 'UibTypeaheadController',
        require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
        link: function(originalScope, element, attrs, ctrls) {
          ctrls[2].init(ctrls[0], ctrls[1]);
        }
      };
    }).directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {
      return {
        scope: {
          matches: '=',
          query: '=',
          active: '=',
          position: '&',
          moveInProgress: '=',
          select: '&',
          assignIsOpen: '&',
          debounce: '&'
        },
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
        },
        link: function(scope, element, attrs) {
          scope.templateUrl = attrs.templateUrl;
          scope.isOpen = function() {
            var isDropdownOpen = scope.matches.length > 0;
            scope.assignIsOpen({isOpen: isDropdownOpen});
            return isDropdownOpen;
          };
          scope.isActive = function(matchIdx) {
            return scope.active === matchIdx;
          };
          scope.selectActive = function(matchIdx) {
            scope.active = matchIdx;
          };
          scope.selectMatch = function(activeIdx, evt) {
            var debounce = scope.debounce();
            if (angular.isNumber(debounce) || angular.isObject(debounce)) {
              $$debounce(function() {
                scope.select({
                  activeIdx: activeIdx,
                  evt: evt
                });
              }, angular.isNumber(debounce) ? debounce : debounce['default']);
            } else {
              scope.select({
                activeIdx: activeIdx,
                evt: evt
              });
            }
          };
        }
      };
    }]).directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
      return {
        scope: {
          index: '=',
          match: '=',
          query: '='
        },
        link: function(scope, element, attrs) {
          var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
          $templateRequest(tplUrl).then(function(tplContent) {
            var tplEl = angular.element(tplContent.trim());
            element.replaceWith(tplEl);
            $compile(tplEl)(scope);
          });
        }
      };
    }]).filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
      var isSanitizePresent;
      isSanitizePresent = $injector.has('$sanitize');
      function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      }
      function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
      }
      return function(matchItem, query) {
        if (!isSanitizePresent && containsHtml(matchItem)) {
          $log.warn('Unsafe use of typeahead please use ngSanitize');
        }
        matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
        if (!isSanitizePresent) {
          matchItem = $sce.trustAsHtml(matchItem);
        }
        return matchItem;
      };
    }]);
    angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/accordion/accordion-group.html", "<div class=\"panel\" ng-class=\"panelClass || 'panel-default'\">\n" + "  <div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" + "    <h4 class=\"panel-title\">\n" + "      <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" + "    </h4>\n" + "  </div>\n" + "  <div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" + "    <div class=\"panel-body\" ng-transclude></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/accordion/accordion.html", "<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>");
    }]);
    angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/alert/alert.html", "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" + "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" + "        <span aria-hidden=\"true\">&times;</span>\n" + "        <span class=\"sr-only\">Close</span>\n" + "    </button>\n" + "    <div ng-transclude></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/carousel/carousel.html", "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" + "  <div class=\"carousel-inner\" ng-transclude></div>\n" + "  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" + "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" + "    <span class=\"sr-only\">previous</span>\n" + "  </a>\n" + "  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" + "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" + "    <span class=\"sr-only\">next</span>\n" + "  </a>\n" + "  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" + "    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" + "      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" + "    </li>\n" + "  </ol>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/carousel/slide.html", "<div ng-class=\"{\n" + "    'active': active\n" + "  }\" class=\"item text-center\" ng-transclude></div>\n" + "");
    }]);
    angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/datepicker/datepicker.html", "<div class=\"uib-datepicker\" ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" + "  <uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"></uib-daypicker>\n" + "  <uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"></uib-monthpicker>\n" + "  <uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"></uib-yearpicker>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/datepicker/day.html", "<table class=\"uib-daypicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "    <tr>\n" + "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" + "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default btn-sm\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/datepicker/month.html", "<table class=\"uib-monthpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/datepicker/year.html", "<table class=\"uib-yearpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" + "        id=\"{{::dt.uid}}\"\n" + "        ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" class=\"btn btn-default\"\n" + "          uib-is-class=\"\n" + "            'btn-info' for selectedDt,\n" + "            'active' for activeDt\n" + "            on dt\"\n" + "          ng-click=\"select(dt.date)\"\n" + "          ng-disabled=\"::dt.disabled\"\n" + "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/datepickerPopup/popup.html", "<div>\n" + "  <ul class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" + "    <li ng-transclude></li>\n" + "    <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\n" + "      <span class=\"btn-group pull-left\">\n" + "        <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today', $event)\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" + "        <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText('clear') }}</button>\n" + "      </span>\n" + "      <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText('close') }}</button>\n" + "    </li>\n" + "  </ul>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/modal/backdrop.html", "<div class=\"modal-backdrop\"\n" + "     uib-modal-animation-class=\"fade\"\n" + "     modal-in-class=\"in\"\n" + "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" + "></div>\n" + "");
    }]);
    angular.module("uib/template/modal/window.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/modal/window.html", "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" + "    uib-modal-animation-class=\"fade\"\n" + "    modal-in-class=\"in\"\n" + "    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\">\n" + "    <div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/pager/pager.html", "<ul class=\"pager\">\n" + "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" + "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" + "</ul>\n" + "");
    }]);
    angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/pagination/pagination.html", "<ul class=\"pagination\">\n" + "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" + "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" + "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" + "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" + "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" + "</ul>\n" + "");
    }]);
    angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/tooltip/tooltip-html-popup.html", "<div class=\"tooltip\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/tooltip/tooltip-popup.html", "<div class=\"tooltip\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/tooltip/tooltip-template-popup.html", "<div class=\"tooltip\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\"\n" + "    uib-tooltip-template-transclude=\"contentExp()\"\n" + "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/popover/popover-html.html", "<div class=\"popover\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/popover/popover-template.html", "<div class=\"popover\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "      <div class=\"popover-content\"\n" + "        uib-tooltip-template-transclude=\"contentExp()\"\n" + "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/popover/popover.html", "<div class=\"popover\"\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\n" + "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/progressbar/bar.html", "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" + "");
    }]);
    angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/progressbar/progress.html", "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
    }]);
    angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/progressbar/progressbar.html", "<div class=\"progress\">\n" + "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/rating/rating.html", "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\n" + "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" + "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\"></i>\n" + "</span>\n" + "");
    }]);
    angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/tabs/tab.html", "<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\n" + "  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\n" + "</li>\n" + "");
    }]);
    angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/tabs/tabset.html", "<div>\n" + "  <ul class=\"nav nav-{{tabset.type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" + "  <div class=\"tab-content\">\n" + "    <div class=\"tab-pane\"\n" + "         ng-repeat=\"tab in tabset.tabs\"\n" + "         ng-class=\"{active: tabset.active === tab.index}\"\n" + "         uib-tab-content-transclude=\"tab\">\n" + "    </div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/timepicker/timepicker.html", "<table class=\"uib-timepicker\">\n" + "  <tbody>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "    <tr>\n" + "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" + "        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td class=\"uib-separator\">:</td>\n" + "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" + "        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" + "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" + "        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\n" + "      </td>\n" + "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" + "    </tr>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" + "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/typeahead/typeahead-match.html", "<a href\n" + "   tabindex=\"-1\"\n" + "   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\n" + "   ng-attr-title=\"{{match.label}}\"></a>\n" + "");
    }]);
    angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" + "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" + "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" + "    </li>\n" + "</ul>\n" + "");
    }]);
    angular.module('ui.bootstrap.carousel').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');
      angular.$$uibCarouselCss = true;
    });
    angular.module('ui.bootstrap.datepicker').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>');
      angular.$$uibDatepickerCss = true;
    });
    angular.module('ui.bootstrap.position').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>');
      angular.$$uibPositionCss = true;
    });
    angular.module('ui.bootstrap.datepickerPopup').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>');
      angular.$$uibDatepickerpopupCss = true;
    });
    angular.module('ui.bootstrap.tooltip').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>');
      angular.$$uibTooltipCss = true;
    });
    angular.module('ui.bootstrap.timepicker').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>');
      angular.$$uibTimepickerCss = true;
    });
    angular.module('ui.bootstrap.typeahead').run(function() {
      !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>');
      angular.$$uibTypeaheadCss = true;
    });
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular-ui/bootstrap-bower@1.3.2/index.js", ["./ui-bootstrap-tpls"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('./ui-bootstrap-tpls');
  module.exports = 'ui.bootstrap';
  return module.exports;
});

System.registerDynamic("github:angular-ui/bootstrap-bower@1.3.2.js", ["github:angular-ui/bootstrap-bower@1.3.2/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:angular-ui/bootstrap-bower@1.3.2/index.js');
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular@1.5.4/angular.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.5.4/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = window.document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj))
          return false;
        if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
          return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item == 'function');
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else if (src.nodeName) {
                dst[key] = src.cloneNode(true);
              } else if (isElement(src)) {
                dst[key] = src.clone();
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function valueRef() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
      function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      function isArrayBuffer(obj) {
        return toString.call(obj) === '[object ArrayBuffer]';
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination) {
        var stackSource = [];
        var stackDest = [];
        if (destination) {
          if (isTypedArray(destination) || isArrayBuffer(destination)) {
            throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
          }
          if (source === destination) {
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          }
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              if (key !== '$$hashKey') {
                delete destination[key];
              }
            });
          }
          stackSource.push(source);
          stackDest.push(destination);
          return copyRecurse(source, destination);
        }
        return copyElement(source);
        function copyRecurse(source, destination) {
          var h = destination.$$hashKey;
          var key;
          if (isArray(source)) {
            for (var i = 0,
                ii = source.length; i < ii; i++) {
              destination.push(copyElement(source[i]));
            }
          } else if (isBlankObject(source)) {
            for (key in source) {
              destination[key] = copyElement(source[key]);
            }
          } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
              if (source.hasOwnProperty(key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          } else {
            for (key in source) {
              if (hasOwnProperty.call(source, key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          }
          setHashKey(destination, h);
          return destination;
        }
        function copyElement(source) {
          if (!isObject(source)) {
            return source;
          }
          var index = stackSource.indexOf(source);
          if (index !== -1) {
            return stackDest[index];
          }
          if (isWindow(source) || isScope(source)) {
            throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
          }
          var needsRecurse = false;
          var destination = copyType(source);
          if (destination === undefined) {
            destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
            needsRecurse = true;
          }
          stackSource.push(source);
          stackDest.push(destination);
          return needsRecurse ? copyRecurse(source, destination) : destination;
        }
        function copyType(source) {
          switch (toString.call(source)) {
            case '[object Int8Array]':
            case '[object Int16Array]':
            case '[object Int32Array]':
            case '[object Float32Array]':
            case '[object Float64Array]':
            case '[object Uint8Array]':
            case '[object Uint8ClampedArray]':
            case '[object Uint16Array]':
            case '[object Uint32Array]':
              return new source.constructor(copyElement(source.buffer));
            case '[object ArrayBuffer]':
              if (!source.slice) {
                var copied = new ArrayBuffer(source.byteLength);
                new Uint8Array(copied).set(new Uint8Array(source));
                return copied;
              }
              return source.slice(0);
            case '[object Boolean]':
            case '[object Number]':
            case '[object String]':
            case '[object Date]':
              return new source.constructor(source.valueOf());
            case '[object RegExp]':
              var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              re.lastIndex = source.lastIndex;
              return re;
            case '[object Blob]':
              return new source.constructor([source], {type: source.type});
          }
          if (isFunction(source.cloneNode)) {
            return source.cloneNode(true);
          }
        }
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2 && t1 == 'object') {
          if (isArray(o1)) {
            if (!isArray(o2))
              return false;
            if ((length = o1.length) == o2.length) {
              for (key = 0; key < length; key++) {
                if (!equals(o1[key], o2[key]))
                  return false;
              }
              return true;
            }
          } else if (isDate(o1)) {
            if (!isDate(o2))
              return false;
            return equals(o1.getTime(), o2.getTime());
          } else if (isRegExp(o1)) {
            if (!isRegExp(o2))
              return false;
            return o1.toString() == o2.toString();
          } else {
            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
              return false;
            keySet = createMap();
            for (key in o1) {
              if (key.charAt(0) === '$' || isFunction(o1[key]))
                continue;
              if (!equals(o1[key], o2[key]))
                return false;
              keySet[key] = true;
            }
            for (key in o2) {
              if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                return false;
            }
            return true;
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (window.document.querySelector('[ng-csp]') || window.document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && window.document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (isUndefined(obj))
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      var ALL_COLONS = /:/g;
      function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, '');
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === window.document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App already bootstrapped with this element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            for (var i = 0,
                elem; (elem = elems[i]) != null; i++) {
              events = jQuery._data(elem, "events");
              if (events && events.$destroy) {
                jQuery(elem).triggerHandler('$destroy');
              }
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.5.4',
        major: 1,
        minor: 5,
        dot: 4,
        codeName: 'graduated-sophistry'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteCleanData(nodes) {
        for (var i = 0,
            ii = nodes.length; i < ii; i++) {
          jqLiteRemoveData(nodes[i]);
        }
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        if (parent) {
          parent.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
      }
      var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
      };
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          var removeHandler = function(type) {
            var listenerFns = events[type];
            if (isDefined(fn)) {
              arrayRemove(listenerFns || [], fn);
            }
            if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
              removeEventListenerFn(element, type, handle);
              delete events[type];
            }
          };
          forEach(type.split(' '), function(type) {
            removeHandler(type);
            if (MOUSE_EVENT_MAP[type]) {
              removeHandler(MOUSE_EVENT_MAP[type]);
            }
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (window.document.readyState === 'complete') {
            window.setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: jqLiteCleanData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              handlerWrapper(element, event, eventFns[i]);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
      }
      function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || (related !== target && !jqLiteContains.call(target, related))) {
          handler.call(target, event);
        }
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          var addHandler = function(type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            if (!eventFns) {
              eventFns = events[type] = [];
              eventFns.specialHandlerWrapper = specialHandlerWrapper;
              if (type !== '$destroy' && !noEventListener) {
                addEventListenerFn(element, type, handle);
              }
            }
            eventFns.push(fn);
          };
          while (i--) {
            type = types[i];
            if (MOUSE_EVENT_MAP[type]) {
              addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
              addHandler(type, undefined, true);
            } else {
              addHandler(type);
            }
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var ARROW_ARG = /^([^\(]+?)=>/;
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function extractArgs(fn) {
        var fnText = Function.prototype.toString.call(fn).replace(STRIP_COMMENTS, ''),
            args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
      }
      function anonFn(fn) {
        var args = extractArgs(fn);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              argDecl = extractArgs(fn);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }),
            instanceInjector = protoInstanceInjector;
        providerCache['$injector' + providerSuffix] = {$get: valueFn(protoInstanceInjector)};
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get('$injector');
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function injectionArgs(fn, locals, serviceName) {
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName);
            for (var i = 0,
                length = $inject.length; i < length; i++) {
              var key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            return args;
          }
          function isClass(func) {
            if (msie <= 11) {
              return false;
            }
            return typeof func === 'function' && /^(?:class\s|constructor\()/.test(Function.prototype.toString.call(func));
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = injectionArgs(fn, locals, serviceName);
            if (isArray(fn)) {
              fn = fn[fn.length - 1];
            }
            if (!isClass(fn)) {
              return fn.apply(self, args);
            } else {
              args.unshift(null);
              return new (Function.prototype.bind.apply(fn, args))();
            }
          }
          function instantiate(Type, locals, serviceName) {
            var ctor = (isArray(Type) ? Type[Type.length - 1] : Type);
            var args = injectionArgs(Type, locals, serviceName);
            args.unshift(null);
            return new (Function.prototype.bind.apply(ctor, args))();
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateJsProvider = function() {
        this.$get = noop;
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              var runner = new $$AnimateRunner();
              runner.complete();
              return runner;
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = ['$$rAF', function($$rAF) {
          var waitQueue = [];
          function waitForTick(fn) {
            waitQueue.push(fn);
            if (waitQueue.length > 1)
              return;
            $$rAF(function() {
              for (var i = 0; i < waitQueue.length; i++) {
                waitQueue[i]();
              }
              waitQueue = [];
            });
          }
          return function() {
            var passed = false;
            waitForTick(function() {
              passed = true;
            });
            return function(callback) {
              passed ? callback() : waitForTick(callback);
            };
          };
        }];
      };
      var $$AnimateRunnerFactoryProvider = function() {
        this.$get = ['$q', '$sniffer', '$$animateAsyncRun', '$document', '$timeout', function($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
          var INITIAL_STATE = 0;
          var DONE_PENDING_STATE = 1;
          var DONE_COMPLETE_STATE = 2;
          AnimateRunner.chain = function(chain, callback) {
            var index = 0;
            next();
            function next() {
              if (index === chain.length) {
                callback(true);
                return;
              }
              chain[index](function(response) {
                if (response === false) {
                  callback(false);
                  return;
                }
                index++;
                next();
              });
            }
          };
          AnimateRunner.all = function(runners, callback) {
            var count = 0;
            var status = true;
            forEach(runners, function(runner) {
              runner.done(onProgress);
            });
            function onProgress(response) {
              status = status && response;
              if (++count === runners.length) {
                callback(status);
              }
            }
          };
          function AnimateRunner(host) {
            this.setHost(host);
            var rafTick = $$animateAsyncRun();
            var timeoutTick = function(fn) {
              $timeout(fn, 0, false);
            };
            this._doneCallbacks = [];
            this._tick = function(fn) {
              var doc = $document[0];
              if (doc && doc.hidden) {
                timeoutTick(fn);
              } else {
                rafTick(fn);
              }
            };
            this._state = 0;
          }
          AnimateRunner.prototype = {
            setHost: function(host) {
              this.host = host || {};
            },
            done: function(fn) {
              if (this._state === DONE_COMPLETE_STATE) {
                fn();
              } else {
                this._doneCallbacks.push(fn);
              }
            },
            progress: noop,
            getPromise: function() {
              if (!this.promise) {
                var self = this;
                this.promise = $q(function(resolve, reject) {
                  self.done(function(status) {
                    status === false ? reject() : resolve();
                  });
                });
              }
              return this.promise;
            },
            then: function(resolveHandler, rejectHandler) {
              return this.getPromise().then(resolveHandler, rejectHandler);
            },
            'catch': function(handler) {
              return this.getPromise()['catch'](handler);
            },
            'finally': function(handler) {
              return this.getPromise()['finally'](handler);
            },
            pause: function() {
              if (this.host.pause) {
                this.host.pause();
              }
            },
            resume: function() {
              if (this.host.resume) {
                this.host.resume();
              }
            },
            end: function() {
              if (this.host.end) {
                this.host.end();
              }
              this._resolve(true);
            },
            cancel: function() {
              if (this.host.cancel) {
                this.host.cancel();
              }
              this._resolve(false);
            },
            complete: function(response) {
              var self = this;
              if (self._state === INITIAL_STATE) {
                self._state = DONE_PENDING_STATE;
                self._tick(function() {
                  self._resolve(response);
                });
              }
            },
            _resolve: function(response) {
              if (this._state !== DONE_COMPLETE_STATE) {
                forEach(this._doneCallbacks, function(fn) {
                  fn(response);
                });
                this._doneCallbacks.length = 0;
                this._state = DONE_COMPLETE_STATE;
              }
            }
          };
          return AnimateRunner;
        }];
      };
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, $$AnimateRunner) {
          return function(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = copy(options);
            }
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new $$AnimateRunner();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                applyAnimationContents();
                if (!closed) {
                  runner.complete();
                }
                closed = true;
              });
              return runner;
            }
            function applyAnimationContents() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null,
            getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
              try {
                return history.state;
              } catch (e) {}
            };
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase || pendingLocation) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = createMap(),
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = createMap(),
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                if (!(key in data))
                  return;
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = createMap();
                size = 0;
                lruHash = createMap();
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      function UNINITIALIZED_VALUE() {}
      var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        var bindingCache = createMap();
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = createMap();
          forEach(scope, function(definition, scopeName) {
            if (definition in bindingCache) {
              bindings[scopeName] = bindingCache[definition];
              return;
            }
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
            if (match[4]) {
              bindingCache[definition] = bindings[scopeName];
            }
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = directive.require || (directive.controller && directive.name);
                    directive.restrict = directive.restrict || 'EA';
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.component = function registerComponent(name, options) {
          var controller = options.controller || function() {};
          function factory($injector) {
            function makeInjectable(fn) {
              if (isFunction(fn) || isArray(fn)) {
                return function(tElement, tAttrs) {
                  return $injector.invoke(fn, this, {
                    $element: tElement,
                    $attrs: tAttrs
                  });
                };
              } else {
                return fn;
              }
            }
            var template = (!options.template && !options.templateUrl ? '' : options.template);
            var ddo = {
              controller: controller,
              controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
              template: makeInjectable(template),
              templateUrl: makeInjectable(options.templateUrl),
              transclude: options.transclude,
              scope: {},
              bindToController: options.bindings || {},
              restrict: 'E',
              require: options.require
            };
            forEach(options, function(val, key) {
              if (key.charAt(0) === '$')
                ddo[key] = val;
            });
            return ddo;
          }
          forEach(options, function(val, key) {
            if (key.charAt(0) === '$') {
              factory[key] = val;
              if (isFunction(controller))
                controller[key] = val;
            }
          });
          factory.$inject = ['$injector'];
          return this.directive(name, factory);
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
          if (arguments.length) {
            TTL = value;
            return this;
          }
          return TTL;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
          var SIMPLE_ATTR_NAME = /^\w/;
          var specialAttrHolder = window.document.createElement('div');
          var onChangesTtl = TTL;
          var onChangesQueue;
          function flushOnChangesQueue() {
            try {
              if (!(--onChangesTtl)) {
                onChangesQueue = undefined;
                throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
              }
              $rootScope.$apply(function() {
                for (var i = 0,
                    ii = onChangesQueue.length; i < ii; ++i) {
                  onChangesQueue[i]();
                }
                onChangesQueue = undefined;
              });
            } finally {
              onChangesTtl++;
            }
          }
          function Attributes(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          }
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && (key === 'href' || key === 'xlinkHref')) || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset') {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  if (SIMPLE_ATTR_NAME.test(attrName)) {
                    this.$$element.attr(attrName, value);
                  } else {
                    setSpecialAttr(this.$$element[0], attrName, value);
                  }
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function setSpecialAttr(element, attrName, value) {
            specialAttrHolder.innerHTML = "<span " + attrName + ">";
            var attributes = specialAttrHolder.firstChild.attributes;
            var attribute = attributes[0];
            attributes.removeNamedItem(attribute.name);
            attribute.value = value;
            element.attributes.setNamedItem(attribute);
          }
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' && endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          compile.$$createComment = function(directiveName, comment) {
            var content = '';
            if (debugInfoEnabled) {
              content = ' ' + (directiveName || '') + ': ' + (comment || '') + ' ';
            }
            return window.document.createComment(content);
          };
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            var NOT_EMPTY = /\S+/;
            for (var i = 0,
                len = $compileNodes.length; i < len; i++) {
              var domNode = $compileNodes[i];
              if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
                jqLiteWrapNode(domNode, $compileNodes[i] = window.document.createElement('span'));
              }
            }
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              if (previousCompileContext && previousCompileContext.needsNewScope) {
                scope = scope.$parent.$new();
              }
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            }
            var boundSlots = boundTranscludeFn.$$slots = createMap();
            for (var slotName in transcludeFn.$$slots) {
              if (transcludeFn.$$slots[slotName]) {
                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
              } else {
                boundSlots[slotName] = null;
              }
            }
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                  if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                    attrStartName = name;
                    attrEndName = name.substr(0, name.length - 5) + 'end';
                    name = name.substr(0, name.length - 6);
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            var compiled;
            if (eager) {
              return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
            }
            return function lazyCompilation() {
              if (!compiled) {
                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                $compileNodes = transcludeFn = previousCompileContext = null;
              }
              return compiled.apply(this, arguments);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                didScanForMultipleTransclusion = false,
                mightHaveMultipleTransclusionError = false,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) || (directive.transclude && !directive.$$tlb))) {
                var candidateDirective;
                for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                  if ((candidateDirective.transclude && !candidateDirective.$$tlb) || (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template))) {
                    mightHaveMultipleTransclusionError = true;
                    break;
                  }
                }
                didScanForMultipleTransclusion = true;
              }
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  $template[0].$$parentNode = $template[0].parentNode;
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  var slots = createMap();
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  if (isObject(directiveValue)) {
                    $template = [];
                    var slotMap = createMap();
                    var filledSlots = createMap();
                    forEach(directiveValue, function(elementSelector, slotName) {
                      var optional = (elementSelector.charAt(0) === '?');
                      elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                      slotMap[elementSelector] = slotName;
                      slots[slotName] = null;
                      filledSlots[slotName] = optional;
                    });
                    forEach($compileNode.contents(), function(node) {
                      var slotName = slotMap[directiveNormalize(nodeName_(node))];
                      if (slotName) {
                        filledSlots[slotName] = true;
                        slots[slotName] = slots[slotName] || [];
                        slots[slotName].push(node);
                      } else {
                        $template.push(node);
                      }
                    });
                    forEach(filledSlots, function(filled, slotName) {
                      if (!filled) {
                        throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                      }
                    });
                    for (var slotName in slots) {
                      if (slots[slotName]) {
                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                      }
                    }
                  }
                  $compileNode.empty();
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {needsNewScope: directive.$$isolateScope || directive.$$newScope});
                  childTranscludeFn.$$slots = slots;
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective || newScopeDirective) {
                    markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  if (isFunction(linkFn)) {
                    addLinkFns(null, linkFn, attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
              var i,
                  ii,
                  linkFn,
                  isolateScope,
                  controllerScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs,
                  scopeBindingInfo;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              controllerScope = scope;
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              } else if (newScopeDirective) {
                controllerScope = scope.$parent;
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
                transcludeFn.isSlotFilled = function(slotName) {
                  return !!boundTranscludeFn.$$slots[slotName];
                };
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                if (scopeBindingInfo.removeWatches) {
                  isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);
                }
              }
              for (var name in elementControllers) {
                var controllerDirective = controllerDirectives[name];
                var controller = elementControllers[name];
                var bindings = controllerDirective.$$bindings.bindToController;
                if (controller.identifier && bindings) {
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                } else {
                  controller.bindingInfo = {};
                }
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches();
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
                $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
              }
              forEach(controllerDirectives, function(controllerDirective, name) {
                var require = controllerDirective.require;
                if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                  extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                }
              });
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$onChanges)) {
                  controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                }
                if (isFunction(controllerInstance.$onInit)) {
                  controllerInstance.$onInit();
                }
                if (isFunction(controllerInstance.$onDestroy)) {
                  controllerScope.$on('$destroy', function callOnDestroyHook() {
                    controllerInstance.$onDestroy();
                  });
                }
              });
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$postLink)) {
                  controllerInstance.$postLink();
                }
              });
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  slotName = futureParentElement;
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                if (slotName) {
                  var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                  if (slotTranscludeFn) {
                    return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                  } else if (isUndefined(slotTranscludeFn)) {
                    throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                  }
                } else {
                  return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                }
              }
            }
          }
          function getControllers(directiveName, require, $element, elementControllers) {
            var value;
            if (isString(require)) {
              var match = require.match(REQUIRE_PREFIX_REGEXP);
              var name = require.substring(match[0].length);
              var inheritType = match[1] || match[3];
              var optional = match[2] === '?';
              if (inheritType === '^^') {
                $element = $element.parent();
              } else {
                value = elementControllers && elementControllers[name];
                value = value && value.instance;
              }
              if (!value) {
                var dataName = '$' + name + 'Controller';
                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
              }
              if (!value && !optional) {
                throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
              }
            } else if (isArray(require)) {
              value = [];
              for (var i = 0,
                  ii = require.length; i < ii; i++) {
                value[i] = getControllers(directiveName, require[i], $element, elementControllers);
              }
            } else if (isObject(require)) {
              value = {};
              forEach(require, function(controller, property) {
                value[property] = getControllers(directiveName, controller, $element, elementControllers);
              });
            }
            return value || null;
          }
          function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
            var elementControllers = createMap();
            for (var controllerKey in controllerDirectives) {
              var directive = controllerDirectives[controllerKey];
              var locals = {
                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                $element: $element,
                $attrs: attrs,
                $transclude: transcludeFn
              };
              var controller = directive.controller;
              if (controller == '@') {
                controller = attrs[directive.name];
              }
              elementControllers[directive.name] = $controller(controller, locals, true, directive.controllerAs);
            }
            return elementControllers;
          }
          function markDirectiveScope(directives, isolateScope, newScope) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {
                $$isolateScope: isolateScope,
                $$newScope: newScope
              });
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    if (!directive.$$bindings) {
                      var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                      if (isObject(bindings.isolateScope)) {
                        directive.$$isolateBindings = bindings.isolateScope;
                      }
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (key == 'class') {
                safeAddClass($element, value);
                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
              } else if (key == 'style') {
                $element.attr('style', $element.attr('style') + ';' + value);
                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
              } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                dst[key] = value;
                dstAttr[key] = srcAttr[key];
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = window.document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = window.document.createDocumentFragment();
            for (i = 0; i < removeCount; i++) {
              fragment.appendChild(elementsToRemove[i]);
            }
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite.data(newNode, jqLite.data(firstElementToRemove));
              jqLite(firstElementToRemove).off('$destroy');
            }
            jqLite.cleanData(fragment.querySelectorAll('*'));
            for (i = 1; i < removeCount; i++) {
              delete elementsToRemove[i];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
            var removeWatchCollection = [];
            var initialChanges = {};
            var changes;
            forEach(bindings, function initializeBinding(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare,
                  removeWatch;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value) || isBoolean(value)) {
                      var oldValue = destination[scopeName];
                      recordChanges(scopeName, value, oldValue);
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  lastValue = attrs[attrName];
                  if (isString(lastValue)) {
                    destination[scopeName] = $interpolate(lastValue)(scope);
                  } else if (isBoolean(lastValue)) {
                    destination[scopeName] = lastValue;
                  }
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function simpleCompare(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  if (definition.collection) {
                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  removeWatchCollection.push(removeWatch);
                  break;
                case '<':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  destination[scopeName] = parentGet(scope);
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                    if (newValue === oldValue) {
                      oldValue = destination[scopeName];
                    }
                    recordChanges(scopeName, newValue, oldValue);
                    destination[scopeName] = newValue;
                  }, parentGet.literal);
                  removeWatchCollection.push(removeWatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            function recordChanges(key, currentValue, previousValue) {
              if (isFunction(destination.$onChanges) && currentValue !== previousValue) {
                if (!onChangesQueue) {
                  scope.$$postDigest(flushOnChangesQueue);
                  onChangesQueue = [];
                }
                if (!changes) {
                  changes = {};
                  onChangesQueue.push(triggerOnChangesHook);
                }
                if (changes[key]) {
                  previousValue = changes[key].previousValue;
                }
                changes[key] = new SimpleChange(previousValue, currentValue);
              }
            }
            function triggerOnChangesHook() {
              destination.$onChanges(changes);
              changes = undefined;
            }
            return {
              initialChanges: initialChanges,
              removeWatches: removeWatchCollection.length && function removeWatches() {
                for (var i = 0,
                    ii = removeWatchCollection.length; i < ii; ++i) {
                  removeWatchCollection[i]();
                }
              }
            };
          }
        }];
      }
      function SimpleChange(previous, current) {
        this.previousValue = previous;
        this.currentValue = current;
      }
      SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
      };
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.has = function(name) {
          return controllers.hasOwnProperty(name);
        };
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function $controller(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function $controllerInit() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            if (!isString(requestConfig.url)) {
              throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
            }
            return promise;
            function createApplyHandlers(eventHandlers) {
              if (eventHandlers) {
                var applyHandlers = {};
                forEach(eventHandlers, function(eventHandler, key) {
                  applyHandlers[key] = function() {
                    if (useApplyAsync) {
                      $rootScope.$applyAsync(eventHandler);
                    } else if ($rootScope.$$phase) {
                      eventHandler();
                    } else {
                      $rootScope.$apply(eventHandler);
                    }
                  };
                });
                return applyHandlers;
              }
            }
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            forEach(eventHandlers, function(value, key) {
              xhr.addEventListener(key, value);
            });
            forEach(uploadEventHandlers, function(value, key) {
              xhr.upload.addEventListener(key, value);
            });
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
            var unwatch;
            return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
              unwatch();
              return constantInterp(scope);
            }, listener, objectEquality);
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            if (!text.length || text.indexOf(startSymbol) === -1) {
              var constantInterp;
              if (!mustHaveExpression) {
                var unescapedText = unescapeText(text);
                constantInterp = valueFn(unescapedText);
                constantInterp.exp = text;
                constantInterp.expressions = [];
                constantInterp.$$watchDelegate = constantWatchDelegate;
              }
              return constantInterp;
            }
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser', function($rootScope, $window, $q, $$q, $browser) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.$$intervalId = setInterval(function tick() {
              if (skipApply) {
                $browser.defer(callback);
              } else {
                $rootScope.$evalAsync(callback);
              }
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
            function callback() {
              if (!hasParams) {
                fn(iteration);
              } else {
                fn.apply(null, args);
              }
            }
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
          return whole.substr(begin.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = beginsWith(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = beginsWith(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (url.indexOf(base) === 0) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              newUrl = trimEmptyHash(newUrl);
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name) {
        return name + '';
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdentifierStart(this.peekMultichar())) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdentifierStart: function(ch) {
          return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isIdentifierContinue: function(ch) {
          return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
          return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
          if (ch.length === 1)
            return ch.charCodeAt(0);
          return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35FDC00;
        },
        peekMultichar: function() {
          var ch = this.text.charAt(this.index);
          var peek = this.peek();
          if (!peek) {
            return ch;
          }
          var cp1 = ch.charCodeAt(0);
          var cp2 = peek.charCodeAt(0);
          if (cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF) {
            return ch + peek;
          }
          return ch;
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          this.index += this.peekMultichar().length;
          while (this.index < this.text.length) {
            var ch = this.peekMultichar();
            if (!this.isIdentifierContinue(ch)) {
              break;
            }
            this.index += ch.length;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.LocalsExpression = 'LocalsExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
            primary = copy(this.selfReferential[this.consume().text]);
          } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
            primary = {
              type: AST.Literal,
              value: this.options.literals[this.consume().text]
            };
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.expression());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
              } else {
                this.throwError("invalid key", this.peek());
              }
              this.consume(':');
              property.value = this.expression();
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        selfReferential: {
          'this': {type: AST.ThisExpression},
          '$locals': {type: AST.LocalsExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
          case AST.LocalsExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (create && create !== 1) {
                    self.addEnsureSafeAssignContext(left);
                  }
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                self.recurse(property.value, self.nextId(), undefined, function(expr) {
                  args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                });
              });
              expression = '{' + args.join(',') + '}';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.LocalsExpression:
              this.assign(intoId, 'l');
              recursionFn('l');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          var SAFE_IDENTIFIER = /[$_a-zA-Z][$_a-zA-Z0-9]*/;
          var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
          if (SAFE_IDENTIFIER.test(right)) {
            return left + '.' + right;
          } else {
            return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
          }
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ')');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                args.push({
                  key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                  value: self.recurse(property.value)
                });
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.LocalsExpression:
              return function(scope, locals) {
                return context ? {value: locals} : locals;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1) {
                ensureSafeAssignContext(lhs);
                if (lhs && !(lhs[rhs])) {
                  lhs[rhs] = {};
                }
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1) {
              ensureSafeAssignContext(lhs);
              if (lhs && !(lhs[right])) {
                lhs[right] = {};
              }
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(lexer, options);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        var literals = {
          'true': true,
          'false': false,
          'null': null,
          'undefined': undefined
        };
        var identStart,
            identContinue;
        this.addLiteral = function(literalName, literalValue) {
          literals[literalName] = literalValue;
        };
        this.setIdentifierFns = function(identifierStart, identifierContinue) {
          identStart = identifierStart;
          identContinue = identifierContinue;
          return this;
        };
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false,
            literals: copy(literals),
            isIdentifierStart: isFunction(identStart) && identStart,
            isIdentifierContinue: isFunction(identContinue) && identContinue
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
              };
          var runningChecksEnabled = false;
          $parse.$$runningExpensiveChecks = function() {
            return runningChecksEnabled;
          };
          return $parse;
          function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            expensiveChecks = expensiveChecks || runningChecksEnabled;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  if (expensiveChecks) {
                    parsedExpression = expensiveChecksInterceptor(parsedExpression);
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return addInterceptor(noop, interceptorFn);
            }
          }
          function expensiveChecksInterceptor(fn) {
            if (!fn)
              return fn;
            expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
            expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
            expensiveCheckFn.constant = fn.constant;
            expensiveCheckFn.literal = fn.literal;
            for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
              fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
            }
            expensiveCheckFn.inputs = fn.inputs;
            return expensiveCheckFn;
            function expensiveCheckFn(scope, locals, assign, inputs) {
              var expensiveCheckOldValue = runningChecksEnabled;
              runningChecksEnabled = true;
              try {
                return fn(scope, locals, assign, inputs);
              } finally {
                runningChecksEnabled = expensiveCheckOldValue;
              }
            }
          }
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              unwatch();
              return parsedExpression(scope);
            }, listener, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var useInputs = false;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              useInputs = !parsedExpression.inputs;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        var defer = function() {
          var d = new Deferred();
          d.resolve = simpleBind(d, d.resolve);
          d.reject = simpleBind(d, d.reject);
          d.notify = simpleBind(d, d.notify);
          return d;
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then;
            var that = this;
            var done = false;
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              rejectPromise(e);
              exceptionHandler(e);
            }
            function resolvePromise(val) {
              if (done)
                return;
              done = true;
              that.$$resolve(val);
            }
            function rejectPromise(val) {
              if (done)
                return;
              done = true;
              that.$$reject(val);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.prototype = Promise.prototype;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$exceptionHandler', '$parse', '$browser', function($exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function cleanUpScope($scope) {
            if (msie === 9) {
              $scope.$$childHead && cleanUpScope($scope.$$childHead);
              $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
            }
            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  fn,
                  get,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                while (asyncQueue.length) {
                  try {
                    asyncTask = asyncQueue.shift();
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          get = watch.get;
                          if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            fn = watch.fn;
                            fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueue.length) {
                try {
                  postDigestQueue.shift()();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$$nextSibling = null;
              cleanUpScope(this);
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: $parse(expr),
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              expr = $parse(expr);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              isChromePackagedApp = $window.chrome && $window.chrome.app && $window.chrome.app.runtime,
              hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState,
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!(hasHistoryPushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $templateRequestMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
          if (val) {
            httpOptions = val;
            return this;
          }
          return httpOptions;
        };
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || !$templateCache.get(tpl)) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            return $http.get(tpl, extend({
              cache: $templateCache,
              transformResponse: transformResponse
            }, httpOptions))['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = window.document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      var MAX_DIGITS = 22;
      var DECIMAL_SEP = '.';
      var ZERO_CHAR = '0';
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      function parse(numStr) {
        var exponent = 0,
            digits,
            numberOfIntegerDigits;
        var i,
            j,
            zeros;
        if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
          numStr = numStr.replace(DECIMAL_SEP, '');
        }
        if ((i = numStr.search(/e/i)) > 0) {
          if (numberOfIntegerDigits < 0)
            numberOfIntegerDigits = i;
          numberOfIntegerDigits += +numStr.slice(i + 1);
          numStr = numStr.substring(0, i);
        } else if (numberOfIntegerDigits < 0) {
          numberOfIntegerDigits = numStr.length;
        }
        for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {}
        if (i == (zeros = numStr.length)) {
          digits = [0];
          numberOfIntegerDigits = 1;
        } else {
          zeros--;
          while (numStr.charAt(zeros) == ZERO_CHAR)
            zeros--;
          numberOfIntegerDigits -= i;
          digits = [];
          for (j = 0; i <= zeros; i++, j++) {
            digits[j] = +numStr.charAt(i);
          }
        }
        if (numberOfIntegerDigits > MAX_DIGITS) {
          digits = digits.splice(0, MAX_DIGITS - 1);
          exponent = numberOfIntegerDigits - 1;
          numberOfIntegerDigits = 1;
        }
        return {
          d: digits,
          e: exponent,
          i: numberOfIntegerDigits
        };
      }
      function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        var fractionLen = digits.length - parsedNumber.i;
        fractionSize = (isUndefined(fractionSize)) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i;
        var digit = digits[roundAt];
        if (roundAt > 0) {
          digits.splice(Math.max(parsedNumber.i, roundAt));
          for (var j = roundAt; j < digits.length; j++) {
            digits[j] = 0;
          }
        } else {
          fractionLen = Math.max(0, fractionLen);
          parsedNumber.i = 1;
          digits.length = Math.max(1, roundAt = fractionSize + 1);
          digits[0] = 0;
          for (var i = 1; i < roundAt; i++)
            digits[i] = 0;
        }
        if (digit >= 5) {
          if (roundAt - 1 < 0) {
            for (var k = 0; k > roundAt; k--) {
              digits.unshift(0);
              parsedNumber.i++;
            }
            digits.unshift(1);
            parsedNumber.i++;
          } else {
            digits[roundAt - 1]++;
          }
        }
        for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
          digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
          d = d + carry;
          digits[i] = d % 10;
          return Math.floor(d / 10);
        }, 0);
        if (carry) {
          digits.unshift(carry);
          parsedNumber.i++;
        }
      }
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!(isString(number) || isNumber(number)) || isNaN(number))
          return '';
        var isInfinity = !isFinite(number);
        var isZero = false;
        var numStr = Math.abs(number) + '',
            formattedText = '',
            parsedNumber;
        if (isInfinity) {
          formattedText = '\u221e';
        } else {
          parsedNumber = parse(numStr);
          roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
          var digits = parsedNumber.d;
          var integerLen = parsedNumber.i;
          var exponent = parsedNumber.e;
          var decimals = [];
          isZero = digits.reduce(function(isZero, d) {
            return isZero && !d;
          }, true);
          while (integerLen < 0) {
            digits.unshift(0);
            integerLen++;
          }
          if (integerLen > 0) {
            decimals = digits.splice(integerLen);
          } else {
            decimals = digits;
            digits = [0];
          }
          var groups = [];
          if (digits.length >= pattern.lgSize) {
            groups.unshift(digits.splice(-pattern.lgSize).join(''));
          }
          while (digits.length > pattern.gSize) {
            groups.unshift(digits.splice(-pattern.gSize).join(''));
          }
          if (digits.length) {
            groups.unshift(digits.join(''));
          }
          formattedText = groups.join(groupSep);
          if (decimals.length) {
            formattedText += decimalSep + decimals.join('');
          }
          if (exponent) {
            formattedText += 'e+' + exponent;
          }
        }
        if (number < 0 && !isZero) {
          return pattern.negPre + formattedText + pattern.negSuf;
        } else {
          return pattern.posPre + formattedText + pattern.posSuf;
        }
      }
      function padNumber(num, digits, trim, negWrap) {
        var neg = '';
        if (num < 0 || (negWrap && num <= 0)) {
          if (negWrap) {
            num = -num + 1;
          } else {
            num = -num;
            neg = '-';
          }
        }
        num = '' + num;
        while (num.length < digits)
          num = ZERO_CHAR + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim, negWrap) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim, negWrap);
        };
      }
      function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
          var value = date['get' + name]();
          var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
          var get = uppercase(propPrefix + name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4, 0, false, true),
        yy: dateGetter('FullYear', 2, 0, true, true),
        y: dateGetter('FullYear', 1, 0, false, true),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        LLLL: dateStrGetter('Month', false, true),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArray(input) && !isString(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
          if (limit >= 0) {
            return input.slice(begin, begin + limit);
          } else {
            if (begin === 0) {
              return input.slice(limit, input.length);
            } else {
              return input.slice(Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
          if (array == null)
            return array;
          if (!isArrayLike(array)) {
            throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
          }
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate, reverseOrder);
          predicates.push({
            get: function() {
              return {};
            },
            descending: reverseOrder ? -1 : 1
          });
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            var result = 0;
            for (var index = 0,
                length = predicates.length; index < length; ++index) {
              result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
              if (result)
                break;
            }
            return result;
          }
        };
        function processPredicates(sortPredicate, reverseOrder) {
          reverseOrder = reverseOrder ? -1 : 1;
          return sortPredicate.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending * reverseOrder
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value, index) {
          if (typeof value.valueOf === 'function') {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return index;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'string') {
            value = value.toLowerCase();
          } else if (type === 'object') {
            value = objectValue(value, index);
          }
          return {
            value: value,
            type: type
          };
        }
        function compare(v1, v2) {
          var result = 0;
          if (v1.type === v2.type) {
            if (v1.value !== v2.value) {
              result = v1.value < v2.value ? -1 : 1;
            }
          } else {
            result = v1.type < v2.type ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
      var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
      var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
      var PARTIAL_VALIDATION_TYPES = createMap();
      forEach('date,datetime-local,month,time,week'.split(','), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = true;
      });
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function() {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var timeout;
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
          element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
              var validity = this[VALIDITY_STATE_PROPERTY];
              var origBadInput = validity.badInput;
              var origTypeMismatch = validity.typeMismatch;
              timeout = $browser.defer(function() {
                timeout = null;
                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                  listener(ev);
                }
              });
            }
          });
        }
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
              return (value || '').toString();
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                if (isArray(newVal)) {
                  oldVal = newVal.map(function(v) {
                    return shallowCopy(v);
                  });
                } else {
                  oldVal = shallowCopy(newVal);
                }
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (toString.call($element[0]).match(/SVG/)) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending',
          EMPTY_CLASS = 'ng-empty',
          NOT_EMPTY_CLASS = 'ng-not-empty';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: newValue});
              } else {
                parsedNgModelAssign($scope, newValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        this.$$updateEmptyClasses = function(value) {
          if (ctrl.$isEmpty(value)) {
            $animate.removeClass($element, NOT_EMPTY_CLASS);
            $animate.addClass($element, EMPTY_CLASS);
          } else {
            $animate.removeClass($element, EMPTY_CLASS);
            $animate.addClass($element, NOT_EMPTY_CLASS);
          }
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr('nopromise', "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function() {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$updateEmptyClasses(viewValue);
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$$updateEmptyClasses(viewValue);
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function() {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$document', '$parse', function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var selectValue = getTrackByValueFn(value, locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = window.document.createElement('option'),
            optGroupTemplate = window.document.createElement('optgroup');
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
          var selectCtrl = ctrls[0];
          var ngModelCtrl = ctrls[1];
          var multiple = attr.multiple;
          var emptyOption;
          for (var i = 0,
              children = selectElement.children(),
              ii = children.length; i < ii; i++) {
            if (children[i].value === '') {
              emptyOption = children.eq(i);
              break;
            }
          }
          var providedEmptyOption = !!emptyOption;
          var unknownOption = jqLite(optionTemplate.cloneNode(false));
          unknownOption.val('?');
          var options;
          var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
          var listFragment = $document[0].createDocumentFragment();
          var renderEmptyOption = function() {
            if (!providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            selectElement.val('');
            emptyOption.prop('selected', true);
            emptyOption.attr('selected', true);
          };
          var removeEmptyOption = function() {
            if (!providedEmptyOption) {
              emptyOption.remove();
            }
          };
          var renderUnknownOption = function() {
            selectElement.prepend(unknownOption);
            selectElement.val('?');
            unknownOption.prop('selected', true);
            unknownOption.attr('selected', true);
          };
          var removeUnknownOption = function() {
            unknownOption.remove();
          };
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              var option = options.getOptionFromViewValue(value);
              if (option) {
                if (selectElement[0].value !== option.selectValue) {
                  removeUnknownOption();
                  removeEmptyOption();
                  selectElement[0].value = option.selectValue;
                  option.element.selected = true;
                }
                option.element.setAttribute('selected', 'selected');
              } else {
                if (value === null || providedEmptyOption) {
                  removeUnknownOption();
                  renderEmptyOption();
                } else {
                  removeEmptyOption();
                  renderUnknownOption();
                }
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              var selectedOption = options.selectValueMap[selectElement.val()];
              if (selectedOption && !selectedOption.disabled) {
                removeEmptyOption();
                removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              }, function() {
                ngModelCtrl.$render();
              });
            }
          } else {
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
              options.items.forEach(function(option) {
                option.element.selected = false;
              });
              if (value) {
                value.forEach(function(item) {
                  var option = options.getOptionFromViewValue(item);
                  if (option)
                    option.element.selected = true;
                });
              }
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              var selectedValues = selectElement.val() || [],
                  selections = [];
              forEach(selectedValues, function(value) {
                var option = options.selectValueMap[value];
                if (option && !option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
            if (ngOptions.trackBy) {
              scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              }, function() {
                ngModelCtrl.$render();
              });
            }
          }
          if (providedEmptyOption) {
            emptyOption.remove();
            $compile(emptyOption)(scope);
            emptyOption.removeClass('ng-scope');
          } else {
            emptyOption = jqLite(optionTemplate.cloneNode(false));
          }
          selectElement.empty();
          updateOptions();
          scope.$watchCollection(ngOptions.getWatchables, updateOptions);
          function addOptionElement(option, parent) {
            var optionElement = optionTemplate.cloneNode(false);
            parent.appendChild(optionElement);
            updateOptionElement(option, optionElement);
          }
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
            if (option.value !== element.value)
              element.value = option.selectValue;
          }
          function updateOptions() {
            var previousValue = options && selectCtrl.readValue();
            if (options) {
              for (var i = options.items.length - 1; i >= 0; i--) {
                var option = options.items[i];
                if (option.group) {
                  jqLiteRemove(option.element.parentNode);
                } else {
                  jqLiteRemove(option.element);
                }
              }
            }
            options = ngOptions.getOptions();
            var groupElementMap = {};
            if (providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            options.items.forEach(function addOption(option) {
              var groupElement;
              if (isDefined(option.group)) {
                groupElement = groupElementMap[option.group];
                if (!groupElement) {
                  groupElement = optGroupTemplate.cloneNode(false);
                  listFragment.appendChild(groupElement);
                  groupElement.label = option.group;
                  groupElementMap[option.group] = groupElement;
                }
                addOptionElement(option, groupElement);
              } else {
                addOptionElement(option, listFragment);
              }
            });
            selectElement[0].appendChild(listFragment);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              var nextValue = selectCtrl.readValue();
              var isNotPrimitive = ngOptions.trackBy || multiple;
              if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', 'ngModel'],
          link: {
            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
              ctrls[0].registerOption = noop;
            },
            post: ngOptionsPostLink
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', '$compile', function($parse, $animate, $compile) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, previousNode);
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, previousNode);
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeMinErr = minErr('ngTransclude');
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
            $attrs.ngTransclude = '';
          }
          function ngTranscludeCloneAttachFn(clone) {
            if (clone.length) {
              $element.empty();
              $element.append(clone);
            }
          }
          if (!$transclude) {
            throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
          $transclude(ngTranscludeCloneAttachFn, null, slotName);
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute('selected')) {
          optionElement[0].selected = true;
        }
      }
      var SelectController = ['$element', '$scope', function($element, $scope) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(window.document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          if (element[0].nodeType === NODE_TYPE_COMMENT)
            return;
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
          self.ngModelCtrl.$render();
          chromeHack(element);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
          if (interpolateValueFn) {
            var oldVal;
            optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
            });
          } else if (interpolateTextFn) {
            optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set('value', newVal);
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
            });
          } else {
            self.addOption(optionAttrs.value, optionElement);
          }
          optionElement.on('$destroy', function() {
            self.removeOption(optionAttrs.value);
            self.ngModelCtrl.$render();
          });
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          priority: 1,
          link: {
            pre: selectPreLink,
            post: selectPostLink
          }
        };
        function selectPreLink(scope, element, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          selectCtrl.ngModelCtrl = ngModelCtrl;
          element.on('change', function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
          });
          if (attr.multiple) {
            selectCtrl.readValue = function readMultipleValue() {
              var array = [];
              forEach(element.find('option'), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
              var items = new HashMap(value);
              forEach(element.find('option'), function(option) {
                option.selected = isDefined(items.get(option.value));
              });
            };
            var lastView,
                lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
              if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
              }
              lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
        }
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var interpolateValueFn = $interpolate(attr.value, true);
            } else {
              var interpolateTextFn = $interpolate(element.text(), true);
              if (!interpolateTextFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl) {
                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        if (window.console) {
          console.log('WARNING: Tried to load angular more than once.');
        }
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "STANDALONEMONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "localeID": "en_US",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(window.document).ready(function() {
        angularInit(window.document, bootstrap);
      });
    })(window);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular@1.5.4.js", ["github:angular/bower-angular@1.5.4/angular"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:angular/bower-angular@1.5.4/angular');
  return module.exports;
});

System.registerDynamic("github:angular-ui/ui-router@0.2.18/angular-ui-router.js", ["angular"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = 'ui.router';
    }
    (function(window, angular, undefined) {
      'use strict';
      var isDefined = angular.isDefined,
          isFunction = angular.isFunction,
          isString = angular.isString,
          isObject = angular.isObject,
          isArray = angular.isArray,
          forEach = angular.forEach,
          extend = angular.extend,
          copy = angular.copy,
          toJson = angular.toJson;
      function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype: parent}))(), extra);
      }
      function merge(dst) {
        forEach(arguments, function(obj) {
          if (obj !== dst) {
            forEach(obj, function(value, key) {
              if (!dst.hasOwnProperty(key))
                dst[key] = value;
            });
          }
        });
        return dst;
      }
      function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
          if (first.path[n] !== second.path[n])
            break;
          path.push(first.path[n]);
        }
        return path;
      }
      function objectKeys(object) {
        if (Object.keys) {
          return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
          result.push(key);
        });
        return result;
      }
      function indexOf(array, value) {
        if (Array.prototype.indexOf) {
          return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0,
            from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
          from += len;
        for (; from < len; from++) {
          if (from in array && array[from] === value)
            return from;
        }
        return -1;
      }
      function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to),
            parentParams,
            inherited = {},
            inheritList = [];
        for (var i in parents) {
          if (!parents[i] || !parents[i].params)
            continue;
          parentParams = objectKeys(parents[i].params);
          if (!parentParams.length)
            continue;
          for (var j in parentParams) {
            if (indexOf(inheritList, parentParams[j]) >= 0)
              continue;
            inheritList.push(parentParams[j]);
            inherited[parentParams[j]] = currentParams[parentParams[j]];
          }
        }
        return extend({}, inherited, newParams);
      }
      function equalForKeys(a, b, keys) {
        if (!keys) {
          keys = [];
          for (var n in a)
            keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (a[k] != b[k])
            return false;
        }
        return true;
      }
      function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
          filtered[name] = values[name];
        });
        return filtered;
      }
      function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
          result[item[propName]] = item;
        });
        return result;
      }
      function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      }
      function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
          if (indexOf(keys, key) == -1)
            copy[key] = obj[key];
        }
        return copy;
      }
      function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
      }
      function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
          if (callback(val, i)) {
            result[array ? result.length : i] = val;
          }
        });
        return result;
      }
      function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = callback(val, i);
        });
        return result;
      }
      angular.module('ui.router.util', ['ng']);
      angular.module('ui.router.router', ['ui.router.util']);
      angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
      angular.module('ui.router', ['ui.router.state']);
      angular.module('ui.router.compat', ['ui.router']);
      $Resolve.$inject = ['$q', '$injector'];
      function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1,
            VISIT_DONE = 2,
            NOTHING = {},
            NO_DEPENDENCIES = [],
            NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {
              $$promises: NOTHING,
              $$values: NOTHING
            });
        this.study = function(invocables) {
          if (!isObject(invocables))
            throw new Error("'invocables' must be an object");
          var invocableKeys = objectKeys(invocables || {});
          var plan = [],
              cycle = [],
              visited = {};
          function visit(value, key) {
            if (visited[key] === VISIT_DONE)
              return;
            cycle.push(key);
            if (visited[key] === VISIT_IN_PROGRESS) {
              cycle.splice(0, indexOf(cycle, key));
              throw new Error("Cyclic dependency: " + cycle.join(" -> "));
            }
            visited[key] = VISIT_IN_PROGRESS;
            if (isString(value)) {
              plan.push(key, [function() {
                return $injector.get(value);
              }], NO_DEPENDENCIES);
            } else {
              var params = $injector.annotate(value);
              forEach(params, function(param) {
                if (param !== key && invocables.hasOwnProperty(param))
                  visit(invocables[param], param);
              });
              plan.push(key, value, params);
            }
            cycle.pop();
            visited[key] = VISIT_DONE;
          }
          forEach(invocables, visit);
          invocables = cycle = visited = null;
          function isResolve(value) {
            return isObject(value) && value.then && value.$$promises;
          }
          return function(locals, parent, self) {
            if (isResolve(locals) && self === undefined) {
              self = parent;
              parent = locals;
              locals = null;
            }
            if (!locals)
              locals = NO_LOCALS;
            else if (!isObject(locals)) {
              throw new Error("'locals' must be an object");
            }
            if (!parent)
              parent = NO_PARENT;
            else if (!isResolve(parent)) {
              throw new Error("'parent' must be a promise returned by $resolve.resolve()");
            }
            var resolution = $q.defer(),
                result = resolution.promise,
                promises = result.$$promises = {},
                values = extend({}, locals),
                wait = 1 + plan.length / 3,
                merged = false;
            function done() {
              if (!--wait) {
                if (!merged)
                  merge(values, parent.$$values);
                result.$$values = values;
                result.$$promises = result.$$promises || true;
                delete result.$$inheritedValues;
                resolution.resolve(values);
              }
            }
            function fail(reason) {
              result.$$failure = reason;
              resolution.reject(reason);
            }
            if (isDefined(parent.$$failure)) {
              fail(parent.$$failure);
              return result;
            }
            if (parent.$$inheritedValues) {
              merge(values, omit(parent.$$inheritedValues, invocableKeys));
            }
            extend(promises, parent.$$promises);
            if (parent.$$values) {
              merged = merge(values, omit(parent.$$values, invocableKeys));
              result.$$inheritedValues = omit(parent.$$values, invocableKeys);
              done();
            } else {
              if (parent.$$inheritedValues) {
                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
              }
              parent.then(done, fail);
            }
            for (var i = 0,
                ii = plan.length; i < ii; i += 3) {
              if (locals.hasOwnProperty(plan[i]))
                done();
              else
                invoke(plan[i], plan[i + 1], plan[i + 2]);
            }
            function invoke(key, invocable, params) {
              var invocation = $q.defer(),
                  waitParams = 0;
              function onfailure(reason) {
                invocation.reject(reason);
                fail(reason);
              }
              forEach(params, function(dep) {
                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                  waitParams++;
                  promises[dep].then(function(result) {
                    values[dep] = result;
                    if (!(--waitParams))
                      proceed();
                  }, onfailure);
                }
              });
              if (!waitParams)
                proceed();
              function proceed() {
                if (isDefined(result.$$failure))
                  return;
                try {
                  invocation.resolve($injector.invoke(invocable, self, values));
                  invocation.promise.then(function(result) {
                    values[key] = result;
                    done();
                  }, onfailure);
                } catch (e) {
                  onfailure(e);
                }
              }
              promises[key] = invocation.promise;
            }
            return result;
          };
        };
        this.resolve = function(invocables, locals, parent, self) {
          return this.study(invocables)(locals, parent, self);
        };
      }
      angular.module('ui.router.util').service('$resolve', $Resolve);
      $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
      function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
          return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
        };
        this.fromString = function(template, params) {
          return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
          if (isFunction(url))
            url = url(params);
          if (url == null)
            return null;
          else
            return $http.get(url, {
              cache: $templateCache,
              headers: {Accept: 'text/html'}
            }).then(function(response) {
              return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
          return $injector.invoke(provider, null, locals || {params: params});
        };
      }
      angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
      var $$UMFP;
      function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = '^',
            last = 0,
            m,
            segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
            paramNames = [];
        function addParameter(id, type, config, location) {
          paramNames.push(id);
          if (parentParams[id])
            return parentParams[id];
          if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id))
            throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
          if (params[id])
            throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
          params[id] = new $$UMFP.Param(id, type, config, location);
          return params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
          var surroundPattern = ['', ''],
              result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
          if (!pattern)
            return result;
          switch (squash) {
            case false:
              surroundPattern = ['(', ')' + (optional ? "?" : "")];
              break;
            case true:
              result = result.replace(/\/$/, '');
              surroundPattern = ['(?:\/(', ')|\/)?'];
              break;
            default:
              surroundPattern = ['(' + squash + "|", ')?'];
              break;
          }
          return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
          var id,
              regexp,
              segment,
              type,
              cfg,
              arrayMode;
          id = m[2] || m[3];
          cfg = config.params[id];
          segment = pattern.substring(last, m.index);
          regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
          if (regexp) {
            type = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)});
          }
          return {
            id: id,
            regexp: regexp,
            segment: segment,
            type: type,
            cfg: cfg
          };
        }
        var p,
            param,
            segment;
        while ((m = placeholder.exec(pattern))) {
          p = matchDetails(m, false);
          if (p.segment.indexOf('?') >= 0)
            break;
          param = addParameter(p.id, p.type, p.cfg, "path");
          compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
          segments.push(p.segment);
          last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf('?');
        if (i >= 0) {
          var search = this.sourceSearch = segment.substring(i);
          segment = segment.substring(0, i);
          this.sourcePath = pattern.substring(0, last + i);
          if (search.length > 0) {
            last = 0;
            while ((m = searchPlaceholder.exec(search))) {
              p = matchDetails(m, true);
              param = addParameter(p.id, p.type, p.cfg, "search");
              last = placeholder.lastIndex;
            }
          }
        } else {
          this.sourcePath = pattern;
          this.sourceSearch = '';
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
      }
      UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
          caseInsensitive: $$UMFP.caseInsensitive(),
          strict: $$UMFP.strictMode(),
          squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
      };
      UrlMatcher.prototype.toString = function() {
        return this.source;
      };
      UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m)
          return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(),
            nTotal = paramNames.length,
            nPath = this.segments.length - 1,
            values = {},
            i,
            j,
            cfg,
            paramName;
        if (nPath !== m.length - 1)
          throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
          function reverseString(str) {
            return str.split("").reverse().join("");
          }
          function unquoteDashes(str) {
            return str.replace(/\\-/g, "-");
          }
          var split = reverseString(string).split(/-(?!\\)/);
          var allReversed = map(split, reverseString);
          return map(allReversed, unquoteDashes).reverse();
        }
        var param,
            paramVal;
        for (i = 0; i < nPath; i++) {
          paramName = paramNames[i];
          param = this.params[paramName];
          paramVal = m[i + 1];
          for (j = 0; j < param.replace.length; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (paramVal && param.array === true)
            paramVal = decodePathArray(paramVal);
          if (isDefined(paramVal))
            paramVal = param.type.decode(paramVal);
          values[paramName] = param.value(paramVal);
        }
        for (; i < nTotal; i++) {
          paramName = paramNames[i];
          values[paramName] = this.params[paramName].value(searchParams[paramName]);
          param = this.params[paramName];
          paramVal = searchParams[paramName];
          for (j = 0; j < param.replace.length; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (isDefined(paramVal))
            paramVal = param.type.decode(paramVal);
          values[paramName] = param.value(paramVal);
        }
        return values;
      };
      UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param))
          return this.$$paramNames;
        return this.params[param] || null;
      };
      UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
      };
      UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments,
            params = this.parameters(),
            paramset = this.params;
        if (!this.validates(values))
          return null;
        var i,
            search = false,
            nPath = segments.length - 1,
            nTotal = params.length,
            result = segments[0];
        function encodeDashes(str) {
          return encodeURIComponent(str).replace(/-/g, function(c) {
            return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
          });
        }
        for (i = 0; i < nTotal; i++) {
          var isPathParam = i < nPath;
          var name = params[i],
              param = paramset[name],
              value = param.value(values[name]);
          var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
          var squash = isDefaultValue ? param.squash : false;
          var encoded = param.type.encode(value);
          if (isPathParam) {
            var nextSegment = segments[i + 1];
            var isFinalPathParam = i + 1 === nPath;
            if (squash === false) {
              if (encoded != null) {
                if (isArray(encoded)) {
                  result += map(encoded, encodeDashes).join("-");
                } else {
                  result += encodeURIComponent(encoded);
                }
              }
              result += nextSegment;
            } else if (squash === true) {
              var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
              result += nextSegment.match(capture)[1];
            } else if (isString(squash)) {
              result += squash + nextSegment;
            }
            if (isFinalPathParam && param.squash === true && result.slice(-1) === '/')
              result = result.slice(0, -1);
          } else {
            if (encoded == null || (isDefaultValue && squash !== false))
              continue;
            if (!isArray(encoded))
              encoded = [encoded];
            if (encoded.length === 0)
              continue;
            encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
            result += (search ? '&' : '?') + (name + '=' + encoded);
            search = true;
          }
        }
        return result;
      };
      function Type(config) {
        extend(this, config);
      }
      Type.prototype.is = function(val, key) {
        return true;
      };
      Type.prototype.encode = function(val, key) {
        return val;
      };
      Type.prototype.decode = function(val, key) {
        return val;
      };
      Type.prototype.equals = function(a, b) {
        return a == b;
      };
      Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
      };
      Type.prototype.pattern = /.*/;
      Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
      };
      Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
      };
      Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode)
          return this;
        if (mode === "auto" && !isSearch)
          throw new Error("'auto' array mode is for query parameters only");
        function ArrayType(type, mode) {
          function bindTo(type, callbackName) {
            return function() {
              return type[callbackName].apply(type, arguments);
            };
          }
          function arrayWrap(val) {
            return isArray(val) ? val : (isDefined(val) ? [val] : []);
          }
          function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return undefined;
              case 1:
                return mode === "auto" ? val[0] : val;
              default:
                return val;
            }
          }
          function falsey(val) {
            return !val;
          }
          function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
              if (isArray(val) && val.length === 0)
                return val;
              val = arrayWrap(val);
              var result = map(val, callback);
              if (allTruthyMode === true)
                return filter(result, falsey).length === 0;
              return arrayUnwrap(result);
            };
          }
          function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
              var left = arrayWrap(val1),
                  right = arrayWrap(val2);
              if (left.length !== right.length)
                return false;
              for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                  return false;
              }
              return true;
            };
          }
          this.encode = arrayHandler(bindTo(type, 'encode'));
          this.decode = arrayHandler(bindTo(type, 'decode'));
          this.is = arrayHandler(bindTo(type, 'is'), true);
          this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
          this.pattern = type.pattern;
          this.$normalize = arrayHandler(bindTo(type, '$normalize'));
          this.name = type.name;
          this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
      };
      function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false,
            isStrictMode = true,
            defaultSquashPolicy = false;
        function valToString(val) {
          return val != null ? val.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : val;
        }
        function valFromString(val) {
          return val != null ? val.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : val;
        }
        var $types = {},
            enqueue = true,
            typeQueue = [],
            injector,
            defaultTypes = {
              "string": {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                  return val == null || !isDefined(val) || typeof val === "string";
                },
                pattern: /[^/]*/
              },
              "int": {
                encode: valToString,
                decode: function(val) {
                  return parseInt(val, 10);
                },
                is: function(val) {
                  return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
              },
              "bool": {
                encode: function(val) {
                  return val ? 1 : 0;
                },
                decode: function(val) {
                  return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                  return val === true || val === false;
                },
                pattern: /0|1/
              },
              "date": {
                encode: function(val) {
                  if (!this.is(val))
                    return undefined;
                  return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                },
                decode: function(val) {
                  if (this.is(val))
                    return val;
                  var match = this.capture.exec(val);
                  return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                  return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                  return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
              },
              "json": {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
              },
              "any": {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
              }
            };
        function getDefaultConfig() {
          return {
            strict: isStrictMode,
            caseInsensitive: isCaseInsensitive
          };
        }
        function isInjectable(value) {
          return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
          if (!isInjectable(config.value))
            return config.value;
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
          if (isDefined(value))
            isCaseInsensitive = value;
          return isCaseInsensitive;
        };
        this.strictMode = function(value) {
          if (isDefined(value))
            isStrictMode = value;
          return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
          if (!isDefined(value))
            return defaultSquashPolicy;
          if (value !== true && value !== false && !isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
          defaultSquashPolicy = value;
          return value;
        };
        this.compile = function(pattern, config) {
          return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
          if (!isObject(o))
            return false;
          var result = true;
          forEach(UrlMatcher.prototype, function(val, name) {
            if (isFunction(val)) {
              result = result && (isDefined(o[name]) && isFunction(o[name]));
            }
          });
          return result;
        };
        this.type = function(name, definition, definitionFn) {
          if (!isDefined(definition))
            return $types[name];
          if ($types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
          $types[name] = new Type(extend({name: name}, definition));
          if (definitionFn) {
            typeQueue.push({
              name: name,
              def: definitionFn
            });
            if (!enqueue)
              flushTypeQueue();
          }
          return this;
        };
        function flushTypeQueue() {
          while (typeQueue.length) {
            var type = typeQueue.shift();
            if (type.pattern)
              throw new Error("You cannot override a type's .pattern at runtime.");
            angular.extend($types[type.name], injector.invoke(type.def));
          }
        }
        forEach(defaultTypes, function(type, name) {
          $types[name] = new Type(extend({name: name}, type));
        });
        $types = inherit($types, {});
        this.$get = ['$injector', function($injector) {
          injector = $injector;
          enqueue = false;
          flushTypeQueue();
          forEach(defaultTypes, function(type, name) {
            if (!$types[name])
              $types[name] = new Type(type);
          });
          return this;
        }];
        this.Param = function Param(id, type, config, location) {
          var self = this;
          config = unwrapShorthand(config);
          type = getType(config, type, location);
          var arrayMode = getArrayMode();
          type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
          if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
            config.value = "";
          var isOptional = config.value !== undefined;
          var squash = getSquashPolicy(config, isOptional);
          var replace = getReplace(config, arrayMode, isOptional, squash);
          function unwrapShorthand(config) {
            var keys = isObject(config) ? objectKeys(config) : [];
            var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
            if (isShorthand)
              config = {value: config};
            config.$$fn = isInjectable(config.value) ? config.value : function() {
              return config.value;
            };
            return config;
          }
          function getType(config, urlType, location) {
            if (config.type && urlType)
              throw new Error("Param '" + id + "' has two type configurations.");
            if (urlType)
              return urlType;
            if (!config.type)
              return (location === "config" ? $types.any : $types.string);
            if (angular.isString(config.type))
              return $types[config.type];
            if (config.type instanceof Type)
              return config.type;
            return new Type(config.type);
          }
          function getArrayMode() {
            var arrayDefaults = {array: (location === "search" ? "auto" : false)};
            var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
            return extend(arrayDefaults, arrayParamNomenclature, config).array;
          }
          function getSquashPolicy(config, isOptional) {
            var squash = config.squash;
            if (!isOptional || squash === false)
              return false;
            if (!isDefined(squash) || squash == null)
              return defaultSquashPolicy;
            if (squash === true || isString(squash))
              return squash;
            throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
          }
          function getReplace(config, arrayMode, isOptional, squash) {
            var replace,
                configuredKeys,
                defaultPolicy = [{
                  from: "",
                  to: (isOptional || arrayMode ? undefined : "")
                }, {
                  from: null,
                  to: (isOptional || arrayMode ? undefined : "")
                }];
            replace = isArray(config.replace) ? config.replace : [];
            if (isString(squash))
              replace.push({
                from: squash,
                to: undefined
              });
            configuredKeys = map(replace, function(item) {
              return item.from;
            });
            return filter(defaultPolicy, function(item) {
              return indexOf(configuredKeys, item.from) === -1;
            }).concat(replace);
          }
          function $$getDefaultValue() {
            if (!injector)
              throw new Error("Injectable functions cannot be called at configuration time");
            var defaultValue = injector.invoke(config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
              throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
            return defaultValue;
          }
          function $value(value) {
            function hasReplaceVal(val) {
              return function(obj) {
                return obj.from === val;
              };
            }
            function $replace(value) {
              var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                return obj.to;
              });
              return replacement.length ? replacement[0] : value;
            }
            value = $replace(value);
            return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
          }
          function toString() {
            return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
          }
          extend(this, {
            id: id,
            type: type,
            location: location,
            array: arrayMode,
            squash: squash,
            replace: replace,
            isOptional: isOptional,
            value: $value,
            dynamic: undefined,
            config: config,
            toString: toString
          });
        };
        function ParamSet(params) {
          extend(this, params || {});
        }
        ParamSet.prototype = {
          $$new: function() {
            return inherit(this, extend(new ParamSet(), {$$parent: this}));
          },
          $$keys: function() {
            var keys = [],
                chain = [],
                parent = this,
                ignore = objectKeys(ParamSet.prototype);
            while (parent) {
              chain.push(parent);
              parent = parent.$$parent;
            }
            chain.reverse();
            forEach(chain, function(paramset) {
              forEach(objectKeys(paramset), function(key) {
                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                  keys.push(key);
              });
            });
            return keys;
          },
          $$values: function(paramValues) {
            var values = {},
                self = this;
            forEach(self.$$keys(), function(key) {
              values[key] = self[key].value(paramValues && paramValues[key]);
            });
            return values;
          },
          $$equals: function(paramValues1, paramValues2) {
            var equal = true,
                self = this;
            forEach(self.$$keys(), function(key) {
              var left = paramValues1 && paramValues1[key],
                  right = paramValues2 && paramValues2[key];
              if (!self[key].type.equals(left, right))
                equal = false;
            });
            return equal;
          },
          $$validates: function $$validate(paramValues) {
            var keys = this.$$keys(),
                i,
                param,
                rawVal,
                normalized,
                encoded;
            for (i = 0; i < keys.length; i++) {
              param = this[keys[i]];
              rawVal = paramValues[keys[i]];
              if ((rawVal === undefined || rawVal === null) && param.isOptional)
                break;
              normalized = param.type.$normalize(rawVal);
              if (!param.type.is(normalized))
                return false;
              encoded = param.type.encode(normalized);
              if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                return false;
            }
            return true;
          },
          $$parent: undefined
        };
        this.ParamSet = ParamSet;
      }
      angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
      angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
      $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
      function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [],
            otherwise = null,
            interceptDeferred = false,
            listener;
        function regExpPrefix(re) {
          var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
          return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }
        function interpolate(pattern, match) {
          return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
            return match[what === '$' ? 0 : Number(what)];
          });
        }
        this.rule = function(rule) {
          if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          rules.push(rule);
          return this;
        };
        this.otherwise = function(rule) {
          if (isString(rule)) {
            var redirect = rule;
            rule = function() {
              return redirect;
            };
          } else if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          otherwise = rule;
          return this;
        };
        function handleIfMatch($injector, handler, match) {
          if (!match)
            return false;
          var result = $injector.invoke(handler, handler, {$match: match});
          return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
          var redirect,
              handlerIsString = isString(handler);
          if (isString(what))
            what = $urlMatcherFactory.compile(what);
          if (!handlerIsString && !isFunction(handler) && !isArray(handler))
            throw new Error("invalid 'handler' in when()");
          var strategies = {
            matcher: function(what, handler) {
              if (handlerIsString) {
                redirect = $urlMatcherFactory.compile(handler);
                handler = ['$match', function($match) {
                  return redirect.format($match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
              }, {prefix: isString(what.prefix) ? what.prefix : ''});
            },
            regex: function(what, handler) {
              if (what.global || what.sticky)
                throw new Error("when() RegExp must not be global or sticky");
              if (handlerIsString) {
                redirect = handler;
                handler = ['$match', function($match) {
                  return interpolate(redirect, $match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path()));
              }, {prefix: regExpPrefix(what)});
            }
          };
          var check = {
            matcher: $urlMatcherFactory.isMatcher(what),
            regex: what instanceof RegExp
          };
          for (var n in check) {
            if (check[n])
              return this.rule(strategies[n](what, handler));
          }
          throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
          if (defer === undefined)
            defer = true;
          interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];
        function $get($location, $rootScope, $injector, $browser, $sniffer) {
          var baseHref = $browser.baseHref(),
              location = $location.url(),
              lastPushedUrl;
          function appendBasePath(url, isHtml5, absolute) {
            if (baseHref === '/')
              return url;
            if (isHtml5)
              return baseHref.slice(0, -1) + url;
            if (absolute)
              return baseHref.slice(1) + url;
            return url;
          }
          function update(evt) {
            if (evt && evt.defaultPrevented)
              return;
            var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
            lastPushedUrl = undefined;
            function check(rule) {
              var handled = rule($injector, $location);
              if (!handled)
                return false;
              if (isString(handled))
                $location.replace().url(handled);
              return true;
            }
            var n = rules.length,
                i;
            for (i = 0; i < n; i++) {
              if (check(rules[i]))
                return;
            }
            if (otherwise)
              check(otherwise);
          }
          function listen() {
            listener = listener || $rootScope.$on('$locationChangeSuccess', update);
            return listener;
          }
          if (!interceptDeferred)
            listen();
          return {
            sync: function() {
              update();
            },
            listen: function() {
              return listen();
            },
            update: function(read) {
              if (read) {
                location = $location.url();
                return;
              }
              if ($location.url() === location)
                return;
              $location.url(location);
              $location.replace();
            },
            push: function(urlMatcher, params, options) {
              var url = urlMatcher.format(params || {});
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              $location.url(url);
              lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
              if (options && options.replace)
                $location.replace();
            },
            href: function(urlMatcher, params, options) {
              if (!urlMatcher.validates(params))
                return null;
              var isHtml5 = $locationProvider.html5Mode();
              if (angular.isObject(isHtml5)) {
                isHtml5 = isHtml5.enabled;
              }
              isHtml5 = isHtml5 && $sniffer.history;
              var url = urlMatcher.format(params);
              options = options || {};
              if (!isHtml5 && url !== null) {
                url = "#" + $locationProvider.hashPrefix() + url;
              }
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              url = appendBasePath(url, isHtml5, options.absolute);
              if (!options.absolute || !url) {
                return url;
              }
              var slash = (!isHtml5 && url ? '/' : ''),
                  port = $location.port();
              port = (port === 80 || port === 443 ? '' : ':' + port);
              return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
            }
          };
        }
      }
      angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
      $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
      function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root,
            states = {},
            $state,
            queue = {},
            abstractKey = 'abstract';
        var stateBuilder = {
          parent: function(state) {
            if (isDefined(state.parent) && state.parent)
              return findState(state.parent);
            var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
            return compositeName ? findState(compositeName[1]) : root;
          },
          data: function(state) {
            if (state.parent && state.parent.data) {
              state.data = state.self.data = inherit(state.parent.data, state.data);
            }
            return state.data;
          },
          url: function(state) {
            var url = state.url,
                config = {params: state.params || {}};
            if (isString(url)) {
              if (url.charAt(0) == '^')
                return $urlMatcherFactory.compile(url.substring(1), config);
              return (state.parent.navigable || root).url.concat(url, config);
            }
            if (!url || $urlMatcherFactory.isMatcher(url))
              return url;
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
          },
          navigable: function(state) {
            return state.url ? state : (state.parent ? state.parent.navigable : null);
          },
          ownParams: function(state) {
            var params = state.url && state.url.params || new $$UMFP.ParamSet();
            forEach(state.params || {}, function(config, id) {
              if (!params[id])
                params[id] = new $$UMFP.Param(id, null, config, "config");
            });
            return params;
          },
          params: function(state) {
            var ownParams = pick(state.ownParams, state.ownParams.$$keys());
            return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
          },
          views: function(state) {
            var views = {};
            forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
              if (name.indexOf('@') < 0)
                name += '@' + state.parent.name;
              views[name] = view;
            });
            return views;
          },
          path: function(state) {
            return state.parent ? state.parent.path.concat(state) : [];
          },
          includes: function(state) {
            var includes = state.parent ? extend({}, state.parent.includes) : {};
            includes[state.name] = true;
            return includes;
          },
          $delegates: {}
        };
        function isRelative(stateName) {
          return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
          if (!stateOrName)
            return undefined;
          var isStr = isString(stateOrName),
              name = isStr ? stateOrName : stateOrName.name,
              path = isRelative(name);
          if (path) {
            if (!base)
              throw new Error("No reference point given for path '" + name + "'");
            base = findState(base);
            var rel = name.split("."),
                i = 0,
                pathLength = rel.length,
                current = base;
            for (; i < pathLength; i++) {
              if (rel[i] === "" && i === 0) {
                current = base;
                continue;
              }
              if (rel[i] === "^") {
                if (!current.parent)
                  throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                current = current.parent;
                continue;
              }
              break;
            }
            rel = rel.slice(i).join(".");
            name = current.name + (current.name && rel ? "." : "") + rel;
          }
          var state = states[name];
          if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
          }
          return undefined;
        }
        function queueState(parentName, state) {
          if (!queue[parentName]) {
            queue[parentName] = [];
          }
          queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
          var queued = queue[parentName] || [];
          while (queued.length) {
            registerState(queued.shift());
          }
        }
        function registerState(state) {
          state = inherit(state, {
            self: state,
            resolve: state.resolve || {},
            toString: function() {
              return this.name;
            }
          });
          var name = state.name;
          if (!isString(name) || name.indexOf('@') >= 0)
            throw new Error("State must have a valid name");
          if (states.hasOwnProperty(name))
            throw new Error("State '" + name + "' is already defined");
          var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
          if (parentName && !states[parentName]) {
            return queueState(parentName, state.self);
          }
          for (var key in stateBuilder) {
            if (isFunction(stateBuilder[key]))
              state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
          }
          states[name] = state;
          if (!state[abstractKey] && state.url) {
            $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
              if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                $state.transitionTo(state, $match, {
                  inherit: true,
                  location: false
                });
              }
            }]);
          }
          flushQueuedChildren(name);
          return state;
        }
        function isGlob(text) {
          return text.indexOf('*') > -1;
        }
        function doesStateMatchGlob(glob) {
          var globSegments = glob.split('.'),
              segments = $state.$current.name.split('.');
          for (var i = 0,
              l = globSegments.length; i < l; i++) {
            if (globSegments[i] === '*') {
              segments[i] = '*';
            }
          }
          if (globSegments[0] === '**') {
            segments = segments.slice(indexOf(segments, globSegments[1]));
            segments.unshift('**');
          }
          if (globSegments[globSegments.length - 1] === '**') {
            segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
            segments.push('**');
          }
          if (globSegments.length != segments.length) {
            return false;
          }
          return segments.join('') === globSegments.join('');
        }
        root = registerState({
          name: '',
          url: '^',
          views: null,
          'abstract': true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
          if (isString(name) && !isDefined(func)) {
            return stateBuilder[name];
          }
          if (!isFunction(func) || !isString(name)) {
            return this;
          }
          if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
            stateBuilder.$delegates[name] = stateBuilder[name];
          }
          stateBuilder[name] = func;
          return this;
        }
        this.state = state;
        function state(name, definition) {
          if (isObject(name))
            definition = name;
          else
            definition.name = name;
          registerState(definition);
          return this;
        }
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
          var TransitionSuperseded = $q.reject(new Error('transition superseded'));
          var TransitionPrevented = $q.reject(new Error('transition prevented'));
          var TransitionAborted = $q.reject(new Error('transition aborted'));
          var TransitionFailed = $q.reject(new Error('transition failed'));
          function handleRedirect(redirect, state, params, options) {
            var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
            if (evt.defaultPrevented) {
              $urlRouter.update();
              return TransitionAborted;
            }
            if (!evt.retry) {
              return null;
            }
            if (options.$retry) {
              $urlRouter.update();
              return TransitionFailed;
            }
            var retryTransition = $state.transition = $q.when(evt.retry);
            retryTransition.then(function() {
              if (retryTransition !== $state.transition)
                return TransitionSuperseded;
              redirect.options.$retry = true;
              return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
            }, function() {
              return TransitionAborted;
            });
            $urlRouter.update();
            return retryTransition;
          }
          root.locals = {
            resolve: null,
            globals: {$stateParams: {}}
          };
          $state = {
            params: {},
            current: root.self,
            $current: root,
            transition: null
          };
          $state.reload = function reload(state) {
            return $state.transitionTo($state.current, $stateParams, {
              reload: state || true,
              inherit: false,
              notify: true
            });
          };
          $state.go = function go(to, params, options) {
            return $state.transitionTo(to, params, extend({
              inherit: true,
              relative: $state.$current
            }, options));
          };
          $state.transitionTo = function transitionTo(to, toParams, options) {
            toParams = toParams || {};
            options = extend({
              location: true,
              inherit: false,
              relative: null,
              notify: true,
              reload: false,
              $retry: false
            }, options || {});
            var from = $state.$current,
                fromParams = $state.params,
                fromPath = from.path;
            var evt,
                toState = findState(to, options.relative);
            var hash = toParams['#'];
            if (!isDefined(toState)) {
              var redirect = {
                to: to,
                toParams: toParams,
                options: options
              };
              var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
              if (redirectResult) {
                return redirectResult;
              }
              to = redirect.to;
              toParams = redirect.toParams;
              options = redirect.options;
              toState = findState(to, options.relative);
              if (!isDefined(toState)) {
                if (!options.relative)
                  throw new Error("No such state '" + to + "'");
                throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
              }
            }
            if (toState[abstractKey])
              throw new Error("Cannot transition to abstract state '" + to + "'");
            if (options.inherit)
              toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
            if (!toState.params.$$validates(toParams))
              return TransitionFailed;
            toParams = toState.params.$$values(toParams);
            to = toState;
            var toPath = to.path;
            var keep = 0,
                state = toPath[keep],
                locals = root.locals,
                toLocals = [];
            if (!options.reload) {
              while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            } else if (isString(options.reload) || isObject(options.reload)) {
              if (isObject(options.reload) && !options.reload.name) {
                throw new Error('Invalid reload state object');
              }
              var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
              if (options.reload && !reloadState) {
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
              }
              while (state && state === fromPath[keep] && state !== reloadState) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            }
            if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
              if (hash)
                toParams['#'] = hash;
              $state.params = toParams;
              copy($state.params, $stateParams);
              copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
              if (options.location && to.navigable && to.navigable.url) {
                $urlRouter.push(to.navigable.url, toParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
                $urlRouter.update(true);
              }
              $state.transition = null;
              return $q.when($state.current);
            }
            toParams = filterByKeys(to.params.$$keys(), toParams || {});
            if (hash)
              toParams['#'] = hash;
            if (options.notify) {
              if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
                $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                if ($state.transition == null)
                  $urlRouter.update();
                return TransitionPrevented;
              }
            }
            var resolved = $q.when(locals);
            for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
              locals = toLocals[l] = inherit(locals);
              resolved = resolveState(state, toParams, state === to, resolved, locals, options);
            }
            var transition = $state.transition = resolved.then(function() {
              var l,
                  entering,
                  exiting;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              for (l = fromPath.length - 1; l >= keep; l--) {
                exiting = fromPath[l];
                if (exiting.self.onExit) {
                  $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                }
                exiting.locals = null;
              }
              for (l = keep; l < toPath.length; l++) {
                entering = toPath[l];
                entering.locals = toLocals[l];
                if (entering.self.onEnter) {
                  $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                }
              }
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.$current = to;
              $state.current = to.self;
              $state.params = toParams;
              copy($state.params, $stateParams);
              $state.transition = null;
              if (options.location && to.navigable) {
                $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
              }
              if (options.notify) {
                $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
              }
              $urlRouter.update(true);
              return $state.current;
            }, function(error) {
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.transition = null;
              evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
              if (!evt.defaultPrevented) {
                $urlRouter.update();
              }
              return $q.reject(error);
            });
            return transition;
          };
          $state.is = function is(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if ($state.$current !== state) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
          };
          $state.includes = function includes(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            if (isString(stateOrName) && isGlob(stateOrName)) {
              if (!doesStateMatchGlob(stateOrName)) {
                return false;
              }
              stateOrName = $state.$current.name;
            }
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if (!isDefined($state.$current.includes[state.name])) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
          };
          $state.href = function href(stateOrName, params, options) {
            options = extend({
              lossy: true,
              inherit: true,
              absolute: false,
              relative: $state.$current
            }, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state))
              return null;
            if (options.inherit)
              params = inheritParams($stateParams, params || {}, $state.$current, state);
            var nav = (state && options.lossy) ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
              return null;
            }
            return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {absolute: options.absolute});
          };
          $state.get = function(stateOrName, context) {
            if (arguments.length === 0)
              return map(objectKeys(states), function(name) {
                return states[name].self;
              });
            var state = findState(stateOrName, context || $state.$current);
            return (state && state.self) ? state.self : null;
          };
          function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
            var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
            var locals = {$stateParams: $stateParams};
            dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
            var promises = [dst.resolve.then(function(globals) {
              dst.globals = globals;
            })];
            if (inherited)
              promises.push(inherited);
            function resolveViews() {
              var viewsPromises = [];
              forEach(state.views, function(view, name) {
                var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
                injectables.$template = [function() {
                  return $view.load(name, {
                    view: view,
                    locals: dst.globals,
                    params: $stateParams,
                    notify: options.notify
                  }) || '';
                }];
                viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                  if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                    var injectLocals = angular.extend({}, injectables, dst.globals);
                    result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                  } else {
                    result.$$controller = view.controller;
                  }
                  result.$$state = state;
                  result.$$controllerAs = view.controllerAs;
                  dst[name] = result;
                }));
              });
              return $q.all(viewsPromises).then(function() {
                return dst.globals;
              });
            }
            return $q.all(promises).then(resolveViews).then(function(values) {
              return dst;
            });
          }
          return $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
          function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
            function notSearchParam(key) {
              return fromAndToState.params[key].location != "search";
            }
            var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
            var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
            var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
            return nonQueryParamSet.$$equals(fromParams, toParams);
          }
          if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
            return true;
          }
        }
      }
      angular.module('ui.router.state').factory('$stateParams', function() {
        return {};
      }).provider('$state', $StateProvider);
      $ViewProvider.$inject = [];
      function $ViewProvider() {
        this.$get = $get;
        $get.$inject = ['$rootScope', '$templateFactory'];
        function $get($rootScope, $templateFactory) {
          return {load: function load(name, options) {
              var result,
                  defaults = {
                    template: null,
                    controller: null,
                    view: null,
                    locals: null,
                    notify: true,
                    async: true,
                    params: {}
                  };
              options = extend(defaults, options);
              if (options.view) {
                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
              }
              return result;
            }};
        }
      }
      angular.module('ui.router.state').provider('$view', $ViewProvider);
      function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
          useAnchorScroll = true;
        };
        this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
          if (useAnchorScroll) {
            return $anchorScroll;
          }
          return function($element) {
            return $timeout(function() {
              $element[0].scrollIntoView();
            }, 0, false);
          };
        }];
      }
      angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
      var ngMajorVer = angular.version.major;
      var ngMinorVer = angular.version.minor;
      $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
      function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
          return ($injector.has) ? function(service) {
            return $injector.has(service) ? $injector.get(service) : null;
          } : function(service) {
            try {
              return $injector.get(service);
            } catch (e) {
              return null;
            }
          };
        }
        var service = getService(),
            $animator = service('$animator'),
            $animate = service('$animate');
        function getRenderer(attrs, scope) {
          var statics = {
            enter: function(element, target, cb) {
              target.after(element);
              cb();
            },
            leave: function(element, cb) {
              element.remove();
              cb();
            }
          };
          if (!!attrs.noanimation)
            return statics;
          function animEnabled(element) {
            if (ngMajorVer === 1 && ngMinorVer >= 4)
              return !!$animate.enabled(element);
            if (ngMajorVer === 1 && ngMinorVer >= 2)
              return !!$animate.enabled();
            return (!!$animator);
          }
          if ($animate) {
            return {
              enter: function(element, target, cb) {
                if (!animEnabled(element)) {
                  statics.enter(element, target, cb);
                } else if (angular.version.minor > 2) {
                  $animate.enter(element, null, target).then(cb);
                } else {
                  $animate.enter(element, null, target, cb);
                }
              },
              leave: function(element, cb) {
                if (!animEnabled(element)) {
                  statics.leave(element, cb);
                } else if (angular.version.minor > 2) {
                  $animate.leave(element).then(cb);
                } else {
                  $animate.leave(element, cb);
                }
              }
            };
          }
          if ($animator) {
            var animate = $animator && $animator(scope, attrs);
            return {
              enter: function(element, target, cb) {
                animate.enter(element, null, target);
                cb();
              },
              leave: function(element, cb) {
                animate.leave(element);
                cb();
              }
            };
          }
          return statics;
        }
        var directive = {
          restrict: 'ECA',
          terminal: true,
          priority: 400,
          transclude: 'element',
          compile: function(tElement, tAttrs, $transclude) {
            return function(scope, $element, attrs) {
              var previousEl,
                  currentEl,
                  currentScope,
                  latestLocals,
                  onloadExp = attrs.onload || '',
                  autoScrollExp = attrs.autoscroll,
                  renderer = getRenderer(attrs, scope);
              scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              updateView(true);
              function cleanupLastView() {
                var _previousEl = previousEl;
                var _currentScope = currentScope;
                if (_currentScope) {
                  _currentScope._willBeDestroyed = true;
                }
                function cleanOld() {
                  if (_previousEl) {
                    _previousEl.remove();
                  }
                  if (_currentScope) {
                    _currentScope.$destroy();
                  }
                }
                if (currentEl) {
                  renderer.leave(currentEl, function() {
                    cleanOld();
                    previousEl = null;
                  });
                  previousEl = currentEl;
                } else {
                  cleanOld();
                  previousEl = null;
                }
                currentEl = null;
                currentScope = null;
              }
              function updateView(firstTime) {
                var newScope,
                    name = getUiViewName(scope, attrs, $element, $interpolate),
                    previousLocals = name && $state.$current && $state.$current.locals[name];
                if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed)
                  return;
                newScope = scope.$new();
                latestLocals = $state.$current.locals[name];
                newScope.$emit('$viewContentLoading', name);
                var clone = $transclude(newScope, function(clone) {
                  renderer.enter(clone, $element, function onUiViewEnter() {
                    if (currentScope) {
                      currentScope.$emit('$viewContentAnimationEnded');
                    }
                    if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                      $uiViewScroll(clone);
                    }
                  });
                  cleanupLastView();
                });
                currentEl = clone;
                currentScope = newScope;
                currentScope.$emit('$viewContentLoaded', name);
                currentScope.$eval(onloadExp);
              }
            };
          }
        };
        return directive;
      }
      $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
      function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
          restrict: 'ECA',
          priority: -400,
          compile: function(tElement) {
            var initial = tElement.html();
            return function(scope, $element, attrs) {
              var current = $state.$current,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  locals = current && current.locals[name];
              if (!locals) {
                return;
              }
              $element.data('$uiView', {
                name: name,
                state: locals.$$state
              });
              $element.html(locals.$template ? locals.$template : initial);
              var link = $compile($element.contents());
              if (locals.$$controller) {
                locals.$scope = scope;
                locals.$element = $element;
                var controller = $controller(locals.$$controller, locals);
                if (locals.$$controllerAs) {
                  scope[locals.$$controllerAs] = controller;
                }
                $element.data('$ngControllerController', controller);
                $element.children().data('$ngControllerController', controller);
              }
              link(scope);
            };
          }
        };
      }
      function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
      }
      angular.module('ui.router.state').directive('uiView', $ViewDirective);
      angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
      function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
            parsed;
        if (preparsed)
          ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4)
          throw new Error("Invalid state ref '" + ref + "'");
        return {
          state: parsed[1],
          paramExpr: parsed[3] || null
        };
      }
      function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');
        if (stateData && stateData.state && stateData.state.name) {
          return stateData.state;
        }
      }
      function getTypeInfo(el) {
        var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
        var isForm = el[0].nodeName === "FORM";
        return {
          attr: isForm ? "action" : (isSvg ? 'xlink:href' : 'href'),
          isAnchor: el.prop("tagName").toUpperCase() === "A",
          clickable: !isForm
        };
      }
      function clickHook(el, $state, $timeout, type, current) {
        return function(e) {
          var button = e.which || e.button,
              target = current();
          if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
            var transition = $timeout(function() {
              $state.go(target.state, target.params, target.options);
            });
            e.preventDefault();
            var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
            e.preventDefault = function() {
              if (ignorePreventDefaultCount-- <= 0)
                $timeout.cancel(transition);
            };
          }
        };
      }
      function defaultOpts(el, $state) {
        return {
          relative: stateContext(el) || $state.$current,
          inherit: true
        };
      }
      $StateRefDirective.$inject = ['$state', '$timeout'];
      function $StateRefDirective($state, $timeout) {
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var ref = parseStateRef(attrs.uiSref, $state.current.name);
            var def = {
              state: ref.state,
              href: null,
              params: null
            };
            var type = getTypeInfo(element);
            var active = uiSrefActive[1] || uiSrefActive[0];
            def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
            var update = function(val) {
              if (val)
                def.params = angular.copy(val);
              def.href = $state.href(ref.state, def.params, def.options);
              if (active)
                active.$$addStateInfo(ref.state, def.params);
              if (def.href !== null)
                attrs.$set(type.attr, def.href);
            };
            if (ref.paramExpr) {
              scope.$watch(ref.paramExpr, function(val) {
                if (val !== def.params)
                  update(val);
              }, true);
              def.params = angular.copy(scope.$eval(ref.paramExpr));
            }
            update();
            if (!type.clickable)
              return;
            element.bind("click", clickHook(element, $state, $timeout, type, function() {
              return def;
            }));
          }
        };
      }
      $StateRefDynamicDirective.$inject = ['$state', '$timeout'];
      function $StateRefDynamicDirective($state, $timeout) {
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var type = getTypeInfo(element);
            var active = uiSrefActive[1] || uiSrefActive[0];
            var group = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];
            var watch = '[' + group.map(function(val) {
              return val || 'null';
            }).join(', ') + ']';
            var def = {
              state: null,
              params: null,
              options: null,
              href: null
            };
            function runStateRefLink(group) {
              def.state = group[0];
              def.params = group[1];
              def.options = group[2];
              def.href = $state.href(def.state, def.params, def.options);
              if (active)
                active.$$addStateInfo(def.state, def.params);
              if (def.href)
                attrs.$set(type.attr, def.href);
            }
            scope.$watch(watch, runStateRefLink, true);
            runStateRefLink(scope.$eval(watch));
            if (!type.clickable)
              return;
            element.bind("click", clickHook(element, $state, $timeout, type, function() {
              return def;
            }));
          }
        };
      }
      $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
      function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
          restrict: "A",
          controller: ['$scope', '$element', '$attrs', '$timeout', function($scope, $element, $attrs, $timeout) {
            var states = [],
                activeClasses = {},
                activeEqClass,
                uiSrefActive;
            activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
            try {
              uiSrefActive = $scope.$eval($attrs.uiSrefActive);
            } catch (e) {}
            uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
            if (isObject(uiSrefActive)) {
              forEach(uiSrefActive, function(stateOrName, activeClass) {
                if (isString(stateOrName)) {
                  var ref = parseStateRef(stateOrName, $state.current.name);
                  addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                }
              });
            }
            this.$$addStateInfo = function(newState, newParams) {
              if (isObject(uiSrefActive) && states.length > 0) {
                return;
              }
              addState(newState, newParams, uiSrefActive);
              update();
            };
            $scope.$on('$stateChangeSuccess', update);
            function addState(stateName, stateParams, activeClass) {
              var state = $state.get(stateName, stateContext($element));
              var stateHash = createStateHash(stateName, stateParams);
              states.push({
                state: state || {name: stateName},
                params: stateParams,
                hash: stateHash
              });
              activeClasses[stateHash] = activeClass;
            }
            function createStateHash(state, params) {
              if (!isString(state)) {
                throw new Error('state should be a string');
              }
              if (isObject(params)) {
                return state + toJson(params);
              }
              params = $scope.$eval(params);
              if (isObject(params)) {
                return state + toJson(params);
              }
              return state;
            }
            function update() {
              for (var i = 0; i < states.length; i++) {
                if (anyMatch(states[i].state, states[i].params)) {
                  addClass($element, activeClasses[states[i].hash]);
                } else {
                  removeClass($element, activeClasses[states[i].hash]);
                }
                if (exactMatch(states[i].state, states[i].params)) {
                  addClass($element, activeEqClass);
                } else {
                  removeClass($element, activeEqClass);
                }
              }
            }
            function addClass(el, className) {
              $timeout(function() {
                el.addClass(className);
              });
            }
            function removeClass(el, className) {
              el.removeClass(className);
            }
            function anyMatch(state, params) {
              return $state.includes(state.name, params);
            }
            function exactMatch(state, params) {
              return $state.is(state.name, params);
            }
            update();
          }]
        };
      }
      angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective).directive('uiState', $StateRefDynamicDirective);
      $IsStateFilter.$inject = ['$state'];
      function $IsStateFilter($state) {
        var isFilter = function(state, params) {
          return $state.is(state, params);
        };
        isFilter.$stateful = true;
        return isFilter;
      }
      $IncludedByStateFilter.$inject = ['$state'];
      function $IncludedByStateFilter($state) {
        var includesFilter = function(state, params, options) {
          return $state.includes(state, params, options);
        };
        includesFilter.$stateful = true;
        return includesFilter;
      }
      angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular-ui/ui-router@0.2.18.js", ["github:angular-ui/ui-router@0.2.18/angular-ui-router"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:angular-ui/ui-router@0.2.18/angular-ui-router');
  return module.exports;
});

(function() {
var define = System.amdDefine;
(function(global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  var arr = [];
  var document = window.document;
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var version = "2.2.3",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function(callback) {
      return jQuery.each(this, callback);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor();
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      var realStringObj = obj && obj.toString();
      return !jQuery.isArray(obj) && (realStringObj - parseFloat(realStringObj) + 1) >= 0;
    },
    isPlainObject: function(obj) {
      var key;
      if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
        return false;
      }
      for (key in obj) {}
      return key === undefined || hasOwn.call(obj, key);
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    globalEval: function(code) {
      var script,
          indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback) {
      var length,
          i = 0;
      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = [];
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp,
          args,
          proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  }
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArrayLike(obj) {
    var length = !!obj && "length" in obj && obj.length,
        type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        MAX_NEGATIVE = 1 << 31,
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        unloadHandler = function() {
          setDocument();
        };
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          nidselect,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if ((m = match[1])) {
              if (nodeType === 9) {
                if ((elem = context.getElementById(m))) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;
            } else if (context.nodeName.toLowerCase() !== "object") {
              if ((nid = context.getAttribute("id"))) {
                nid = nid.replace(rescape, "\\$&");
              } else {
                context.setAttribute("id", (nid = expando));
              }
              groups = tokenize(selector);
              i = groups.length;
              nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
              while (i--) {
                groups[i] = nidselect + " " + toSelector(groups[i]);
              }
              newSelector = groups.join(",");
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement("div");
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      if ((parent = document.defaultView) && parent.top !== parent) {
        if (parent.addEventListener) {
          parent.addEventListener("unload", unloadHandler, false);
        } else if (parent.attachEvent) {
          parent.attachEvent("onunload", unloadHandler);
        }
      }
      support.attributes = assert(function(div) {
        div.className = "i";
        return !div.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(div) {
        div.appendChild(document.createComment(""));
        return !div.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      support.getById = assert(function(div) {
        docElem.appendChild(div).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var m = context.getElementById(id);
            return m ? [m] : [];
          }
        };
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
      } else {
        delete Expr.find["ID"];
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(document.querySelectorAll))) {
        assert(function(div) {
          docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
          if (div.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!div.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(div) {
          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          div.appendChild(input).setAttribute("name", "D");
          if (div.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          div.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(div) {
          support.disconnectedMatch = matches.call(div, "div");
          matches.call(div, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return document;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": function(elem) {
          return elem.disabled === false;
        },
        "disabled": function(elem) {
          return elem.disabled === true;
        },
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function(elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                uniqueCache[dir] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context === document || context || outermost;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(div1) {
      return div1.compareDocumentPosition(document.createElement("div")) & 1;
    });
    if (!assert(function(div) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(div) {
      div.innerHTML = "<input/>";
      div.firstChild.setAttribute("value", "");
      return div.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(div) {
      return div.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var dir = function(elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;
    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };
  var siblings = function(n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }
    return matched;
  };
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/);
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) > -1) !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          len = this.length,
          ret = [],
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      init = jQuery.fn.init = function(selector, context, root) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (jQuery.isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem && elem.parentNode) {
                this.length = 1;
                this[0] = elem;
              }
              this.context = document;
              this.selector = selector;
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this.context = this[0] = selector;
          this.length = 1;
          return this;
        } else if (jQuery.isFunction(selector)) {
          return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
          this.selector = selector.selector;
          this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return siblings(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
    var firing,
        memory,
        fired,
        locked,
        list = [],
        queue = [],
        firingIndex = -1,
        fire = function() {
          locked = options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  if (jQuery.isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          remove: function() {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            locked = queue = [];
            if (!memory) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            then: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = jQuery.isFunction(fns[i]) && fns[i];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(subordinate) {
      var i = 0,
          resolveValues = slice.call(arguments),
          length = resolveValues.length,
          remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
          deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
          updateFunc = function(i, contexts, values) {
            return function(value) {
              contexts[i] = this;
              values[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (values === progressValues) {
                deferred.notifyWith(contexts, values);
              } else if (!(--remaining)) {
                deferred.resolveWith(contexts, values);
              }
            };
          },
          progressValues,
          progressContexts,
          resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
        window.setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed);
        window.addEventListener("load", completed);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
  };
  var acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.prototype = {
    register: function(owner, initial) {
      var value = initial || {};
      if (owner.nodeType) {
        owner[this.expando] = value;
      } else {
        Object.defineProperty(owner, this.expando, {
          value: value,
          writable: true,
          configurable: true
        });
      }
      return owner[this.expando];
    },
    cache: function(owner) {
      if (!acceptData(owner)) {
        return {};
      }
      var value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function(owner, data, value) {
      var prop,
          cache = this.cache(owner);
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        for (prop in data) {
          cache[prop] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
    },
    access: function(owner, key, value) {
      var stored;
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          name,
          camel,
          cache = owner[this.expando];
      if (cache === undefined) {
        return;
      }
      if (key === undefined) {
        this.register(owner);
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
      if (key === undefined || jQuery.isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {}
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function(elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function(elem, name) {
      dataUser.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);
          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          dataUser.set(this, key);
        });
      }
      return access(this, function(value) {
        var data,
            camelKey;
        if (elem && value === undefined) {
          data = dataUser.get(elem, key) || dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());
          if (data !== undefined) {
            return data;
          }
          camelKey = jQuery.camelCase(key);
          data = dataUser.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        camelKey = jQuery.camelCase(key);
        this.each(function() {
          var data = dataUser.get(this, camelKey);
          dataUser.set(this, camelKey, value);
          if (key.indexOf("-") > -1 && data !== undefined) {
            dataUser.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          dataPriv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };
  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale = 1,
        maxIterations = 20,
        currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
    if (initialInUnit && initialInUnit[3] !== unit) {
      unit = unit || initialInUnit[3];
      valueParts = valueParts || [];
      initialInUnit = +initial || 1;
      do {
        scale = scale || ".5";
        initialInUnit = initialInUnit / scale;
        jQuery.style(elem, prop, initialInUnit + unit);
      } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
    }
    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;
      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  var rtagName = (/<([\w:-]+)/);
  var rscriptType = (/^$|\/(?:java|ecma)script/i);
  var wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function getAll(context, tag) {
    var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }
  var rhtml = /<|&#?\w+;/;
  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        if (jQuery.type(elem) === "object") {
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }
          jQuery.merge(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
      }
    }
    fragment.textContent = "";
    i = 0;
    while ((elem = nodes[i++])) {
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }
      contains = jQuery.contains(elem.ownerDocument, elem);
      tmp = getAll(fragment.appendChild(elem), "script");
      if (contains) {
        setGlobalEval(tmp);
      }
      if (scripts) {
        j = 0;
        while ((elem = tmp[j++])) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }
    return fragment;
  }
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  function on(elem, types, selector, data, fn, one) {
    var origFn,
        type;
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }
    if (data == null && fn == null) {
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data;
        data = undefined;
      } else {
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }
    if (one === 1) {
      origFn = fn;
      fn = function(event) {
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function() {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function(event) {
      event = jQuery.event.fix(event);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue = [],
          args = slice.call(arguments),
          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          matches,
          sel,
          handleObj,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
      filter: function(event, original) {
        var eventDoc,
            doc,
            body,
            button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }
        return event;
      }
    },
    fix: function(event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i,
          prop,
          copy,
          type = event.type,
          originalEvent = event,
          fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
      rnoInnerhtml = /<script|<style|<link/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  function domManip(collection, args, callback, ignored) {
    args = concat.apply([], args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        isFunction = jQuery.isFunction(value);
    if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
      return collection.each(function(index) {
        var self = collection.eq(index);
        if (isFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }
    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);
            if (hasScripts) {
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }
          callback.call(collection[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;
          jQuery.map(scripts, restoreScript);
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src) {
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
              }
            }
          }
        }
      }
    }
    return collection;
  }
  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;
    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }
      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }
    return elem;
  }
  jQuery.extend({
    htmlPrefilter: function(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if ((data = elem[dataPriv.expando])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    domManip: domManip,
    detach: function(selector) {
      return remove(this, selector, true);
    },
    remove: function(selector) {
      return remove(this, selector);
    },
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var ignored = [];
      return domManip(this, arguments, function(elem) {
        var parent = this.parentNode;
        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));
          if (parent) {
            parent.replaceChild(elem, this);
          }
        }
      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe,
      elemdisplay = {
        HTML: "block",
        BODY: "block"
      };
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
        display = jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }
  function defaultDisplay(nodeName) {
    var doc = document,
        display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    var view = elem.ownerDocument.defaultView;
    if (!view || !view.opener) {
      view = window;
    }
    return view.getComputedStyle(elem);
  };
  var swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var documentElement = document.documentElement;
  (function() {
    var pixelPositionVal,
        boxSizingReliableVal,
        pixelMarginRightVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
    container.appendChild(div);
    function computeStyleTests() {
      div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
      div.innerHTML = "";
      documentElement.appendChild(container);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";
      reliableMarginLeftVal = divStyle.marginLeft === "2px";
      boxSizingReliableVal = divStyle.width === "4px";
      div.style.marginRight = "50%";
      pixelMarginRightVal = divStyle.marginRight === "4px";
      documentElement.removeChild(container);
    }
    jQuery.extend(support, {
      pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
      },
      boxSizingReliable: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return boxSizingReliableVal;
      },
      pixelMarginRight: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return pixelMarginRightVal;
      },
      reliableMarginLeft: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return reliableMarginLeftVal;
      },
      reliableMarginRight: function() {
        var ret,
            marginDiv = div.appendChild(document.createElement("div"));
        marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
        marginDiv.style.marginRight = marginDiv.style.width = "0";
        div.style.width = "1px";
        documentElement.appendChild(container);
        ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
        documentElement.removeChild(container);
        div.removeChild(marginDiv);
        return ret;
      }
    });
  })();
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
    if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
      ret = jQuery.style(elem, name);
    }
    if (computed) {
      if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "O", "Moz", "ms"],
      emptyStyle = document.createElement("div").style;
  function vendorPropName(name) {
    if (name in emptyStyle) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rcssNum.exec(value);
    return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
        val = 0;
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (document.msFullscreenElement && window.top !== window) {
      if (elem.getClientRects().length) {
        val = Math.round(elem.getBoundingClientRect()[name] * 100);
      }
    }
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
  }
  function showHide(elements, show) {
    var display,
        elem,
        hidden,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = dataPriv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {"float": "cssFloat"},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var matches,
            styles = extra && getStyles(elem),
            subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[name] = value;
          value = jQuery.css(elem, name);
        }
        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {marginLeft: 0}, function() {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  });
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
    if (computed) {
      return swap(elem, {"display": "inline-block"}, curCSS, [elem, "marginRight"]);
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;
  function createFxNow() {
    window.setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        tween,
        hooks,
        oldfire,
        display,
        checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden(elem),
        dataShow = dataPriv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = dataPriv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        dataPriv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          } else {
            deferred.resolveWith(elem, [animation]);
            return false;
          }
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        if (jQuery.isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
        }
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {"*": [function(prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]},
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnotwhite);
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    window.clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function() {
        window.clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        elem.setAttribute(name, value + "");
        return value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      ret = jQuery.find.attr(elem, name);
      return ret == null ? undefined : ret;
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}},
    removeAttr: function(elem, value) {
      var name,
          propName,
          i = 0,
          attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    }
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        return (elem[name] = value);
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      return elem[name];
    },
    propHooks: {tabIndex: {get: function(elem) {
          var tabindex = jQuery.find.attr(elem, "tabindex");
          return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
        }}},
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function(elem) {
        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnotwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }
      if (!arguments.length) {
        return this.attr("class", "");
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnotwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = jQuery.trim(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }
      return this.each(function() {
        var className,
            i,
            self,
            classNames;
        if (type === "string") {
          i = 0;
          self = jQuery(this);
          classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            dataPriv.set(this, "__className__", className);
          }
          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";
      while ((elem = this[i++])) {
        if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g,
      rspaces = /[\x20\t\r\n\f]+/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one" || index < 0,
              values = one ? null : [],
              max = one ? index + 1 : options.length,
              i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
  jQuery.extend(jQuery.event, {
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") > -1) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    simulate: function(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  });
  jQuery.fn.extend({
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }});
  support.focusin = "onfocusin" in window;
  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  var location = window.location;
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function(data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      xml = (new window.DOMParser()).parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rhash = /#.*$/,
      rts = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      originAnchor = document.createElement("a");
  originAnchor.href = location.href;
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          urlAnchor,
          fireGlobals,
          i,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          state = 0,
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (state === 2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return state === 2 ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              var lname = name.toLowerCase();
              if (!state) {
                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (!state) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (state < 2) {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                } else {
                  jqXHR.always(map[jqXHR.status]);
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");
        try {
          urlAnchor.href = s.url;
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          s.crossDomain = true;
        }
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in {
        success: 1,
        error: 1,
        complete: 1
      }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (state === 2) {
          return jqXHR;
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function() {
      return this.parent().each(function() {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function(elem) {
    return !jQuery.expr.filters.visible(elem);
  };
  jQuery.expr.filters.visible = function(elem) {
    return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
  };
  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, value) {
          value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };
  var xhrSuccessStatus = {
    0: 200,
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback,
        errorCallback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {binary: xhr.response} : {text: xhr.responseText}, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          errorCallback = xhr.onerror = callback("error");
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                window.setTimeout(function() {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          }
          callback = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"},
    contents: {script: /\b(?:java|ecma)script\b/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);
        } else {
          window[callbackName] = overwritten;
        }
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data),
        scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off > -1) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).always(callback && function(jqXHR, status) {
        self.each(function() {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem,
          win,
          elem = this[0],
          box = {
            top: 0,
            left: 0
          },
          doc = elem && elem.ownerDocument;
      if (!doc) {
        return;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      box = elem.getBoundingClientRect();
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
          offset,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent;
        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.extend({
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    size: function() {
      return this.length;
    }
  });
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" && define.amd) {
    define("npm:jquery@2.2.3/dist/jquery.js", [], function() {
      return jQuery;
    }), define("jquery", ["npm:jquery@2.2.3/dist/jquery.js"], function(m) {
      return m;
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));

})();
(function() {
var define = System.amdDefine;
define("npm:jquery@2.2.3.js", ["npm:jquery@2.2.3/dist/jquery.js"], function(main) {
  return main;
});

})();
System.registerDynamic("vendor/bootstrap/js/transition.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      function transitionEnd() {
        var el = document.createElement('bootstrap');
        var transEndEventNames = {
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          OTransition: 'oTransitionEnd otransitionend',
          transition: 'transitionend'
        };
        for (var name in transEndEventNames) {
          if (el.style[name] !== undefined) {
            return {end: transEndEventNames[name]};
          }
        }
        return false;
      }
      $.fn.emulateTransitionEnd = function(duration) {
        var called = false;
        var $el = this;
        $(this).one('bsTransitionEnd', function() {
          called = true;
        });
        var callback = function() {
          if (!called)
            $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
      };
      $(function() {
        $.support.transition = transitionEnd();
        if (!$.support.transition)
          return;
        $.event.special.bsTransitionEnd = {
          bindType: $.support.transition.end,
          delegateType: $.support.transition.end,
          handle: function(e) {
            if ($(e.target).is(this))
              return e.handleObj.handler.apply(this, arguments);
          }
        };
      });
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/alert.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      var dismiss = '[data-dismiss="alert"]';
      var Alert = function(el) {
        $(el).on('click', dismiss, this.close);
      };
      Alert.VERSION = '3.3.6';
      Alert.TRANSITION_DURATION = 150;
      Alert.prototype.close = function(e) {
        var $this = $(this);
        var selector = $this.attr('data-target');
        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
        }
        var $parent = $(selector);
        if (e)
          e.preventDefault();
        if (!$parent.length) {
          $parent = $this.closest('.alert');
        }
        $parent.trigger(e = $.Event('close.bs.alert'));
        if (e.isDefaultPrevented())
          return;
        $parent.removeClass('in');
        function removeElement() {
          $parent.detach().trigger('closed.bs.alert').remove();
        }
        $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.alert');
          if (!data)
            $this.data('bs.alert', (data = new Alert(this)));
          if (typeof option == 'string')
            data[option].call($this);
        });
      }
      var old = $.fn.alert;
      $.fn.alert = Plugin;
      $.fn.alert.Constructor = Alert;
      $.fn.alert.noConflict = function() {
        $.fn.alert = old;
        return this;
      };
      $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/button.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
      };
      Button.VERSION = '3.3.6';
      Button.DEFAULTS = {loadingText: 'loading...'};
      Button.prototype.setState = function(state) {
        var d = 'disabled';
        var $el = this.$element;
        var val = $el.is('input') ? 'val' : 'html';
        var data = $el.data();
        state += 'Text';
        if (data.resetText == null)
          $el.data('resetText', $el[val]());
        setTimeout($.proxy(function() {
          $el[val](data[state] == null ? this.options[state] : data[state]);
          if (state == 'loadingText') {
            this.isLoading = true;
            $el.addClass(d).attr(d, d);
          } else if (this.isLoading) {
            this.isLoading = false;
            $el.removeClass(d).removeAttr(d);
          }
        }, this), 0);
      };
      Button.prototype.toggle = function() {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
          var $input = this.$element.find('input');
          if ($input.prop('type') == 'radio') {
            if ($input.prop('checked'))
              changed = false;
            $parent.find('.active').removeClass('active');
            this.$element.addClass('active');
          } else if ($input.prop('type') == 'checkbox') {
            if (($input.prop('checked')) !== this.$element.hasClass('active'))
              changed = false;
            this.$element.toggleClass('active');
          }
          $input.prop('checked', this.$element.hasClass('active'));
          if (changed)
            $input.trigger('change');
        } else {
          this.$element.attr('aria-pressed', !this.$element.hasClass('active'));
          this.$element.toggleClass('active');
        }
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.button');
          var options = typeof option == 'object' && option;
          if (!data)
            $this.data('bs.button', (data = new Button(this, options)));
          if (option == 'toggle')
            data.toggle();
          else if (option)
            data.setState(option);
        });
      }
      var old = $.fn.button;
      $.fn.button = Plugin;
      $.fn.button.Constructor = Button;
      $.fn.button.noConflict = function() {
        $.fn.button = old;
        return this;
      };
      $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target);
        if (!$btn.hasClass('btn'))
          $btn = $btn.closest('.btn');
        Plugin.call($btn, 'toggle');
        if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]')))
          e.preventDefault();
      }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function(e) {
        $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
      });
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/carousel.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      var Carousel = function(element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find('.carousel-indicators');
        this.options = options;
        this.paused = null;
        this.sliding = null;
        this.interval = null;
        this.$active = null;
        this.$items = null;
        this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));
        this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));
      };
      Carousel.VERSION = '3.3.6';
      Carousel.TRANSITION_DURATION = 600;
      Carousel.DEFAULTS = {
        interval: 5000,
        pause: 'hover',
        wrap: true,
        keyboard: true
      };
      Carousel.prototype.keydown = function(e) {
        if (/input|textarea/i.test(e.target.tagName))
          return;
        switch (e.which) {
          case 37:
            this.prev();
            break;
          case 39:
            this.next();
            break;
          default:
            return;
        }
        e.preventDefault();
      };
      Carousel.prototype.cycle = function(e) {
        e || (this.paused = false);
        this.interval && clearInterval(this.interval);
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
        return this;
      };
      Carousel.prototype.getItemIndex = function(item) {
        this.$items = item.parent().children('.item');
        return this.$items.index(item || this.$active);
      };
      Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = (direction == 'prev' && activeIndex === 0) || (direction == 'next' && activeIndex == (this.$items.length - 1));
        if (willWrap && !this.options.wrap)
          return active;
        var delta = direction == 'prev' ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
      };
      Carousel.prototype.to = function(pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));
        if (pos > (this.$items.length - 1) || pos < 0)
          return;
        if (this.sliding)
          return this.$element.one('slid.bs.carousel', function() {
            that.to(pos);
          });
        if (activeIndex == pos)
          return this.pause().cycle();
        return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));
      };
      Carousel.prototype.pause = function(e) {
        e || (this.paused = true);
        if (this.$element.find('.next, .prev').length && $.support.transition) {
          this.$element.trigger($.support.transition.end);
          this.cycle(true);
        }
        this.interval = clearInterval(this.interval);
        return this;
      };
      Carousel.prototype.next = function() {
        if (this.sliding)
          return;
        return this.slide('next');
      };
      Carousel.prototype.prev = function() {
        if (this.sliding)
          return;
        return this.slide('prev');
      };
      Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find('.item.active');
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == 'next' ? 'left' : 'right';
        var that = this;
        if ($next.hasClass('active'))
          return (this.sliding = false);
        var relatedTarget = $next[0];
        var slideEvent = $.Event('slide.bs.carousel', {
          relatedTarget: relatedTarget,
          direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented())
          return;
        this.sliding = true;
        isCycling && this.pause();
        if (this.$indicators.length) {
          this.$indicators.find('.active').removeClass('active');
          var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
          $nextIndicator && $nextIndicator.addClass('active');
        }
        var slidEvent = $.Event('slid.bs.carousel', {
          relatedTarget: relatedTarget,
          direction: direction
        });
        if ($.support.transition && this.$element.hasClass('slide')) {
          $next.addClass(type);
          $next[0].offsetWidth;
          $active.addClass(direction);
          $next.addClass(direction);
          $active.one('bsTransitionEnd', function() {
            $next.removeClass([type, direction].join(' ')).addClass('active');
            $active.removeClass(['active', direction].join(' '));
            that.sliding = false;
            setTimeout(function() {
              that.$element.trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
          $active.removeClass('active');
          $next.addClass('active');
          this.sliding = false;
          this.$element.trigger(slidEvent);
        }
        isCycling && this.cycle();
        return this;
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.carousel');
          var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option);
          var action = typeof option == 'string' ? option : options.slide;
          if (!data)
            $this.data('bs.carousel', (data = new Carousel(this, options)));
          if (typeof option == 'number')
            data.to(option);
          else if (action)
            data[action]();
          else if (options.interval)
            data.pause().cycle();
        });
      }
      var old = $.fn.carousel;
      $.fn.carousel = Plugin;
      $.fn.carousel.Constructor = Carousel;
      $.fn.carousel.noConflict = function() {
        $.fn.carousel = old;
        return this;
      };
      var clickHandler = function(e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''));
        if (!$target.hasClass('carousel'))
          return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr('data-slide-to');
        if (slideIndex)
          options.interval = false;
        Plugin.call($target, options);
        if (slideIndex) {
          $target.data('bs.carousel').to(slideIndex);
        }
        e.preventDefault();
      };
      $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);
      $(window).on('load', function() {
        $('[data-ride="carousel"]').each(function() {
          var $carousel = $(this);
          Plugin.call($carousel, $carousel.data());
        });
      });
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/collapse.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;
        if (this.options.parent) {
          this.$parent = this.getParent();
        } else {
          this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }
        if (this.options.toggle)
          this.toggle();
      };
      Collapse.VERSION = '3.3.6';
      Collapse.TRANSITION_DURATION = 350;
      Collapse.DEFAULTS = {toggle: true};
      Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass('width');
        return hasWidth ? 'width' : 'height';
      };
      Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass('in'))
          return;
        var activesData;
        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');
        if (actives && actives.length) {
          activesData = actives.data('bs.collapse');
          if (activesData && activesData.transitioning)
            return;
        }
        var startEvent = $.Event('show.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented())
          return;
        if (actives && actives.length) {
          Plugin.call(actives, 'hide');
          activesData || actives.data('bs.collapse', null);
        }
        var dimension = this.dimension();
        this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);
        this.$trigger.removeClass('collapsed').attr('aria-expanded', true);
        this.transitioning = 1;
        var complete = function() {
          this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');
          this.transitioning = 0;
          this.$element.trigger('shown.bs.collapse');
        };
        if (!$.support.transition)
          return complete.call(this);
        var scrollSize = $.camelCase(['scroll', dimension].join('-'));
        this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
      };
      Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass('in'))
          return;
        var startEvent = $.Event('hide.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented())
          return;
        var dimension = this.dimension();
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
        this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);
        this.$trigger.addClass('collapsed').attr('aria-expanded', false);
        this.transitioning = 1;
        var complete = function() {
          this.transitioning = 0;
          this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');
        };
        if (!$.support.transition)
          return complete.call(this);
        this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
      };
      Collapse.prototype.toggle = function() {
        this[this.$element.hasClass('in') ? 'hide' : 'show']();
      };
      Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
          var $element = $(element);
          this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
      };
      Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass('in');
        $element.attr('aria-expanded', isOpen);
        $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);
      };
      function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '');
        return $(target);
      }
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.collapse');
          var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option);
          if (!data && options.toggle && /show|hide/.test(option))
            options.toggle = false;
          if (!data)
            $this.data('bs.collapse', (data = new Collapse(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.collapse;
      $.fn.collapse = Plugin;
      $.fn.collapse.Constructor = Collapse;
      $.fn.collapse.noConflict = function() {
        $.fn.collapse = old;
        return this;
      };
      $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        if (!$this.attr('data-target'))
          e.preventDefault();
        var $target = getTargetFromTrigger($this);
        var data = $target.data('bs.collapse');
        var option = data ? 'toggle' : $this.data();
        Plugin.call($target, option);
      });
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/dropdown.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      var backdrop = '.dropdown-backdrop';
      var toggle = '[data-toggle="dropdown"]';
      var Dropdown = function(element) {
        $(element).on('click.bs.dropdown', this.toggle);
      };
      Dropdown.VERSION = '3.3.6';
      function getParent($this) {
        var selector = $this.attr('data-target');
        if (!selector) {
          selector = $this.attr('href');
          selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
        }
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
      }
      function clearMenus(e) {
        if (e && e.which === 3)
          return;
        $(backdrop).remove();
        $(toggle).each(function() {
          var $this = $(this);
          var $parent = getParent($this);
          var relatedTarget = {relatedTarget: this};
          if (!$parent.hasClass('open'))
            return;
          if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target))
            return;
          $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));
          if (e.isDefaultPrevented())
            return;
          $this.attr('aria-expanded', 'false');
          $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget));
        });
      }
      Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if ($this.is('.disabled, :disabled'))
          return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');
        clearMenus();
        if (!isActive) {
          if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
            $(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus);
          }
          var relatedTarget = {relatedTarget: this};
          $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));
          if (e.isDefaultPrevented())
            return;
          $this.trigger('focus').attr('aria-expanded', 'true');
          $parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget));
        }
        return false;
      };
      Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName))
          return;
        var $this = $(this);
        e.preventDefault();
        e.stopPropagation();
        if ($this.is('.disabled, :disabled'))
          return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
          if (e.which == 27)
            $parent.find(toggle).trigger('focus');
          return $this.trigger('click');
        }
        var desc = ' li:not(.disabled):visible a';
        var $items = $parent.find('.dropdown-menu' + desc);
        if (!$items.length)
          return;
        var index = $items.index(e.target);
        if (e.which == 38 && index > 0)
          index--;
        if (e.which == 40 && index < $items.length - 1)
          index++;
        if (!~index)
          index = 0;
        $items.eq(index).trigger('focus');
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.dropdown');
          if (!data)
            $this.data('bs.dropdown', (data = new Dropdown(this)));
          if (typeof option == 'string')
            data[option].call($this);
        });
      }
      var old = $.fn.dropdown;
      $.fn.dropdown = Plugin;
      $.fn.dropdown.Constructor = Dropdown;
      $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old;
        return this;
      };
      $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function(e) {
        e.stopPropagation();
      }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/modal.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      var Modal = function(element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$dialog = this.$element.find('.modal-dialog');
        this.$backdrop = null;
        this.isShown = null;
        this.originalBodyPad = null;
        this.scrollbarWidth = 0;
        this.ignoreBackdropClick = false;
        if (this.options.remote) {
          this.$element.find('.modal-content').load(this.options.remote, $.proxy(function() {
            this.$element.trigger('loaded.bs.modal');
          }, this));
        }
      };
      Modal.VERSION = '3.3.6';
      Modal.TRANSITION_DURATION = 300;
      Modal.BACKDROP_TRANSITION_DURATION = 150;
      Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
      };
      Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
      };
      Modal.prototype.show = function(_relatedTarget) {
        var that = this;
        var e = $.Event('show.bs.modal', {relatedTarget: _relatedTarget});
        this.$element.trigger(e);
        if (this.isShown || e.isDefaultPrevented())
          return;
        this.isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass('modal-open');
        this.escape();
        this.resize();
        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));
        this.$dialog.on('mousedown.dismiss.bs.modal', function() {
          that.$element.one('mouseup.dismiss.bs.modal', function(e) {
            if ($(e.target).is(that.$element))
              that.ignoreBackdropClick = true;
          });
        });
        this.backdrop(function() {
          var transition = $.support.transition && that.$element.hasClass('fade');
          if (!that.$element.parent().length) {
            that.$element.appendTo(that.$body);
          }
          that.$element.show().scrollTop(0);
          that.adjustDialog();
          if (transition) {
            that.$element[0].offsetWidth;
          }
          that.$element.addClass('in');
          that.enforceFocus();
          var e = $.Event('shown.bs.modal', {relatedTarget: _relatedTarget});
          transition ? that.$dialog.one('bsTransitionEnd', function() {
            that.$element.trigger('focus').trigger(e);
          }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
        });
      };
      Modal.prototype.hide = function(e) {
        if (e)
          e.preventDefault();
        e = $.Event('hide.bs.modal');
        this.$element.trigger(e);
        if (!this.isShown || e.isDefaultPrevented())
          return;
        this.isShown = false;
        this.escape();
        this.resize();
        $(document).off('focusin.bs.modal');
        this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');
        this.$dialog.off('mousedown.dismiss.bs.modal');
        $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
      };
      Modal.prototype.enforceFocus = function() {
        $(document).off('focusin.bs.modal').on('focusin.bs.modal', $.proxy(function(e) {
          if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
            this.$element.trigger('focus');
          }
        }, this));
      };
      Modal.prototype.escape = function() {
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keydown.dismiss.bs.modal', $.proxy(function(e) {
            e.which == 27 && this.hide();
          }, this));
        } else if (!this.isShown) {
          this.$element.off('keydown.dismiss.bs.modal');
        }
      };
      Modal.prototype.resize = function() {
        if (this.isShown) {
          $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
        } else {
          $(window).off('resize.bs.modal');
        }
      };
      Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide();
        this.backdrop(function() {
          that.$body.removeClass('modal-open');
          that.resetAdjustments();
          that.resetScrollbar();
          that.$element.trigger('hidden.bs.modal');
        });
      };
      Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
      };
      Modal.prototype.backdrop = function(callback) {
        var that = this;
        var animate = this.$element.hasClass('fade') ? 'fade' : '';
        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate;
          this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);
          this.$element.on('click.dismiss.bs.modal', $.proxy(function(e) {
            if (this.ignoreBackdropClick) {
              this.ignoreBackdropClick = false;
              return;
            }
            if (e.target !== e.currentTarget)
              return;
            this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
          }, this));
          if (doAnimate)
            this.$backdrop[0].offsetWidth;
          this.$backdrop.addClass('in');
          if (!callback)
            return;
          doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in');
          var callbackRemove = function() {
            that.removeBackdrop();
            callback && callback();
          };
          $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
          callback();
        }
      };
      Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
      };
      Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
          paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
          paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
        });
      };
      Modal.prototype.resetAdjustments = function() {
        this.$element.css({
          paddingLeft: '',
          paddingRight: ''
        });
      };
      Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
          var documentElementRect = document.documentElement.getBoundingClientRect();
          fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
        this.scrollbarWidth = this.measureScrollbar();
      };
      Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10);
        this.originalBodyPad = document.body.style.paddingRight || '';
        if (this.bodyIsOverflowing)
          this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
      };
      Modal.prototype.resetScrollbar = function() {
        this.$body.css('padding-right', this.originalBodyPad);
      };
      Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement('div');
        scrollDiv.className = 'modal-scrollbar-measure';
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
      };
      function Plugin(option, _relatedTarget) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.modal');
          var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option);
          if (!data)
            $this.data('bs.modal', (data = new Modal(this, options)));
          if (typeof option == 'string')
            data[option](_relatedTarget);
          else if (options.show)
            data.show(_relatedTarget);
        });
      }
      var old = $.fn.modal;
      $.fn.modal = Plugin;
      $.fn.modal.Constructor = Modal;
      $.fn.modal.noConflict = function() {
        $.fn.modal = old;
        return this;
      };
      $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function(e) {
        var $this = $(this);
        var href = $this.attr('href');
        var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, '')));
        var option = $target.data('bs.modal') ? 'toggle' : $.extend({remote: !/#/.test(href) && href}, $target.data(), $this.data());
        if ($this.is('a'))
          e.preventDefault();
        $target.one('show.bs.modal', function(showEvent) {
          if (showEvent.isDefaultPrevented())
            return;
          $target.one('hidden.bs.modal', function() {
            $this.is(':visible') && $this.trigger('focus');
          });
        });
        Plugin.call($target, option, this);
      });
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/tooltip.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      var Tooltip = function(element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.inState = null;
        this.init('tooltip', element, options);
      };
      Tooltip.VERSION = '3.3.6';
      Tooltip.TRANSITION_DURATION = 150;
      Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
          selector: 'body',
          padding: 0
        }
      };
      Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport));
        this.inState = {
          click: false,
          hover: false,
          focus: false
        };
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
          throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');
        }
        var triggers = this.options.trigger.split(' ');
        for (var i = triggers.length; i--; ) {
          var trigger = triggers[i];
          if (trigger == 'click') {
            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
          } else if (trigger != 'manual') {
            var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';
            this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
          }
        }
        this.options.selector ? (this._options = $.extend({}, this.options, {
          trigger: 'manual',
          selector: ''
        })) : this.fixTitle();
      };
      Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
      };
      Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);
        if (options.delay && typeof options.delay == 'number') {
          options.delay = {
            show: options.delay,
            hide: options.delay
          };
        }
        return options;
      };
      Tooltip.prototype.getDelegateOptions = function() {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function(key, value) {
          if (defaults[key] != value)
            options[key] = value;
        });
        return options;
      };
      Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);
        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }
        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true;
        }
        if (self.tip().hasClass('in') || self.hoverState == 'in') {
          self.hoverState = 'in';
          return;
        }
        clearTimeout(self.timeout);
        self.hoverState = 'in';
        if (!self.options.delay || !self.options.delay.show)
          return self.show();
        self.timeout = setTimeout(function() {
          if (self.hoverState == 'in')
            self.show();
        }, self.options.delay.show);
      };
      Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) {
          if (this.inState[key])
            return true;
        }
        return false;
      };
      Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);
        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }
        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false;
        }
        if (self.isInStateTrue())
          return;
        clearTimeout(self.timeout);
        self.hoverState = 'out';
        if (!self.options.delay || !self.options.delay.hide)
          return self.hide();
        self.timeout = setTimeout(function() {
          if (self.hoverState == 'out')
            self.hide();
        }, self.options.delay.hide);
      };
      Tooltip.prototype.show = function() {
        var e = $.Event('show.bs.' + this.type);
        if (this.hasContent() && this.enabled) {
          this.$element.trigger(e);
          var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
          if (e.isDefaultPrevented() || !inDom)
            return;
          var that = this;
          var $tip = this.tip();
          var tipId = this.getUID(this.type);
          this.setContent();
          $tip.attr('id', tipId);
          this.$element.attr('aria-describedby', tipId);
          if (this.options.animation)
            $tip.addClass('fade');
          var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
          var autoToken = /\s?auto?\s?/i;
          var autoPlace = autoToken.test(placement);
          if (autoPlace)
            placement = placement.replace(autoToken, '') || 'top';
          $tip.detach().css({
            top: 0,
            left: 0,
            display: 'block'
          }).addClass(placement).data('bs.' + this.type, this);
          this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
          this.$element.trigger('inserted.bs.' + this.type);
          var pos = this.getPosition();
          var actualWidth = $tip[0].offsetWidth;
          var actualHeight = $tip[0].offsetHeight;
          if (autoPlace) {
            var orgPlacement = placement;
            var viewportDim = this.getPosition(this.$viewport);
            placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement;
            $tip.removeClass(orgPlacement).addClass(placement);
          }
          var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
          this.applyPlacement(calculatedOffset, placement);
          var complete = function() {
            var prevHoverState = that.hoverState;
            that.$element.trigger('shown.bs.' + that.type);
            that.hoverState = null;
            if (prevHoverState == 'out')
              that.leave(that);
          };
          $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
      };
      Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;
        var marginTop = parseInt($tip.css('margin-top'), 10);
        var marginLeft = parseInt($tip.css('margin-left'), 10);
        if (isNaN(marginTop))
          marginTop = 0;
        if (isNaN(marginLeft))
          marginLeft = 0;
        offset.top += marginTop;
        offset.left += marginLeft;
        $.offset.setOffset($tip[0], $.extend({using: function(props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left)
            });
          }}, offset), 0);
        $tip.addClass('in');
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;
        if (placement == 'top' && actualHeight != height) {
          offset.top = offset.top + height - actualHeight;
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left)
          offset.left += delta.left;
        else
          offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
      };
      Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');
      };
      Tooltip.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
        $tip.removeClass('fade in top bottom left right');
      };
      Tooltip.prototype.hide = function(callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event('hide.bs.' + this.type);
        function complete() {
          if (that.hoverState != 'in')
            $tip.detach();
          that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
          callback && callback();
        }
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $tip.removeClass('in');
        $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
      };
      Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
        }
      };
      Tooltip.prototype.hasContent = function() {
        return this.getTitle();
      };
      Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == 'BODY';
        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
          elRect = $.extend({}, elRect, {
            width: elRect.right - elRect.left,
            height: elRect.bottom - elRect.top
          });
        }
        var elOffset = isBody ? {
          top: 0,
          left: 0
        } : $element.offset();
        var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()};
        var outerDims = isBody ? {
          width: $(window).width(),
          height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
      };
      Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? {
          top: pos.top + pos.height,
          left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'top' ? {
          top: pos.top - actualHeight,
          left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'left' ? {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left - actualWidth
        } : {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left + pos.width
        };
      };
      Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
          top: 0,
          left: 0
        };
        if (!this.$viewport)
          return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
          var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
          if (topEdgeOffset < viewportDimensions.top) {
            delta.top = viewportDimensions.top - topEdgeOffset;
          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
          }
        } else {
          var leftEdgeOffset = pos.left - viewportPadding;
          var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
          if (leftEdgeOffset < viewportDimensions.left) {
            delta.left = viewportDimensions.left - leftEdgeOffset;
          } else if (rightEdgeOffset > viewportDimensions.right) {
            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
          }
        }
        return delta;
      };
      Tooltip.prototype.getTitle = function() {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);
        return title;
      };
      Tooltip.prototype.getUID = function(prefix) {
        do
          prefix += ~~(Math.random() * 1000000);
 while (document.getElementById(prefix));
        return prefix;
      };
      Tooltip.prototype.tip = function() {
        if (!this.$tip) {
          this.$tip = $(this.options.template);
          if (this.$tip.length != 1) {
            throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!');
          }
        }
        return this.$tip;
      };
      Tooltip.prototype.arrow = function() {
        return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'));
      };
      Tooltip.prototype.enable = function() {
        this.enabled = true;
      };
      Tooltip.prototype.disable = function() {
        this.enabled = false;
      };
      Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
      };
      Tooltip.prototype.toggle = function(e) {
        var self = this;
        if (e) {
          self = $(e.currentTarget).data('bs.' + this.type);
          if (!self) {
            self = new this.constructor(e.currentTarget, this.getDelegateOptions());
            $(e.currentTarget).data('bs.' + this.type, self);
          }
        }
        if (e) {
          self.inState.click = !self.inState.click;
          if (self.isInStateTrue())
            self.enter(self);
          else
            self.leave(self);
        } else {
          self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
        }
      };
      Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function() {
          that.$element.off('.' + that.type).removeData('bs.' + that.type);
          if (that.$tip) {
            that.$tip.detach();
          }
          that.$tip = null;
          that.$arrow = null;
          that.$viewport = null;
        });
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.tooltip');
          var options = typeof option == 'object' && option;
          if (!data && /destroy|hide/.test(option))
            return;
          if (!data)
            $this.data('bs.tooltip', (data = new Tooltip(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.tooltip;
      $.fn.tooltip = Plugin;
      $.fn.tooltip.Constructor = Tooltip;
      $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old;
        return this;
      };
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/popover.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      var Popover = function(element, options) {
        this.init('popover', element, options);
      };
      if (!$.fn.tooltip)
        throw new Error('Popover requires tooltip.js');
      Popover.VERSION = '3.3.6';
      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      });
      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
      Popover.prototype.constructor = Popover;
      Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
      };
      Popover.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
        $tip.find('.popover-content').children().detach().end()[this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'](content);
        $tip.removeClass('fade top bottom left right in');
        if (!$tip.find('.popover-title').html())
          $tip.find('.popover-title').hide();
      };
      Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
      };
      Popover.prototype.getContent = function() {
        var $e = this.$element;
        var o = this.options;
        return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
      };
      Popover.prototype.arrow = function() {
        return (this.$arrow = this.$arrow || this.tip().find('.arrow'));
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.popover');
          var options = typeof option == 'object' && option;
          if (!data && /destroy|hide/.test(option))
            return;
          if (!data)
            $this.data('bs.popover', (data = new Popover(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.popover;
      $.fn.popover = Plugin;
      $.fn.popover.Constructor = Popover;
      $.fn.popover.noConflict = function() {
        $.fn.popover = old;
        return this;
      };
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/scrollspy.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      function ScrollSpy(element, options) {
        this.$body = $(document.body);
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || '') + ' .nav li > a';
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;
        this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));
        this.refresh();
        this.process();
      }
      ScrollSpy.VERSION = '3.3.6';
      ScrollSpy.DEFAULTS = {offset: 10};
      ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
      };
      ScrollSpy.prototype.refresh = function() {
        var that = this;
        var offsetMethod = 'offset';
        var offsetBase = 0;
        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();
        if (!$.isWindow(this.$scrollElement[0])) {
          offsetMethod = 'position';
          offsetBase = this.$scrollElement.scrollTop();
        }
        this.$body.find(this.selector).map(function() {
          var $el = $(this);
          var href = $el.data('target') || $el.attr('href');
          var $href = /^#./.test(href) && $(href);
          return ($href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]]) || null;
        }).sort(function(a, b) {
          return a[0] - b[0];
        }).each(function() {
          that.offsets.push(this[0]);
          that.targets.push(this[1]);
        });
      };
      ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;
        if (this.scrollHeight != scrollHeight) {
          this.refresh();
        }
        if (scrollTop >= maxScroll) {
          return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }
        if (activeTarget && scrollTop < offsets[0]) {
          this.activeTarget = null;
          return this.clear();
        }
        for (i = offsets.length; i--; ) {
          activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
        }
      };
      ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target;
        this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
        var active = $(selector).parents('li').addClass('active');
        if (active.parent('.dropdown-menu').length) {
          active = active.closest('li.dropdown').addClass('active');
        }
        active.trigger('activate.bs.scrollspy');
      };
      ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.scrollspy');
          var options = typeof option == 'object' && option;
          if (!data)
            $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.scrollspy;
      $.fn.scrollspy = Plugin;
      $.fn.scrollspy.Constructor = ScrollSpy;
      $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old;
        return this;
      };
      $(window).on('load.bs.scrollspy.data-api', function() {
        $('[data-spy="scroll"]').each(function() {
          var $spy = $(this);
          Plugin.call($spy, $spy.data());
        });
      });
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/tab.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      var Tab = function(element) {
        this.element = $(element);
      };
      Tab.VERSION = '3.3.6';
      Tab.TRANSITION_DURATION = 150;
      Tab.prototype.show = function() {
        var $this = this.element;
        var $ul = $this.closest('ul:not(.dropdown-menu)');
        var selector = $this.data('target');
        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
        }
        if ($this.parent('li').hasClass('active'))
          return;
        var $previous = $ul.find('.active:last a');
        var hideEvent = $.Event('hide.bs.tab', {relatedTarget: $this[0]});
        var showEvent = $.Event('show.bs.tab', {relatedTarget: $previous[0]});
        $previous.trigger(hideEvent);
        $this.trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented())
          return;
        var $target = $(selector);
        this.activate($this.closest('li'), $ul);
        this.activate($target, $target.parent(), function() {
          $previous.trigger({
            type: 'hidden.bs.tab',
            relatedTarget: $this[0]
          });
          $this.trigger({
            type: 'shown.bs.tab',
            relatedTarget: $previous[0]
          });
        });
      };
      Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find('> .active');
        var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);
        function next() {
          $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);
          element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);
          if (transition) {
            element[0].offsetWidth;
            element.addClass('in');
          } else {
            element.removeClass('fade');
          }
          if (element.parent('.dropdown-menu').length) {
            element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
          }
          callback && callback();
        }
        $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
        $active.removeClass('in');
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.tab');
          if (!data)
            $this.data('bs.tab', (data = new Tab(this)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.tab;
      $.fn.tab = Plugin;
      $.fn.tab.Constructor = Tab;
      $.fn.tab.noConflict = function() {
        $.fn.tab = old;
        return this;
      };
      var clickHandler = function(e) {
        e.preventDefault();
        Plugin.call($(this), 'show');
      };
      $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/js/affix.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    +function($) {
      'use strict';
      var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);
        this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));
        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;
        this.checkPosition();
      };
      Affix.VERSION = '3.3.6';
      Affix.RESET = 'affix affix-top affix-bottom';
      Affix.DEFAULTS = {
        offset: 0,
        target: window
      };
      Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();
        if (offsetTop != null && this.affixed == 'top')
          return scrollTop < offsetTop ? 'top' : false;
        if (this.affixed == 'bottom') {
          if (offsetTop != null)
            return (scrollTop + this.unpin <= position.top) ? false : 'bottom';
          return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom';
        }
        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;
        if (offsetTop != null && scrollTop <= offsetTop)
          return 'top';
        if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom))
          return 'bottom';
        return false;
      };
      Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset)
          return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass('affix');
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return (this.pinnedOffset = position.top - scrollTop);
      };
      Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
      };
      Affix.prototype.checkPosition = function() {
        if (!this.$element.is(':visible'))
          return;
        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = Math.max($(document).height(), $(document.body).height());
        if (typeof offset != 'object')
          offsetBottom = offsetTop = offset;
        if (typeof offsetTop == 'function')
          offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == 'function')
          offsetBottom = offset.bottom(this.$element);
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
        if (this.affixed != affix) {
          if (this.unpin != null)
            this.$element.css('top', '');
          var affixType = 'affix' + (affix ? '-' + affix : '');
          var e = $.Event(affixType + '.bs.affix');
          this.$element.trigger(e);
          if (e.isDefaultPrevented())
            return;
          this.affixed = affix;
          this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;
          this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');
        }
        if (affix == 'bottom') {
          this.$element.offset({top: scrollHeight - height - offsetBottom});
        }
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.affix');
          var options = typeof option == 'object' && option;
          if (!data)
            $this.data('bs.affix', (data = new Affix(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.affix;
      $.fn.affix = Plugin;
      $.fn.affix.Constructor = Affix;
      $.fn.affix.noConflict = function() {
        $.fn.affix = old;
        return this;
      };
      $(window).on('load', function() {
        $('[data-spy="affix"]').each(function() {
          var $spy = $(this);
          var data = $spy.data();
          data.offset = data.offset || {};
          if (data.offsetBottom != null)
            data.offset.bottom = data.offsetBottom;
          if (data.offsetTop != null)
            data.offset.top = data.offsetTop;
          Plugin.call($spy, data);
        });
      });
    }(jQuery);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("vendor/bootstrap/dist/js/npm.js", ["../../js/transition.js", "../../js/alert.js", "../../js/button.js", "../../js/carousel.js", "../../js/collapse.js", "../../js/dropdown.js", "../../js/modal.js", "../../js/tooltip.js", "../../js/popover.js", "../../js/scrollspy.js", "../../js/tab.js", "../../js/affix.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('../../js/transition.js');
  $__require('../../js/alert.js');
  $__require('../../js/button.js');
  $__require('../../js/carousel.js');
  $__require('../../js/collapse.js');
  $__require('../../js/dropdown.js');
  $__require('../../js/modal.js');
  $__require('../../js/tooltip.js');
  $__require('../../js/popover.js');
  $__require('../../js/scrollspy.js');
  $__require('../../js/tab.js');
  $__require('../../js/affix.js');
  return module.exports;
});

System.registerDynamic("npm:bootstrap-dialog@1.34.6/src/js/bootstrap-dialog.js", ["jquery", "bootstrap"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(root, factory) {
    "use strict";
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = factory($__require('jquery'), $__require('bootstrap'));
    } else if (typeof define === "function" && define.amd) {
      define("bootstrap-dialog", ["jquery", "bootstrap"], function($) {
        return factory($);
      });
    } else {
      root.BootstrapDialog = factory(root.jQuery);
    }
  }(this, function($) {
    "use strict";
    var Modal = $.fn.modal.Constructor;
    var BootstrapDialogModal = function(element, options) {
      Modal.call(this, element, options);
    };
    BootstrapDialogModal.getModalVersion = function() {
      var version = null;
      if (typeof $.fn.modal.Constructor.VERSION === 'undefined') {
        version = 'v3.1';
      } else if (/3\.2\.\d+/.test($.fn.modal.Constructor.VERSION)) {
        version = 'v3.2';
      } else if (/3\.3\.[1,2]/.test($.fn.modal.Constructor.VERSION)) {
        version = 'v3.3';
      } else {
        version = 'v3.3.4';
      }
      return version;
    };
    BootstrapDialogModal.ORIGINAL_BODY_PADDING = parseInt(($('body').css('padding-right') || 0), 10);
    BootstrapDialogModal.METHODS_TO_OVERRIDE = {};
    BootstrapDialogModal.METHODS_TO_OVERRIDE['v3.1'] = {};
    BootstrapDialogModal.METHODS_TO_OVERRIDE['v3.2'] = {hide: function(e) {
        if (e) {
          e.preventDefault();
        }
        e = $.Event('hide.bs.modal');
        this.$element.trigger(e);
        if (!this.isShown || e.isDefaultPrevented()) {
          return;
        }
        this.isShown = false;
        var openedDialogs = this.getGlobalOpenedDialogs();
        if (openedDialogs.length === 0) {
          this.$body.removeClass('modal-open');
        }
        this.resetScrollbar();
        this.escape();
        $(document).off('focusin.bs.modal');
        this.$element.removeClass('in').attr('aria-hidden', true).off('click.dismiss.bs.modal');
        $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(300) : this.hideModal();
      }};
    BootstrapDialogModal.METHODS_TO_OVERRIDE['v3.3'] = {
      setScrollbar: function() {
        var bodyPad = BootstrapDialogModal.ORIGINAL_BODY_PADDING;
        if (this.bodyIsOverflowing) {
          this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
        }
      },
      resetScrollbar: function() {
        var openedDialogs = this.getGlobalOpenedDialogs();
        if (openedDialogs.length === 0) {
          this.$body.css('padding-right', BootstrapDialogModal.ORIGINAL_BODY_PADDING);
        }
      },
      hideModal: function() {
        this.$element.hide();
        this.backdrop($.proxy(function() {
          var openedDialogs = this.getGlobalOpenedDialogs();
          if (openedDialogs.length === 0) {
            this.$body.removeClass('modal-open');
          }
          this.resetAdjustments();
          this.resetScrollbar();
          this.$element.trigger('hidden.bs.modal');
        }, this));
      }
    };
    BootstrapDialogModal.METHODS_TO_OVERRIDE['v3.3.4'] = $.extend({}, BootstrapDialogModal.METHODS_TO_OVERRIDE['v3.3']);
    BootstrapDialogModal.prototype = {
      constructor: BootstrapDialogModal,
      getGlobalOpenedDialogs: function() {
        var openedDialogs = [];
        $.each(BootstrapDialog.dialogs, function(id, dialogInstance) {
          if (dialogInstance.isRealized() && dialogInstance.isOpened()) {
            openedDialogs.push(dialogInstance);
          }
        });
        return openedDialogs;
      }
    };
    BootstrapDialogModal.prototype = $.extend(BootstrapDialogModal.prototype, Modal.prototype, BootstrapDialogModal.METHODS_TO_OVERRIDE[BootstrapDialogModal.getModalVersion()]);
    var BootstrapDialog = function(options) {
      this.defaultOptions = $.extend(true, {
        id: BootstrapDialog.newGuid(),
        buttons: [],
        data: {},
        onshow: null,
        onshown: null,
        onhide: null,
        onhidden: null
      }, BootstrapDialog.defaultOptions);
      this.indexedButtons = {};
      this.registeredButtonHotkeys = {};
      this.draggableData = {
        isMouseDown: false,
        mouseOffset: {}
      };
      this.realized = false;
      this.opened = false;
      this.initOptions(options);
      this.holdThisInstance();
    };
    BootstrapDialog.BootstrapDialogModal = BootstrapDialogModal;
    BootstrapDialog.NAMESPACE = 'bootstrap-dialog';
    BootstrapDialog.TYPE_DEFAULT = 'type-default';
    BootstrapDialog.TYPE_INFO = 'type-info';
    BootstrapDialog.TYPE_PRIMARY = 'type-primary';
    BootstrapDialog.TYPE_SUCCESS = 'type-success';
    BootstrapDialog.TYPE_WARNING = 'type-warning';
    BootstrapDialog.TYPE_DANGER = 'type-danger';
    BootstrapDialog.DEFAULT_TEXTS = {};
    BootstrapDialog.DEFAULT_TEXTS[BootstrapDialog.TYPE_DEFAULT] = 'Information';
    BootstrapDialog.DEFAULT_TEXTS[BootstrapDialog.TYPE_INFO] = 'Information';
    BootstrapDialog.DEFAULT_TEXTS[BootstrapDialog.TYPE_PRIMARY] = 'Information';
    BootstrapDialog.DEFAULT_TEXTS[BootstrapDialog.TYPE_SUCCESS] = 'Success';
    BootstrapDialog.DEFAULT_TEXTS[BootstrapDialog.TYPE_WARNING] = 'Warning';
    BootstrapDialog.DEFAULT_TEXTS[BootstrapDialog.TYPE_DANGER] = 'Danger';
    BootstrapDialog.DEFAULT_TEXTS['OK'] = 'OK';
    BootstrapDialog.DEFAULT_TEXTS['CANCEL'] = 'Cancel';
    BootstrapDialog.DEFAULT_TEXTS['CONFIRM'] = 'Confirmation';
    BootstrapDialog.SIZE_NORMAL = 'size-normal';
    BootstrapDialog.SIZE_SMALL = 'size-small';
    BootstrapDialog.SIZE_WIDE = 'size-wide';
    BootstrapDialog.SIZE_LARGE = 'size-large';
    BootstrapDialog.BUTTON_SIZES = {};
    BootstrapDialog.BUTTON_SIZES[BootstrapDialog.SIZE_NORMAL] = '';
    BootstrapDialog.BUTTON_SIZES[BootstrapDialog.SIZE_SMALL] = '';
    BootstrapDialog.BUTTON_SIZES[BootstrapDialog.SIZE_WIDE] = '';
    BootstrapDialog.BUTTON_SIZES[BootstrapDialog.SIZE_LARGE] = 'btn-lg';
    BootstrapDialog.ICON_SPINNER = 'glyphicon glyphicon-asterisk';
    BootstrapDialog.defaultOptions = {
      type: BootstrapDialog.TYPE_PRIMARY,
      size: BootstrapDialog.SIZE_NORMAL,
      cssClass: '',
      title: null,
      message: null,
      nl2br: true,
      closable: true,
      closeByBackdrop: true,
      closeByKeyboard: true,
      spinicon: BootstrapDialog.ICON_SPINNER,
      autodestroy: true,
      draggable: false,
      animate: true,
      description: '',
      tabindex: -1
    };
    BootstrapDialog.configDefaultOptions = function(options) {
      BootstrapDialog.defaultOptions = $.extend(true, BootstrapDialog.defaultOptions, options);
    };
    BootstrapDialog.dialogs = {};
    BootstrapDialog.openAll = function() {
      $.each(BootstrapDialog.dialogs, function(id, dialogInstance) {
        dialogInstance.open();
      });
    };
    BootstrapDialog.closeAll = function() {
      $.each(BootstrapDialog.dialogs, function(id, dialogInstance) {
        dialogInstance.close();
      });
    };
    BootstrapDialog.moveFocus = function() {
      var lastDialogInstance = null;
      $.each(BootstrapDialog.dialogs, function(id, dialogInstance) {
        lastDialogInstance = dialogInstance;
      });
      if (lastDialogInstance !== null && lastDialogInstance.isRealized()) {
        lastDialogInstance.getModal().focus();
      }
    };
    BootstrapDialog.METHODS_TO_OVERRIDE = {};
    BootstrapDialog.METHODS_TO_OVERRIDE['v3.1'] = {
      handleModalBackdropEvent: function() {
        this.getModal().on('click', {dialog: this}, function(event) {
          event.target === this && event.data.dialog.isClosable() && event.data.dialog.canCloseByBackdrop() && event.data.dialog.close();
        });
        return this;
      },
      updateZIndex: function() {
        var zIndexBackdrop = 1040;
        var zIndexModal = 1050;
        var dialogCount = 0;
        $.each(BootstrapDialog.dialogs, function(dialogId, dialogInstance) {
          dialogCount++;
        });
        var $modal = this.getModal();
        var $backdrop = $modal.data('bs.modal').$backdrop;
        $modal.css('z-index', zIndexModal + (dialogCount - 1) * 20);
        $backdrop.css('z-index', zIndexBackdrop + (dialogCount - 1) * 20);
        return this;
      },
      open: function() {
        !this.isRealized() && this.realize();
        this.getModal().modal('show');
        this.updateZIndex();
        return this;
      }
    };
    BootstrapDialog.METHODS_TO_OVERRIDE['v3.2'] = {
      handleModalBackdropEvent: BootstrapDialog.METHODS_TO_OVERRIDE['v3.1']['handleModalBackdropEvent'],
      updateZIndex: BootstrapDialog.METHODS_TO_OVERRIDE['v3.1']['updateZIndex'],
      open: BootstrapDialog.METHODS_TO_OVERRIDE['v3.1']['open']
    };
    BootstrapDialog.METHODS_TO_OVERRIDE['v3.3'] = {};
    BootstrapDialog.METHODS_TO_OVERRIDE['v3.3.4'] = $.extend({}, BootstrapDialog.METHODS_TO_OVERRIDE['v3.1']);
    BootstrapDialog.prototype = {
      constructor: BootstrapDialog,
      initOptions: function(options) {
        this.options = $.extend(true, this.defaultOptions, options);
        return this;
      },
      holdThisInstance: function() {
        BootstrapDialog.dialogs[this.getId()] = this;
        return this;
      },
      initModalStuff: function() {
        this.setModal(this.createModal()).setModalDialog(this.createModalDialog()).setModalContent(this.createModalContent()).setModalHeader(this.createModalHeader()).setModalBody(this.createModalBody()).setModalFooter(this.createModalFooter());
        this.getModal().append(this.getModalDialog());
        this.getModalDialog().append(this.getModalContent());
        this.getModalContent().append(this.getModalHeader()).append(this.getModalBody()).append(this.getModalFooter());
        return this;
      },
      createModal: function() {
        var $modal = $('<div class="modal" role="dialog" aria-hidden="true"></div>');
        $modal.prop('id', this.getId());
        $modal.attr('aria-labelledby', this.getId() + '_title');
        return $modal;
      },
      getModal: function() {
        return this.$modal;
      },
      setModal: function($modal) {
        this.$modal = $modal;
        return this;
      },
      createModalDialog: function() {
        return $('<div class="modal-dialog"></div>');
      },
      getModalDialog: function() {
        return this.$modalDialog;
      },
      setModalDialog: function($modalDialog) {
        this.$modalDialog = $modalDialog;
        return this;
      },
      createModalContent: function() {
        return $('<div class="modal-content"></div>');
      },
      getModalContent: function() {
        return this.$modalContent;
      },
      setModalContent: function($modalContent) {
        this.$modalContent = $modalContent;
        return this;
      },
      createModalHeader: function() {
        return $('<div class="modal-header"></div>');
      },
      getModalHeader: function() {
        return this.$modalHeader;
      },
      setModalHeader: function($modalHeader) {
        this.$modalHeader = $modalHeader;
        return this;
      },
      createModalBody: function() {
        return $('<div class="modal-body"></div>');
      },
      getModalBody: function() {
        return this.$modalBody;
      },
      setModalBody: function($modalBody) {
        this.$modalBody = $modalBody;
        return this;
      },
      createModalFooter: function() {
        return $('<div class="modal-footer"></div>');
      },
      getModalFooter: function() {
        return this.$modalFooter;
      },
      setModalFooter: function($modalFooter) {
        this.$modalFooter = $modalFooter;
        return this;
      },
      createDynamicContent: function(rawContent) {
        var content = null;
        if (typeof rawContent === 'function') {
          content = rawContent.call(rawContent, this);
        } else {
          content = rawContent;
        }
        if (typeof content === 'string') {
          content = this.formatStringContent(content);
        }
        return content;
      },
      formatStringContent: function(content) {
        if (this.options.nl2br) {
          return content.replace(/\r\n/g, '<br />').replace(/[\r\n]/g, '<br />');
        }
        return content;
      },
      setData: function(key, value) {
        this.options.data[key] = value;
        return this;
      },
      getData: function(key) {
        return this.options.data[key];
      },
      setId: function(id) {
        this.options.id = id;
        return this;
      },
      getId: function() {
        return this.options.id;
      },
      getType: function() {
        return this.options.type;
      },
      setType: function(type) {
        this.options.type = type;
        this.updateType();
        return this;
      },
      updateType: function() {
        if (this.isRealized()) {
          var types = [BootstrapDialog.TYPE_DEFAULT, BootstrapDialog.TYPE_INFO, BootstrapDialog.TYPE_PRIMARY, BootstrapDialog.TYPE_SUCCESS, BootstrapDialog.TYPE_WARNING, BootstrapDialog.TYPE_DANGER];
          this.getModal().removeClass(types.join(' ')).addClass(this.getType());
        }
        return this;
      },
      getSize: function() {
        return this.options.size;
      },
      setSize: function(size) {
        this.options.size = size;
        this.updateSize();
        return this;
      },
      updateSize: function() {
        if (this.isRealized()) {
          var dialog = this;
          this.getModal().removeClass(BootstrapDialog.SIZE_NORMAL).removeClass(BootstrapDialog.SIZE_SMALL).removeClass(BootstrapDialog.SIZE_WIDE).removeClass(BootstrapDialog.SIZE_LARGE);
          this.getModal().addClass(this.getSize());
          this.getModalDialog().removeClass('modal-sm');
          if (this.getSize() === BootstrapDialog.SIZE_SMALL) {
            this.getModalDialog().addClass('modal-sm');
          }
          this.getModalDialog().removeClass('modal-lg');
          if (this.getSize() === BootstrapDialog.SIZE_WIDE) {
            this.getModalDialog().addClass('modal-lg');
          }
          $.each(this.options.buttons, function(index, button) {
            var $button = dialog.getButton(button.id);
            var buttonSizes = ['btn-lg', 'btn-sm', 'btn-xs'];
            var sizeClassSpecified = false;
            if (typeof button['cssClass'] === 'string') {
              var btnClasses = button['cssClass'].split(' ');
              $.each(btnClasses, function(index, btnClass) {
                if ($.inArray(btnClass, buttonSizes) !== -1) {
                  sizeClassSpecified = true;
                }
              });
            }
            if (!sizeClassSpecified) {
              $button.removeClass(buttonSizes.join(' '));
              $button.addClass(dialog.getButtonSize());
            }
          });
        }
        return this;
      },
      getCssClass: function() {
        return this.options.cssClass;
      },
      setCssClass: function(cssClass) {
        this.options.cssClass = cssClass;
        return this;
      },
      getTitle: function() {
        return this.options.title;
      },
      setTitle: function(title) {
        this.options.title = title;
        this.updateTitle();
        return this;
      },
      updateTitle: function() {
        if (this.isRealized()) {
          var title = this.getTitle() !== null ? this.createDynamicContent(this.getTitle()) : this.getDefaultText();
          this.getModalHeader().find('.' + this.getNamespace('title')).html('').append(title).prop('id', this.getId() + '_title');
        }
        return this;
      },
      getMessage: function() {
        return this.options.message;
      },
      setMessage: function(message) {
        this.options.message = message;
        this.updateMessage();
        return this;
      },
      updateMessage: function() {
        if (this.isRealized()) {
          var message = this.createDynamicContent(this.getMessage());
          this.getModalBody().find('.' + this.getNamespace('message')).html('').append(message);
        }
        return this;
      },
      isClosable: function() {
        return this.options.closable;
      },
      setClosable: function(closable) {
        this.options.closable = closable;
        this.updateClosable();
        return this;
      },
      setCloseByBackdrop: function(closeByBackdrop) {
        this.options.closeByBackdrop = closeByBackdrop;
        return this;
      },
      canCloseByBackdrop: function() {
        return this.options.closeByBackdrop;
      },
      setCloseByKeyboard: function(closeByKeyboard) {
        this.options.closeByKeyboard = closeByKeyboard;
        return this;
      },
      canCloseByKeyboard: function() {
        return this.options.closeByKeyboard;
      },
      isAnimate: function() {
        return this.options.animate;
      },
      setAnimate: function(animate) {
        this.options.animate = animate;
        return this;
      },
      updateAnimate: function() {
        if (this.isRealized()) {
          this.getModal().toggleClass('fade', this.isAnimate());
        }
        return this;
      },
      getSpinicon: function() {
        return this.options.spinicon;
      },
      setSpinicon: function(spinicon) {
        this.options.spinicon = spinicon;
        return this;
      },
      addButton: function(button) {
        this.options.buttons.push(button);
        return this;
      },
      addButtons: function(buttons) {
        var that = this;
        $.each(buttons, function(index, button) {
          that.addButton(button);
        });
        return this;
      },
      getButtons: function() {
        return this.options.buttons;
      },
      setButtons: function(buttons) {
        this.options.buttons = buttons;
        this.updateButtons();
        return this;
      },
      getButton: function(id) {
        if (typeof this.indexedButtons[id] !== 'undefined') {
          return this.indexedButtons[id];
        }
        return null;
      },
      getButtonSize: function() {
        if (typeof BootstrapDialog.BUTTON_SIZES[this.getSize()] !== 'undefined') {
          return BootstrapDialog.BUTTON_SIZES[this.getSize()];
        }
        return '';
      },
      updateButtons: function() {
        if (this.isRealized()) {
          if (this.getButtons().length === 0) {
            this.getModalFooter().hide();
          } else {
            this.getModalFooter().show().find('.' + this.getNamespace('footer')).html('').append(this.createFooterButtons());
          }
        }
        return this;
      },
      isAutodestroy: function() {
        return this.options.autodestroy;
      },
      setAutodestroy: function(autodestroy) {
        this.options.autodestroy = autodestroy;
      },
      getDescription: function() {
        return this.options.description;
      },
      setDescription: function(description) {
        this.options.description = description;
        return this;
      },
      setTabindex: function(tabindex) {
        this.options.tabindex = tabindex;
        return this;
      },
      getTabindex: function() {
        return this.options.tabindex;
      },
      updateTabindex: function() {
        if (this.isRealized()) {
          this.getModal().attr('tabindex', this.getTabindex());
        }
        return this;
      },
      getDefaultText: function() {
        return BootstrapDialog.DEFAULT_TEXTS[this.getType()];
      },
      getNamespace: function(name) {
        return BootstrapDialog.NAMESPACE + '-' + name;
      },
      createHeaderContent: function() {
        var $container = $('<div></div>');
        $container.addClass(this.getNamespace('header'));
        $container.append(this.createTitleContent());
        $container.prepend(this.createCloseButton());
        return $container;
      },
      createTitleContent: function() {
        var $title = $('<div></div>');
        $title.addClass(this.getNamespace('title'));
        return $title;
      },
      createCloseButton: function() {
        var $container = $('<div></div>');
        $container.addClass(this.getNamespace('close-button'));
        var $icon = $('<button class="close">&times;</button>');
        $container.append($icon);
        $container.on('click', {dialog: this}, function(event) {
          event.data.dialog.close();
        });
        return $container;
      },
      createBodyContent: function() {
        var $container = $('<div></div>');
        $container.addClass(this.getNamespace('body'));
        $container.append(this.createMessageContent());
        return $container;
      },
      createMessageContent: function() {
        var $message = $('<div></div>');
        $message.addClass(this.getNamespace('message'));
        return $message;
      },
      createFooterContent: function() {
        var $container = $('<div></div>');
        $container.addClass(this.getNamespace('footer'));
        return $container;
      },
      createFooterButtons: function() {
        var that = this;
        var $container = $('<div></div>');
        $container.addClass(this.getNamespace('footer-buttons'));
        this.indexedButtons = {};
        $.each(this.options.buttons, function(index, button) {
          if (!button.id) {
            button.id = BootstrapDialog.newGuid();
          }
          var $button = that.createButton(button);
          that.indexedButtons[button.id] = $button;
          $container.append($button);
        });
        return $container;
      },
      createButton: function(button) {
        var $button = $('<button class="btn"></button>');
        $button.prop('id', button.id);
        $button.data('button', button);
        if (typeof button.icon !== 'undefined' && $.trim(button.icon) !== '') {
          $button.append(this.createButtonIcon(button.icon));
        }
        if (typeof button.label !== 'undefined') {
          $button.append(button.label);
        }
        if (typeof button.cssClass !== 'undefined' && $.trim(button.cssClass) !== '') {
          $button.addClass(button.cssClass);
        } else {
          $button.addClass('btn-default');
        }
        if (typeof button.hotkey !== 'undefined') {
          this.registeredButtonHotkeys[button.hotkey] = $button;
        }
        $button.on('click', {
          dialog: this,
          $button: $button,
          button: button
        }, function(event) {
          var dialog = event.data.dialog;
          var $button = event.data.$button;
          var button = $button.data('button');
          if (typeof button.action === 'function') {
            button.action.call($button, dialog, event);
          }
          if (button.autospin) {
            $button.toggleSpin(true);
          }
        });
        this.enhanceButton($button);
        return $button;
      },
      enhanceButton: function($button) {
        $button.dialog = this;
        $button.toggleEnable = function(enable) {
          var $this = this;
          if (typeof enable !== 'undefined') {
            $this.prop("disabled", !enable).toggleClass('disabled', !enable);
          } else {
            $this.prop("disabled", !$this.prop("disabled"));
          }
          return $this;
        };
        $button.enable = function() {
          var $this = this;
          $this.toggleEnable(true);
          return $this;
        };
        $button.disable = function() {
          var $this = this;
          $this.toggleEnable(false);
          return $this;
        };
        $button.toggleSpin = function(spin) {
          var $this = this;
          var dialog = $this.dialog;
          var $icon = $this.find('.' + dialog.getNamespace('button-icon'));
          if (typeof spin === 'undefined') {
            spin = !($button.find('.icon-spin').length > 0);
          }
          if (spin) {
            $icon.hide();
            $button.prepend(dialog.createButtonIcon(dialog.getSpinicon()).addClass('icon-spin'));
          } else {
            $icon.show();
            $button.find('.icon-spin').remove();
          }
          return $this;
        };
        $button.spin = function() {
          var $this = this;
          $this.toggleSpin(true);
          return $this;
        };
        $button.stopSpin = function() {
          var $this = this;
          $this.toggleSpin(false);
          return $this;
        };
        return this;
      },
      createButtonIcon: function(icon) {
        var $icon = $('<span></span>');
        $icon.addClass(this.getNamespace('button-icon')).addClass(icon);
        return $icon;
      },
      enableButtons: function(enable) {
        $.each(this.indexedButtons, function(id, $button) {
          $button.toggleEnable(enable);
        });
        return this;
      },
      updateClosable: function() {
        if (this.isRealized()) {
          this.getModalHeader().find('.' + this.getNamespace('close-button')).toggle(this.isClosable());
        }
        return this;
      },
      onShow: function(onshow) {
        this.options.onshow = onshow;
        return this;
      },
      onShown: function(onshown) {
        this.options.onshown = onshown;
        return this;
      },
      onHide: function(onhide) {
        this.options.onhide = onhide;
        return this;
      },
      onHidden: function(onhidden) {
        this.options.onhidden = onhidden;
        return this;
      },
      isRealized: function() {
        return this.realized;
      },
      setRealized: function(realized) {
        this.realized = realized;
        return this;
      },
      isOpened: function() {
        return this.opened;
      },
      setOpened: function(opened) {
        this.opened = opened;
        return this;
      },
      handleModalEvents: function() {
        this.getModal().on('show.bs.modal', {dialog: this}, function(event) {
          var dialog = event.data.dialog;
          dialog.setOpened(true);
          if (dialog.isModalEvent(event) && typeof dialog.options.onshow === 'function') {
            var openIt = dialog.options.onshow(dialog);
            if (openIt === false) {
              dialog.setOpened(false);
            }
            return openIt;
          }
        });
        this.getModal().on('shown.bs.modal', {dialog: this}, function(event) {
          var dialog = event.data.dialog;
          dialog.isModalEvent(event) && typeof dialog.options.onshown === 'function' && dialog.options.onshown(dialog);
        });
        this.getModal().on('hide.bs.modal', {dialog: this}, function(event) {
          var dialog = event.data.dialog;
          dialog.setOpened(false);
          if (dialog.isModalEvent(event) && typeof dialog.options.onhide === 'function') {
            var hideIt = dialog.options.onhide(dialog);
            if (hideIt === false) {
              dialog.setOpened(true);
            }
            return hideIt;
          }
        });
        this.getModal().on('hidden.bs.modal', {dialog: this}, function(event) {
          var dialog = event.data.dialog;
          dialog.isModalEvent(event) && typeof dialog.options.onhidden === 'function' && dialog.options.onhidden(dialog);
          if (dialog.isAutodestroy()) {
            delete BootstrapDialog.dialogs[dialog.getId()];
            $(this).remove();
          }
          BootstrapDialog.moveFocus();
        });
        this.handleModalBackdropEvent();
        this.getModal().on('keyup', {dialog: this}, function(event) {
          event.which === 27 && event.data.dialog.isClosable() && event.data.dialog.canCloseByKeyboard() && event.data.dialog.close();
        });
        this.getModal().on('keyup', {dialog: this}, function(event) {
          var dialog = event.data.dialog;
          if (typeof dialog.registeredButtonHotkeys[event.which] !== 'undefined') {
            var $button = $(dialog.registeredButtonHotkeys[event.which]);
            !$button.prop('disabled') && $button.focus().trigger('click');
          }
        });
        return this;
      },
      handleModalBackdropEvent: function() {
        this.getModal().on('click', {dialog: this}, function(event) {
          $(event.target).hasClass('modal-backdrop') && event.data.dialog.isClosable() && event.data.dialog.canCloseByBackdrop() && event.data.dialog.close();
        });
        return this;
      },
      isModalEvent: function(event) {
        return typeof event.namespace !== 'undefined' && event.namespace === 'bs.modal';
      },
      makeModalDraggable: function() {
        if (this.options.draggable) {
          this.getModalHeader().addClass(this.getNamespace('draggable')).on('mousedown', {dialog: this}, function(event) {
            var dialog = event.data.dialog;
            dialog.draggableData.isMouseDown = true;
            var dialogOffset = dialog.getModalDialog().offset();
            dialog.draggableData.mouseOffset = {
              top: event.clientY - dialogOffset.top,
              left: event.clientX - dialogOffset.left
            };
          });
          this.getModal().on('mouseup mouseleave', {dialog: this}, function(event) {
            event.data.dialog.draggableData.isMouseDown = false;
          });
          $('body').on('mousemove', {dialog: this}, function(event) {
            var dialog = event.data.dialog;
            if (!dialog.draggableData.isMouseDown) {
              return;
            }
            dialog.getModalDialog().offset({
              top: event.clientY - dialog.draggableData.mouseOffset.top,
              left: event.clientX - dialog.draggableData.mouseOffset.left
            });
          });
        }
        return this;
      },
      realize: function() {
        this.initModalStuff();
        this.getModal().addClass(BootstrapDialog.NAMESPACE).addClass(this.getCssClass());
        this.updateSize();
        if (this.getDescription()) {
          this.getModal().attr('aria-describedby', this.getDescription());
        }
        this.getModalFooter().append(this.createFooterContent());
        this.getModalHeader().append(this.createHeaderContent());
        this.getModalBody().append(this.createBodyContent());
        this.getModal().data('bs.modal', new BootstrapDialogModal(this.getModal(), {
          backdrop: 'static',
          keyboard: false,
          show: false
        }));
        this.makeModalDraggable();
        this.handleModalEvents();
        this.setRealized(true);
        this.updateButtons();
        this.updateType();
        this.updateTitle();
        this.updateMessage();
        this.updateClosable();
        this.updateAnimate();
        this.updateSize();
        this.updateTabindex();
        return this;
      },
      open: function() {
        !this.isRealized() && this.realize();
        this.getModal().modal('show');
        return this;
      },
      close: function() {
        this.getModal().modal('hide');
        return this;
      }
    };
    BootstrapDialog.prototype = $.extend(BootstrapDialog.prototype, BootstrapDialog.METHODS_TO_OVERRIDE[BootstrapDialogModal.getModalVersion()]);
    BootstrapDialog.newGuid = function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0,
            v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    };
    BootstrapDialog.show = function(options) {
      return new BootstrapDialog(options).open();
    };
    BootstrapDialog.alert = function() {
      var options = {};
      var defaultOptions = {
        type: BootstrapDialog.TYPE_PRIMARY,
        title: null,
        message: null,
        closable: false,
        draggable: false,
        buttonLabel: BootstrapDialog.DEFAULT_TEXTS.OK,
        callback: null
      };
      if (typeof arguments[0] === 'object' && arguments[0].constructor === {}.constructor) {
        options = $.extend(true, defaultOptions, arguments[0]);
      } else {
        options = $.extend(true, defaultOptions, {
          message: arguments[0],
          callback: typeof arguments[1] !== 'undefined' ? arguments[1] : null
        });
      }
      return new BootstrapDialog({
        type: options.type,
        title: options.title,
        message: options.message,
        closable: options.closable,
        draggable: options.draggable,
        data: {callback: options.callback},
        onhide: function(dialog) {
          !dialog.getData('btnClicked') && dialog.isClosable() && typeof dialog.getData('callback') === 'function' && dialog.getData('callback')(false);
        },
        buttons: [{
          label: options.buttonLabel,
          action: function(dialog) {
            dialog.setData('btnClicked', true);
            typeof dialog.getData('callback') === 'function' && dialog.getData('callback')(true);
            dialog.close();
          }
        }]
      }).open();
    };
    BootstrapDialog.confirm = function() {
      var options = {};
      var defaultOptions = {
        type: BootstrapDialog.TYPE_PRIMARY,
        title: null,
        message: null,
        closable: false,
        draggable: false,
        btnCancelLabel: BootstrapDialog.DEFAULT_TEXTS.CANCEL,
        btnOKLabel: BootstrapDialog.DEFAULT_TEXTS.OK,
        btnOKClass: null,
        callback: null
      };
      if (typeof arguments[0] === 'object' && arguments[0].constructor === {}.constructor) {
        options = $.extend(true, defaultOptions, arguments[0]);
      } else {
        options = $.extend(true, defaultOptions, {
          message: arguments[0],
          closable: false,
          buttonLabel: BootstrapDialog.DEFAULT_TEXTS.OK,
          callback: typeof arguments[1] !== 'undefined' ? arguments[1] : null
        });
      }
      if (options.btnOKClass === null) {
        options.btnOKClass = ['btn', options.type.split('-')[1]].join('-');
      }
      return new BootstrapDialog({
        type: options.type,
        title: options.title,
        message: options.message,
        closable: options.closable,
        draggable: options.draggable,
        data: {callback: options.callback},
        buttons: [{
          label: options.btnCancelLabel,
          action: function(dialog) {
            typeof dialog.getData('callback') === 'function' && dialog.getData('callback')(false);
            dialog.close();
          }
        }, {
          label: options.btnOKLabel,
          cssClass: options.btnOKClass,
          action: function(dialog) {
            typeof dialog.getData('callback') === 'function' && dialog.getData('callback')(true);
            dialog.close();
          }
        }]
      }).open();
    };
    BootstrapDialog.warning = function(message, callback) {
      return new BootstrapDialog({
        type: BootstrapDialog.TYPE_WARNING,
        message: message
      }).open();
    };
    BootstrapDialog.danger = function(message, callback) {
      return new BootstrapDialog({
        type: BootstrapDialog.TYPE_DANGER,
        message: message
      }).open();
    };
    BootstrapDialog.success = function(message, callback) {
      return new BootstrapDialog({
        type: BootstrapDialog.TYPE_SUCCESS,
        message: message
      }).open();
    };
    return BootstrapDialog;
  }));
  return module.exports;
});

System.registerDynamic("npm:bootstrap-dialog@1.34.6.js", ["npm:bootstrap-dialog@1.34.6/src/js/bootstrap-dialog.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:bootstrap-dialog@1.34.6/src/js/bootstrap-dialog.js');
  return module.exports;
});

System.register("js/app.js", ["angular", "angular-animate", "angular-bootstrap", "angular-ui-router", "bootstrap-dialog"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var angular,
      bootstrap_dialog_1;
  var app,
      VENDOR_FOLDER_MARKER;
  function makeKey(name) {
    var DOMAIN = ['mathdoodle', 'io'];
    return DOMAIN.reverse().concat(name).join('.');
  }
  function vendorPath(packageFolder, fileName) {
    return VENDOR_FOLDER_MARKER + '/' + packageFolder + '/' + fileName;
  }
  return {
    setters: [function(angular_1) {
      angular = angular_1;
    }, function(_1) {}, function(_2) {}, function(_3) {}, function(bootstrap_dialog_1_1) {
      bootstrap_dialog_1 = bootstrap_dialog_1_1;
    }],
    execute: function() {
      app = angular.module('app', ['ui.bootstrap', 'ui.bootstrap.modal', 'ui.router']);
      VENDOR_FOLDER_MARKER = '$VENDOR-FOLDER-MARKER';
      app.constant('version', '2.0.0');
      app.constant('githubKey', makeKey('github'));
      app.constant('doodlesKey', makeKey('doodles'));
      app.constant('configKey', makeKey('config'));
      app.constant('FILENAME_META', 'doodle.json');
      app.constant('FILENAME_HTML', 'index.html');
      app.constant('FILENAME_CODE', 'script.ts');
      app.constant('FILENAME_LIBS', 'extras.ts');
      app.constant('FILENAME_LESS', 'style.less');
      app.constant('VENDOR_FOLDER_MARKER', VENDOR_FOLDER_MARKER);
      app.constant('SCRIPTS_MARKER', '<!-- SCRIPTS-MARKER -->');
      app.constant('STYLE_MARKER', '/* STYLE-MARKER */');
      app.constant('CODE_MARKER', '// CODE-MARKER');
      app.constant('LIBS_MARKER', '// LIBS-MARKER');
      app.constant('NAMESPACE_GOOGLE_ANALYTICS', 'googleAnalytics');
      app.constant('NAMESPACE_TWITTER_WIDGETS', 'twttr');
      app.constant('GITHUB_TOKEN_COOKIE_NAME', 'github-token');
      app.constant('STATE_DOODLE', 'doodle');
      app.constant('STATE_EXAMPLES', 'examples');
      app.constant('STATE_GISTS', 'gists');
      app.constant('FILENAME_TYPESCRIPT_CURRENT_LIB_DTS', vendorPath('typescript@1.4.1.3', 'lib.d.ts'));
      app.constant('FILENAME_MATHSCRIPT_CURRENT_LIB_MIN_JS', vendorPath('davinci-mathscript@1.0.8', 'dist/davinci-mathscript.min.js'));
      app.config(['$stateProvider', '$urlRouterProvider', 'STATE_DOODLE', 'STATE_EXAMPLES', 'STATE_GISTS', function($stateProvider, $urlRouterProvider, STATE_DOODLE, STATE_EXAMPLES, STATE_GISTS) {
        $stateProvider.state('home', {
          url: '/',
          templateUrl: 'home.html',
          controller: 'home-controller'
        }).state(STATE_DOODLE, {
          url: '/doodle',
          templateUrl: 'doodle.html',
          controller: 'doodle-controller'
        }).state(STATE_EXAMPLES, {
          url: '/examples',
          templateUrl: 'examples.html',
          controller: 'examples-controller'
        }).state(STATE_GISTS, {
          url: '/' + STATE_GISTS + '/{gistId}',
          templateUrl: 'doodle.html',
          controller: 'doodle-controller'
        }).state('new', {
          url: '/new',
          templateUrl: 'new.html',
          controller: 'new-controller'
        }).state('open', {
          url: '/open',
          templateUrl: 'open.html',
          controller: 'open-controller'
        }).state('copy', {
          url: '/copy',
          templateUrl: 'copy.html',
          controller: 'copy-controller'
        }).state('properties', {
          url: '/properties',
          templateUrl: 'properties.html',
          controller: 'properties-controller'
        }).state('download', {
          url: '/download',
          templateUrl: 'download.html',
          controller: 'download-controller'
        }).state('about', {
          url: '/about',
          templateUrl: 'about.html',
          controller: 'about-controller'
        });
        $urlRouterProvider.otherwise('/');
      }]);
      app.run(['$rootScope', '$state', '$stateParams', '$window', 'cookie', 'uuid4', 'ga', 'githubKey', 'version', function($rootScope, $state, $stateParams, $window, cookie, uuid4, ga, githubKey, version) {
        var GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME = 'mathdoodle-github-application-client-id';
        var GITHUB_TOKEN_COOKIE_NAME = 'github-token';
        var GITHUB_LOGIN_COOKIE_NAME = 'github-login';
        var GITHUB_GET_LOGIN_OAUTH_AUTHORIZE = "https://github.com/login/oauth/authorize";
        $rootScope.$state = $state;
        $rootScope.$stateParams = $stateParams;
        $rootScope.version = version;
        $window.applicationCache.addEventListener('updateready', function(e) {
          $rootScope.$apply(function() {});
        }, false);
        $window.onload = function() {
          $window.applicationCache.addEventListener('updateready', function(e) {
            if ($window.applicationCache.status === $window.applicationCache.UPDATEREADY) {
              bootstrap_dialog_1.default.show({
                type: bootstrap_dialog_1.default.TYPE_SUCCESS,
                title: $("<h3>Update Ready</h3>"),
                message: "A new version of mathdoodle is available. Would you like to use it now?",
                buttons: [{
                  label: "Yes, Now",
                  cssClass: 'btn btn-primary',
                  action: function(dialog) {
                    $window.location.reload();
                    dialog.close();
                  }
                }, {
                  label: "No, Later",
                  cssClass: 'btn',
                  action: function(dialog) {
                    dialog.close();
                  }
                }]
              });
            } else {}
          }, false);
        };
        $window.applicationCache.addEventListener('checking', function(e) {
          $rootScope.$apply(function() {});
        }, false);
        $window.applicationCache.addEventListener('noupdate', function(e) {
          $rootScope.$apply(function() {});
        }, false);
        $window.applicationCache.addEventListener('downloading', function(e) {
          $rootScope.$apply(function() {});
        }, false);
        $window.applicationCache.addEventListener('progress', function(e) {
          $rootScope.$apply(function() {});
        }, false);
        $window.applicationCache.addEventListener('cached', function(e) {
          $rootScope.$apply(function() {});
        }, false);
        $window.applicationCache.addEventListener('obsolete', function(e) {
          $rootScope.$apply(function() {});
        }, false);
        $window.applicationCache.addEventListener('error', function(e) {
          $rootScope.$apply(function() {});
        }, false);
        $rootScope.clientId = function() {
          return cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
        };
        $rootScope.log = function(thing) {
          console.log(thing);
        };
        $rootScope.alert = function(thing) {
          alert(thing);
        };
        $rootScope.login = function(label, value) {
          ga('send', 'event', 'GitHub', 'login', label, value);
          var pending = uuid4.generate();
          var githubURL = GITHUB_GET_LOGIN_OAUTH_AUTHORIZE + "?client_id=" + $rootScope.clientId() + "&amp;scope=user,gist" + "&amp;state=" + pending;
          var github = {oauth: {pending: pending}};
          $window.localStorage.setItem(githubKey, JSON.stringify(github));
          $window.location.href = githubURL;
        };
        $rootScope.logout = function(label, value) {
          ga('send', 'event', 'GitHub', 'logout', label, value);
          cookie.removeItem(GITHUB_TOKEN_COOKIE_NAME);
          cookie.removeItem(GITHUB_LOGIN_COOKIE_NAME);
        };
        $rootScope.isLoggedIn = function() {
          return cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
        };
        $rootScope.userLogin = function() {
          return cookie.getItem(GITHUB_LOGIN_COOKIE_NAME);
        };
      }]);
      exports_1("default", app);
    }
  };
});

System.register("js/template-cache.js", ["./app"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }],
    execute: function() {
      app_1.default.run(['$templateCache', function($templateCache) {
        'use strict';
        $templateCache.put('alert-modal.html', "<div class=\"modal-header\" style=\"clear: both\">\n" + "    <h3 class='modal-title' style=\"float: left;\"><logo-text version='{{version}}'/></h3>\n" + "    <h3 class='modal-title' style=\"float: right;\">{{options.title}}</h3>\n" + "</div>\n" + "<div class=\"modal-body\">\n" + "    <p>{{options.message}}</p>\n" + "</div>\n" + "<div class=\"modal-footer\">\n" + "    <button class=\"btn btn-primary\" type=\"button\" data-ng-click=\"close();\">Close</button>\n" + "</div>");
        $templateCache.put('confirm-modal.html', "<div class=\"modal-header\" style=\"clear: both\">\n" + "    <h3 class='modal-title' style=\"float: left;\"><logo-text version='{{version}}'/></h3>\n" + "    <h3 class='modal-title' style=\"float: right;\">{{options.title}}</h3>\n" + "</div>\n" + "<div class=\"modal-body\">\n" + "    <p>{{options.message}}</p>\n" + "</div>\n" + "<div class=\"modal-footer\">\n" + "    <button class=\"btn btn-secondary\" type=\"button\" data-ng-click=\"cancel()\">{{options.cancelButtonText}}</button>\n" + "    <button class=\"btn btn-primary\" type=\"button\" data-ng-click=\"ok();\">{{options.actionButtonText}}</button>\n" + "</div>");
        $templateCache.put('copy.html', "<div class='modal-content'>\n" + "  <div class='modal-header'>\n" + "      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden='true' ng-click='doCancel()'>&times;</button>\n" + "    <h3>Make Copy of Doodle \"{{template.description}}\"</h3>\n" + "  </div>\n" + "  <div class='modal-body'>\n" + "    <input type='text' ng-model='description' placeholder=\"Enter description\" autofocus/>\n" + "  </div>\n" + "  <div class='modal-footer'>\n" + "    <button class='btn btn-primary' ng-click='doOK()'>Copy doodle</button>\n" + "    <button class='btn' ng-click='doCancel()'>Cancel</button>\n" + "  </div>\n" + "</div>\n");
        $templateCache.put('doodle.html', "<div id='doodle-page'>\n" + "    <workspace>\n" + "        <nav id='toolbar' class='navbar navbar-inverse'>\n" + "            <div class='navbar-header'>\n" + "                <a role='button' class='navbar-brand' ng-click='goHome()'>\n" + "                    <logo-text version='{{version}}' />\n" + "                </a>\n" + "            </div>\n" + "            <div class='ignore-collapse ignore-navbar-collapse'>\n" + "                <ul class='nav navbar-nav'>\n" + "                    <li>\n" + "                        <a role='button' ng-click='toggleExplorer()'>\n" + "                            <span\n" + "                                ng-show='isExplorerVisible'\n" + "                                class=\"glyphicon glyphicon-list\"\n" + "                                aria-hidden=\"true\"\n" + "                                uib-tooltip=\"Hide File Explorer\"\n" + "                                tooltip-placement=\"bottom\">\n" + "                            </span>\n" + "                            <span\n" + "                                ng-hide='isExplorerVisible'\n" + "                                class=\"glyphicon glyphicon-list\"\n" + "                                aria-hidden=\"true\"\n" + "                                uib-tooltip=\"Show File Explorer\"\n" + "                                tooltip-placement=\"bottom\">\n" + "                            </span>\n" + "                        </a>\n" + "                    </li>\n" + "                    <li ng-show='isEditMode'>\n" + "                        <a role='button' ng-click='toggleView()' ng-hide='isViewVisible'>\n" + "                            <span\n" + "                                class=\"glyphicon glyphicon-play\"\n" + "                                aria-hidden=\"true\"\n" + "                                ng-hide='isViewVisible'\n" + "                                uib-tooltip=\"Run\",\n" + "                                tooltip-placement=\"bottom\">\n" + "                            </span>\n" + "                        </a>\n" + "                        <a role='button' ng-click='toggleView()' ng-show='isViewVisible'>\n" + "                            <span\n" + "                                class=\"glyphicon glyphicon-off\"\n" + "                                aria-hidden=\"true\"\n" + "                                ng-show='isViewVisible'\n" + "                                uib-tooltip=\"Stop\",\n" + "                                tooltip-placement=\"bottom\">\n" + "                            </span>\n" + "                        </a>\n" + "                    </li>\n" + "                    <li uib-dropdown ng-show='isEditMode'>\n" + "                        <a uib-dropdown-toggle role=\"button\" aria-expanded=\"false\" uib-tooltip=\"Project\" tooltip-placement=\"bottom\">\n" + "                            <span class=\"glyphicon glyphicon-hdd\" aria-hidden='true'></span>\n" + "                            <span class='caret'></span>\n" + "                        </a>\n" + "                        <ul uib-dropdown-menu role=\"menu\">\n" + "                            <li><a role='button' ng-click='doNew()'>New Project</a></li>\n" + "                            <li><a role='button' ng-click='doOpen()'>Open existing Project</a></li>\n" + "                            <li><a role='button' ng-click='doCopy()'>Copy this Project</a></li>\n" + "                        </ul>\n" + "                    </li>\n" + "                    <li ng-show='isEditMode'>\n" + "                        <a role='button' ng-click='doProperties()'>\n" + "                            <span \n" + "                                class=\"glyphicon glyphicon-check\"\n" + "                                aria-hidden=\"true\"\n" + "                                uib-tooltip=\"Properties\"\n" + "                                tooltip-placement=\"bottom\">\n" + "                            </span>\n" + "                        </a>\n" + "                    </li>\n" + "                    <li uib-dropdown ng-show='isEditMode &amp;&amp; isLoggedIn()'>\n" + "                        <a ng-show='isLoggedIn()' uib-dropdown-toggle role=\"button\" aria-expanded=\"false\" uib-tooltip=\"GitHub\" tooltip-placement=\"bottom\">\n" + "                            <span class=\"glyphicon glyphicon-cloud\" aria-hidden=\"true\"></span>\n" + "                            <span class='caret' ng-show='isLoggedIn()'></span>\n" + "                        </a>\n" + "                        <ul uib-dropdown-menu role=\"menu\">\n" + "                            <li>\n" + "                                <a ng-click='clickDownload()' ng-show='isLoggedIn()' role='button'>\n" + "                                    <span class=\"glyphicon glyphicon-cloud-download\" aria-hidden=\"true\"></span> Download\n" + "                                </a>\n" + "                            </li>\n" + "                            <li>\n" + "                                <a ng-click='doUpload()' ng-show='isLoggedIn()' role='button'>\n" + "                                    <span class=\"glyphicon glyphicon-cloud-upload\" aria-hidden=\"true\"></span> Upload\n" + "                                </a>\n" + "                            </li>\n" + "                        </ul>\n" + "                    </li>\n" + "                    <!--\n" + "                    <li>\n" + "                        <a role='button'>\n" + "                            <span class=\"glyphicon glyphicon-search\" aria-hidden=\"true\"></span>\n" + "                        </a>\n" + "                    </li>\n" + "                    -->\n" + "                </ul>\n" + "            </div>\n" + "        </nav>\n" + "        <div id='doodle-container'>\n" + "            <explorer ng-model='currentDoodle().files' class='explorer' ng-show='isExplorerVisible'></explorer>\n" + "            <div id='editors' resizable r-directions=\"['right']\" r-flex='true'>\n" + "                <div editor ng-repeat='(name, file) in currentDoodle().files' ng-model='file.content' id='{{name}}' mode='{{file.language}}'\n" + "                ng-show='isEditMode &amp;&amp; file.selected'></div>\n" + "            </div>\n" + "            <div id='preview'></div>\n" + "        </div>\n" + "    </workspace>\n" + "</div>");
        $templateCache.put('download.html', "<div class='modal-content'>\n" + "  <div class='modal-header'>\n" + "      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden='true' ng-click='doCancel()'>&times;</button>\n" + "    <h3>Download Doodle</h3>\n" + "  </div>\n" + "  <div class='modal-body'>\n" + "    <p ng-repeat='gist in gists track by gist.id'>\n" + "      <a ui-sref='gists({gistId: gist.id})'>{{gist.description}}</a>\n" + "    </p>\n" + "  </div>\n" + "  <div class='modal-footer'>\n" + "    <button class='btn' ng-click=\"doPageF()\">First</button>\n" + "    <button class='btn' ng-click=\"doPageP()\">Previous</button>\n" + "    <button class='btn' ng-click=\"doPageN()\">Next</button>\n" + "    <button class='btn' ng-click=\"doPageL()\">Last</button>\n" + "    <button class='btn' ng-click='doCancel()'>Close</button>\n" + "  </div>\n" + "</div>\n");
        $templateCache.put('examples.html', "<div id='examples-page'>\n" + "  <nav id='toolbar' class='navbar navbar-inverse'>\n" + "    <div class='navbar-header'>\n" + "      <a role='button' class='navbar-brand' ng-click='goHome()'><logo-text version='{{version}}'/></a>\n" + "    </div>\n" + "  </nav>\n" + "  <div class='md-docs-header'>\n" + "    <div class='container'>\n" + "      <h1>Examples</h1>\n" + "    </div>\n" + "  </div>\n" + "  <div class='container md-docs-container'>\n" + "    <div class='row'>\n" + "      <div class='col-md-9' role='main'>\n" + "\n" + "        <div class='md-docs-section'>\n" + "          <h1 class='page-header'>Geometric Algebra and 3D WebGL Graphics</h1>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/129a4a31fa803df9e4a5'>Creating and Animating a Scene with Eight.Js</a>\n" + "          </p>\n" + "          <p>\n" + "          The Eight.Js library that ships with MathDoodle has a cohesive layered architecture that allows you to choose the appropriate level for flexibility and reuse. Eight.Js integrates Geometric Algebra with WebGL Graphics providing an efficient starting point for explorations into Geometry, Physics, Mathematics, and Computing.\n" + "          </p>\n" + "          <p>\n" + "          This example demonstrates many features of the Eight.Js library. It builds a scene from high level components and drives the animation using Geometric Algebra for computation.\n" + "          </p>\n" + "          <p>\n" + "          <em>This example is rather verbose and contains boilerplate code that could be\n" + "          eliminated with an appropriate application framework. However, the explicit\n" + "          nature of the example makes it easier to understand the various components and\n" + "          how they interact.</em>\n" + "          </p>\n" + "        </div>\n" + "\n" + "        <div class='md-docs-section'>\n" + "          <h1 class='page-header'>Physics Exploration</h1>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/72b8c2b765792d2fe100'>Projectile Motion</a>\n" + "          <p>\n" + "          Physics demonstrations and explorations require accessible solutions without having to re-invent graphical components. This example shows how to model projectile motion by composing high-level components in the Eight.Js library.\n" + "          </p>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/e5a3cbf25d8972d1b79d'>Binary Star</a>\n" + "          <p>\n" + "          A classic two-body simulation demonstrating gravitation, center of mass, and reduced-mass concepts.\n" + "          </p>\n" + "          <p class='lead'>\n" + "          <a href='/#/gists/925701cc2a654bfefcf0'>Earth-Moon</a>\n" + "          <p>\n" + "          Demonstrates using two viewports to display a scene from different perspectives.\n" + "          Simulates the Earth-Moon gravitation system with directional lighting\n" + "          provided by the sun. The scene is rendered in plan view and and from the Earth.\n" + "          </p>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/a1ee16bc6b1c98317ba1'>Units of Measure</a>\n" + "          <p>\n" + "          The Eight.Js library includes Geometric Algebra measures that include optional units of\n" + "          measure. The units are based upon the seven S.I. base units and is also able to recognize\n" + "          some common derived units.\n" + "          </p>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/d51e8b997c6a1de2ce71'>Basis Labeling</a>\n" + "          <p>\n" + "          Replacing the labels used for basis vectors can be an instructive way to learn the\n" + "          relationships between geometric measures, geometric quantities, magnitudes, directions,\n" + "          aspect, and orientation.\n" + "          </p>\n" + "          <p>\n" + "          Basis labels can also be customized appropriate to the context, e.g. compass directions. In this example we use Unicode graphical symbols to represent vectors, bivectors and the pseudoscalar and show how they interact under the geometric product.\n" + "          </p>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/43e23d39431bae5bb401'>Projectile Motion with Units</a>\n" + "          <p>\n" + "          Brings units of measure into simulations. While this may not be desirable for high-performance applications, it does motivate the use of consistent units in order to allow the simulation to run!\n" + "          </p>\n" + "        </div>\n" + "\n" + "        <div class='md-docs-section'>\n" + "          <h1 class='page-header'>Teaching 3D Computer Graphics</h1>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/157e85464659bbbd3bac'>Teaching a Computer Graphics Course with WebGL</a>\n" + "          <p>\n" + "          This example was inspired by the article by Edward Angel and Dave Shreiner in the book\n" + "          WebGL Insights by Patrick Cozzi.\n" + "          </p>\n" + "          <p>\n" + "          The article describes the benefits of moving from OpenGL to WebGL. MathDoodle enhances the experience for the student by providing a powerful development environment, Geometric Algebra libraries, and a Graphics Library with entry points at many levels of flexibility and reuse.\n" + "          </p>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/89ee3cf12e4360999510'>Ray Tracing: The Science behind Computer Animation</a>\n" + "          <p>\n" + "          While WebGL provides a high performance real-time graphics environment, movie-quality animations require Physics calculations based upon Geometric Optics and are often computed off-line taking many hours.\n" + "          </p>\n" + "          <p>\n" + "          This example shows how simple ray tracing can be performed in the browser with the results written out to the HTML5 Canvas in a few seconds. The example is due to Microsoft. It would be interesting to adapt it to Geometric Algebra and enable learning Geometric Optics.\n" + "          </p>\n" + "        </div>\n" + "\n" + "        <div class='md-docs-section'>\n" + "          <h1 class='page-header'>Mathematical Research</h1>\n" + "          <p class='lead'>\n" + "          <a href='/#/gists/d4a1b374cb80ca178ad2'>Eight Surface</a>\n" + "          <p>\n" + "          This example demonstrates the flexibility inherent in an environment that is based upon\n" + "          general-purpose programming with standards-based tools.\n" + "          </p>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/8571a36545d10f34bfef'>Fundamental Theorem of Algebra</a>\n" + "          <p>\n" + "          Colors a complex (G2+) function in the Wessel (Argand) plane in order to visualize the direction. This may be used as a basis for introductory arguments for the Fundamental Theorem of Algebra.\n" + "          </p>\n" + "          <p>\n" + "          This example takes advantage of the GPU using custom shader programs for fast rendering.\n" + "          </p>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/5c70bee3c68b2b7a4572'>Mandelbrot Set</a>\n" + "          <p>\n" + "          A rendering of the Mandelbrot Set.\n" + "          </p>\n" + "          <p class='lead'>\n" + "            <a href='/#/gists/39390d95450ff9159b8e'>Julia Set</a>\n" + "          <p>\n" + "          A rendering of the Julia Set in 2D. Interestingly, this may be generalized to 3D and higher dimensions through the use of Geometric Algebra.\n" + "          </p>\n" + "        </div>\n" + "\n" + "        <div class='md-docs-section'>\n" + "          <h1 class='page-header'>Integrated Learning through a Game Development Project</h1>\n" + "          <p class='lead'><a href='/#/gists/563f391f711bfcfccac5'>Game2D</a></p>\n" + "          <p>\n" + "          A computer game that realistically applies Physics principles, uses Geometric\n" + "          mathematics for the simulation and graphics, and with User Interaction through keyboard\n" + "          and mouse.\n" + "          </p>\n" + "          <p>\n" + "          This makes an ideal Capstone project or a theme for Project Based Learning.\n" + "          </p>\n" + "          <p>\n" + "          (This example is under development).\n" + "          </p>\n" + "        </div>\n" + "\n" + "        <div class='md-docs-section'>\n" + "\n" + "          <h1 class='page-header'>\n" + "            Miscellaneous\n" + "          </h1>\n" + "\n" + "          <p class='lead'><a href='/#/gists/8d58e1a9412168b987f7'>SingleViewApp</a></p>\n" + "          <p>\n" + "          Demonstrates a lightweigh application framework for minimizing boilerplate code in a browser application using Eight.Js. This framework creates a single Viewport for a Scene with a Linear Perspective Camera and DirectionalLight. The framework coordinates with DOM loading and cleans up correctly when the window is unloaded. See the API reference for details.\n" + "          </p>\n" + "\n" + "          <p class='lead'><a href='/#/gists/2685e5f638fe34a7f97f'>MultiViewApp</a></p>\n" + "          <p>\n" + "          Upgrade a single view application to multiple viewports.\n" + "          </p>\n" + "\n" + "          <p class='lead'><a href='/#/gists/d1259b443308060443a1'>Orbit Controls</a></p>\n" + "          <p>\n" + "          Controls that keep the camera upright.\n" + "          </p>\n" + "\n" + "        </div>\n" + "\n" + "      </div>\n" + "    </div>\n" + "  </div>\n" + "</div>\n" + "\n" + "</div>");
        $templateCache.put('explorer.html', "<div id='explorer'>\n" + "    <div class='explorer-section' ng-controller='ExplorerFilesController as filesController'>\n" + "        <div class='explorer-section-header'>\n" + "            <div class='navbar navbar-inverse explorer-section-box'>\n" + "                <div>\n" + "                    <span>FILES</span>\n" + "                </div>\n" + "            </div>\n" + "            <div class='navbar navbar-inverse explorer-section-box'>\n" + "                <ul class='nav navbar-nav'>\n" + "                    <li>\n" + "                        <a role='button' ng-click='filesController.newFile()'>\n" + "                            <span class=\"glyphicon glyphicon-file\" aria-hidden=\"true\" uib-tooltip=\"New File\" tooltip-placement=\"bottom\"></span>\n" + "                        </a>\n" + "                    </li>\n" + "                </ul>\n" + "            </div>\n" + "        </div>\n" + "        <ul class='files'>\n" + "            <li ng-repeat='(name, file) in currentDoodle().files' ng-class='{selected: file.selected}' context-menu='menu(name, file)'>\n" + "                <a href ng-click='$ctrl.selectFile(name)' ng-dblclick='$ctrl.openFile(name)'>{{name}}</a>\n" + "            </li>\n" + "        </ul>\n" + "    </div>\n" + "</div>");
        $templateCache.put('home.html', "<header class='navbar navbar-static-top navbar-inverse md-docs-nav'>\n" + "  <div class='container'>\n" + "    <div class='navbar-header'>\n" + "      <button type='button' class='navbar-toggle collapsed' data-toggle='collapse' data-target='#navbar-header-collapse'>\n" + "        <span class=\"sr-only\">Toggle navigation</span>\n" + "        <span class=\"icon-bar\"></span>\n" + "        <span class=\"icon-bar\"></span>\n" + "        <span class=\"icon-bar\"></span>\n" + "      </button>\n" + "    </div>\n" + "    <div class='collapse navbar-collapse' id='navbar-header-collapse'>\n" + "      <button type=\"button\" class=\"btn btn-primary navbar-btn\" ng-click='goDoodle()'>Doodle Now!</button>\n" + "      <button type=\"button\" class=\"btn btn-secondary navbar-btn\" ng-click='goExamples()'>Browse Examples</button>\n" + "      <button type=\"button\" class=\"btn btn-default navbar-btn\" ng-click='logout()' ng-show='isLoggedIn()'>Log out {{userLogin()}}</button>\n" + "      <button type=\"button\" class=\"btn btn-default navbar-btn\" ng-click='login()' ng-hide='isLoggedIn()'>Log In</button>\n" + "    </div>\n" + "  </div>\n" + "</header>\n" + "\n" + "<div class='md-docs-header'>\n" + "  <div class='container'>\n" + "    <h1><logo-text version='{{version}}'/></h1>\n" + "    <p>\n" + "      Learning Mathematics and Geometric Physics<br/>through Computational Modeling.\n" + "    </p>\n" + "  </div>\n" + "</div>\n" + "\n" + "<div class='container md-docs-container'>\n" + "  <div class='row'>\n" + "    <div class='col-md-9' role='main'>\n" + "      <div class='md-docs-section'>\n" + "        <h1 id='overview' class='page-header'>\n" + "          MathDoodle Overview\n" + "        </h1>\n" + "        <p class='lead'>\n" + "          The principle behind MathDoodle is to provide a learning environment in which the student can verify personal understanding and conceptual models by constructing a working software model. This learning environment takes the form of a general-purpose software development environment optimized for Mathematics and Computer Graphics. Programming a computer, sometimes in collaboration with others, provides a non-threatening environment, clarifies understanding, challenges mastery, and motivates further exploration.\n" + "        </p>\n" + "      </div>\n" + "      <div class='md-docs-section'>\n" + "        <h1 id='problem' class='page-header'>\n" + "          Motivation\n" + "        </h1>\n" + "        <p class='lead'>\n" + "          <ul>\n" + "            <li class='lead'>\n" + "            The importance of geometry to modern mathematics has grown over the last century but is not reflected in student course choices.\n" + "            </li>\n" + "            <li class='lead'>\n" + "            The Geometry curriculum of Euclid's elements and Descartes coordinates is obsolete, ineffective, and inefficient compared to modern approaches which unify algebra and geometry.\n" + "            </li>\n" + "            <li class='lead'>\n" + "            Mathematics and Physics courses under-utilize and misuse computers.\n" + "            </li>\n" + "          </ul>\n" + "        </p>\n" + "      </div>\n" + "      <div class='md-docs-section'>\n" + "        <h1 id='manifesto' class='page-header'>\n" + "          Manifesto\n" + "        </h1>\n" + "        <p class='lead'>\n" + "          <ul>\n" + "            <li class='lead'>\n" + "            Rework the geometry curriculum around the modern mathematical notation of Geometric Algebra.\n" + "            </li>\n" + "            <li class='lead'>\n" + "            Ensure students learn a general purpose programming language so that they can use computers for truly active and constructive learning by programming Mathematics, Physics and Computer Graphics.\n" + "            </li>\n" + "          </ul>\n" + "        </p>\n" + "      </div>\n" + "      <div class='md-docs-section'>\n" + "        <h1 id='features' class='page-header'>\n" + "          Features and Benefits of MathDoodle\n" + "        </h1>\n" + "        <p class='lead'>\n" + "          MathDoodle is unique among browser editing environments by being optimized for learning Mathematics and Geometry.\n" + "        </p>\n" + "        <p>\n" + "          <dl>\n" + "            <dt>Code Editor and Preview in your browser</dt>\n" + "            <dd>\n" + "              No setup or installation required. Just use a compatible browser such as Chrome, Firefox or IE9.\n" + "            </dd>\n" + "            <dt>JavaScript, HTML, CSS</dt>\n" + "            <dd>\n" + "              Use the tools that are the bread-and-butter of a contemporary software developer.\n" + "              The modeling-development environment is general purpose and allows external libraries to be used and services to be called over the internet.\n" + "            </dd>\n" + "            <dt>TypeScript Language</dt>\n" + "            <dd>\n" + "              TypeScript is JavaScript with optional type information and features taken from future JavaScript releases.\n" + "              Using TypeScript provides intelligent checking and context-sensitive help, allowing the student to spend more time focusing on the task in hand instead of trying to find errors or lookup documentation.\n" + "            </dd>\n" + "            <dt>Local Caching</dt>\n" + "            <dd>\n" + "              Allows you to work even in situations with limited internet connectivity.\n" + "              Your work is automatically saved locally in the browser and can be uploaded when connectivity becomes available.\n" + "            </dd>\n" + "            <dt>Cloud Sharing</dt>\n" + "            <dd>\n" + "              Students and educators can store their work permanently in their personal and free GitHub account. Educators may use GitHub as a means to create and distribute assignments, while students may use GitHub to provide a permanent record of their work and as a means for sharing.\n" + "            </dd>\n" + "            <dt>Operator Overloading</dt>\n" + "            <dd>\n" + "              Operator Overloading is essential for making mathematical programming look natural\n" + "              when dealing with structured types such as vectors and matrices. MathDoodle supports a rich set of mathematical operators (useful for performing multivector analysis). In addition to the usual arithmetic operators, there is support for inner and outer products, as well as left and right contraction. These operators may be used with your own custom datatypes. Operator Overloading is optional.\n" + "            </dd>\n" + "            <dt>Geometric Algebra Library</dt>\n" + "            <dd>\n" + "              MathDoodle provides a library (davinci-eight a.k.a 'EIGHT') for perfoming Geometric Algebra computations in 2D and 3D Euclidean geometries.\n" + "            </dd>\n" + "            <dt>WebGL Mathematical Computer Graphics Library</dt>\n" + "            <dd>\n" + "              MathDoodle provides a library (davinci-eight a.k.a 'EIGHT') that helps to manage the complexity of WebGL shader programs rather than trying to hide it. This is important for high-performance graphics and mathematical flexibility.\n" + "            </dd>\n" + "            <dt>Units of Measure</dt>\n" + "            <dd>\n" + "              MathDoodle incorporates a library (davinci-eight a.k.a 'EIGHT') that combines geometric quantities with units to create measures. Students can explore dimensional analysis and the S.I. system of units. Calculations may be performed without units or by carrying through units.\n" + "            </dd>\n" + "          </dl>\n" + "        </p>\n" + "      </div>\n" + "\n" + "      <div class='md-docs-section'>\n" + "        <h1 id='curriculum' class='page-header'>\n" + "          A STEM Curriculum for the 21st Century\n" + "        </h1>\n" + "        <p class='lead'>\n" + "        Learning Geometric Algebra through Computational Modeling and Computer Graphics.\n" + "        </p>\n" + "        <p>\n" + "        I am frequently asked whether there is a curriculum for learning Geometric Algebra\n" + "        at the middle and high-school level using MathDoodle to practice the concepts.\n" + "        To address this need I have created a blog in which I will capture a possible\n" + "        approach. I hope this will be a proving ground for developing a new curriculum.\n" + "        The <a href='http://www.geometricphysics.org'>Geometric Physics</a> blog will explain the pedagogic philosophy, incrementally develop the necessary mathematical theory for Geometric Algebra, provide the practical information for\n" + "        using MathDoodle and related technologies, and finally guide the student or\n" + "        educator in developing their own geometric numbers, computations and graphics.\n" + "        Once the necessary mathematical and computing infrastructure has been developed,\n" + "        it will be applied to understand the laws of Physics which are described geometrically.\n" + "        </p>\n" + "        <a href='http://www.geometricphysics.org'>Geometric Physics</a> Blog\n" + "        <p>\n" + "        </p>\n" + "      </div>\n" + "\n" + "      <div class='md-docs-section'>\n" + "        <h1 id='audience' class='page-header'>\n" + "          Audience\n" + "        </h1>\n" + "        <p class='lead'>\n" + "        MathDoodle is a general purpose mathematical tool for the scientific community.\n" + "        </p>\n" + "        <p>\n" + "        MathDoodle was conceived to tackle the problem of learning geometry effectively, but\n" + "        its general purpose nature makes it useful to a much wider audience. At the youngest\n" + "        end of the spectrum it can be used as the first introduction to a grown-up programming\n" + "        language. In the middle of the spectrum the tool may be used for learning and experiencing mathematical geometry with the programming being second-nature. Educators may\n" + "        use MathDoodle for demonstration purposes or to set hands-on problems. Researchers may use the tool for convenient computation, exploring problems, or to present their work.\n" + "        </p>\n" + "      </div>\n" + "\n" + "      <div class='md-docs-section'>\n" + "        <h1 id='workshops' class='page-header'>\n" + "          Workshops\n" + "        </h1>\n" + "        <p class='lead'>\n" + "        Workshops are available for both students and educators and may be customized according to your needs.\n" + "        </p>\n" + "        <address>\n" + "          <strong>David Geo Holmes</strong><br/>\n" + "          <strong>david</strong>&nbsp;DOT&nbsp;<strong>geo</strong>&nbsp;DOT&nbsp;<strong>holmes</strong>&nbsp;AT&nbsp;<strong>gmail</strong>&nbsp;DOT&nbsp;<strong>com</strong><br/>\n" + "          (919)&nbsp;880-8589<br/>\n" + "        </address>\n" + "      </div>\n" + "\n" + "    </div>\n" + "  </div>\n" + "</div>\n" + "\n" + "<footer class='md-docs-footer' role='contentinfo'>\n" + "  <div class='container'>\n" + "    <!--\n" + "    <div class='md-docs-social'>\n" + "      <ul class='md-docs-social-buttons'>\n" + "        <li class='follow-btn'>\n" + "          <a class='twitter-follow-button'\n" + "            href='https://twitter.com/mathdoodle'>\n" + "            Follow @mathdoodle</a>\n" + "        </li>\n" + "        <li class='tweet-btn'>\n" + "          <a class='twitter-share-button'\n" + "            href='https://twitter.com/intent/tweet?text={{twitterShareText}}'>\n" + "            Tweet</a>\n" + "        </li>\n" + "      </ul>\n" + "    </div>\n" + "  -->\n" + "  </div>\n" + "</footer>");
        $templateCache.put('login.html', "<h1>Login</h1>\n" + "<button ng-click=\"githubLogin()\">Login with GitHub - Really</button>");
        $templateCache.put('new.html', "<div class='modal-content'>\n" + "  <div class='modal-header'>\n" + "      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden='true' ng-click='doCancel()'>&times;</button>\n" + "    <h3>Create a New Doodle</h3>\n" + "  </div>\n" + "  <div class='modal-body'>\n" + "    <input type='text' ng-model='description' placeholder=\"Enter description\" autofocus/>\n" + "    <label class='text-muted'>Template:</label>\n" + "    <select ng-model='template' ng-options='template.description for template in templates track by template.uuid'></select>\n" + "  </div>\n" + "  <div class='modal-footer'>\n" + "    <button class='btn btn-primary' ng-click='doOK()'>Create doodle</button>\n" + "    <button class='btn' ng-click='doCancel()'>Cancel</button>\n" + "  </div>\n" + "</div>\n");
        $templateCache.put('open.html', "<div class='modal-content'>\n" + "  <div class='modal-header'>\n" + "      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden='true' ng-click='doClose()'>&times;</button>\n" + "    <h3>Open Doodle</h3>\n" + "  </div>\n" + "  <div class='modal-body'>\n" + "    <p ng-repeat='doodle in doodles() track by doodle.uuid'>\n" + "      <a role='button' ng-click='doDelete(doodle.uuid)' class='delete'>&times;</a>\n" + "      <a role='button' ng-click='doOpen(doodle.uuid)'>{{doodle.description}}</a>\n" + "    </p>\n" + "  </div>\n" + "  <div class='modal-footer'>\n" + "    <button class='btn' ng-click='doClose()'>Close</button>\n" + "  </div>\n" + "</div>\n");
        $templateCache.put('prompt-modal.html', "<div class=\"modal-header\" style=\"clear: both\">\n" + "    <h3 class='modal-title' style=\"float: left;\"><logo-text version='{{version}}'/></h3>\n" + "    <h3 class='modal-title' style=\"float: right;\">{{options.title}}</h3>\n" + "</div>\n" + "<div class=\"modal-body\">\n" + "    <p>{{options.message}}</p>\n" + "    <input ng-model='options.text' type='text' placeholder='{{options.placeholder}}'></input>\n" + "</div>\n" + "<div class=\"modal-footer\">\n" + "    <button class=\"btn btn-secondary\" type=\"button\" data-ng-click=\"cancel()\">{{options.cancelButtonText}}</button>\n" + "    <button class=\"btn btn-primary\" type=\"button\" data-ng-click=\"ok();\">{{options.actionButtonText}}</button>\n" + "</div>");
        $templateCache.put('properties.html', "<div class=\"modal-content\">\n" + "  <div class=\"modal-header\">\n" + "      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden='true' ng-click='doCancel()'>&times;</button>\n" + "    <h3>Doodle Properties</h3>\n" + "  </div>\n" + "  <div class='modal-body'>\n" + "    <label>Description</label>\n" + "    <input type='text' ng-model='zombie.description' placeholder=\"Enter description\" autofocus/>\n" + "    <br/>\n" + "    <label class='checkbox-inline'>\n" + "      <input type='checkbox' ng-model='zombie.operatorOverloading'>Operator Overloading</input>\n" + "    </label>\n" + "    <h4>Dependencies</h4>\n" + "    <table>\n" + "      <tbody>\n" + "        <tr ng-repeat='option in options track by option.name'>\n" + "          <td>\n" + "            <label class='checkbox-inline'>\n" + "              <input type='checkbox' ng-checked='zombie.dependencies.indexOf(option.name) > -1' ng-click='toggleDependency(option.name)'>{{option.moniker}}</input>\n" + "              </label>\n" + "          </td>\n" + "          <td>{{option.description}}</td>\n" + "          <td>{{option.version}}</td>\n" + "          <td><a href='{{option.homepage}}' target='_blank'>{{option.homepage}}</a></td>\n" + "        </tr>\n" + "      </tbody>\n" + "    </table>\n" + "  </div>\n" + "  <div class=\"modal-footer\" style=\"display: block;\">\n" + "    <button class='btn btn-primary' ng-click='doOK()'>OK</button>\n" + "    <button class='btn' ng-click='doCancel()'>Cancel</button>\n" + "  </div>\n" + "</div>\n");
      }]);
    }
  };
});

System.register("js/bootstrap.js", ["./app", "angular", "./directives/contextMenu/contextMenu.directive", "./controllers/DoodleController", "./directives/editor/editor.component", "./directives/explorer/explorer.component", "./directives/explorer/ExplorerFilesController", "./directives/logoText/logoText", "./services/modalService/AlertController", "./services/modalService/ConfirmController", "./services/modalService/PromptController", "./services/modalService/ModalService", "./directives/resizable/resizable", "./services/text/TextService", "./directives/workspace/workspace.component", "./controllers/AboutController", "./controllers/BodyController", "./controllers/CopyController", "./controllers/DownloadController", "./controllers/ExamplesController", "./controllers/HomeController", "./controllers/LoginController", "./controllers/NewController", "./controllers/OpenController", "./controllers/PropertiesController", "./fugly/ga/ga", "./services/cloud/cloud", "./services/cookie/cookie", "./services/doodles/doodles", "./services/gham/GitHubAuthManager", "./services/github/GitHub", "./services/options/options", "./services/settings/settings", "./services/templates/templates", "./services/tw/tw", "./services/uuid/UuidService", "./template-cache"], function(exports_1, context_1) {
  "use strict";
  var __moduleName = context_1 && context_1.id;
  var app_1,
      angular,
      contextMenu_directive_1,
      DoodleController_1,
      editor_component_1,
      explorer_component_1,
      ExplorerFilesController_1,
      logoText_1,
      AlertController_1,
      ConfirmController_1,
      PromptController_1,
      ModalService_1,
      resizable_1,
      TextService_1,
      workspace_component_1;
  return {
    setters: [function(app_1_1) {
      app_1 = app_1_1;
    }, function(angular_1) {
      angular = angular_1;
    }, function(contextMenu_directive_1_1) {
      contextMenu_directive_1 = contextMenu_directive_1_1;
    }, function(DoodleController_1_1) {
      DoodleController_1 = DoodleController_1_1;
    }, function(editor_component_1_1) {
      editor_component_1 = editor_component_1_1;
    }, function(explorer_component_1_1) {
      explorer_component_1 = explorer_component_1_1;
    }, function(ExplorerFilesController_1_1) {
      ExplorerFilesController_1 = ExplorerFilesController_1_1;
    }, function(logoText_1_1) {
      logoText_1 = logoText_1_1;
    }, function(AlertController_1_1) {
      AlertController_1 = AlertController_1_1;
    }, function(ConfirmController_1_1) {
      ConfirmController_1 = ConfirmController_1_1;
    }, function(PromptController_1_1) {
      PromptController_1 = PromptController_1_1;
    }, function(ModalService_1_1) {
      ModalService_1 = ModalService_1_1;
    }, function(resizable_1_1) {
      resizable_1 = resizable_1_1;
    }, function(TextService_1_1) {
      TextService_1 = TextService_1_1;
    }, function(workspace_component_1_1) {
      workspace_component_1 = workspace_component_1_1;
    }, function(_1) {}, function(_2) {}, function(_3) {}, function(_4) {}, function(_5) {}, function(_6) {}, function(_7) {}, function(_8) {}, function(_9) {}, function(_10) {}, function(_11) {}, function(_12) {}, function(_13) {}, function(_14) {}, function(_15) {}, function(_16) {}, function(_17) {}, function(_18) {}, function(_19) {}, function(_20) {}, function(_21) {}, function(_22) {}],
    execute: function() {
      app_1.default.controller('doodle-controller', DoodleController_1.default);
      app_1.default.controller('ExplorerFilesController', ExplorerFilesController_1.default);
      app_1.default.controller('AlertController', AlertController_1.default);
      app_1.default.controller('ConfirmController', ConfirmController_1.default);
      app_1.default.controller('PromptController', PromptController_1.default);
      app_1.default.directive('contextMenu', contextMenu_directive_1.default);
      app_1.default.directive('editor', editor_component_1.default);
      app_1.default.directive('explorer', explorer_component_1.default);
      app_1.default.directive('logoText', logoText_1.default);
      app_1.default.directive('resizable', resizable_1.default);
      app_1.default.directive('workspace', workspace_component_1.default);
      app_1.default.service('modalService', ModalService_1.default);
      app_1.default.service('textService', TextService_1.default);
      angular.element(document).ready(function() {
        angular.bootstrap(document.documentElement, [app_1.default.name], {strictDi: true});
      });
    }
  };
});

//# sourceMappingURL=bootstrap.js.map