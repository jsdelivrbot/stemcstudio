import io from 'socket.io-client';
import RoomListener from './RoomListener';
import Shareable from '../../../base/Shareable';
import MwEdits from '../../../synchronization/MwEdits';
import uniqueId from '../../../synchronization/uniqueId';

/**
 * 
 */
export default class RoomAgent implements Shareable {

    /**
     * The remote room identifier. This is generated by the server and obtained in the POST /rooms response.
     */
    private roomId: string;

    /**
     * The local room identifier. 
     */
    private nodeId: string;

    /**
     * 
     */
    public owner: string;

    private _socket: SocketIOClient.Socket | undefined;

    /**
     * The reference count is 1 immediately following construction.
     */
    private refCount = 1;
    private roomListeners: RoomListener[] = [];

    /**
     * @param roomId The identifier of the room (on the server side).
     */
    constructor(roomId: string, owner: string) {
        this.roomId = roomId;
        this.nodeId = uniqueId();
        this.owner = owner;

        // If we don't autoConnect, then how do we connect?
        // Maybe can't use secure if doing localhost?
        this._socket = io.connect({ autoConnect: false/*, secure: true*/ });
        this._socket.on('message', function message(socket: any) {
            // console.lg("RoomAgent socket message");
        });
        this._socket.on('disconnect', function disconnect() {
            // We do get this if the server goes down.
            // console.lg("RoomAgent got disconnect");
        });
        this._socket.on('connect', function connect() {
            // This is received when we connect to a server that is already running.
            // We also get this message as the last message when the server comes back up.
            // console.lg("RoomAgent successfully established a working connection.");
        });
        this._socket.on('connecting', function () {
            // I see this message when I don't auto connect.
            // console.lg("RoomAgent socket connecting");
        });
        this._socket.on('connect_failed', function () {
            // Haven't seen this.
            // console.lg("RoomAgent socket connect_failed");
        });
        this._socket.on('error', function error(reason: any) {
            // Haven't seen this.
            console.error("Unable to connect Socket.IO", reason);
        });
        this._socket.on('reconnect_failed', function () {
            // Haven't seen this.
            // console.lg("RoomAgent socket reconnect_failed");
        });
        this._socket.on('reconnect', function () {
            // We get this event first when the server goes down.
            // We also get it as the server comes up before we get another connect message.
            // console.lg("RoomAgent socket reconnect");
        });
        this._socket.on('reconnecting', function () {
            // We get this repeatedly when the server is down.
            // console.lg("RoomAgent socket reconnecting");
        });
        this._socket.on('edits', (data: { fromId: string, roomId: string; path: string; edits: MwEdits }) => {
            // Having the roomId sent back seems a bit redundant since this room agent already knows it.
            // We can use it as either a safety check or to future proof for multiple client rooms per socket.
            const { fromId, roomId, path, edits } = data;
            if (fromId === this.roomId && roomId === this.nodeId) {
                for (let i = 0; i < this.roomListeners.length; i++) {
                    const roomListener = this.roomListeners[i];
                    roomListener.setEdits(fromId, path, edits);
                }
            }
            else {
                console.warn(`edits received with fromId ${fromId}`);
                console.warn(`edits received with roomId ${roomId}`);
                console.warn(`this.roomId => ${this.roomId}`);
                console.warn(`this.nodeId => ${this.nodeId}`);
            }
        });
        // We'd rather connect outside the constructor, but OK for now.
        this._socket.connect();
    }
    addRef(): number {
        if (this.refCount <= 0) {
            throw new Error(`RoomAgent.addRef when refCount is ${this.refCount}`);
        }
        this.refCount++;
        return this.refCount;
    }
    release(): number {
        if (this.refCount <= 0) {
            throw new Error(`RoomAgent.release when refCount is ${this.refCount}`);
        }
        this.refCount--;
        if (this.refCount === 0) {
            this.destructor();
        }
        return this.refCount;
    }
    protected destructor(): void {
        if (this._socket) {
            if (this._socket.connected) {
                this._socket.disconnect();
            }
            this._socket = void 0;
        }
    }
    addListener(roomListener: RoomListener): void {
        this.roomListeners.push(roomListener);
    }
    removeListener(roomListener: RoomListener): void {
        const index = this.roomListeners.indexOf(roomListener);
        if (index >= 0) {
            this.roomListeners.splice(index, 1);
        }
    }
    get id(): string {
        return this.roomId;
    }

    /**
     * Initiate a download of the remote room.
     */
    download(callback: (err: any, files: { [path: string]: MwEdits }) => any) {
        const params = { fromId: this.nodeId, roomId: this.roomId };
        if (this._socket) {
            this._socket.emit('download', params, (err: any, files: { [path: string]: MwEdits }) => {
                callback(err, files);
            });
        }
    }

    /**
     *
     */
    setEdits(path: string, edits: MwEdits) {
        // The roomId and the nodeId should not be required because of previous calls
        // that established those properties on the socket?
        if (this._socket) {
            this._socket.emit('edits', { fromId: this.nodeId, roomId: this.roomId, path, edits }, () => {
                // console.lg(`Room ${this.roomId} has acknowledged edits for path ${path}.`);
            });
        }
    }
}
