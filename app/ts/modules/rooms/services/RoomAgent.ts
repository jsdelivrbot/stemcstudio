import io from 'socket.io-client';
import Room from './Room';
import RoomListener from './RoomListener';
import Shareable from '../../../utils/Shareable';
import MwAction from '../../../modules/synchronization/MwAction';
import MwChange from '../../../modules/synchronization/MwChange';
import MwEdits from '../../../modules/synchronization/MwEdits';
import uniqueId from '../../../modules/synchronization/uniqueId';

function peek(edits: MwEdits) {
    return edits.x.map((change: MwChange) => {
        const action = change.a;
        const kind = action.c;
        const n = action.n;
        const m = change.m;
        return {
            kind, n, m
        }
    })
}

/**
 * 
 */
export default class RoomAgent implements Shareable {
    /**
     * The remote room identifier. This is generated by the server and obtained in the POST /rooms response.
     */
    private roomId: string;
    /**
     * The local room identifier. 
     */
    private nodeId: string;
    private _socket: SocketIOClient.Socket;
    /**
     * The reference count is 1 immediately following construction.
     */
    private refCount = 1;
    private roomListeners: RoomListener[] = [];

    /**
     * @param roomId The identifier of the room (on the server side).
     */
    constructor(roomId: string) {
        this.roomId = roomId;
        this.nodeId = uniqueId();
        // If we don't autoConnect, then how do we connect?
        // Maybe can't use secure if doing localhost?
        this._socket = io.connect({ autoConnect: false/*, secure: true*/ });
        this._socket.on('message', function(socket) {
            // console.lg("RoomAgent socket message");
        });
        this._socket.on('disconnect', function() {
            // We do get this if the server goes down.
            // console.lg("RoomAgent got disconnect");
        });
        this._socket.on('connect', function() {
            // This is received when we connect to a server that is already running.
            // We also get this message as the last message when the server comes back up.
            // console.lg("RoomAgent successfully established a working connection.");
        });
        this._socket.on('connecting', function() {
            // I see this message when I don't auto connect.
            // console.lg("RoomAgent socket connecting");
        });
        this._socket.on('connect_failed', function() {
            // Haven't seen this.
            // console.lg("RoomAgent socket connect_failed");
        });
        this._socket.on('error', function(reason) {
            // Haven't seen this.
            console.error("Unable to connect Socket.IO", reason);
        });
        this._socket.on('reconnect_failed', function() {
            // Haven't seen this.
            // console.lg("RoomAgent socket reconnect_failed");
        });
        this._socket.on('reconnect', function() {
            // We get this event first when the server goes down.
            // We also get it as the server comes up before we get another connect message.
            // console.lg("RoomAgent socket reconnect");
        });
        this._socket.on('reconnecting', function() {
            // We get this repeatedly when the server is down.
            // console.lg("RoomAgent socket reconnecting");
        });
        this._socket.on('edits', (data: { fromId: string, roomId: string; fileName: string; edits: MwEdits }) => {
            // Having the roomId sent back seems a bit redundant since this room agent already knows it.
            // We can use it as either a safety check or to future proof for multiple client rooms per socket.
            const {fromId, roomId, fileName, edits} = data;
            console.log(`RoomAgent receiving edits for file ${fileName}: ${JSON.stringify(edits, null, 2)}`);
            if (fromId === this.roomId && roomId == this.nodeId) {
                for (let i = 0; i < this.roomListeners.length; i++) {
                    const roomListener = this.roomListeners[i];
                    roomListener.setEdits(fromId, fileName, edits);
                }
            }
            else {
                console.warn(`edits received with fromId ${fromId}`);
                console.warn(`edits received with roomId ${roomId}`);
                console.warn(`this.roomId => ${this.roomId}`);
                console.warn(`this.nodeId => ${this.nodeId}`);
            }
        });
        // We'd rather connect outside the constructor, but OK for now.
        this._socket.connect();
        // const joinMessage = { fromId: this.nodeId, roomId: this.roomId };
        // console.log(`joinMessage => ${JSON.stringify(joinMessage, null, 2)}`);
        // this._socket.emit('join', joinMessage, () => {
        // console.lg(`RoomAgent has joined the ${this.roomId} room.`);
        //});
    }
    addRef(): number {
        if (this.refCount > 0) {
            this.refCount++;
            return this.refCount;
        }
        else {
            throw new Error(`RoomAgent.addRef when refCount is ${this.refCount}`);
        }
    }
    release(): number {
        this.refCount--;
        if (this.refCount === 0) {
            this.destructor();
        }
        return this.refCount;
    }
    protected destructor(): void {
        if (this._socket) {
            if (this._socket.connected) {
                this._socket.disconnect();
            }
            this._socket = void 0;
        }
    }
    addListener(roomListener: RoomListener): void {
        this.roomListeners.push(roomListener);
    }
    removeListener(roomListener: RoomListener): void {
        const index = this.roomListeners.indexOf(roomListener);
        if (index >= 0) {
            this.roomListeners.splice(index, 1);
        }
    }
    get id(): string {
        return this.roomId;
    }

    /**
     * Initiate a download of the remote room.
     */
    download(callback: (err, files: { [fileName: string]: MwEdits }) => any) {
        const params = { fromId: this.nodeId, roomId: this.roomId };
        console.log(`params => ${JSON.stringify(params, null, 2)}`);
        this._socket.emit('download', params, (err: any, files: { [fileName: string]: MwEdits }) => {
            callback(err, files);
        });
    }

    /**
     * fileName corresponds 1:1 with the edits.s, which is the MwUnit unique identifier.
     */
    setEdits(fileName: string, edits: MwEdits) {
        // The roomId and the nodeId should not be required because of previous calls
        // that established those properties on the socket.
        this._socket.emit('edits', { fromId: this.nodeId, roomId: this.roomId, fileName, edits }, () => {
            // console.lg(`Room ${this.roomId} has acknowledged edits for file ${fileName}.`);
        });
    }
}
