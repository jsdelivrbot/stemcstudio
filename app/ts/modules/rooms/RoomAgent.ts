import io from 'socket.io-client';
import { RoomListener } from './RoomListener';
import Shareable from '../../base/Shareable';
import { SocketZen } from './SocketZen';
import { MwAction } from '../../synchronization/MwAction';
import { ACTION_NULLIFY_UPPERCASE } from '../../synchronization/MwAction';
import MwChange from '../../synchronization/MwChange';
import MwEdits from '../../synchronization/MwEdits';
import uniqueId from '../../synchronization/uniqueId';

const SOCKET_EVENT_DOWNLOAD = 'download';
const SOCKET_EVENT_EDITS = 'edits';

const EVENT_SOCKET_IO_RECONNECTING = 'reconnecting';
const EVENT_SOCKET_IO_RECONNECT = 'reconnect';
// const EVENT_SOCKET_IO_RECONNECT_FAILED = 'reconnect_failed';

/**
 * A summary of the edits, for debugging purposes.
 */
function summarize(edits: MwEdits) {
    return edits.x.map(change => { return { type: change.a.c, local: change.a.n, remote: change.m }; });
}

/**
 * A proxy for the room on the remote server.
 * An observable owing to the socket connection to the room.
 */
export default class RoomAgent implements Shareable {

    /**
     * The remote room identifier. This is generated by the server and obtained in the POST /rooms response.
     */
    private readonly roomId: string;

    /**
     * The local room (agent) identifier.
     * This is generated in the constructor.
     */
    private readonly nodeId = uniqueId();

    /**
     * 
     */
    public readonly owner: string;

    /**
     * The socket connection to the server.
     */
    private socket: SocketZen;

    /**
     * The reference count is 1 immediately following construction.
     */
    private refCount = 1;

    /**
     * Used to control logging.
     */
    private readonly verbose = false;

    /**
     * 
     */
    private roomListeners: RoomListener[] = [];

    /**
     * roomId is the identifier of the room (on the server side).
     */
    constructor(roomId: string, owner: string) {
        this.roomId = roomId;
        this.owner = owner;

        // Maybe can't use secure if doing localhost?
        this.socket = new SocketZen(io.connect({ autoConnect: false/*, secure: true*/ }));

        // We'd rather connect outside the constructor, but OK for now.
        this.connect();
    }

    /**
     * 
     */
    connect(): Promise<void> {
        this.socket.on(SOCKET_EVENT_EDITS, this.editsHandler);
        this.socket.on(EVENT_SOCKET_IO_RECONNECTING, this.reconnectingHandler);
        this.socket.on(EVENT_SOCKET_IO_RECONNECT, this.reconnectHandler);
        return this.socket.connect();
    }

    /**
     * 
     */
    disconnect(): Promise<void> {
        this.socket.off(SOCKET_EVENT_EDITS, this.editsHandler);
        this.socket.off(EVENT_SOCKET_IO_RECONNECTING, this.reconnectingHandler);
        this.socket.off(EVENT_SOCKET_IO_RECONNECT, this.reconnectHandler);
        return this.socket.disconnect();
    }

    /**
     * 
     */
    addRef(): number {
        if (this.refCount <= 0) {
            throw new Error(`RoomAgent.addRef when refCount is ${this.refCount}`);
        }
        this.refCount++;
        return this.refCount;
    }

    /**
     * 
     */
    release(): number {
        if (this.refCount <= 0) {
            throw new Error(`RoomAgent.release when refCount is ${this.refCount}`);
        }
        this.refCount--;
        if (this.refCount === 0) {
            this.destructor();
        }
        return this.refCount;
    }

    /**
     * 
     */
    protected destructor(): void {
        if (this.socket.connected) {
            this.socket.disconnect();
        }
    }

    /**
     * 
     */
    addListener(roomListener: RoomListener): void {
        this.roomListeners.push(roomListener);
    }

    /**
     * 
     */
    removeListener(roomListener: RoomListener): void {
        const index = this.roomListeners.indexOf(roomListener);
        if (index >= 0) {
            this.roomListeners.splice(index, 1);
        }
    }

    /**
     * The remote (server) room identifier.
     * This was generated by the server when a POST was made to the /rooms endpoint.
     */
    get id(): string {
        return this.roomId;
    }

    /**
     * Sends a message to the remote room requesting that the file with the specified path be deleted.
     */
    deleteFile(path: string): void {
        const action: MwAction = { c: ACTION_NULLIFY_UPPERCASE };
        const changes: MwChange[] = [{ a: action }];
        const edits: MwEdits = { x: changes };
        this.socket.emit(SOCKET_EVENT_EDITS, { fromId: this.nodeId, roomId: this.roomId, path, edits }, (err: any) => {
            console.log(`Room ${this.roomId} has acknowledged message to deleteFile('${path}') sent from this node ${this.nodeId}.`);
        });
    }

    /**
     * Initiate a download of the remote room.
     */
    download(callback: (err: any, files: { [path: string]: MwEdits }) => any) {
        const params = { fromId: this.nodeId, roomId: this.roomId };
        // console.lg(`emit('${SOCKET_EVENT_DOWNLOAD}') ${JSON.stringify(params)}`);
        this.socket.emit(SOCKET_EVENT_DOWNLOAD, params, (err: any, files: { [path: string]: MwEdits }) => {
            callback(err, files);
        });
    }

    /**
     * Typesafe method for emitting 'edits' to the remote server.
     */
    setEdits(path: string, edits: MwEdits) {
        // The roomId and the nodeId should not be required because of previous calls
        // that established those properties on the socket?
        if (this.verbose) {
            console.log(`${this.nodeId} ${path} SENDING '${SOCKET_EVENT_EDITS}' ${JSON.stringify(summarize(edits))}`);
        }
        this.socket.emit(SOCKET_EVENT_EDITS, { fromId: this.nodeId, roomId: this.roomId, path, edits }, () => {
            // console.lg(`Room has acknowledged edits for path ${path} from this node ${this.nodeId}.`);
        });
    }

    /**
     * Remark. The properties in the message could be a bit confusing.
     * This is because of the symmetry between synchronization peers.
     * The roomId maps onto the room agent's nodeId.
     * The fromId maps onto the remote room id.
     * TODO: Perhaps roomId should be renamed targetId?
     */
    private editsHandler = (data: { fromId: string, roomId: string; path: string; edits: MwEdits }) => {
        // Having the roomId sent back seems a bit redundant since this room agent already knows it.
        // We can use it as either a safety check or to future proof for multiple client rooms per socket.
        const { fromId, roomId, path, edits } = data;
        if (fromId === this.roomId && roomId === this.nodeId) {
            if (this.verbose) {
                console.log(`${this.nodeId} ${path} RECEIVE ${SOCKET_EVENT_EDITS} ${JSON.stringify(summarize(edits))}`);
            }
            for (const roomListener of this.roomListeners) {
                roomListener.setDocumentEdits(this.roomId, path, edits);
            }
        }
        else {
            console.warn(`edits received with fromId ${fromId}`);
            console.warn(`edits received with roomId ${roomId}`);
            console.warn(`this.roomId => ${this.roomId}`);
            console.warn(`this.nodeId => ${this.nodeId}`);
        }
    }

    /**
     * 
     */
    private reconnectingHandler = () => {
        if (this.verbose) {
            console.log(`reconnecting`);
        }
    }

    /**
     * 
     */
    private reconnectHandler = () => {
        if (this.verbose) {
            console.log(`reconnect`);
        }
        for (const roomListener of this.roomListeners) {
            const editsByPath = roomListener.getWorkspaceEdits(this.roomId);
            const paths = Object.keys(editsByPath);
            for (const path of paths) {
                const edits = editsByPath[path];
                this.setEdits(path, edits);
            }
        }
    }
}
